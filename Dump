  18:44:42.773  Printing now...  -  Edit
  18:44:42.773  --- START OF FILE game.txt ---
  -  Edit
  18:44:42.773   â–¶ ==================================================================== (x2)  -  Edit
  18:44:42.774  ==                                                                ==  -  Edit
  18:44:42.774  ==                 START OF SCRIPT EXPORT PROCESS                 ==  -  Edit
  18:44:42.774  ==                                                                ==  -  Edit
  18:44:42.774  ====================================================================  -  Edit
  18:44:42.774  ====================================================================
  -  Edit
  18:44:42.777  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.Workspace.Test Area.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.Workspace.Test Area.Rig.Animate

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.Workspace.Test Area.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.Workspace.Test Area.Rig.Animate

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.Workspace.Test Area.IMPORTED ASSETS FROM REARMED.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.Workspace.Test Area.IMPORTED ASSETS FROM REARMED.Rig.Animate

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.Workspace.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.Workspace.Rig.Animate

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.Workspace.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.Workspace.Rig.Animate

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.Workspace.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.Workspace.Rig.Animate

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.Workspace.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileL [trimmed]  -  Edit
  18:44:43.032  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.ReplicatedStorage.Peak.Assets.LensFlare.Client.InitLensFlare | Enabled: true
--------------------------------------------------------------------
--[[
	InitLensFlare
	10/20/25
	@gluGPU
	
	Initiates the LensFlare Module.
--]]

local CollectionService = game:GetService("CollectionService")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local lensFlareDir = ReplicatedStorage.Peak.Assets.LensFlare
local LensFlare = require(lensFlareDir.Modules.LensFlare)
local Configuration = require(lensFlareDir.Configuration)

local camera = workspace.CurrentCamera
local localPlayer = Players.LocalPlayer

local SUN_DISTANCE = 5000

local SUN_EXPOSURE_ADJUST = Configuration.SUN_EXPOSURE_ADJUSTMENT
local SUN_EXPOSURE_SMOOTH_TIME = Configuration.SUN_EXPOSURE_TIME

local SUN_BRIGHTNESS_THRESHOLD = Configuration.SUN_BRIGHTNESS_THRESHOLD
local SUN_ANGLE_THRESHOLD = Configuration.SUN_ANGLE_THRESHOLD

local up = vector.create(0, 1, 0)

-- Sun Lens Flare
local sunPart = Instance.new("Part")
sunPart.Anchored = true
sunPart.CanCollide = false
sunPart.CanQuery = false
sunPart.CanTouch = false
sunPart.Transparency = 0.5
sunPart.Size = vector.create(1, 1, 1)
sunPart.Name = "SunFlareTestPart"
sunPart.Parent = workspace

sunPart:SetAttribute("LensFlareStrength", 1)

local sunFlare = LensFlare.new(camera, "Default", sunPart)

local function updateColor()
	sunPart.Color = Lighting.ColorShift_Top
end

updateColor()
Lighting:GetPropertyChangedSignal("ColorShift_Top"):Connect(updateColor)

local function updateStrength()
	local sunAngle = Lighting:GetSunDirection().Y * 90
	local sunAlpha = math.clamp(sunAngle / SUN_ANGLE_THRESHOLD, 0, 1)
	local brightnessAlpha = math.clamp(Lighting.Brightness / SUN_BRIGHTNESS_THRESHOLD, 0, 1)
	local totalAlpha = sunAlpha * brightnessAlpha
	
	sunFlare.Enabled = totalAlpha > 0
	
	sunPart:SetAttribute("LensFlareStrength", totalAlpha)
end

updateStrength()
Lighting:GetPropertyChangedSignal("Brightness"):Connect(updateStrength)
Lighting:GetPropertyChangedSignal("ClockTime"):Connect(updateStrength)

RunService:BindToRenderStep("UpdateLensFlarePart", Enum.RenderPriority.Camera.Value + 9, function()
	sunPart.Position = camera.CFrame.Position + (Lighting:GetSunDirection() * SUN_DISTANCE)
end)

local alpha, vel = 0, 0
RunService:BindToRenderStep("UpdateExposure", Enum.RenderPriority.Camera.Value + 11, function(delta: number)
	Lighting.ExposureCompensation -= (alpha * SUN_EXPOSURE_ADJUST)
	alpha, vel = TweenService:SmoothDamp(alpha, sunFlare.Alpha^2, vel, SUN_EXPOSURE_SMOOTH_TIME, nil, delta)
	Lighting.ExposureCompensation += (alpha * SUN_EXPOSURE_ADJUST)
end)


local parts = {}
for _, part in CollectionService:GetTagged("LensFlare") do
	if part:IsA("BasePart") or part:IsA("Attachment") and not parts[part] then
		local flare = LensFlare.new(camera, part:GetAttribute("LensFlareStyle"), part)
		parts[part] = flare
	end
end

CollectionService:GetInstanceAddedSignal("LensFlare"):Connect(function(object: Instance)
	if object:IsA("BasePart") or object:IsA("Attachment") and not parts[object] then
		local flare = LensFlare.new(camera, object:GetAttribute("LensFlareStyle"), object)
		parts[object] = flare
	end
end)

CollectionService:GetInstanceRemovedSignal("LensFlare"):Connect(function(object: Instance)
	if parts[object] then
		parts[object]:Destroy()
		parts[object] = nil
	end
end)
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Assets.LensFlare.Client.InitLensFlare

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.PlayerData | Enabled: N/A
--------------------------------------------------------------------
local PlayerData = {}

PlayerData.DefaultPlayerData = {

	--  PLAYER CORE PROGRESSION
	Core = {
		Level = 1,
		XP = 0,
		SkillPoints = 0,

		-- Skill tree categories similar to TLOU:
		Skills = {
			Survival = 0,   -- Healing speed, crafting bonuses
			Stealth = 0,    -- Sneaking, silent takedown bonuses
			Combat = 0,     -- Weapon sway reduction, reload speed
		},
	},

	--  INVENTORY SYSTEM
	Inventory = {

		Resources = {
			Alcohol = 0,
			Blades = 0,
			Rags = 0,
			Binding = 0,
			MetalParts = 0,
			Explosives = 0
		},

		Consumables = {
			Medkits = 0,
			Shivs = 0,
			Molotovs = 0,
			SmokeBombs = 0,
			NailBombs = 0,
			Mines = 0,
			Pipebomb = 0,
		},

		Ammo = {
			Secondary = 0,
			Primary = 0,
			Purchasable = 0,
			Secondary2 = 0,
		},

		Weapons = {
			Primary = "Vepr",
			Purchaseable = nil,
			Secondary = "Beretta",
			Melee = nil,
		},
	},

	--  PLAYER CONDITION (TLOU Survivor Style)
	Status = {
		Health = 100,
		MaxHealth = 100,

		InfectionLevel = 0,
		BleedTimer = 0,
		Stamina = 100,
		MaxStamina = 100,
	},

	--  PLAYER APPEARANCE / COSMETICS
	Cosmetics = {

		Owned = {
			Masks = {},
			Hats = {},
			Shirts = {},
			Pants = {},
			Backpacks = {"Backpack","CamoBag","LeatherBag", "GunBag",},
		},

		Equipped = {
			Mask = nil,
			Hat = nil,
			Shirt = nil,
			Pants = nil,
			Backpack = "Backpack",
		},
	},
	--leather bag co Y pos for clothing 0.04

	--  QUESTS / CHECKPOINTS
	Progression = {
		Story = {
			CurrentChapter = 1,
			Checkpoints = {},
		},
		SideQuests = {},
		Collectibles = {
			FireflyPendants = {},
			Artifacts = {},
			Comics = {},
		}
	},

	--  CRAFTING + WORKBENCH
	Workbench = {
		Upgrades = {
			WeaponSway = 0,
			ReloadSpeed = 0,
			FireRate = 0,
			Damage = 0,
		},

		CraftingRecipesUnlocked = {
			Medkit = true,
			Shiv = true,
			Molotov = false,
			SmokeBomb = false,
		},
	},

	-- GLOBAL STATISTICS
	Stats = {
		TimeSurvived = 0,
		InfectedKilled = 0,
		HumansKilled = 0,
		Deaths = 0,

		Headshots = 0,
		StealthKills = 0,

		DistanceTraveled = 0,
		CraftedItems = 0,
	},
}

return PlayerData

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.PlayerData

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.DataHelper | Enabled: N/A
--------------------------------------------------------------------
-- DataHelper.lua
local DataUtils = {}

-- Returns parent table and last key for a dotted path, e.g. "Inventory.Resources.Alcohol"
local function resolvePath(root, path)
	if not path or path == "" then return nil end
	local current = root
	local lastKey = nil

	for segment in string.gmatch(path, "[^.]+") do
		lastKey = segment
		if current[lastKey] == nil then
			-- don't create automatically; just return what we have
			return current, lastKey
		end
		if type(current[lastKey]) ~= "table" then
			-- if this is final segment it may be number/string, so break
			break
		end
		current = current[lastKey]
	end

	return current, lastKey
end

-- Generic safe getter: returns value at path
local function getPath(root, path)
	if path == nil or path == "" then return nil end
	local current = root
	for segment in string.gmatch(path, "[^.]+") do
		if type(current) ~= "table" then return nil end
		current = current[segment]
		if current == nil then return nil end
	end
	return current
end

-- Adds a value to the data and prints the result
function DataUtils.Add(playerProfile, path, value)
	if not playerProfile or not playerProfile.Data then
		warn("[DataUtils] Add: invalid profile")
		return
	end

	local parent, key = resolvePath(playerProfile.Data, path)
	local currentVal = getPath(playerProfile.Data, path)

	-- If parent is nil or key nil, try top-level assignment
	if not parent or not key then
		-- fallback: set direct key on Data
		local prev = playerProfile.Data[path]
		if type(prev) == "number" then
			playerProfile.Data[path] = prev + (value or 0)
		else
			playerProfile.Data[path] = value
		end

		print("[DATA ADD] ->", path, "=", tostring(playerProfile.Data[path]))
		return
	end

	-- If the resolved value exists and is a table, insert into it
	if type(currentVal) == "table" then
		table.insert(currentVal, value)
		print("[DATA ADD] -> inserted into table:", path, "value =", tostring(value))
		return
	end

	-- If numeric, add
	if type(currentVal) == "number" then
		parent[key] = currentVal + (value or 0)
		print("[DATA ADD] ->", path, "=", tostring(parent[key]))
		return
	end

	-- Otherwise overwrite / set
	parent[key] = value
	print("[DATA ADD] ->", path, "=", tostring(parent[key]))
end

-- Removes a value from the data and prints the result
function DataUtils.Remove(playerProfile, path, value)
	if not playerProfile or not playerProfile.Data then
		warn("[DataUtils] Remove: invalid profile")
		return
	end

	local parent, key = resolvePath(playerProfile.Data, path)
	local currentVal = getPath(playerProfile.Data, path)

	if not parent or not key then
		-- fallback: remove top-level
		playerProfile.Data[path] = nil
		print("[DATA REMOVE] ->", path, " = nil")
		return
	end

	-- If table, remove first matching entry
	if type(currentVal) == "table" then
		for i, v in ipairs(currentVal) do
			if v == value then
				table.remove(currentVal, i)
				print("[DATA REMOVE] -> removed from table:", path, "value =", tostring(value))
				return
			end
		end
		print("[DATA REMOVE] -> value not found in table:", path)
		return
	end

	-- If number, subtract
	if type(currentVal) == "number" and type(value) == "number" then
		parent[key] = currentVal - value
		print("[DATA REMOVE] ->", path, "=", tostring(parent[key]))
		return
	end

	-- Otherwise set nil
	parent[key] = nil
	print("[DATA REMOVE] ->", path, " = nil")
end

return DataUtils

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.DataHelper

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SoundList | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SoundList

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Init? | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Init?

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Init?.ModuleScript | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Init?.ModuleScript

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Data? | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Data?

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone | Enabled: N/A
--------------------------------------------------------------------
--!nocheck

local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Components = script:WaitForChild("Components")
local Dependencies = script:WaitForChild("Dependencies")

local CeiveImOverlay = require(Dependencies:WaitForChild("Debug"):WaitForChild("ImOverlay"))
local Config = require(Dependencies:WaitForChild("Config"))
local Frustum = require(Dependencies:WaitForChild("Frustum"))
local Utilities = require(Dependencies:WaitForChild("Utilities"))
local ImOverlay

local BoneClass = require(Components:WaitForChild("Bone"))
local BoneTreeClass = require(Components:WaitForChild("BoneTree"))
local ColliderObjectClass = require(Components:WaitForChild("Collision"):WaitForChild("ColliderObject"))

local ActorRuntime = Dependencies:WaitForChild("Runtime")

local function CopyPasteAttributes(Object1: BasePart, Object2: BasePart)
	for k, v in Object1:GetAttributes() do
		Object2:SetAttribute(k, v)
	end
end

export type IBoneTree = BoneTreeClass.IBoneTree
export type IBone = BoneClass.IBone
export type IColliderObject = ColliderObjectClass.IColliderObject
export type IColliderTable = ColliderObjectClass.IColliderTable

type ImOverlay = {
	Begin: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: () -> (),
	Text: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> ()
}

type bool = boolean

local SB_INDENT_LOG = Utilities.SB_INDENT_LOG
local SB_UNINDENT_LOG = Utilities.SB_UNINDENT_LOG
-- local SB_ASSERT_CB = Utilities.SB_ASSERT_CB
local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG
local SB_VERBOSE_WARN = Utilities.SB_VERBOSE_WARN
-- local SB_VERBOSE_ERROR = Utilities.SB_VERBOSE_ERROR

--- @class SmartBone
--- Root for all SmartBone objects.

--- @within SmartBone
--- @readonly
--- @prop ID string
--- Unique ID of the root object

--- @within SmartBone
--- @prop BoneTrees table
--- Table of all bone trees under this root

--- @within SmartBone
--- @prop ColliderObjects table
--- Table of all colliders assigned to this root

--- @within SmartBone
--- @prop ShouldDestroy boolean
--- True if the root has no bonetrees, this is already handled by the runtime

local Class = {}
Class.__index = Class

--- @within SmartBone
--- @return SmartBone
function Class.new()
	local self = setmetatable({
		ID = HttpService:GenerateGUID(false),
		BoneTrees = {},
		ColliderObjects = {},
		ShouldDestroy = false,
	}, Class)

	return self
end

-- Private Functions

--- @private
--- @within SmartBone
--- @param BoneTree table
--- @param BoneObject Bone
--- @param ParentIndex number
--- @param HeirarchyLength number
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Used to add a bone to the provided bone tree
function Class:m_AppendBone(BoneTree: IBoneTree, BoneObject: Bone, ParentIndex: number, HeirarchyLength: number)
	local Settings = Utilities.GatherBoneSettings(BoneObject)
	local Bone: IBone = BoneClass.new(BoneObject, BoneTree.Root, BoneTree.RootPart)

	for k, v in Settings do
		-- "Â¬" represents a nil value, this is done so we can delete attributes at runtime.
		Bone[k] = (v ~= "Â¬") and v or nil
	end

	local ParentBone = BoneTree.Bones[ParentIndex]

	if ParentIndex > 0 then
		local BoneLength = (ParentBone.Position - Bone.Position).Magnitude
		Bone.FreeLength = BoneLength
		Bone.Weight = BoneLength * 0.7 -- Why 0.7?
		Bone.HeirarchyLength = HeirarchyLength

		ParentBone.HasChild = true
		--ParentBone.NumberOfChildren += 1
	end

	if HeirarchyLength <= BoneTree.Settings.AnchorDepth then
		SB_VERBOSE_LOG("Anchoring bone")
		Bone.Anchored = true
	end

	Bone.ParentIndex = ParentIndex

	table.insert(BoneTree.Bones, Bone)
end

--- @private
--- @within SmartBone
--- @param RootPart BasePart
--- @param RootBone Bone
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Creates a bone tree from the RootPart and RootBone and then adds all child bones via m_AppendBone
function Class:m_CreateBoneTree(RootPart: BasePart, RootBone: Bone)
	local BoneTree = BoneTreeClass.new(RootBone, RootPart, Utilities.GatherObjectSettings(RootPart))

	SB_VERBOSE_LOG(`Creating bone tree {RootPart.Name}; {RootBone.Name}`)
	SB_INDENT_LOG()

	local function AddChildren(Bone, ParentIndex, HeirarchyLength)
		SB_VERBOSE_LOG(`Adding bone: {Bone.Name}; {ParentIndex}; {HeirarchyLength}`)
		SB_INDENT_LOG()
		local Children = Bone:GetChildren()
		local HasBoneChild = false

		for _, Child in Children do
			if Child:IsA("Bone") then
				self:m_AppendBone(BoneTree, Child, ParentIndex, HeirarchyLength)

				AddChildren(Child, #BoneTree.Bones, HeirarchyLength + 1)
				HasBoneChild = true
			end
		end

		if string.sub(Bone.Name, #Bone.Name - 3, #Bone.Name) == "_end" or string.sub(Bone.Name, #Bone.Name - 4, #Bone.Name) == "_Tail" then
			HasBoneChild = true
		end

		if not HasBoneChild then -- Add tail bone for transform calculations
			SB_VERBOSE_LOG(`Adding tail bone`)
			local Parent = Bone.Parent
			local ParentWorldPosition = Parent:IsA("Bone") and Parent.WorldPosition or Parent.Position

			local Start = Bone.WorldCFrame + (Bone.WorldCFrame.UpVector.Unit * (Bone.WorldPosition - ParentWorldPosition).Magnitude)
			local tailBone = Instance.new("Bone")
			tailBone.Parent = Bone
			tailBone.Name = Bone.Name .. "_Tail"
			tailBone.WorldCFrame = Start

			CopyPasteAttributes(Bone, tailBone)

			self:m_AppendBone(BoneTree, tailBone, #BoneTree.Bones, HeirarchyLength)
		end

		SB_UNINDENT_LOG()
	end

	self:m_AppendBone(BoneTree, RootBone, 0, 0)

	AddChildren(RootBone, 1, 1)

	table.insert(self.BoneTrees, BoneTree)

	SB_UNINDENT_LOG()
end

--- @private
--- @within SmartBone
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Updates the view frustum used for optimization
function Class:m_UpdateViewFrustum()
	-- Should we do frustum checks this frame, depends on config setting
	if shared.FrameCounter % Config.FRUSTUM_FREQ ~= 0 then
		return
	end
	

local a, b, c, d, e, f, g, h, i = Frustum.GetCFrames(workspace.CurrentCamera, Config.FAR_PLANE) -- Hard coded stud limit on any object

	for _, BoneTree in self.BoneTrees do
		
local FakeObject = {
			CFrame = BoneTree.BoundingBoxCFrame,
			Size = BoneTree.BoundingBoxSize,
		}
		BoneTree.InView = Frustum.ObjectInFrustum(FakeObject, a, b, c, d, e, f, g, h, i)
	
end

end

function Class:m_CleanColliders()
	
local DidDestroy = false

	if #self.ColliderObjects ~= 0 then -- Micro optimizations
		for i, ColliderObject in self.ColliderObjects do
			if #ColliderObject.Colliders == 0 or ColliderObject.Destroyed == true then
				SB_VERBOSE_WARN(`Deleting Collider Object`)
				SB_INDENT_LOG()
				ColliderObject:Destroy()
				SB_UNINDENT_LOG()
				table.remove(self.ColliderObjects, i)

				DidDestroy = true
			end
		end
	end

	if not DidDestroy then -- Prevent warning because we left parallel
	
end
end

--- @private
--- @within SmartBone
--- @param BoneTree table
--- @param Index number
--- @param Delta number
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Updates the provided bone tree with all optimizations
function Class:m_UpdateBoneTree(BoneTree: IBoneTree, Index: number, Delta: number)

	
if BoneTree.Destroyed then
		BoneTree:Destroy()
		table.remove(self.BoneTrees, Index)

		return
	end

	BoneTree:PreUpdate(Delta) -- Pre update MUST be called before we call SkipUpdate!

	if not BoneTree.InView or math.floor(BoneTree.UpdateRate) == 0 or not BoneTree.InWorkspace then
		local AlreadySkipped = BoneTree.IsSkippingUpdates

		BoneTree:SkipUpdate()

		if not AlreadySkipped then

			
task.synchronize()
			BoneTree:ApplyTransform()

			SB_VERBOSE_LOG(
				`Skipping BoneTree, InView: {BoneTree.InView}, Update Rate == 0: {math.floor(BoneTree.UpdateRate) == 0}, InWorkspace: {BoneTree.InWorkspace}`
			)
		end

		return
	end
	

for _, ColliderObject in self.ColliderObjects do
		ColliderObject:Step()
	end

	
local UpdateHz = 1 / BoneTree.UpdateRate
	local DidUpdate = false

	BoneTree.AccumulatedDelta += Delta
	while BoneTree.AccumulatedDelta > UpdateHz do
		BoneTree.AccumulatedDelta -= UpdateHz

		DidUpdate = true

		BoneTree:StepPhysics(UpdateHz)
		BoneTree:Constrain(self.ColliderObjects, UpdateHz)
		BoneTree:SolveTransform(UpdateHz)
	end

	
if DidUpdate then
		task.synchronize()
		BoneTree:ApplyTransform()
	end
end

--- @private
--- @within SmartBone
--- @return boolean
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Returns true if the root should be destroyed
function Class:m_CheckDestroy()
	self.ShouldDestroy = false

	if #self.BoneTrees == 0 then
		self.ShouldDestroy = true
		return true
	end

	return false
end

-- Public Functions

--- @within SmartBone
--- @param Object BasePart
--- Loads the provided object
function Class:LoadObject(Object: BasePart)
	local RootAttribute = Object:GetAttribute("Roots")

	if not RootAttribute then
		warn(`[SmartBone2::LoadObject] Cannot load an object with no roots defined {Object.Name}`)
		return
	end

	local RootNames = RootAttribute:split(",")
	local Bones = {}

	-- Gather bones into table indexed with name
	for _, Descendant in Object:QueryDescendants("Bone") do
		if Bones[Descendant.Name] then
			warn(`[SmartBone2::LoadObject] Duplicate bones of name: {Descendant.Name} in RootPart: {Object.Name}`)
			continue
		end

		Bones[Descendant.Name] = Descendant
	end

	-- Create bone trees
	for _, Name in RootNames do
		local RootBone = Bones[Name]
		if not RootBone then
			warn(`[SmartBone2::LoadObject] Couldn't find Root Bone of name: {Name} in RootPart: {Object.Name}`)
			continue
		end

		self:m_CreateBoneTree(Object, RootBone)
	end
end

--- @within SmartBone
--- @param ColliderModule ModuleScript
--- @param Object BasePart
--- Loads the provided collider module onto the provided object
function Class:LoadColliderModule(ColliderModule: ModuleScript, Object: BasePart)
	assert(ColliderModule, "[SmartBone2::LoadColliderModule] No collider module passed in")

	local RawColliderData = require(ColliderModule)
	local ColliderData = HttpService:JSONDecode(RawColliderData)

	local ColliderObject = ColliderObjectClass.new(ColliderData, Object)

	table.insert(self.ColliderObjects, ColliderObject)
end

--- @within SmartBone
--- @param ColliderData table
--- @param Object BasePart
--- Loads the raw collider data onto the provided object
function Class:LoadRawCollider(ColliderData: IColliderTable, Object: BasePart)
	local ColliderObject = ColliderObjectClass.new(ColliderData, Object)

	table.insert(self.ColliderObjects, ColliderObject)
end

--- @within SmartBone
--- Resets all bone trees to their rest position
function Class:SkipUpdate()
	
for _, BoneTree in self.BoneTrees do
		BoneTree:SkipUpdate()
	end

end

--- @within SmartBone
--- @param Delta number
--- Updates all bone trees
function Class:StepBoneTrees(Delta: number)
	if self:m_CheckDestroy() then
		return
	end

	if Delta <= 0 then
		SB_VERBOSE_WARN("DeltaTime is zero or sub zero, not updating.")
		return
	end

	self:m_CleanColliders()
	self:m_UpdateViewFrustum()
	for i, BoneTree in self.BoneTrees do
		self:m_UpdateBoneTree(BoneTree, i, Delta)
	end
end

--- @client
--- @within SmartBone
--- @param DRAW_COLLIDERS boolean
--- @param DRAW_CONTACTS boolean
--- @param DRAW_PHYSICAL_BONE boolean
--- @param DRAW_BONE boolean
--- @param DRAW_AXIS_LIMITS boolean
--- @param DRAW_ROOT_PART boolean
--- @param DRAW_FILL_COLLIDERS boolean
--- @param DRAW_COLLIDER_INFLUENCE boolean
--- @param DRAW_COLLIDER_AWAKE boolean
--- @param DRAW_COLLIDER_BROADPHASE boolean
--- @param DRAW_BOUNDING_BOX boolean
--- @param DRAW_ROTATION_LIMITS boolean
--- @param DRAW_ACCELERATION_INFO boolean
--- Draws the debug gizmos
function Class:DrawDebug(
	DRAW_COLLIDERS: bool,
	DRAW_CONTACTS: bool,
	DRAW_PHYSICAL_BONE: bool,
	DRAW_BONE: bool,
	DRAW_AXIS_LIMITS: bool,
	DRAW_ROOT_PART: bool,
	DRAW_FILL_COLLIDERS: bool,
	DRAW_COLLIDER_INFLUENCE: bool,
	DRAW_COLLIDER_AWAKE: bool,
	DRAW_COLLIDER_BROADPHASE: bool,
	DRAW_BOUNDING_BOX: bool,
	DRAW_ROTATION_LIMITS: bool,
	DRAW_ACCELERATION_INFO: bool
)
	for _, BoneTree in self.BoneTrees do
		BoneTree:DrawDebug(
			DRAW_CONTACTS,
			DRAW_PHYSICAL_BONE,
			DRAW_BONE,
			DRAW_AXIS_LIMITS,
			DRAW_ROOT_PART,
			DRAW_BOUNDING_BOX,
			DRAW_ROTATION_LIMITS,
			DRAW_ACCELERATION_INFO
		)
	end

	if DRAW_COLLIDERS then
		for _, ColliderObject in self.ColliderObjects do
			ColliderObject:DrawDebug(DRAW_FILL_COLLIDERS, DRAW_COLLIDER_INFLUENCE, DRAW_COLLIDER_AWAKE, DRAW_COLLIDER_BROADPHASE)
		end
	end
end

--- @client
--- @within SmartBone
--- @param Overlay ImOverlay
--- Draws the debug overlay
function Class:DrawOverlay(Overlay: ImOverlay)
	if not Config.DEBUG_OVERLAY_ENABLED then
		return
	end

	local INSTANCE_BACKGROUND_COLOR = Color3.new(1.000000, 0.431373, 0.713725)
	local INSTANCE_TEXT_COLOR = Color3.new(1, 1, 1)
	local ROOT_BACKGROUND_COLOR = Color3.new(0.486275, 0.431373, 1.000000)
	local ROOT_TEXT_COLOR = Color3.new(1, 1, 1)

	Overlay.Begin(`SmartBone Instance ID: {self.ID}`, INSTANCE_BACKGROUND_COLOR, INSTANCE_TEXT_COLOR)
	Overlay.Text(`Frame Counter: {shared.FrameCounter}`)

	if Config.DEBUG_OVERLAY_TREE then
		for i, BoneTree in self.BoneTrees do
			if Config.DEBUG_OVERLAY_MAX_TREES > 0 then
				if Config.DEBUG_OVERLAY_TREE_OFFSET + Config.DEBUG_OVERLAY_MAX_TREES <= i then
					break
				end
			end

			if Config.DEBUG_OVERLAY_TREE_OFFSET > i then
				continue
			end

			Overlay.Begin(`Bone Tree {i}`, ROOT_BACKGROUND_COLOR, ROOT_TEXT_COLOR)
			BoneTree:DrawOverlay(Overlay)
			Overlay.End()
		end
	end

	Overlay.End()
end

--- @within SmartBone
--- Destroys the root and all its children
function Class:Destroy()
	SB_VERBOSE_LOG("Deleting SmartBone Object")

	for _, BoneTree in self.BoneTrees do
		BoneTree:Destroy()
	end

	for _, ColliderObject in self.ColliderObjects do
		ColliderObject:Destroy()
	end

	setmetatable(self, nil)
end

--- @client
--- @within SmartBone
--- @return {Stop: () -> ()}
--- Collects all SmartBone objects and SmartBone colliders and starts running physics + collision on them
function Class.Start(): { Stop: () -> () }
	if not RunService:IsClient() then
		warn("Smartbone.Start() can only be called in client context.")
		return
	end

	if Class.Running then
		warn("Cannot call Smartbone.Start() multiple times")
		return
	end

	if Config.STARTUP_PRINT_ENABLED or Config.LOG_VERBOSE then
		print(`SmartBone2 v{Config.VERSION} Starting`)
	end

	Class.Running = true

	local Player = Players.LocalPlayer
	local PlayerScripts = Player:WaitForChild("PlayerScripts")

	local ActorFolder = Instance.new("Folder")
	ActorFolder.Name = "SmartBone-Actors"
	ActorFolder.Parent = PlayerScripts

	local OverlayEvent = Instance.new("BindableEvent")
	OverlayEvent.Name = "OverlayEvent"
	OverlayEvent.Parent = script

	OverlayEvent.Event:Connect(function(Type, ...)
		if not Config.DEBUG_OVERLAY_ENABLED then
			return
		end

		if Type == "Text" then
			ImOverlay:Text(...)
		elseif Type == "Begin" then
			ImOverlay:Begin(...)
		elseif Type == "End" then
			ImOverlay:End()
		end
	end)

	local ObjectToActor: { [BasePart]: Actor } = {}
	local ActorPool: { Actor } = {}

	local function GetActor(): Actor
		return table.remove(ActorPool) or Instance.new("Actor")
	end

	-- Called when an object is "freed", in this case, it's actor needs to be returned to the actor pool
	local function OnObjectFreed(Object: BasePart)
		local Actor = ObjectToActor[Object]
		ObjectToActor[Object] = nil

		if not Actor then
			return
		end

		Actor.Name = "Pooled Actor"

		table.insert(ActorPool, Actor)
	end

	local function GatherColliders()
		local ColliderObjects = {
			Key = {},
			Raw = {},
		}

		for _, Object in CollectionService:GetTagged("SmartCollider") do
			if not Object:IsA("BasePart") then
				continue
			end

			local ColliderKey = Object:GetAttribute("ColliderKey")

			if ColliderKey then
				ColliderKey = tostring(ColliderKey)

				if not ColliderObjects.Key[ColliderKey] then
					ColliderObjects.Key[ColliderKey] = {}
				end

				table.insert(ColliderObjects.Key[ColliderKey], Object)
			end

			SB_VERBOSE_LOG(`Adding collider: {Object.Name}, Collider Key: {ColliderKey}`)
			table.insert(ColliderObjects.Raw, Object)

			if Config.YIELD_ON_COLLIDER_GATHER then
				task.wait()
			end
		end

		return ColliderObjects
	end

	local function SetupObject(Object: BasePart)
		if not Object:IsA("BasePart") then
			return
		end

		SB_VERBOSE_LOG(`Setup Object: {Object.Name}`)
		SB_INDENT_LOG()

		local GlobalColliders = GatherColliders()
		local ColliderKey = Object:GetAttribute("ColliderKey")
		local ColliderObjects

		if ColliderKey then
			ColliderObjects = GlobalColliders.Key[tostring(ColliderKey)] or {}
		else
			ColliderObjects = GlobalColliders.Raw or {}
		end

		local ColliderDescriptions = {} -- {Description, Object}

		for _, ColliderObject in ColliderObjects do
			table.insert(ColliderDescriptions, { Utilities.GetCollider(ColliderObject), ColliderObject })
		end

		local Actor = GetActor()
		local Runtime = ActorRuntime:Clone()

		Runtime.Parent = Actor
		Runtime.Enabled = true

		Actor.Parent = ActorFolder

		ObjectToActor[Object] = Actor

		-- If we dont yield here a bug happens on occasion where the actor doesn't bind quick enough and misses the setup message
		task.wait()

		Actor:SendMessage("Setup", Object, ColliderDescriptions, script)

		-- Don't have to cleanup this connection since it's tied to the instance
		-- Here we handle freeing up the actor attached to the object when it's destroyed
		Object:GetPropertyChangedSignal("Parent"):Connect(function()
			if Object.Parent ~= nil then
				return
			end

			OnObjectFreed(Object)
		end)

		SB_VERBOSE_LOG(`Runtime Started`)
		SB_UNINDENT_LOG()
	end

	local TagAddedConnection = CollectionService:GetInstanceAddedSignal("SmartBone"):Connect(SetupObject)
	local TagRemovedConnection = CollectionService:GetInstanceRemovedSignal("SmartBone"):Connect(OnObjectFreed)

	for _, Object in CollectionService:GetTagged("SmartBone") do
		SetupObject(Object)
	end

	if Config.DEBUG_OVERLAY_ENABLED then
		ImOverlay = CeiveImOverlay.new()

		local PlayerGui = Players.LocalPlayer.PlayerGui

		local DebugGui = Instance.new("ScreenGui")
		DebugGui.Name = "SmartBoneDebugOverlay"
		DebugGui.IgnoreGuiInset = true
		DebugGui.ResetOnSpawn = false
		DebugGui.Parent = PlayerGui

		ImOverlay.BackFrame.Parent = DebugGui

		RunService.RenderStepped:Connect(function()
			ImOverlay:Render()
		end)
	end

	return {
		Stop = function()
			Class.Running = false

			if not Config.RESET_BONE_ON_DESTROY then
				ActorFolder:Destroy()
				return
			end

			for _, Actor: Actor in ActorFolder:GetChildren() do
				Actor:SendMessage("Destroy")
			end

			if TagAddedConnection then
				TagAddedConnection:Disconnect()
			end

			if TagRemovedConnection then
				TagRemovedConnection:Disconnect()
			end
		end,
	}
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris | Enabled: N/A
--------------------------------------------------------------------
--!optimize 2
local Types = require(script.Types)
local Iris = {} :: Types.Iris
local Internal: Types.Internal = require(script.Internal)(Iris)

Iris.Disabled = false

Iris.Args = {}

Iris.Events = {}

function Iris.HasInit()
	return Internal._started
end

function Iris.Init(parentInstance: BasePlayerGui?, eventConnection: (RBXScriptSignal | () -> ())?): Types.Iris
	if parentInstance == nil then
		-- coalesce to playerGui
		parentInstance = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
	end
	if eventConnection == nil then
		-- coalesce to Heartbeat
		eventConnection = game:GetService("RunService").Heartbeat
	end
	Internal.parentInstance = parentInstance :: BasePlayerGui
	assert(Internal._started == false, "Iris.Init can only be called once.")
	Internal._started = true

	Internal._generateRootInstance()
	Internal._generateSelectionImageObject()

	-- spawns the connection to call `Internal._cycle()` within.
	task.spawn(function()
		if typeof(eventConnection) == "function" then
			while true do
				eventConnection()
				Internal._cycle()
			end
		elseif eventConnection ~= nil then
			eventConnection:Connect(function()
				Internal._cycle()
			end)
		end
	end)

	return Iris
end

function Iris:Connect(callback: () -> ()) -- this uses method syntax for no reason.
	if Internal._started == false then
		warn("Iris:Connect() was called before calling Iris.Init(), the connected function will never run")
	end
	table.insert(Internal._connectedFunctions, callback)
end

function Iris.Append(userInstance: GuiObject)
	local parentWidget: Types.Widget = Internal._GetParentWidget()
	local widgetInstanceParent: GuiObject
	if Internal._config.Parent then
		widgetInstanceParent = Internal._config.Parent :: any
	else
		widgetInstanceParent = Internal._widgets[parentWidget.type].ChildAdded(parentWidget, { type = "userInstance" } :: Types.Widget)
	end
	userInstance.Parent = widgetInstanceParent
end

function Iris.End()
	if Internal._stackIndex == 1 then
		error("Callback has too many calls to Iris.End()", 2)
	end
	Internal._IDStack[Internal._stackIndex] = nil
	Internal._stackIndex -= 1
end

--[[
    ------------------------
        [SECTION] Config
    ------------------------
]]

function Iris.ForceRefresh()
	Internal._globalRefreshRequested = true
end

function Iris.UpdateGlobalConfig(deltaStyle: { [string]: any })
	for index, style in deltaStyle do
		Internal._rootConfig[index] = style
	end
	Iris.ForceRefresh()
end

function Iris.PushConfig(deltaStyle: { [string]: any })
	local ID = Iris.State(-1)
	if ID.value == -1 then
		ID:set(deltaStyle)
	else
		-- compare tables
		if Internal._deepCompare(ID:get(), deltaStyle) == false then
			-- refresh local
			Internal._localRefreshActive = true
			ID:set(deltaStyle)
		end
	end

	Internal._config = setmetatable(deltaStyle, {
		__index = Internal._config,
	}) :: any
end

function Iris.PopConfig()
	Internal._localRefreshActive = false
	Internal._config = getmetatable(Internal._config :: any).__index
end

Iris.TemplateConfig = require(script.config)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark) -- use colorDark and sizeDefault themes by default
Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.utilityDefault)
Internal._globalRefreshRequested = false -- UpdatingGlobalConfig changes this to true, leads to Root being generated twice.

--[[
    --------------------
        [SECTION] ID
    --------------------
]]

function Iris.PushId(id: Types.ID)
	assert(typeof(id) == "string", "Iris expected Iris.PushId id to PushId to be a string.")

	Internal._pushedId = tostring(id)
end

function Iris.PopId()
	Internal._pushedId = nil
end

function Iris.SetNextWidgetID(id: Types.ID)
	Internal._nextWidgetId = id
end

--[[
    -----------------------
        [SECTION] State
    -----------------------
]]

function Iris.State(initialValue: any): Types.State
	local ID: Types.ID = Internal._getID(2)
	if Internal._states[ID] then
		return Internal._states[ID]
	end
	Internal._states[ID] = {
		value = initialValue,
		ConnectedWidgets = {},
		ConnectedFunctions = {},
	} :: any
	setmetatable(Internal._states[ID], Internal.StateClass)
	return Internal._states[ID]
end

function Iris.WeakState(initialValue: any): Types.State
	local ID: Types.ID = Internal._getID(2)
	if Internal._states[ID] then
		if #Internal._states[ID].ConnectedWidgets == 0 then
			Internal._states[ID] = nil
		else
			return Internal._states[ID]
		end
	end
	Internal._states[ID] = {
		value = initialValue,
		ConnectedWidgets = {},
		ConnectedFunctions = {},
	} :: any
	setmetatable(Internal._states[ID], Internal.StateClass)
	return Internal._states[ID]
end

function Iris.ComputedState(firstState: Types.State, onChangeCallback: (firstState: any) -> any): Types.State
	local ID: Types.ID = Internal._getID(2)

	if Internal._states[ID] then
		return Internal._states[ID]
	else
		Internal._states[ID] = {
			value = onChangeCallback(firstState.value),
			ConnectedWidgets = {},
			ConnectedFunctions = {},
		} :: any
		firstState:onChange(function(newValue: any)
			Internal._states[ID]:set(onChangeCallback(newValue))
		end)
		setmetatable(Internal._states[ID], Internal.StateClass)
		return Internal._states[ID]
	end
end

Iris.ShowDemoWindow = require(script.demoWindow)(Iris)

require(script.widgets)(Internal)
require(script.API)(Iris)

return Iris

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

local widgets = {} :: Types.WidgetUtility

return function(Iris: Types.Internal)
    widgets.GuiService = game:GetService("GuiService")
    widgets.RunService = game:GetService("RunService")
    widgets.UserInputService = game:GetService("UserInputService")
    widgets.ContextActionService = game:GetService("ContextActionService")
    widgets.TextService = game:GetService("TextService")

    widgets.ICONS = {
        RIGHT_POINTING_TRIANGLE = "rbxasset://textures/DeveloperFramework/button_arrow_right.png",
        DOWN_POINTING_TRIANGLE = "rbxasset://textures/DeveloperFramework/button_arrow_down.png",
        MULTIPLICATION_SIGN = "rbxasset://textures/AnimationEditor/icon_close.png", -- best approximation for a close X which roblox supports, needs to be scaled about 2x
        BOTTOM_RIGHT_CORNER = "\u{25E2}", -- used in window resize icon in bottom right
        CHECK_MARK = "rbxasset://textures/AnimationEditor/icon_checkmark.png",
        ALPHA_BACKGROUND_TEXTURE = "rbxasset://textures/meshPartFallback.png", -- used for color4 alpha
    }

    widgets.GuiInset = widgets.GuiService:GetGuiInset()

    widgets.IS_STUDIO = widgets.RunService:IsStudio()
    function widgets.getTime()
        -- time() always returns 0 in the context of plugins
        if widgets.IS_STUDIO then
            return os.clock()
        else
            return time()
        end
    end

    function widgets.getMouseLocation(): Vector2
        return widgets.UserInputService:GetMouseLocation() - widgets.GuiInset
    end

    function widgets.findBestWindowPosForPopup(refPos: Vector2, size: Vector2, outerMin: Vector2, outerMax: Vector2): Vector2
        local CURSOR_OFFSET_DIST: number = 20

        if refPos.X + size.X + CURSOR_OFFSET_DIST > outerMax.X then
            if refPos.Y + size.Y + CURSOR_OFFSET_DIST > outerMax.Y then
                -- placed to the top
                refPos += Vector2.new(0, -(CURSOR_OFFSET_DIST + size.Y))
            else
                -- placed to the bottom
                refPos += Vector2.new(0, CURSOR_OFFSET_DIST)
            end
        else
            -- placed to the right
            refPos += Vector2.new(CURSOR_OFFSET_DIST, 0)
        end

        local clampedPos: Vector2 = Vector2.new(math.max(math.min(refPos.X + size.X, outerMax.X) - size.X, outerMin.X), math.max(math.min(refPos.Y + size.Y, outerMax.Y) - size.Y, outerMin.Y))
        return clampedPos
    end

    function widgets.isPosInsideRect(pos: Vector2, rectMin: Vector2, rectMax: Vector2): boolean
        return pos.X > rectMin.X and pos.X < rectMax.X and pos.Y > rectMin.Y and pos.Y < rectMax.Y
    end

    function widgets.extend(superClass: Types.WidgetClass, subClass: Types.WidgetClass): Types.WidgetClass
        local newClass: Types.WidgetClass = table.clone(superClass)
        for index: string, value: any in subClass do
            newClass[index] = value
        end
        return newClass
    end

    function widgets.UIPadding(Parent: GuiObject, PxPadding: Vector2): UIPadding
        local UIPaddingInstance: UIPadding = Instance.new("UIPadding")
        UIPaddingInstance.PaddingLeft = UDim.new(0, PxPadding.X)
        UIPaddingInstance.PaddingRight = UDim.new(0, PxPadding.X)
        UIPaddingInstance.PaddingTop = UDim.new(0, PxPadding.Y)
        UIPaddingInstance.PaddingBottom = UDim.new(0, PxPadding.Y)
        UIPaddingInstance.Parent = Parent
        return UIPaddingInstance
    end

    function widgets.UIListLayout(Parent: GuiObject, FillDirection: Enum.FillDirection, Padding: UDim): UIListLayout
        local UIListLayoutInstance: UIListLayout = Instance.new("UIListLayout")
        UIListLayoutInstance.SortOrder = Enum.SortOrder.LayoutOrder
        UIListLayoutInstance.Padding = Padding
        UIListLayoutInstance.FillDirection = FillDirection
        UIListLayoutInstance.Parent = Parent
        return UIListLayoutInstance
    end

    function widgets.UIStroke(Parent: GuiObject, Thickness: number, Color: Color3, Transparency: number): UIStroke
        local UIStrokeInstance: UIStroke = Instance.new("UIStroke")
        UIStrokeInstance.Thickness = Thickness
        UIStrokeInstance.Color = Color
        UIStrokeInstance.Transparency = Transparency
        UIStrokeInstance.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        UIStrokeInstance.LineJoinMode = Enum.LineJoinMode.Round
        UIStrokeInstance.Parent = Parent
        return UIStrokeInstance
    end

    function widgets.UICorner(Parent: GuiObject, PxRounding: number?): UICorner
        local UICornerInstance: UICorner = Instance.new("UICorner")
        UICornerInstance.CornerRadius = UDim.new(PxRounding and 0 or 1, PxRounding or 0)
        UICornerInstance.Parent = Parent
        return UICornerInstance
    end

    function widgets.UISizeConstraint(Parent: GuiObject, MinSize: Vector2?, MaxSize: Vector2?): UISizeConstraint
        local UISizeConstraintInstance: UISizeConstraint = Instance.new("UISizeConstraint")
        UISizeConstraintInstance.MinSize = MinSize or UISizeConstraintInstance.MinSize -- made these optional
        UISizeConstraintInstance.MaxSize = MaxSize or UISizeConstraintInstance.MaxSize
        UISizeConstraintInstance.Parent = Parent
        return UISizeConstraintInstance
    end

    function widgets.UIReference(Parent: GuiObject, Child: GuiObject, Name: string): ObjectValue
        local ObjectValue: ObjectValue = Instance.new("ObjectValue")
        ObjectValue.Name = Name
        ObjectValue.Value = Child
        ObjectValue.Parent = Parent

        return ObjectValue
    end

    function widgets.getScreenSizeForWindow(thisWidget: Types.Widget): Vector2 -- possible parents are GuiBase2d, CoreGui, PlayerGui
        local size: Vector2
        if thisWidget.usesScreenGUI then
            size = thisWidget.Instance.AbsoluteSize
        else
            local rootParent = thisWidget.Instance.Parent
            if rootParent:IsA("GuiBase2d") then
                size = rootParent.AbsoluteSize
            else
                if rootParent.Parent:IsA("GuiBase2d") then
                    size = rootParent.AbsoluteSize
                else
                    size = workspace.CurrentCamera.ViewportSize
                end
            end
        end
        return size
    end

    -- below uses Iris

    local textParams: GetTextBoundsParams = Instance.new("GetTextBoundsParams")
    textParams.Font = Iris._config.TextFont
    textParams.Size = Iris._config.TextSize
    textParams.Width = math.huge
    function widgets.calculateTextSize(text: string, width: number?): Vector2
        if width then
            textParams.Width = width
        end
        textParams.Text = text

        local size: Vector2 = widgets.TextService:GetTextBoundsAsync(textParams)

        if width then
            textParams.Width = math.huge
        end

        return size
    end

    function widgets.applyTextStyle(thisInstance: TextLabel & TextButton & TextBox)
        thisInstance.FontFace = Iris._config.TextFont
        thisInstance.TextSize = Iris._config.TextSize
        thisInstance.TextColor3 = Iris._config.TextColor
        thisInstance.TextTransparency = Iris._config.TextTransparency
        thisInstance.TextXAlignment = Enum.TextXAlignment.Left

        thisInstance.AutoLocalize = false
        thisInstance.RichText = false
    end

    function widgets.applyInteractionHighlights(Button: GuiButton, Highlightee: GuiObject, Colors: { [string]: any })
        local exitedButton: boolean = false
        Button.MouseEnter:Connect(function()
            Highlightee.BackgroundColor3 = Colors.ButtonHoveredColor
            Highlightee.BackgroundTransparency = Colors.ButtonHoveredTransparency

            exitedButton = false
        end)

        Button.MouseLeave:Connect(function()
            Highlightee.BackgroundColor3 = Colors.ButtonColor
            Highlightee.BackgroundTransparency = Colors.ButtonTransparency

            exitedButton = true
        end)

        Button.InputBegan:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) then
                return
            end
            Highlightee.BackgroundColor3 = Colors.ButtonActiveColor
            Highlightee.BackgroundTransparency = Colors.ButtonActiveTransparency
        end)

        Button.InputEnded:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) or exitedButton then
                return
            end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                Highlightee.BackgroundColor3 = Colors.ButtonHoveredColor
                Highlightee.BackgroundTransparency = Colors.ButtonHoveredTransparency
            end
            if input.UserInputType == Enum.UserInputType.Gamepad1 then
                Highlightee.BackgroundColor3 = Colors.ButtonColor
                Highlightee.BackgroundTransparency = Colors.ButtonTransparency
            end
        end)

        Button.SelectionImageObject = Iris.SelectionImageObject
    end

    function widgets.applyInteractionHighlightsWithMultiHighlightee(Button: GuiButton, Highlightees: { { GuiObject | { [string]: Color3 | number } } })
        local exitedButton: boolean = false
        Button.MouseEnter:Connect(function()
            for _, Highlightee in Highlightees do
                Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonHoveredColor
                Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonHoveredTransparency

                exitedButton = false
            end
        end)

        Button.MouseLeave:Connect(function()
            for _, Highlightee in Highlightees do
                Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonColor
                Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonTransparency

                exitedButton = true
            end
        end)

        Button.InputBegan:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) then
                return
            end
            for _, Highlightee in Highlightees do
                Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonActiveColor
                Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonActiveTransparency
            end
        end)

        Button.InputEnded:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) or exitedButton then
                return
            end
            for _, Highlightee in Highlightees do
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonHoveredColor
                    Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonHoveredTransparency
                end
                if input.UserInputType == Enum.UserInputType.Gamepad1 then
                    Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonColor
                    Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonTransparency
                end
            end
        end)

        Button.SelectionImageObject = Iris.SelectionImageObject
    end

    function widgets.applyTextInteractionHighlights(Button: GuiButton, Highlightee: TextLabel & TextButton & TextBox, Colors: { [string]: any })
        local exitedButton = false
        Button.MouseEnter:Connect(function()
            Highlightee.TextColor3 = Colors.ButtonHoveredColor
            Highlightee.TextTransparency = Colors.ButtonHoveredTransparency

            exitedButton = false
        end)

        Button.MouseLeave:Connect(function()
            Highlightee.TextColor3 = Colors.ButtonColor
            Highlightee.TextTransparency = Colors.ButtonTransparency

            exitedButton = true
        end)

        Button.InputBegan:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) then
                return
            end
            Highlightee.TextColor3 = Colors.ButtonActiveColor
            Highlightee.TextTransparency = Colors.ButtonActiveTransparency
        end)

        Button.InputEnded:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) or exitedButton then
                return
            end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                Highlightee.TextColor3 = Colors.ButtonHoveredColor
                Highlightee.TextTransparency = Colors.ButtonHoveredTransparency
            end
            if input.UserInputType == Enum.UserInputType.Gamepad1 then
                Highlightee.TextColor3 = Colors.ButtonColor
                Highlightee.TextTransparency = Colors.ButtonTransparency
            end
        end)

        Button.SelectionImageObject = Iris.SelectionImageObject
    end

    function widgets.applyFrameStyle(thisInstance: GuiObject, forceNoPadding: boolean?, doubleyNoPadding: boolean?)
        -- padding, border, and rounding
        -- optimized to only use what instances are needed, based on style
        local FramePadding: Vector2 = Iris._config.FramePadding
        local FrameBorderSize: number = Iris._config.FrameBorderSize
        local FrameBorderColor: Color3 = Iris._config.BorderColor
        local FrameBorderTransparency: number = Iris._config.ButtonTransparency
        local FrameRounding: number = Iris._config.FrameRounding

        if FrameBorderSize > 0 and FrameRounding > 0 then
            thisInstance.BorderSizePixel = 0

            local uiStroke: UIStroke = Instance.new("UIStroke")
            uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            uiStroke.LineJoinMode = Enum.LineJoinMode.Round
            uiStroke.Transparency = FrameBorderTransparency
            uiStroke.Thickness = FrameBorderSize
            uiStroke.Color = FrameBorderColor

            widgets.UICorner(thisInstance, FrameRounding)
            uiStroke.Parent = thisInstance

            if not forceNoPadding then
                widgets.UIPadding(thisInstance, Iris._config.FramePadding)
            end
        elseif FrameBorderSize < 1 and FrameRounding > 0 then
            thisInstance.BorderSizePixel = 0

            widgets.UICorner(thisInstance, FrameRounding)
            if not forceNoPadding then
                widgets.UIPadding(thisInstance, Iris._config.FramePadding)
            end
        elseif FrameRounding < 1 then
            thisInstance.BorderSizePixel = FrameBorderSize
            thisInstance.BorderColor3 = FrameBorderColor
            thisInstance.BorderMode = Enum.BorderMode.Inset

            if not forceNoPadding then
                widgets.UIPadding(thisInstance, FramePadding - Vector2.new(FrameBorderSize, FrameBorderSize))
            elseif not doubleyNoPadding then
                widgets.UIPadding(thisInstance, -Vector2.new(FrameBorderSize, FrameBorderSize))
            end
        end
    end

    function widgets.discardState(thisWidget: Types.Widget)
        for _, state: Types.State in thisWidget.state do
            state.ConnectedWidgets[thisWidget.ID] = nil
        end
    end

    widgets.EVENTS = {
        hover = function(pathToHovered: (thisWidget: Types.Widget) -> GuiObject)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local hoveredGuiObject: GuiObject = pathToHovered(thisWidget)
                    hoveredGuiObject.MouseEnter:Connect(function()
                        thisWidget.isHoveredEvent = true
                    end)
                    hoveredGuiObject.MouseLeave:Connect(function()
                        thisWidget.isHoveredEvent = false
                    end)
                    thisWidget.isHoveredEvent = false
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.isHoveredEvent
                end,
            }
        end,

        click = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastClickedTick = -1
                    
clickedGuiObject.MouseButton1Click:Connect(function()
                        thisWidget.lastClickedTick = Iris._cycleTick + 1
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastClickedTick == Iris._cycleTick
                end,
            }
        end,

        rightClick = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastRightClickedTick = -1
                    
clickedGuiObject.MouseButton2Click:Connect(function()
                        thisWidget.lastRightClickedTick = Iris._cycleTick + 1
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastRightClickedTick == Iris._cycleTick
                end,
            }
        end,

        doubleClick = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastClickedTime = -1                    
thisWidget.lastClickedPosition = Vector2.zero
                    thisWidget.lastDoubleClickedTick = -1
                    
clickedGuiObject.MouseButton1Down:Connect(function(x: number, y: number)
                        local currentTime: number = widgets.getTime()
                        local isTimeValid: boolean = currentTime - thisWidget.lastClickedTime < Iris._config.MouseDoubleClickTime
                        if isTimeValid and (Vector2.new(x, y) - thisWidget.lastClickedPosition).Magnitude < Iris._config.MouseDoubleClickMaxDist then
                            thisWidget.lastDoubleClickedTick = Iris._cycleTick + 1
                        else
                            thisWidget.lastClickedTime = currentTime
                            thisWidget.lastClickedPosition = Vector2.new(x, y)
                        end
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastDoubleClickedTick == Iris._cycleTick
                end,
            }
        end,

        ctrlClick = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastCtrlClickedTick = -1
                    
clickedGuiObject.MouseButton1Click:Connect(function()
                        if widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
                            thisWidget.lastCtrlClickedTick = Iris._cycleTick + 1
                        end
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastCtrlClickedTick == Iris._cycleTick
                end,
            }
        end,

        shortcut = function(pathToKeys: (thisWidget: Types.Widget) -> (Enum.KeyCode, Enum.ModifierKey))
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local keycode: Enum.KeyCode, modifier: Enum.ModifierKey = pathToKeys(thisWidget)
                    thisWidget.lastShortcutTick = -1
                    
widgets.ContextActionService:BindAction(thisWidget.ID, function(_, inputState: Enum.UserInputState, inputObject: InputObject)
                        if inputState == Enum.UserInputState.Begin then
                            if inputObject:IsModifierKeyDown(modifier) then
                                thisWidget.lastShortcutTick = Iris._cycleTick + 1
                            end
                        end
                    end, false, keycode)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastShortcutTick == Iris._cycleTick
                end,
            }
        end,
    }

    require(script.Root)(Iris, widgets)
    require(script.Window)(Iris, widgets)

    require(script.Menu)(Iris, widgets)

    require(script.Format)(Iris, widgets)

    require(script.Text)(Iris, widgets)
    require(script.Button)(Iris, widgets)
    require(script.Checkbox)(Iris, widgets)
    require(script.RadioButton)(Iris, widgets)

    require(script.Tree)(Iris, widgets)

    require(script.Input)(Iris, widgets)
    require(script.Combo)(Iris, widgets)

    require(script.Table)(Iris, widgets)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets
  -  Edit
  18:44:43.287  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Button | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local abstractButton = {
        hasState = false,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
        },
        Events = {
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["rightClicked"] = widgets.EVENTS.rightClick(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["doubleClicked"] = widgets.EVENTS.doubleClick(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["ctrlClicked"] = widgets.EVENTS.ctrlClick(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.Widget): TextButton
            local Button: TextButton = Instance.new("TextButton")
            Button.Size = UDim2.fromOffset(0, 0)
            Button.BackgroundColor3 = Iris._config.ButtonColor
            Button.BackgroundTransparency = Iris._config.ButtonTransparency
            Button.AutoButtonColor = false

            widgets.applyTextStyle(Button)
            Button.AutomaticSize = Enum.AutomaticSize.XY

            widgets.applyFrameStyle(Button)

            widgets.applyInteractionHighlights(Button, Button, {
                ButtonColor = Iris._config.ButtonColor,
                ButtonTransparency = Iris._config.ButtonTransparency,
                ButtonHoveredColor = Iris._config.ButtonHoveredColor,
                ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
                ButtonActiveColor = Iris._config.ButtonActiveColor,
                ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
            })

            Button.ZIndex = thisWidget.ZIndex
            Button.LayoutOrder = thisWidget.ZIndex

            return Button
        end,
        Update = function(thisWidget: Types.Widget)
            local Button = thisWidget.Instance :: TextButton
            Button.Text = thisWidget.arguments.Text or "Button"
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass
    widgets.abstractButton = abstractButton

    Iris.WidgetConstructor(
        "Button",
        widgets.extend(abstractButton, {
            Generate = function(thisWidget: Types.Widget): TextButton
                local Button: TextButton = abstractButton.Generate(thisWidget)
                Button.Name = "Iris_Button"

                return Button
            end,
        } :: Types.WidgetClass)
    )

    Iris.WidgetConstructor(
        "SmallButton",
        widgets.extend(abstractButton, {
            Generate = function(thisWidget: Types.Widget): TextButton
                local SmallButton = abstractButton.Generate(thisWidget) :: TextButton
                SmallButton.Name = "Iris_SmallButton"

                local uiPadding: UIPadding = SmallButton.UIPadding
                uiPadding.PaddingLeft = UDim.new(0, 2)
                uiPadding.PaddingRight = UDim.new(0, 2)
                uiPadding.PaddingTop = UDim.new(0, 0)
                uiPadding.PaddingBottom = UDim.new(0, 0)

                return SmallButton
            end,
        } :: Types.WidgetClass)
    )
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Button

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Checkbox | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    Iris.WidgetConstructor("Checkbox", {
        hasState = true,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
        },
        Events = {
            ["checked"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastCheckedTick == Iris._cycleTick
                end,
            },
            ["unchecked"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastUncheckedTick == Iris._cycleTick
                end,
            },
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget): GuiObject
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.Widget): TextButton
            local Checkbox: TextButton = Instance.new("TextButton")
            Checkbox.Name = "Iris_Checkbox"
            Checkbox.BackgroundTransparency = 1
            Checkbox.BorderSizePixel = 0
            Checkbox.Size = UDim2.fromOffset(0, 0)
            Checkbox.Text = ""
            Checkbox.AutomaticSize = Enum.AutomaticSize.XY
            Checkbox.ZIndex = thisWidget.ZIndex
            Checkbox.AutoButtonColor = false
            Checkbox.LayoutOrder = thisWidget.ZIndex

            local checkboxSize: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

            local CheckboxBox: Frame = Instance.new("Frame")
            CheckboxBox.Name = "CheckboxBox"
            CheckboxBox.Size = UDim2.fromOffset(checkboxSize, checkboxSize)
            CheckboxBox.BackgroundColor3 = Iris._config.FrameBgColor
            CheckboxBox.BackgroundTransparency = Iris._config.FrameBgTransparency
            CheckboxBox.ZIndex = thisWidget.ZIndex + 1
            CheckboxBox.LayoutOrder = thisWidget.ZIndex + 1
            widgets.applyFrameStyle(CheckboxBox, true)

            widgets.applyInteractionHighlights(Checkbox, CheckboxBox, {
                ButtonColor = Iris._config.FrameBgColor,
                ButtonTransparency = Iris._config.FrameBgTransparency,
                ButtonHoveredColor = Iris._config.FrameBgHoveredColor,
                ButtonHoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                ButtonActiveColor = Iris._config.FrameBgActiveColor,
                ButtonActiveTransparency = Iris._config.FrameBgActiveTransparency,
            })

            CheckboxBox.Parent = Checkbox

            local padding: number = math.ceil(checkboxSize * 0.1)
            local checkmarkSize: number = checkboxSize - 2 * padding

            local Checkmark: ImageLabel = Instance.new("ImageLabel")
            Checkmark.Name = "Checkmark"
            Checkmark.Size = UDim2.fromOffset(checkmarkSize, checkmarkSize)
            Checkmark.Position = UDim2.fromOffset(padding, padding)
            Checkmark.BackgroundTransparency = 1
            Checkmark.ImageColor3 = Iris._config.CheckMarkColor
            Checkmark.ImageTransparency = Iris._config.CheckMarkTransparency
            Checkmark.ScaleType = Enum.ScaleType.Fit
            Checkmark.ZIndex = thisWidget.ZIndex + 2
            Checkmark.LayoutOrder = thisWidget.ZIndex + 2

            Checkmark.Parent = Checkbox

            Checkbox.MouseButton1Click:Connect(function()
                local wasChecked: boolean = thisWidget.state.isChecked.value
                thisWidget.state.isChecked:set(not wasChecked)
            end)

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            widgets.applyTextStyle(TextLabel)
            TextLabel.AnchorPoint = Vector2.new(0, 0.5)
            TextLabel.Position = UDim2.new(0, checkboxSize + Iris._config.ItemInnerSpacing.X, 0.5, 0)
            TextLabel.ZIndex = thisWidget.ZIndex + 1
            TextLabel.LayoutOrder = thisWidget.ZIndex + 1
            TextLabel.AutomaticSize = Enum.AutomaticSize.XY
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0
            TextLabel.Parent = Checkbox

            return Checkbox
        end,
        Update = function(thisWidget: Types.Widget)
            local Checkbox = thisWidget.Instance :: TextButton
            Checkbox.TextLabel.Text = thisWidget.arguments.Text or "Checkbox"
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
        GenerateState = function(thisWidget: Types.Widget)
            if thisWidget.state.isChecked == nil then
                thisWidget.state.isChecked = Iris._widgetState(thisWidget, "checked", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Widget)
            local Checkbox = thisWidget.Instance :: TextButton
            local Checkmark: ImageLabel = Checkbox.Checkmark
            if thisWidget.state.isChecked.value then
                Checkmark.Image = widgets.ICONS.CHECK_MARK
                thisWidget.lastCheckedTick = Iris._cycleTick + 1
            else
                Checkmark.Image = ""
                thisWidget.lastUncheckedTick = Iris._cycleTick + 1
            end
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Checkbox

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Combo | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local function onSelectionChange(thisWidget)
        if type(thisWidget.state.index.value) == "boolean" then
            thisWidget.state.index:set(not thisWidget.state.index.value)
        else
            thisWidget.state.index:set(thisWidget.arguments.Index)
        end
    end

    Iris.WidgetConstructor("Selectable", {
        hasState = true,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
            ["Index"] = 2,
            ["NoClick"] = 3,
        },
        Events = {
            ["selected"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastSelectedTick == Iris._cycleTick
                end,
            },
            ["unselected"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastUnselectedTick == Iris._cycleTick
                end,
            },
            ["active"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.state.index.value == thisWidget.arguments.Index
                end,
            },
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["rightClicked"] = widgets.EVENTS.rightClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["doubleClicked"] = widgets.EVENTS.doubleClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["ctrlClicked"] = widgets.EVENTS.ctrlClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
        },
        Generate = function(thisWidget: Types.Widget): Frame
            local Selectable: Frame = Instance.new("Frame")
            Selectable.Name = "Iris_Selectable"
            Selectable.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, Iris._config.TextSize))
            Selectable.AutomaticSize = Enum.AutomaticSize.None
            Selectable.BackgroundTransparency = 1
            Selectable.BorderSizePixel = 0
            Selectable.ZIndex = thisWidget.ZIndex
            Selectable.LayoutOrder = thisWidget.ZIndex

            local SelectableButton: TextButton = Instance.new("TextButton")
            SelectableButton.Name = "SelectableButton"
            SelectableButton.Size = UDim2.new(1, 0, 1, Iris._config.ItemSpacing.Y - 1)
            SelectableButton.Position = UDim2.fromOffset(0, -bit32.rshift(Iris._config.ItemSpacing.Y, 1))
            SelectableButton.BackgroundColor3 = Iris._config.HeaderColor
            SelectableButton.ZIndex = thisWidget.ZIndex + 1
            SelectableButton.LayoutOrder = thisWidget.ZIndex + 1

            widgets.applyFrameStyle(SelectableButton)
            widgets.applyTextStyle(SelectableButton)

            thisWidget.ButtonColors = {
                ButtonColor = Iris._config.HeaderColor,
                ButtonTransparency = 1,
                ButtonHoveredColor = Iris._config.HeaderHoveredColor,
                ButtonHoveredTransparency = Iris._config.HeaderHoveredTransparency,
                ButtonActiveColor = Iris._config.HeaderActiveColor,
                ButtonActiveTransparency = Iris._config.HeaderActiveTransparency,
            }

            widgets.applyInteractionHighlights(SelectableButton, SelectableButton, thisWidget.ButtonColors)

            SelectableButton.MouseButton1Click:Connect(function()
                if thisWidget.arguments.NoClick ~= true then
                    onSelectionChange(thisWidget)
                end
            end)

            SelectableButton.Parent = Selectable

            return Selectable
        end,
        Update = function(thisWidget: Types.Widget)
            local Selectable = thisWidget.Instance :: Frame
            local SelectableButton: TextButton = Selectable.SelectableButton
            SelectableButton.Text = thisWidget.arguments.Text or "Selectable"
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
        GenerateState = function(thisWidget: Types.Widget)
            if thisWidget.state.index == nil then
                if thisWidget.arguments.Index ~= nil then
                    error("a shared state index is required for Selectables with an Index argument", 5)
                end
                thisWidget.state.index = Iris._widgetState(thisWidget, "index", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Widget)
            local Selectable = thisWidget.Instance :: Frame
            local SelectableButton: TextButton = Selectable.SelectableButton
            if thisWidget.state.index.value == (thisWidget.arguments.Index or true) then
                thisWidget.ButtonColors.ButtonTransparency = Iris._config.HeaderTransparency
                SelectableButton.BackgroundTransparency = Iris._config.HeaderTransparency
                thisWidget.lastSelectedTick = Iris._cycleTick + 1
            else
                thisWidget.ButtonColors.ButtonTransparency = 1
                SelectableButton.BackgroundTransparency = 1
                thisWidget.lastUnselectedTick = Iris._cycleTick + 1
            end
        end,
    } :: Types.WidgetClass)

    local AnyOpenedCombo = false
    local ComboOpenedTick = -1    
local OpenedCombo

    local function UpdateChildContainerTransform(thisWidget: Types.Widget)
        local Iris_Combo = thisWidget.Instance :: Frame
        local PreviewContainer = Iris_Combo.PreviewContainer :: TextButton
        local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
        local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame

        local labelHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

        local borderWidth: number = Iris._config.PopupBorderSize
        local ChildContainerHeight: number = (labelHeight * math.min(thisWidget.ComboChildrenHeight, 8) - 2 * borderWidth) + (3 * Iris._config.FramePadding.Y)
        local ChildContainerWidth: UDim = UDim.new(0, PreviewContainer.AbsoluteSize.X - 2 * borderWidth)
        ChildContainer.Size = UDim2.new(ChildContainerWidth, UDim.new(0, ChildContainerHeight))

        local ScreenSize: Vector2 = ChildContainer.Parent.AbsoluteSize

        if PreviewLabel.AbsolutePosition.Y + labelHeight + ChildContainerHeight > ScreenSize.Y then
            -- too large to fit below the Combo, so is placed above
            ChildContainer.Position = UDim2.new(0, PreviewLabel.AbsolutePosition.X + borderWidth, 0, PreviewLabel.AbsolutePosition.Y - borderWidth - ChildContainerHeight)
        else
            ChildContainer.Position = UDim2.new(0, PreviewLabel.AbsolutePosition.X + borderWidth, 0, PreviewLabel.AbsolutePosition.Y + labelHeight + borderWidth)
        end
    end

    widgets.UserInputService.InputBegan:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and inputObject.UserInputType ~= Enum.UserInputType.MouseButton2 and inputObject.UserInputType ~= Enum.UserInputType.Touch then
            return
        end
        if AnyOpenedCombo == false then
            return
        end
        if ComboOpenedTick == Iris._cycleTick then
            return
        end
        local MouseLocation: Vector2 = widgets.getMouseLocation()
        local ChildContainer = OpenedCombo.ChildContainer
        local rectMin: Vector2 = ChildContainer.AbsolutePosition - Vector2.new(0, OpenedCombo.LabelHeight)
        local rectMax: Vector2 = ChildContainer.AbsolutePosition + ChildContainer.AbsoluteSize
        if not widgets.isPosInsideRect(MouseLocation, rectMin, rectMax) then
            OpenedCombo.state.isOpened:set(false)
        end
    end)

    Iris.WidgetConstructor("Combo", {
        hasState = true,
        hasChildren = true,
        Args = {
            ["Text"] = 1,
            ["NoButton"] = 2,
            ["NoPreview"] = 3,
        },
        Events = {
            ["opened"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastOpenedTick == Iris._cycleTick
                end,
            },
            ["closed"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastClosedTick == Iris._cycleTick
                end,
            },
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.Widget)
            local frameHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y
            thisWidget.ComboChildrenHeight = 0

            local Combo: Frame = Instance.new("Frame")
            Combo.Name = "Iris_Combo"
            Combo.Size = UDim2.fromScale(1, 0)
            Combo.AutomaticSize = Enum.AutomaticSize.Y
            Combo.BackgroundTransparency = 1
            Combo.BorderSizePixel = 0
            Combo.ZIndex = thisWidget.ZIndex
            Combo.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Combo, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.Y + 1))

            local PreviewContainer: TextButton = Instance.new("TextButton")
            PreviewContainer.Name = "PreviewContainer"
            PreviewContainer.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
            PreviewContainer.AutomaticSize = Enum.AutomaticSize.Y
            PreviewContainer.BackgroundTransparency = 1
            PreviewContainer.Text = ""
            PreviewContainer.ZIndex = thisWidget.ZIndex + 2
            PreviewContainer.LayoutOrder = thisWidget.ZIndex + 2
            PreviewContainer.AutoButtonColor = false

            widgets.applyFrameStyle(PreviewContainer, true, true)
            widgets.UIListLayout(PreviewContainer, Enum.FillDirection.Horizontal, UDim.new(0, 0))

            PreviewContainer.Parent = Combo

            local PreviewLabel: TextLabel = Instance.new("TextLabel")
            PreviewLabel.Name = "PreviewLabel"
            PreviewLabel.Size = UDim2.new(1, 0, 0, 0)
            PreviewLabel.AutomaticSize = Enum.AutomaticSize.Y
            PreviewLabel.BackgroundColor3 = Iris._config.FrameBgColor
            PreviewLabel.BackgroundTransparency = Iris._config.FrameBgTransparency
            PreviewLabel.BorderSizePixel = 0
            PreviewLabel.ZIndex = thisWidget.ZIndex + 3
            PreviewLabel.LayoutOrder = thisWidget.ZIndex + 3

            widgets.applyTextStyle(PreviewLabel)
            widgets.UIPadding(PreviewLabel, Iris._config.FramePadding)

            PreviewLabel.Parent = PreviewContainer

            local DropdownButton: TextLabel = Instance.new("TextLabel")
            DropdownButton.Name = "DropdownButton"
            DropdownButton.Size = UDim2.new(0, frameHeight, 0, frameHeight)
            DropdownButton.BorderSizePixel = 0
            DropdownButton.BackgroundColor3 = Iris._config.ButtonColor
            DropdownButton.BackgroundTransparency = Iris._config.ButtonTransparency
            DropdownButton.Text = ""
            DropdownButton.ZIndex = thisWidget.ZIndex + 4
            DropdownButton.LayoutOrder = thisWidget.ZIndex + 4

            local padding: number = math.round(frameHeight * 0.2)
            local dropdownSize: number = frameHeight - 2 * padding

            local Dropdown: ImageLabel = Instance.new("ImageLabel")
            Dropdown.Name = "Dropdown"
            Dropdown.Size = UDim2.fromOffset(dropdownSize, dropdownSize)
            Dropdown.Position = UDim2.fromOffset(padding, padding)
            Dropdown.BackgroundTransparency = 1
            Dropdown.BorderSizePixel = 0
            Dropdown.ImageColor3 = Iris._config.TextColor
            Dropdown.ImageTransparency = Iris._config.TextTransparency
            Dropdown.ZIndex = thisWidget.ZIndex + 5
            Dropdown.LayoutOrder = thisWidget.ZIndex + 5

            Dropdown.Parent = DropdownButton
            DropdownButton.Parent = PreviewContainer

            -- for some reason ImGui Combo has no highlights for Active, only hovered.
            -- so this deviates from ImGui, but its a good UX change
            widgets.applyInteractionHighlightsWithMultiHighlightee(PreviewContainer, {
                {
                    PreviewLabel,
                    {
                        ButtonColor = Iris._config.FrameBgColor,
                        ButtonTransparency = Iris._config.FrameBgTransparency,
                        ButtonHoveredColor = Iris._config.FrameBgHoveredColor,
                        ButtonHoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                        ButtonActiveColor = Iris._config.FrameBgActiveColor,
                        ButtonActiveTransparency = Iris._config.FrameBgActiveTransparency,
                    },
                },
                {
                    DropdownButton,
                    {
                        ButtonColor = Iris._config.ButtonColor,
                        ButtonTransparency = Iris._config.ButtonTransparency,
                        ButtonHoveredColor = Iris._config.ButtonHoveredColor,
                        ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
                        -- Use hovered for active
                        ButtonActiveColor = Iris._config.ButtonHoveredColor,
                        ButtonActiveTransparency = Iris._config.ButtonHoveredColor,
                    },
                },
            })

            PreviewContainer.InputBegan:Connect(function(inputObject)
                if AnyOpenedCombo and OpenedCombo ~= thisWidget then
                    return
                end
                if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
                    thisWidget.state.isOpened:set(not thisWidget.state.isOpened.value)
                end
            end)

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            TextLabel.Size = UDim2.fromOffset(0, frameHeight)
            TextLabel.AutomaticSize = Enum.AutomaticSize.X
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0
            TextLabel.ZIndex = thisWidget.ZIndex + 5
            TextLabel.LayoutOrder = thisWidget.ZIndex + 5

            widgets.applyTextStyle(TextLabel)

            TextLabel.Parent = Combo

            local ChildContainer: ScrollingFrame = Instance.new("ScrollingFrame")
            ChildContainer.Name = "ChildContainer"
            ChildContainer.BackgroundColor3 = Iris._config.WindowBgColor
            ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency
            ChildContainer.BorderSizePixel = 0

            ChildContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
            ChildContainer.ScrollBarImageTransparency = Iris._config.ScrollbarGrabTransparency
            ChildContainer.ScrollBarImageColor3 = Iris._config.ScrollbarGrabColor
            ChildContainer.ScrollBarThickness = Iris._config.ScrollbarSize
            ChildContainer.CanvasSize = UDim2.fromScale(0, 0)
            ChildContainer.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar

            -- appear over everything else
            ChildContainer.ZIndex = thisWidget.ZIndex + 6
            ChildContainer.LayoutOrder = thisWidget.ZIndex + 6
            ChildContainer.ClipsDescendants = true

            -- Unfortunatley, ScrollingFrame does not work with UICorner
            -- if Iris._config.PopupRounding > 0 then
            --     widgets.UICorner(ChildContainer, Iris._config.PopupRounding)
            -- end

            widgets.UIStroke(ChildContainer, Iris._config.WindowBorderSize, Iris._config.BorderColor, Iris._config.BorderTransparency)
            widgets.UIPadding(ChildContainer, Vector2.new(2, 2 * Iris._config.FramePadding.Y))

            local ChildContainerUIListLayout: UIListLayout = widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
            ChildContainerUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top

            local RootPopupScreenGui = Iris._rootInstance and Iris._rootInstance:WaitForChild("PopupScreenGui") :: GuiObject
            ChildContainer.Parent = RootPopupScreenGui
            thisWidget.ChildContainer = ChildContainer

            return Combo
        end,
        Update = function(thisWidget: Types.Widget)
            local Iris_Combo = thisWidget.Instance :: Frame
            local PreviewContainer = Iris_Combo.PreviewContainer :: TextButton
            local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
            local DropdownButton: TextLabel = PreviewContainer.DropdownButton
            local TextLabel: TextLabel = Iris_Combo.TextLabel

            TextLabel.Text = thisWidget.arguments.Text or "Combo"

            if thisWidget.arguments.NoButton then
                DropdownButton.Visible = false
                PreviewLabel.Size = UDim2.new(1, 0, 0, 0)
            else
                DropdownButton.Visible = true
                local DropdownButtonSize = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y
                PreviewLabel.Size = UDim2.new(1, -DropdownButtonSize, 0, 0)
            end

            if thisWidget.arguments.NoPreview then
                PreviewLabel.Visible = false
                PreviewContainer.Size = UDim2.new(0, 0, 0, 0)
                PreviewContainer.AutomaticSize = Enum.AutomaticSize.X
            else
                PreviewLabel.Visible = true
                PreviewContainer.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
                PreviewContainer.AutomaticSize = Enum.AutomaticSize.Y
            end
        end,
        ChildAdded = function(thisWidget: Types.Widget, thisChild: Types.Widget)
            -- default to largest size if there are widgets other than selectables inside the combo
            if thisChild.type ~= "Selectable" then
                thisWidget.ComboChildrenHeight += 10
            else
                thisWidget.ComboChildrenHeight += 1
            end
            UpdateChildContainerTransform(thisWidget)
            return thisWidget.ChildContainer
        end,
        ChildDiscarded = function(thisWidget: Types.Widget, thisChild: Types.Widget)
            if thisChild.type ~= "Selectable" then
                thisWidget.ComboChildrenHeight -= 10
            else
                thisWidget.ComboChildrenHeight -= 1
            end
        end,
        GenerateState = function(thisWidget: Types.Widget)
            if thisWidget.state.index == nil then
                thisWidget.state.index = Iris._widgetState(thisWidget, "index", "No Selection")
            end
            thisWidget.state.index:onChange(function()
                if thisWidget.state.isOpened.value then
                    thisWidget.state.isOpened:set(false)
                end
            end)
            if thisWidget.state.isOpened == nil then
                thisWidget.state.isOpened = Iris._widgetState(thisWidget, "isOpened", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Widget)
            local Iris_Combo = thisWidget.Instance :: Frame
            local PreviewContainer = Iris_Combo.PreviewContainer :: TextButton
            local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
            local DropdownButton = PreviewContainer.DropdownButton :: TextLabel
            local Dropdown: ImageLabel = DropdownButton.Dropdown
            local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame

            if thisWidget.state.isOpened.value then
                AnyOpenedCombo = true
                OpenedCombo = thisWidget
                ComboOpenedTick = Iris._cycleTick
                thisWidget.lastOpenedTick = Iris._cycleTick + 1

                -- ImGui also does not do this, and the Arrow is always facing down
                Dropdown.Image = widgets.ICONS.RIGHT_POINTING_TRIANGLE
                ChildContainer.Visible = true

                UpdateChildContainerTransform(thisWidget)
            else
                if AnyOpenedCombo then
                    AnyOpenedCombo = false
                    OpenedCombo = nil
                    thisWidget.lastClosedTick = Iris._cycleTick + 1
                end
                Dropdown.Image = widgets.ICONS.DOWN_POINTING_TRIANGLE
                ChildContainer.Visible = false
            end

            local stateIndex: any = thisWidget.state.index.value
            PreviewLabel.Text = if typeof(stateIndex) == "EnumItem" then stateIndex.Name else tostring(stateIndex)
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Combo

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Format | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    Iris.WidgetConstructor("Separator", {
        hasState = false,
        hasChildren = false,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local Separator: Frame = Instance.new("Frame")
            Separator.Name = "Iris_Separator"
            Separator.BackgroundColor3 = Iris._config.SeparatorColor
            Separator.BackgroundTransparency = Iris._config.SeparatorTransparency
            Separator.BorderSizePixel = 0
            if thisWidget.parentWidget.type == "SameLine" then
                Separator.Size = UDim2.new(0, 1, 1, 0)
            else
                Separator.Size = UDim2.new(1, 0, 0, 1)
            end
            Separator.ZIndex = thisWidget.ZIndex
            Separator.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Separator, Enum.FillDirection.Vertical, UDim.new(0, 0))
            -- this is to prevent a bug of AutomaticLayout edge case when its parent has automaticLayout enabled

            return Separator
        end,
        Update = function(_thisWidget: Types.Widget) end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass)

    Iris.WidgetConstructor("Indent", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
        },
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local Indent: Frame = Instance.new("Frame")
            Indent.Name = "Iris_Indent"
            Indent.BackgroundTransparency = 1
            Indent.BorderSizePixel = 0
            Indent.Size = UDim2.fromScale(1, 0)
            Indent.AutomaticSize = Enum.AutomaticSize.Y
            Indent.ZIndex = thisWidget.ZIndex
            Indent.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Indent, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
            widgets.UIPadding(Indent, Vector2.new(0, 0))

            return Indent
        end,
        Update = function(thisWidget: Types.Widget)
            local Indent = thisWidget.Instance :: Frame

            local indentWidth: number
            if thisWidget.arguments.Width then
                indentWidth = thisWidget.arguments.Width
            else
                indentWidth = Iris._config.IndentSpacing
            end
            Indent.UIPadding.PaddingLeft = UDim.new(0, indentWidth)
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Widget, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    Iris.WidgetConstructor("SameLine", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
            ["VerticalAlignment"] = 2,
        },
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local SameLine: Frame = Instance.new("Frame")
            SameLine.Name = "Iris_SameLine"
            SameLine.BackgroundTransparency = 1
            SameLine.BorderSizePixel = 0
            SameLine.Size = UDim2.fromScale(1, 0)
            SameLine.AutomaticSize = Enum.AutomaticSize.Y
            SameLine.ZIndex = thisWidget.ZIndex
            SameLine.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(SameLine, Enum.FillDirection.Horizontal, UDim.new(0, 0))

            return SameLine
        end,
        Update = function(thisWidget: Types.Widget)
            local Sameline = thisWidget.Instance :: Frame
            local uiListLayout: UIListLayout = Sameline.UIListLayout
            local itemWidth: number
            if thisWidget.arguments.Width then
                itemWidth = thisWidget.arguments.Width
            else
                itemWidth = Iris._config.ItemSpacing.X
            end
            uiListLayout.Padding = UDim.new(0, itemWidth)
            if thisWidget.arguments.VerticalAlignment then
                uiListLayout.VerticalAlignment = thisWidget.arguments.VerticalAlignment
            else
                uiListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            end
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Widget, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    Iris.WidgetConstructor("Group", {
        hasState = false,
        hasChildren = true,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local Group: Frame = Instance.new("Frame")
            Group.Name = "Iris_Group"
            Group.BackgroundTransparency = 1
            Group.BorderSizePixel = 0
            Group.Size = UDim2.fromOffset(0, 0)
            Group.AutomaticSize = Enum.AutomaticSize.XY
            Group.ZIndex = thisWidget.ZIndex
            Group.LayoutOrder = thisWidget.ZIndex
            Group.ClipsDescendants = true

            widgets.UIListLayout(Group, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.X))

            return Group
        end,
        Update = function(_thisWidget: Types.Widget) end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Widget, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Format

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Input | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
	local numberChanged = {
		["Init"] = function(_thisWidget: Types.Widget) end,
		["Get"] = function(thisWidget: Types.Widget)
			return thisWidget.lastNumberChangedTick == Iris._cycleTick
		end,
	}

	local function getValueByIndex(value: Types.InputDataType, index: number, arguments: Types.Arguments): number
		if typeof(value) == "number" then
			return value
		elseif typeof(value) == "Vector2" then
			if index == 1 then
				return value.X
			elseif index == 2 then
				return value.Y
			end
		elseif typeof(value) == "Vector3" then
			if index == 1 then
				return value.X
			elseif index == 2 then
				return value.Y
			elseif index == 3 then
				return value.Z
			end
		elseif typeof(value) == "UDim" then
			if index == 1 then
				return value.Scale
			elseif index == 2 then
				return value.Offset
			end
		elseif typeof(value) == "UDim2" then
			if index == 1 then
				return value.X.Scale
			elseif index == 2 then
				return value.X.Offset
			elseif index == 3 then
				return value.Y.Scale
			elseif index == 4 then
				return value.Y.Offset
			end
		elseif typeof(value) == "Color3" then
			local color: { number } = arguments.UseHSV and { value:ToHSV() } or { value.R, value.G, value.B }
			if index == 1 then
				return color[1]
			elseif index == 2 then
				return color[2]
			elseif index == 3 then
				return color[3]
			end
		elseif typeof(value) == "Rect" then
			if index == 1 then
				return value.Min.X
			elseif index == 2 then
				return value.Min.Y
			elseif index == 3 then
				return value.Max.X
			elseif index == 4 then
				return value.Max.Y
			end
		elseif typeof(value) == "table" then
			return value[index]
		end

		error(`Incorrect datatype or value: {value} {typeof(value)} {index}`)
	end

	local function updateValueByIndex(value: Types.InputDataType, index: number, newValue: number, arguments: Types.Arguments): Types.InputDataType
		if typeof(value) == "number" then
			return newValue
		elseif typeof(value) == "Vector2" then
			if index == 1 then
				return Vector2.new(newValue, value.Y)
			elseif index == 2 then
				return Vector2.new(value.X, newValue)
			end
		elseif typeof(value) == "Vector3" then
			if index == 1 then
				return Vector3.new(newValue, value.Y, value.Z)
			elseif index == 2 then
				return Vector3.new(value.X, newValue, value.Z)
			elseif index == 3 then
				return Vector3.new(value.X, value.Y, newValue)
			end
		elseif typeof(value) == "UDim" then
			if index == 1 then
				return UDim.new(newValue, value.Offset)
			elseif index == 2 then
				return UDim.new(value.Scale, newValue)
			end
		elseif typeof(value) == "UDim2" then
			if index == 1 then
				return UDim2.new(UDim.new(newValue, value.X.Offset), value.Y)
			elseif index == 2 then
				return UDim2.new(UDim.new(value.X.Scale, newValue), value.Y)
			elseif index == 3 then
				return UDim2.new(value.X, UDim.new(newValue, value.Y.Offset))
			elseif index == 4 then
				return UDim2.new(value.X, UDim.new(value.Y.Scale, newValue))
			end
		elseif typeof(value) == "Rect" then
			if index == 1 then
				return Rect.new(Vector2.new(newValue, value.Min.Y), value.Max)
			elseif index == 2 then
				return Rect.new(Vector2.new(value.Min.X, newValue), value.Max)
			elseif index == 3 then
				return Rect.new(value.Min, Vector2.new(newValue, value.Max.Y))
			elseif index == 4 then
				return Rect.new(value.Min, Vector2.new(value.Max.X, newValue))
			end
		elseif typeof(value) == "Color3" then
			if arguments.UseHSV then
				local h: number, s: number, v: number = value:ToHSV()
				if index == 1 then
					return Color3.fromHSV(newValue, s, v)
				elseif index == 2 then
					return Color3.fromHSV(h, newValue, v)
				elseif index == 3 then
					return Color3.fromHSV(h, s, newValue)
				end
			end
			if index == 1 then
				return Color3.new(newValue, value.G, value.B)
			elseif index == 2 then
				return Color3.new(value.R, newValue, value.B)
			elseif index == 3 then
				return Color3.new(value.R, value.G, newValue)
			end
		end

		error(`Incorrect datatype or value {value} {typeof(value)} {index}`)
	end

	local defaultIncrements: { [Types.InputDataTypes]: { number } } = {
		Num = { 1 },
		Vector2 = { 1, 1 },
		Vector3 = { 1, 1, 1 },
		UDim = { 0.01, 1 },
		UDim2 = { 0.01, 1, 0.01, 1 },
		Color3 = { 1, 1, 1 },
		Color4 = { 1, 1, 1, 1 },
		Rect = { 1, 1, 1, 1 },
	}

	local defaultMin: { [Types.InputDataTypes]: { number } } = {
		Num = { 0 },
		Vector2 = { 0, 0 },
		Vector3 = { 0, 0, 0 },
		UDim = { 0, 0 },
		UDim2 = { 0, 0, 0, 0 },
		Rect = { 0, 0, 0, 0 },
	}

	local defaultMax: { [Types.InputDataTypes]: { number } } = {
		Num = { 100 },
		Vector2 = { 100, 100 },
		Vector3 = { 100, 100, 100 },
		UDim = { 1, 960 },
		UDim2 = { 1, 960, 1, 960 },
		Rect = { 960, 960, 960, 960 },
	}

	local defaultPrefx: { [Types.InputDataTypes]: { string } } = {
		Num = { "" },
		Vector2 = { "X: ", "Y: " },
		Vector3 = { "X: ", "Y: ", "Z: " },
		UDim = { "", "" },
		UDim2 = { "", "", "", "" },
		Color3_RGB = { "R: ", "G: ", "B: " },
		Color3_HSV = { "H: ", "S: ", "V: " },
		Color4_RGB = { "R: ", "G: ", "B: ", "T: " },
		Color4_HSV = { "H: ", "S: ", "V: ", "T: " },
		Rect = { "X: ", "Y: ", "X: ", "Y: " },
	}

	local defaultSigFigs: { [Types.InputDataTypes]: { number } } = {
		Num = { 0 },
		Vector2 = { 0, 0 },
		Vector3 = { 0, 0, 0 },
		UDim = { 3, 0 },
		UDim2 = { 3, 0, 3, 0 },
		Color3 = { 0, 0, 0 },
		Color4 = { 0, 0, 0, 0 },
		Rect = { 0, 0, 0, 0 },
	}

	--[[
        Input
    ]]
	local generateInputScalar: (dataType: Types.InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
	do
		local function generateButtons(thisWidget: Types.Widget, parent: GuiObject, rightPadding: number, textHeight: number)
			rightPadding += 2 * Iris._config.ItemInnerSpacing.X + 2 * textHeight

			local SubButton = widgets.abstractButton.Generate(thisWidget) :: TextButton
			SubButton.Name = "SubButton"
			SubButton.ZIndex = thisWidget.ZIndex + 5
			SubButton.LayoutOrder = thisWidget.ZIndex + 5
			SubButton.TextXAlignment = Enum.TextXAlignment.Center
			SubButton.Text = "-"
			SubButton.Size = UDim2.fromOffset(Iris._config.TextSize + 2 * Iris._config.FramePadding.Y, Iris._config.TextSize)
			SubButton.Parent = parent

			SubButton.MouseButton1Click:Connect(function()
				local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
					or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
				local changeValue: number = (
					thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, 1, thisWidget.arguments) or 1
				) * (isCtrlHeld and 100 or 1)
				local newValue: number = thisWidget.state.number.value - changeValue
				if thisWidget.arguments.Min ~= nil then
					newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, 1, thisWidget.arguments))
				end
				if thisWidget.arguments.Max ~= nil then
					newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, 1, thisWidget.arguments))
				end
				thisWidget.state.number:set(newValue)
				thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
			end)

			local AddButton = widgets.abstractButton.Generate(thisWidget) :: TextButton
			AddButton.Name = "AddButton"
			AddButton.ZIndex = thisWidget.ZIndex + 6
			AddButton.LayoutOrder = thisWidget.ZIndex + 6
			AddButton.TextXAlignment = Enum.TextXAlignment.Center
			AddButton.Text = "+"
			AddButton.Size = UDim2.fromOffset(Iris._config.TextSize + 2 * Iris._config.FramePadding.Y, Iris._config.TextSize)
			AddButton.Parent = parent

			AddButton.MouseButton1Click:Connect(function()
				local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
					or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
				local changeValue: number = (
					thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, 1, thisWidget.arguments) or 1
				) * (isCtrlHeld and 100 or 1)
				local newValue: number = thisWidget.state.number.value + changeValue
				if thisWidget.arguments.Min ~= nil then
					newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, 1, thisWidget.arguments))
				end
				if thisWidget.arguments.Max ~= nil then
					newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, 1, thisWidget.arguments))
				end
				thisWidget.state.number:set(newValue)
				thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
			end)

			return rightPadding
		end

		function generateInputScalar(dataType: Types.InputDataTypes, components: number, defaultValue: any)
			return {
				hasState = true,
				hasChildren = false,
				Args = {
					["Text"] = 1,
					["Increment"] = 2,
					["Min"] = 3,
					["Max"] = 4,
					["Format"] = 5,
				},
				Events = {
					["numberChanged"] = numberChanged,
					["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
						return thisWidget.Instance
					end),
				},
				Generate = function(thisWidget: Types.Widget)
					local Input: Frame = Instance.new("Frame")
					Input.Name = "Iris_Input" .. dataType
					Input.Size = UDim2.fromScale(1, 0)
					Input.BackgroundTransparency = 1
					Input.BorderSizePixel = 0
					Input.ZIndex = thisWidget.ZIndex
					Input.LayoutOrder = thisWidget.ZIndex
					Input.AutomaticSize = Enum.AutomaticSize.Y
					widgets.UIListLayout(Input, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))

					-- we add plus and minus buttons if there is only one box. This can be disabled through the argument.
					local rightPadding: number = 0
					local textHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

					if components == 1 then
						rightPadding = generateButtons(thisWidget, Input, rightPadding, textHeight)
					end

					-- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
					-- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
					-- 4 pixels shorter, all for the sake of flush.
					local componentWidth: UDim = UDim.new(
						Iris._config.ContentWidth.Scale / components,
						(Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1)) - rightPadding) / components
					)
					local totalWidth: UDim = UDim.new(
						componentWidth.Scale * (components - 1),
						(componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)) + rightPadding
					)
					local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

					-- we handle each component individually since they don't need to interact with each other.
					for index = 1, components do
						local InputField: TextBox = Instance.new("TextBox")
						InputField.Name = "InputField" .. tostring(index)
						InputField.ZIndex = thisWidget.ZIndex + index
						InputField.LayoutOrder = thisWidget.ZIndex + index
						if index == components then
							InputField.Size = UDim2.new(lastComponentWidth, UDim.new())
						else
							InputField.Size = UDim2.new(componentWidth, UDim.new())
						end
						InputField.AutomaticSize = Enum.AutomaticSize.Y
						InputField.BackgroundColor3 = Iris._config.FrameBgColor
						InputField.BackgroundTransparency = Iris._config.FrameBgTransparency
						InputField.ClearTextOnFocus = false
						InputField.TextTruncate = Enum.TextTruncate.AtEnd
						InputField.ClipsDescendants = true

						widgets.applyFrameStyle(InputField)
						widgets.applyTextStyle(InputField)
						widgets.UISizeConstraint(InputField, Vector2.new(1, 0))

						InputField.Parent = Input

						InputField.FocusLost:Connect(function()
							local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
							if newValue ~= nil then
								if thisWidget.arguments.Min ~= nil then
									newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
								end
								if thisWidget.arguments.Max ~= nil then
									newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments))
								end

								if thisWidget.arguments.Increment then
									newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments))
										* getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
								end

								thisWidget.state.number:set(updateValueByIndex(thisWidget.state.number.value, index, newValue, thisWidget.arguments))
								thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
							end
							local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
							if thisWidget.arguments.Prefix then
								format = thisWidget.arguments.Prefix[index] .. format
							end
							InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))

							thisWidget.state.editingText:set(0)
						end)

						InputField.Focused:Connect(function()
							-- this highlights the entire field
							InputField.CursorPosition = #InputField.Text + 1
							InputField.SelectionStart = 1

							thisWidget.state.editingText:set(index)
						end)
					end

					local TextLabel: TextLabel = Instance.new("TextLabel")
					TextLabel.Name = "TextLabel"
					TextLabel.Size = UDim2.fromOffset(0, textHeight)
					TextLabel.BackgroundTransparency = 1
					TextLabel.BorderSizePixel = 0
					TextLabel.ZIndex = thisWidget.ZIndex + 7
					TextLabel.LayoutOrder = thisWidget.ZIndex + 7
					TextLabel.AutomaticSize = Enum.AutomaticSize.X

					widgets.applyTextStyle(TextLabel)

					TextLabel.Parent = Input

					return Input
				end,
				Update = function(thisWidget: Types.Widget)
					local Input = thisWidget.Instance :: GuiObject
					local TextLabel: TextLabel = Input.TextLabel
					TextLabel.Text = thisWidget.arguments.Text or `Input {dataType}`

					if components == 1 then
						Input.SubButton.Visible = not thisWidget.arguments.NoButtons
						Input.AddButton.Visible = not thisWidget.arguments.NoButtons
					end

					if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
						thisWidget.arguments.Format = { thisWidget.arguments.Format }
					else
						-- we calculate the format for the s.f. using the max, min and increment arguments.
						local format: { string } = {}
						for index = 1, components do
							local sigfigs: number = defaultSigFigs[dataType][index]

							if thisWidget.arguments.Increment then
								local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if thisWidget.arguments.Max then
								local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if thisWidget.arguments.Min then
								local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if sigfigs > 0 then
								-- we know it's a float.
								format[index] = `%.{sigfigs}f`
							else
								format[index] = "%d"
							end
						end

						thisWidget.arguments.Format = format
						thisWidget.arguments.Prefix = defaultPrefx[dataType]
					end
				end,
				Discard = function(thisWidget: Types.Widget)
					thisWidget.Instance:Destroy()
					widgets.discardState(thisWidget)
				end,
				GenerateState = function(thisWidget: Types.Widget)
					if thisWidget.state.number == nil then
						thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
					end
					if thisWidget.state.editingText == nil then
						thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", 0)
					end
				end,
				UpdateState = function(thisWidget: Types.Widget)
					local Input = thisWidget.Instance :: GuiObject

					for index = 1, components do
						local InputField: TextBox = Input:FindFirstChild("InputField" .. tostring(index))
						local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
						if thisWidget.arguments.Prefix then
							format = thisWidget.arguments.Prefix[index] .. format
						end
						InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))
					end
				end,
			}
		end
	end

	--[[
        Drag
    ]]
	local generateDragScalar: (dataType: Types.InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
	local generateColorDragScalar: (dataType: Types.InputDataTypes,...any) -> Types.WidgetClass
	do
		local PreviouseMouseXPosition: number = 0
		local AnyActiveDrag: boolean = false
		local ActiveDrag: Types.Widget? 		
local ActiveIndex: number = 0
		local ActiveDataType: Types.InputDataTypes | "" = ""

		local function updateActiveDrag()
			local currentMouseX: number = widgets.getMouseLocation().X
			local mouseXDelta: number = currentMouseX - PreviouseMouseXPosition
			PreviouseMouseXPosition = currentMouseX
			if AnyActiveDrag == false then
				return
			end
			if ActiveDrag == nil then
				return
			end

			local state: Types.State = ActiveDrag.state.number
			if ActiveDataType == "Color3" or ActiveDataType == "Color4" then
				state = ActiveDrag.state.color
				if ActiveIndex == 4 then
					state = ActiveDrag.state.transparency
				end
			end

			local increment: number = ActiveDrag.arguments.Increment
					and getValueByIndex(ActiveDrag.arguments.Increment, ActiveIndex, ActiveDrag.arguments)
				or defaultIncrements[ActiveDataType][ActiveIndex]
			increment *= (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightShift)) and 10 or 1
			increment *= (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightAlt)) and 0.1 or 1
			-- we increase the speed for Color3 and Color4 since it's too slow because the increment argument needs to be low.
			increment *= (ActiveDataType == "Color3" or ActiveDataType == "Color4") and 5 or 1

			local value: number = getValueByIndex(state.value, ActiveIndex, ActiveDrag.arguments)
			local newValue: number = value + (mouseXDelta * increment)

			if ActiveDrag.arguments.Min ~= nil then
				newValue = math.max(newValue, getValueByIndex(ActiveDrag.arguments.Min, ActiveIndex, ActiveDrag.arguments))
			end
			if ActiveDrag.arguments.Max ~= nil then
				newValue = math.min(newValue, getValueByIndex(ActiveDrag.arguments.Max, ActiveIndex, ActiveDrag.arguments))
			end

			state:set(updateValueByIndex(state.value, ActiveIndex, newValue, ActiveDrag.arguments))
			ActiveDrag.lastNumberChangedTick = Iris._cycleTick + 1
		end

		local function DragMouseDown(thisWidget: Types.Widget, dataTypes: Types.InputDataTypes, index: number, x: number, y: number)
			local currentTime: number = widgets.getTime()
			local isTimeValid: boolean = currentTime - thisWidget.lastClickedTime < Iris._config.MouseDoubleClickTime
			local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
				or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
			if
				(isTimeValid and (Vector2.new(x, y) - thisWidget.lastClickedPosition).Magnitude < Iris._config.MouseDoubleClickMaxDist) or isCtrlHeld
			then
				thisWidget.state.editingText:set(index)
			else
				thisWidget.lastClickedTime = currentTime
				thisWidget.lastClickedPosition = Vector2.new(x, y)

				AnyActiveDrag = true
				ActiveDrag = thisWidget
				ActiveIndex = index
				ActiveDataType = dataTypes
				updateActiveDrag()
			end
		end

		widgets.UserInputService.InputChanged:Connect(updateActiveDrag)

		widgets.UserInputService.InputEnded:Connect(function(inputObject: InputObject)
			if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and AnyActiveDrag then
				AnyActiveDrag = false
				ActiveDrag = nil
				ActiveIndex = 0
			end
		end)

		function generateDragScalar(dataType: Types.InputDataTypes, components: number, defaultValue: any)
			return {
				hasState = true,
				hasChildren = false,
				Args = {
					["Text"] = 1,
					["Increment"] = 2,
					["Min"] = 3,
					["Max"] = 4,
					["Format"] = 5,
				},
				Events = {
					["numberChanged"] = numberChanged,
					["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
						return thisWidget.Instance
					end),
				},
				Generate = function(thisWidget: Types.Widget)
					thisWidget.lastClickedTime = -1					
thisWidget.lastClickedPosition = Vector2.zero

					local Drag: Frame = Instance.new("Frame")
					Drag.Name = "Iris_Drag" .. dataType
					Drag.Size = UDim2.fromScale(1, 0)
					Drag.BackgroundTransparency = 1
					Drag.BorderSizePixel = 0
					Drag.ZIndex = thisWidget.ZIndex
					Drag.LayoutOrder = thisWidget.ZIndex
					Drag.AutomaticSize = Enum.AutomaticSize.Y
					widgets.UIListLayout(Drag, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))

					-- we add a color box if it is Color3 or Color4.
					local rightPadding: number = 0
					local textHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

					if dataType == "Color3" or dataType == "Color4" then
						rightPadding += Iris._config.ItemInnerSpacing.X + textHeight

						local ColorBox: ImageLabel = Instance.new("ImageLabel")
						ColorBox.Name = "ColorBox"
						ColorBox.BorderSizePixel = 0
						ColorBox.Size = UDim2.fromOffset(textHeight, textHeight)
						ColorBox.ZIndex = thisWidget.ZIndex + 5
						ColorBox.LayoutOrder = thisWidget.ZIndex + 5
						ColorBox.Image = widgets.ICONS.ALPHA_BACKGROUND_TEXTURE
						ColorBox.ImageTransparency = 1

						widgets.applyFrameStyle(ColorBox, true, true)

						ColorBox.Parent = Drag
					end

					-- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
					-- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
					-- 4 pixels shorter, all for the sake of flush.
					local componentWidth: UDim = UDim.new(
						Iris._config.ContentWidth.Scale / components,
						(Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1)) - rightPadding) / components
					)
					local totalWidth: UDim = UDim.new(
						componentWidth.Scale * (components - 1),
						(componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)) + rightPadding
					)
					local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

					for index = 1, components do
						local DragField: TextButton = Instance.new("TextButton")
						DragField.Name = "DragField" .. tostring(index)
						DragField.ZIndex = thisWidget.ZIndex + index
						DragField.LayoutOrder = thisWidget.ZIndex + index
						if index == components then
							DragField.Size = UDim2.new(lastComponentWidth, UDim.new())
						else
							DragField.Size = UDim2.new(componentWidth, UDim.new())
						end
						DragField.AutomaticSize = Enum.AutomaticSize.Y
						DragField.BackgroundColor3 = Iris._config.FrameBgColor
						DragField.BackgroundTransparency = Iris._config.FrameBgTransparency
						DragField.AutoButtonColor = false
						DragField.Text = ""
						DragField.ClipsDescendants = true

						widgets.applyFrameStyle(DragField)
						widgets.applyTextStyle(DragField)
						widgets.UISizeConstraint(DragField, Vector2.new(1, 0))

						DragField.TextXAlignment = Enum.TextXAlignment.Center

						DragField.Parent = Drag

						widgets.applyInteractionHighlights(DragField, DragField, {
							ButtonColor = Iris._config.FrameBgColor,
							ButtonTransparency = Iris._config.FrameBgTransparency,
							ButtonHoveredColor = Iris._config.FrameBgHoveredColor,
							ButtonHoveredTransparency = Iris._config.FrameBgHoveredTransparency,
							ButtonActiveColor = Iris._config.FrameBgActiveColor,
							ButtonActiveTransparency = Iris._config.FrameBgActiveTransparency,
						})

						local InputField: TextBox = Instance.new("TextBox")
						InputField.Name = "InputField"
						InputField.ZIndex = thisWidget.ZIndex + 5
						InputField.LayoutOrder = thisWidget.ZIndex + 2
						InputField.Size = UDim2.new(1, 0, 1, 0)
						InputField.BackgroundTransparency = 1
						InputField.ClearTextOnFocus = false
						InputField.TextTruncate = Enum.TextTruncate.AtEnd
						InputField.ClipsDescendants = true
						InputField.Visible = false

						widgets.applyFrameStyle(InputField, true)
						widgets.applyTextStyle(InputField)

						InputField.Parent = DragField

						InputField.FocusLost:Connect(function()
							local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
							local state: Types.State = thisWidget.state.number
							if dataType == "Color4" and index == 4 then
								state = thisWidget.state.transparency
							elseif dataType == "Color3" or dataType == "Color4" then
								state = thisWidget.state.color
							end
							if newValue ~= nil then
								if dataType == "Color3" or dataType == "Color4" and not thisWidget.arguments.UseFloats then
									newValue = newValue / 255
								end
								if thisWidget.arguments.Min ~= nil then
									newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
								end
								if thisWidget.arguments.Max ~= nil then
									newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments))
								end

								if thisWidget.arguments.Increment then
									newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments))
										* getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
								end

								state:set(updateValueByIndex(state.value, index, newValue, thisWidget.arguments))
								thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
							end

							local value: number = getValueByIndex(state.value, index, thisWidget.arguments)
							if dataType == "Color3" or dataType == "Color4" and not thisWidget.arguments.UseFloats then
								value = math.round(value * 255)
							end

							local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
							if thisWidget.arguments.Prefix then
								format = thisWidget.arguments.Prefix[index] .. format
							end
							InputField.Text = string.format(format, value)

							thisWidget.state.editingText:set(0)
							InputField:ReleaseFocus(true)
						end)

						InputField.Focused:Connect(function()
							-- this highlights the entire field
							InputField.CursorPosition = #InputField.Text + 1
							InputField.SelectionStart = 1

							thisWidget.state.editingText:set(index)
						end)

						DragField.MouseButton1Down:Connect(function(x: number, y: number)
							DragMouseDown(thisWidget, dataType, index, x, y)
						end)
					end

					local TextLabel: TextLabel = Instance.new("TextLabel")
					TextLabel.Name = "TextLabel"
					TextLabel.Size = UDim2.fromOffset(0, textHeight)
					TextLabel.BackgroundTransparency = 1
					TextLabel.BorderSizePixel = 0
					TextLabel.ZIndex = thisWidget.ZIndex + 5
					TextLabel.LayoutOrder = thisWidget.ZIndex + 5
					TextLabel.AutomaticSize = Enum.AutomaticSize.X

					widgets.applyTextStyle(TextLabel)

					TextLabel.Parent = Drag

					return Drag
				end,
				Update = function(thisWidget: Types.Widget)
					local Input = thisWidget.Instance :: GuiObject
					local TextLabel: TextLabel = Input.TextLabel
					TextLabel.Text = thisWidget.arguments.Text or `Drag {dataType}`

					if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
						thisWidget.arguments.Format = { thisWidget.arguments.Format }
					elseif not thisWidget.arguments.Format then
						-- we calculate the format for the s.f. using the max, min and increment arguments.
						local format: { string } = {}
						for index = 1, components do
							local sigfigs: number = defaultSigFigs[dataType][index]

							if thisWidget.arguments.Increment then
								local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if thisWidget.arguments.Max then
								local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if thisWidget.arguments.Min then
								local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if sigfigs > 0 then
								-- we know it's a float.
								format[index] = `%.{sigfigs}f`
							else
								format[index] = "%d"
							end
						end

						thisWidget.arguments.Format = format
						thisWidget.arguments.Prefix = defaultPrefx[dataType]
					end
				end,
				Discard = function(thisWidget: Types.Widget)
					thisWidget.Instance:Destroy()
					widgets.discardState(thisWidget)
				end,
				GenerateState = function(thisWidget: Types.Widget)
					if thisWidget.state.number == nil then
						thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
					end
					if thisWidget.state.editingText == nil then
						thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
					end
				end,
				UpdateState = function(thisWidget: Types.Widget)
					local Drag = thisWidget.Instance :: Frame

					for index = 1, components do
						local state: Types.State = thisWidget.state.number
						if dataType == "Color3" or dataType == "Color4" then
							state = thisWidget.state.color
							if index == 4 then
								state = thisWidget.state.transparency
							end
						end
						local DragField = Drag:FindFirstChild("DragField" .. tostring(index)) :: TextButton
						local InputField: TextBox = DragField.InputField
						local value: number = getValueByIndex(state.value, index, thisWidget.arguments)
						if (dataType == "Color3" or dataType == "Color4") and not thisWidget.arguments.UseFloats then
							value = math.round(value * 255)
						end

						local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
						if thisWidget.arguments.Prefix then
							format = thisWidget.arguments.Prefix[index] .. format
						end
						DragField.Text = string.format(format, value)
						InputField.Text = tostring(value)

						if thisWidget.state.editingText.value == index then
							InputField.Visible = true
							InputField:CaptureFocus()
							DragField.TextTransparency = 1
						else
							InputField.Visible = false
							DragField.TextTransparency = Iris._config.TextTransparency
						end
					end

					if dataType == "Color3" or dataType == "Color4" then
						local ColorBox: ImageLabel = Drag.ColorBox

						ColorBox.BackgroundColor3 = thisWidget.state.color.value

						if dataType == "Color4" then
							ColorBox.ImageTransparency = 1 - thisWidget.state.transparency.value
						end
					end
				end,
			}
		end

		function generateColorDragScalar(dataType: Types.InputDataTypes, ...: any)
			local defaultValues: { any } = { ... }
			local input: Types.WidgetClass = generateDragScalar(dataType, dataType == "Color4" and 4 or 3, defaultValues[1])

			return widgets.extend(input, {
				Args = {
					["Text"] = 1,
					["UseFloats"] = 2,
					["UseHSV"] = 3,
					["Format"] = 4,
				},
				Update = function(thisWidget: Types.Widget)
					local Input = thisWidget.Instance :: GuiObject
					local TextLabel: TextLabel = Input.TextLabel
					TextLabel.Text = thisWidget.arguments.Text or `Drag {dataType}`

					if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
						thisWidget.arguments.Format = { thisWidget.arguments.Format }
					else
						if thisWidget.arguments.UseFloats then
							thisWidget.arguments.Format = { "%.3f" }
						else
							thisWidget.arguments.Format = { "%d" }
						end

						thisWidget.arguments.Prefix = defaultPrefx[dataType .. if thisWidget.arguments.UseHSV then "_HSV" else "_RGB"]
					end

					thisWidget.arguments.Min = { 0, 0, 0, 0 }
					thisWidget.arguments.Max = { 1, 1, 1, 1 }
					thisWidget.arguments.Increment = { 0.001, 0.001, 0.001, 0.001 }

					-- since the state values have changed display, we call an update. The check is because state is not
					-- initialised on creation, so it would error otherwise.
					if thisWidget.state then
						Iris._widgets[thisWidget.type].UpdateState(thisWidget)
					end
				end,
				GenerateState = function(thisWidget: Types.Widget)
					if thisWidget.state.color == nil then
						thisWidget.state.color = Iris._widgetState(thisWidget, "color", defaultValues[1])
					end
					if dataType == "Color4" then
						if thisWidget.state.transparency == nil then
							thisWidget.state.transparency = Iris._widgetState(thisWidget, "transparency", defaultValues[2])
						end
					end
					if thisWidget.state.editingText == nil then
						thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
					end
				end,
			})
		end
	end

	--[[
        Slider
    ]]
	local generateSliderScalar: (dataType: Types.InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
	local generateEnumSliderScalar: (enum: Enum, item: EnumItem) -> Types.WidgetClass
	do
		local AnyActiveSlider: boolean = false
		local ActiveSlider: Types.Widget? 		
local ActiveIndex: number = 0
		local ActiveDataType: Types.InputDataTypes | "" = ""

		local function updateActiveSlider()
			if AnyActiveSlider == false then
				return
			end
			if ActiveSlider == nil then
				return
			end

			local Slider = ActiveSlider.Instance :: Frame
			local SliderField: TextButton = Slider:FindFirstChild("SliderField" .. tostring(ActiveIndex))

			local increment: number = ActiveSlider.arguments.Increment
					and getValueByIndex(ActiveSlider.arguments.Increment, ActiveIndex, ActiveSlider.arguments)
				or defaultIncrements[ActiveDataType][ActiveIndex]
			local min: number = ActiveSlider.arguments.Min and getValueByIndex(ActiveSlider.arguments.Min, ActiveIndex, ActiveSlider.arguments)
				or defaultMin[ActiveDataType][ActiveIndex]
			local max: number = ActiveSlider.arguments.Max and getValueByIndex(ActiveSlider.arguments.Max, ActiveIndex, ActiveSlider.arguments)
				or defaultMax[ActiveDataType][ActiveIndex]

			local GrabPadding: number = Iris._config.FramePadding.X
			local decimalFix: number = increment < 1 and 0 or 1 -- ??? ?? ??? ?
			local GrabNumPossiblePositions: number = math.floor((decimalFix + max - min) / increment)
			local PositionRatio: number = (widgets.getMouseLocation().X - (SliderField.AbsolutePosition.X + GrabPadding))
				/ (SliderField.AbsoluteSize.X - 2 * GrabPadding)
			local newValue: number = math.clamp(math.floor(PositionRatio * GrabNumPossiblePositions) * increment + min, min, max)

			ActiveSlider.state.number:set(updateValueByIndex(ActiveSlider.state.number.value, ActiveIndex, newValue, ActiveSlider.arguments))
			ActiveSlider.lastNumberChangedTick = Iris._cycleTick + 1
		end

		local function SliderMouseDown(thisWidget: Types.Widget, dataType: Types.InputDataTypes, index: number)
			local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
				or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
			if isCtrlHeld then
				thisWidget.state.editingText:set(index)
			else
				AnyActiveSlider = true
				ActiveSlider = thisWidget
				ActiveIndex = index
				ActiveDataType = dataType
				updateActiveSlider()
			end
		end

		widgets.UserInputService.InputChanged:Connect(updateActiveSlider)

		widgets.UserInputService.InputEnded:Connect(function(inputObject: InputObject)
			if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and AnyActiveSlider then
				AnyActiveSlider = false
				ActiveSlider = nil
				ActiveIndex = 0
				ActiveDataType = ""
			end
		end)

		function generateSliderScalar(dataType: Types.InputDataTypes, components: number, defaultValue: any, ...: any)
			return {
				hasState = true,
				hasChildren = false,
				Args = {
					["Text"] = 1,
					["Increment"] = 2,
					["Min"] = 3,
					["Max"] = 4,
					["Format"] = 5,
				},
				Events = {
					["numberChanged"] = numberChanged,
					["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
						return thisWidget.Instance
					end),
				},
				Generate = function(thisWidget: Types.Widget)
					local Slider: Frame = Instance.new("Frame")
					Slider.Name = "Iris_Slider" .. dataType
					Slider.Size = UDim2.fromScale(1, 0)
					Slider.BackgroundTransparency = 1
					Slider.BorderSizePixel = 0
					Slider.ZIndex = thisWidget.ZIndex
					Slider.LayoutOrder = thisWidget.ZIndex
					Slider.AutomaticSize = Enum.AutomaticSize.Y
					widgets.UIListLayout(Slider, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))

					local textHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

					-- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
					-- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
					-- 4 pixels shorter, all for the sake of flush.
					local componentWidth: UDim = UDim.new(
						Iris._config.ContentWidth.Scale / components,
						(Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1))) / components
					)
					local totalWidth: UDim = UDim.new(
						componentWidth.Scale * (components - 1),
						(componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1))
					)
					local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

					for index = 1, components do
						local SliderField: TextButton = Instance.new("TextButton")
						SliderField.Name = "SliderField" .. tostring(index)
						SliderField.ZIndex = thisWidget.ZIndex + index
						SliderField.LayoutOrder = thisWidget.ZIndex + index
						if index == components then
							SliderField.Size = UDim2.new(lastComponentWidth, UDim.new())
						else
							SliderField.Size = UDim2.new(componentWidth, UDim.new())
						end
						SliderField.AutomaticSize = Enum.AutomaticSize.Y
						SliderField.BackgroundColor3 = Iris._config.FrameBgColor
						SliderField.BackgroundTransparency = Iris._config.FrameBgTransparency
						SliderField.AutoButtonColor = false
						SliderField.Text = ""
						SliderField.ClipsDescendants = true

						widgets.applyFrameStyle(SliderField)
						widgets.applyTextStyle(SliderField)
						widgets.UISizeConstraint(SliderField, Vector2.new(1, 0))

						SliderField.Parent = Slider

						local OverlayText = Instance.new("TextLabel")
						OverlayText.Name = "OverlayText"
						OverlayText.Size = UDim2.fromScale(1, 1)
						OverlayText.BackgroundTransparency = 1
						OverlayText.BorderSizePixel = 0
						OverlayText.ZIndex = thisWidget.ZIndex + 10
						OverlayText.ClipsDescendants = true

						widgets.applyTextStyle(OverlayText)

						OverlayText.TextXAlignment = Enum.TextXAlignment.Center

						OverlayText.Parent = SliderField

						widgets.applyInteractionHighlights(SliderField, SliderField, {
							ButtonColor = Iris._config.FrameBgColor,
							ButtonTransparency = Iris._config.FrameBgTransparency,
							ButtonHoveredColor = Iris._config.FrameBgHoveredColor,
							ButtonHoveredTransparency = Iris._config.FrameBgHoveredTransparency,
							ButtonActiveColor = Iris._config.FrameBgActiveColor,
							ButtonActiveTransparency = Iris._config.FrameBgActiveTransparency,
						})

						local InputField: TextBox = Instance.new("TextBox")
						InputField.Name = "InputField"
						InputField.ZIndex = thisWidget.ZIndex + 5
						InputField.LayoutOrder = thisWidget.ZIndex + 2
						InputField.Size = UDim2.new(1, 0, 1, 0)
						InputField.BackgroundTransparency = 1
						InputField.ClearTextOnFocus = false
						InputField.TextTruncate = Enum.TextTruncate.AtEnd
						InputField.ClipsDescendants = true
						InputField.Visible = false

						widgets.applyFrameStyle(InputField, true)
						widgets.applyTextStyle(InputField)

						InputField.Parent = SliderField

						InputField.FocusLost:Connect(function()
							local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
							if newValue ~= nil then
								if thisWidget.arguments.Min ~= nil then
									newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
								end
								if thisWidget.arguments.Max ~= nil then
									newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments))
								end

								if thisWidget.arguments.Increment then
									newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments))
										* getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
								end

								thisWidget.state.number:set(updateValueByIndex(thisWidget.state.number.value, index, newValue, thisWidget.arguments))
								thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
							end

							local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
							if thisWidget.arguments.Prefix then
								format = thisWidget.arguments.Prefix[index] .. format
							end

							InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))

							thisWidget.state.editingText:set(0)
							InputField:ReleaseFocus(true)
						end)

						InputField.Focused:Connect(function()
							-- this highlights the entire field
							InputField.CursorPosition = #InputField.Text + 1
							InputField.SelectionStart = 1

							thisWidget.state.editingText:set(index)
						end)

						SliderField.MouseButton1Down:Connect(function()
							SliderMouseDown(thisWidget, dataType, index)
						end)

						local GrabBar: Frame = Instance.new("Frame")
						GrabBar.Name = "GrabBar"
						GrabBar.ZIndex = thisWidget.ZIndex + 5
						GrabBar.LayoutOrder = thisWidget.ZIndex + 5
						GrabBar.AnchorPoint = Vector2.new(0, 0.5)
						GrabBar.Position = UDim2.new(0, 0, 0.5, 0)
						GrabBar.BorderSizePixel = 0
						GrabBar.BackgroundColor3 = Iris._config.SliderGrabColor
						GrabBar.Transparency = Iris._config.SliderGrabTransparency
						if Iris._config.GrabRounding > 0 then
							widgets.UICorner(GrabBar, Iris._config.GrabRounding)
						end

						GrabBar.Parent = SliderField
					end

					local TextLabel: TextLabel = Instance.new("TextLabel")
					TextLabel.Name = "TextLabel"
					TextLabel.Size = UDim2.fromOffset(0, textHeight)
					TextLabel.BackgroundTransparency = 1
					TextLabel.BorderSizePixel = 0
					TextLabel.ZIndex = thisWidget.ZIndex + 5
					TextLabel.LayoutOrder = thisWidget.ZIndex + 5
					TextLabel.AutomaticSize = Enum.AutomaticSize.X

					widgets.applyTextStyle(TextLabel)

					TextLabel.Parent = Slider

					return Slider
				end,
				Update = function(thisWidget: Types.Widget)
					local Input = thisWidget.Instance :: GuiObject
					local TextLabel: TextLabel = Input.TextLabel
					TextLabel.Text = thisWidget.arguments.Text or `Slider {dataType}`

					if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
						thisWidget.arguments.Format = { thisWidget.arguments.Format }
					else
						-- we calculate the format for the s.f. using the max, min and increment arguments.
						local format: { string } = {}
						for index = 1, components do
							local sigfigs: number = defaultSigFigs[dataType][index]

							if thisWidget.arguments.Increment then
								local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if thisWidget.arguments.Max then
								local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if thisWidget.arguments.Min then
								local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
								sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
							end

							if sigfigs > 0 then
								-- we know it's a float.
								format[index] = `%.{sigfigs}f`
							else
								format[index] = "%d"
							end
						end

						thisWidget.arguments.Format = format
						thisWidget.arguments.Prefix = defaultPrefx[dataType]
					end

					for index = 1, components do
						local SliderField = Input:FindFirstChild("SliderField" .. tostring(index)) :: TextButton
						local GrabBar: Frame = SliderField.GrabBar

						local increment: number = thisWidget.arguments.Increment
								and getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
							or defaultIncrements[dataType][index]
						local min: number = thisWidget.arguments.Min and getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
							or defaultMin[dataType][index]
						local max: number = thisWidget.arguments.Max and getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
							or defaultMax[dataType][index]

						local grabScaleSize =
							math.max(1 / math.floor((1 + max - min) / increment), Iris._config.GrabMinSize / SliderField.AbsoluteSize.X)

						GrabBar.Size = UDim2.new(grabScaleSize, 0, 1, 0)
					end
				end,
				Discard = function(thisWidget: Types.Widget)
					thisWidget.Instance:Destroy()
					widgets.discardState(thisWidget)
				end,
				GenerateState = function(thisWidget: Types.Widget)
					if thisWidget.state.number == nil then
						thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
					end
					if thisWidget.state.editingText == nil then
						thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
					end
				end,
				UpdateState = function(thisWidget: Types.Widget)
					local Slider = thisWidget.Instance :: Frame

					for index = 1, components do
						local SliderField = Slider:FindFirstChild("SliderField" .. tostring(index)) :: TextButton
						local InputField: TextBox = SliderField.InputField
						local OverlayText: TextLabel = SliderField.OverlayText
						local GrabBar: Frame = SliderField.GrabBar

						local value: number = getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments)
						local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
						if thisWidget.arguments.Prefix then
							format = thisWidget.arguments.Prefix[index] .. format
						end

						OverlayText.Text = string.format(format, value)
						InputField.Text = tostring(value)

						local increment: number = thisWidget.arguments.Increment
								and getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
							or defaultIncrements[dataType][index]
						local min: number = thisWidget.arguments.Min and getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
							or defaultMin[dataType][index]
						local max: number = thisWidget.arguments.Max and getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
							or defaultMax[dataType][index]

						local GrabPadding: number = Iris._config.FramePadding.X
						local decimalFix: number = increment < 1 and 0 or 1 -- ??? ?? ??? ?
						local GrabNumPossiblePositions: number = math.floor((decimalFix + max - min) / increment)
						local PositionRatio: number = (value - min) / (max - min)
						local MaxScaleSize: number = 1 - (GrabBar.AbsoluteSize.X / (SliderField.AbsoluteSize.X - 2 * GrabPadding))
						local GrabBarPos: number =
							math.clamp(math.floor(PositionRatio * GrabNumPossiblePositions) / GrabNumPossiblePositions, 0, MaxScaleSize)
						GrabBar.Position = UDim2.new(GrabBarPos, 0, 0.5, 0)

						if thisWidget.state.editingText.value == index then
							InputField.Visible = true
							OverlayText.Visible = false
							GrabBar.Visible = false
							InputField:CaptureFocus()
						else
							InputField.Visible = false
							OverlayText.Visible = true
							GrabBar.Visible = true
						end
					end
				end,
			}
		end

		function generateEnumSliderScalar(enum: Enum, item: EnumItem)
			local input: Types.WidgetClass = generateSliderScalar("Enum", 1, item.Value)
			local valueToName = { string }

			for _, enumItem: EnumItem in enum:GetEnumItems() do
				valueToName[enumItem.Value] = enumItem.Name
			end

			return widgets.extend(input, {
				Args = {
					["Text"] = 1,
				},
				Update = function(thisWidget: Types.Widget)
					local Input = thisWidget.Instance :: GuiObject
					local TextLabel: TextLabel = Input.TextLabel
					TextLabel.Text = thisWidget.arguments.Text or "Input Enum"

					thisWidget.arguments.Increment = 1
					thisWidget.arguments.Min = 0
					thisWidget.arguments.Max = #enum:GetEnumItems() - 1

					local SliderField = Input:FindFirstChild("SliderField1") :: TextButton
					local GrabBar: Frame = SliderField.GrabBar

					local grabScaleSize = math.max(1 / math.floor(#enum:GetEnumItems()), Iris._config.GrabMinSize / SliderField.AbsoluteSize.X)

					GrabBar.Size = UDim2.new(grabScaleSize, 0, 1, 0)
				end,
				GenerateState = function(thisWidget: Types.Widget)
					if thisWidget.state.number == nil then
						thisWidget.state.number = Iris._widgetState(thisWidget, "number", item.Value)
					end
					if thisWidget.state.enumItem == nil then
						thisWidget.state.enumItem = Iris._widgetState(thisWidget, "enumItem", item)
					end
					if thisWidget.state.editingText == nil then
						thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
					end
				end,
			})
		end
	end

	do
		local inputNum: Types.WidgetClass = generateInputScalar("Num", 1, 0)
		inputNum.Args["NoButtons"] = 6
		Iris.WidgetConstructor("InputNum", inputNum)
	end
	Iris.WidgetConstructor("InputVector2", generateInputScalar("Vector2", 2, Vector2.zero))
	Iris.WidgetConstructor("InputVector3", generateInputScalar("Vector3", 3, Vector3.zero))
	Iris.WidgetConstructor("InputUDim", generateInputScalar("UDim", 2, UDim.new()))
	Iris.WidgetConstructor("InputUDim2", generateInputScalar("UDim2", 4, UDim2.new()))
	Iris.WidgetConstructor("InputRect", generateInputScalar("Rect", 4, Rect.new(0, 0, 0, 0)))

	Iris.WidgetConstructor("DragNum", generateDragScalar("Num", 1, 0))
	Iris.WidgetConstructor("DragVector2", generateDragScalar("Vector2", 2, Vector2.zero))
	Iris.WidgetConstructor("DragVector3", generateDragScalar("Vector3", 3, Vector3.zero))
	Iris.WidgetConstructor("DragUDim", generateDragScalar("UDim", 2, UDim.new()))
	Iris.WidgetConstructor("DragUDim2", generateDragScalar("UDim2", 4, UDim2.new()))
	Iris.WidgetConstructor("DragRect", generateDragScalar("Rect", 4, Rect.new(0, 0, 0, 0)))

	Iris.WidgetConstructor("InputColor3", generateColorDragScalar("Color3", Color3.fromRGB(0, 0, 0)))
	Iris.WidgetConstructor("InputColor4", generateColorDragScalar("Color4", Color3.fromRGB(0, 0, 0), 0))

	Iris.WidgetConstructor("SliderNum", generateSliderScalar("Num", 1, 0))
	Iris.WidgetConstructor("SliderVector2", generateSliderScalar("Vector2", 2, Vector2.zero))
	Iris.WidgetConstructor("SliderVector3", generateSliderScalar("Vector3", 3, Vector3.zero))
	Iris.WidgetConstructor("SliderUDim", generateSliderScalar("UDim", 2, UDim.new()))
	Iris.WidgetConstructor("SliderUDim2", generateSliderScalar("UDim2", 4, UDim2.new()))
	Iris.WidgetConstructor("SliderRect", generateSliderScalar("Rect", 4, Rect.new(0, 0, 0, 0)))
	-- Iris.WidgetConstructor("SliderEnum", generateSliderScalar("Enum", 4, 0))

	Iris.WidgetConstructor("InputText", {
		hasState = true,
		hasChildren = false,
		Args = {
			["Text"] = 1,
			["TextHint"] = 2,
		},
		Events = {
			["textChanged"] = {
				["Init"] = function(thisWidget: Types.Widget)
					thisWidget.lastTextchangeTick = 0
				end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastTextchangeTick == Iris._cycleTick
				end,
			},
			["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
				return thisWidget.Instance
			end),
		},
		Generate = function(thisWidget: Types.Widget)
			local InputText: Frame = Instance.new("Frame")
			InputText.Name = "Iris_InputText"
			InputText.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
			InputText.BackgroundTransparency = 1
			InputText.BorderSizePixel = 0
			InputText.ZIndex = thisWidget.ZIndex
			InputText.LayoutOrder = thisWidget.ZIndex
			InputText.AutomaticSize = Enum.AutomaticSize.Y
			widgets.UIListLayout(InputText, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))

			local InputField: TextBox = Instance.new("TextBox")
			InputField.Name = "InputField"
			InputField.Size = UDim2.new(1, 0, 0, 0)
			InputField.AutomaticSize = Enum.AutomaticSize.Y
			InputField.BackgroundColor3 = Iris._config.FrameBgColor
			InputField.BackgroundTransparency = Iris._config.FrameBgTransparency
			InputField.Text = ""
			InputField.PlaceholderColor3 = Iris._config.TextDisabledColor
			InputField.TextTruncate = Enum.TextTruncate.AtEnd
			InputField.ClearTextOnFocus = false
			InputField.ZIndex = thisWidget.ZIndex + 1
			InputField.LayoutOrder = thisWidget.ZIndex + 1
			InputField.ClipsDescendants = true

			widgets.applyFrameStyle(InputField)
			widgets.applyTextStyle(InputField)
			widgets.UISizeConstraint(InputField, Vector2.new(1, 0)) -- prevents sizes beaking when getting too small.
			-- InputField.UIPadding.PaddingLeft = UDim.new(0, Iris._config.ItemInnerSpacing.X)
			-- InputField.UIPadding.PaddingRight = UDim.new(0, 0)
			InputField.Parent = InputText

			InputField.FocusLost:Connect(function()
				thisWidget.state.text:set(InputField.Text)
				thisWidget.lastTextchangeTick = Iris._cycleTick + 1
			end)

			local frameHeight: number = Iris._config.TextSize + Iris._config.FramePadding.Y * 2

			local TextLabel: TextLabel = Instance.new("TextLabel")
			TextLabel.Name = "TextLabel"
			TextLabel.Size = UDim2.fromOffset(0, frameHeight)
			TextLabel.AutomaticSize = Enum.AutomaticSize.X
			TextLabel.BackgroundTransparency = 1
			TextLabel.BorderSizePixel = 0
			TextLabel.ZIndex = thisWidget.ZIndex + 4
			TextLabel.LayoutOrder = thisWidget.ZIndex + 4

			widgets.applyTextStyle(TextLabel)

			TextLabel.Parent = InputText

			return InputText
		end,
		Update = function(thisWidget: Types.Widget)
			local InputText = thisWidget.Instance :: Frame
			local TextLabel: TextLabel = InputText.TextLabel
			local InputField: TextBox = InputText.InputField

			TextLabel.Text = thisWidget.arguments.Text or "Input Text"
			InputField.PlaceholderText = thisWidget.arguments.TextHint or ""
		end,
		Discard = function(thisWidget: Types.Widget)
			thisWidget.Instance:Destroy()
			widgets.discardState(thisWidget)
		end,
		GenerateState = function(thisWidget: Types.Widget)
			if thisWidget.state.text == nil then
				thisWidget.state.text = Iris._widgetState(thisWidget, "text", "")
			end
		end,
		UpdateState = function(thisWidget: Types.Widget)
			local InputText = thisWidget.Instance :: Frame
			local InputField: TextBox = InputText.InputField

			InputField.Text = thisWidget.state.text.value
		end,
	} :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Input

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Menu | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local AnyMenuOpen: boolean = false
    local ActiveMenu: Types.Widget?
    local MenuStack: { Types.Widget } = {}

    local function EmptyMenuStack(menuIndex: number?)
        for index = #MenuStack, menuIndex and menuIndex + 1 or 1, -1 do
            local widget: Types.Widget = MenuStack[index]
            widget.state.isOpened:set(false)

            widget.Instance.BackgroundColor3 = Iris._config.HeaderColor
            widget.Instance.BackgroundTransparency = 1
            
            table.remove(MenuStack, index)
        end

        if #MenuStack == 0 then
            AnyMenuOpen = false
            ActiveMenu = nil
        end
    end

    local function UpdateChildContainerTransform(thisWidget: Types.Widget)
        local submenu: boolean = thisWidget.parentWidget.type == "Menu"

        local Menu = thisWidget.Instance :: Frame
        local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame
        ChildContainer.Size = UDim2.fromOffset(math.max(ChildContainer.AbsoluteSize.X, Menu.AbsoluteSize.X), math.max(ChildContainer.AbsoluteSize.Y, Menu.AbsoluteSize.Y))
        if ChildContainer.Parent == nil then
            return
        end

        local menuPosition: Vector2 = Menu.AbsolutePosition
        local menuSize: Vector2 = Menu.AbsoluteSize
        local containerSize: Vector2 = ChildContainer.AbsoluteSize
        local borderSize: number = Iris._config.PopupBorderSize
        local screenSize: Vector2 = ChildContainer.Parent.AbsoluteSize

        local x: number = menuPosition.X + borderSize
        local y: number

        if thisWidget.parentWidget.type == "Menu" then
            if menuPosition.X + containerSize.X > screenSize.X then
                x = menuPosition.X - borderSize - (submenu and containerSize.X or 0)
            else
                x = menuPosition.X + borderSize + (submenu and menuSize.X or 0)
            end
        end

        if menuPosition.Y + containerSize.Y > screenSize.Y then
            -- too low.
            y = menuPosition.Y - borderSize - containerSi [trimmed]  -  Edit
  18:44:43.578  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Tree | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local abstractTree = {
        hasState = true,
        hasChildren = true,
        Events = {
            ["collasped"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastCollapsedTick == Iris._cycleTick
                end,
            },
            ["uncollapsed"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastUncollapsedTick == Iris._cycleTick
                end,
            },
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget)
                return thisWidget.Instance
            end),
        },
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
        ChildAdded = function(thisWidget: Types.Widget)
            local Tree = thisWidget.Instance :: Frame
            local ChildContainer: Frame = Tree.ChildContainer

            ChildContainer.Visible = thisWidget.state.isUncollapsed.value

            return ChildContainer
        end,
        UpdateState = function(thisWidget: Types.Widget)
            local isUncollapsed: boolean = thisWidget.state.isUncollapsed.value
            local Tree = thisWidget.Instance :: Frame
            local ChildContainer: Frame = Tree.ChildContainer
            local Header = Tree.Header :: Frame
            local Button = Header.Button :: TextButton
            local Arrow: ImageLabel = Button.Arrow

            Arrow.Image = (isUncollapsed and widgets.ICONS.DOWN_POINTING_TRIANGLE or widgets.ICONS.RIGHT_POINTING_TRIANGLE)
            if isUncollapsed then
                thisWidget.lastUncollapsedTick = Iris._cycleTick + 1
            else
                thisWidget.lastCollapsedTick = Iris._cycleTick + 1
            end

            ChildContainer.Visible = isUncollapsed
        end,
        GenerateState = function(thisWidget: Types.Widget)
            if thisWidget.state.isUncollapsed == nil then
                thisWidget.state.isUncollapsed = Iris._widgetState(thisWidget, "isUncollapsed", false)
            end
        end,
    } :: Types.WidgetClass

    Iris.WidgetConstructor(
        "Tree",
        widgets.extend(abstractTree, {
            Args = {
                ["Text"] = 1,
                ["SpanAvailWidth"] = 2,
                ["NoIndent"] = 3,
            },
            Generate = function(thisWidget: Types.Widget)
                local Tree: Frame = Instance.new("Frame")
                Tree.Name = "Iris_Tree"
                Tree.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, 0))
                Tree.AutomaticSize = Enum.AutomaticSize.Y
                Tree.BackgroundTransparency = 1
                Tree.BorderSizePixel = 0
                Tree.ZIndex = thisWidget.ZIndex
                Tree.LayoutOrder = thisWidget.ZIndex

                widgets.UIListLayout(Tree, Enum.FillDirection.Vertical, UDim.new(0, 0))

                local ChildContainer: Frame = Instance.new("Frame")
                ChildContainer.Name = "ChildContainer"
                ChildContainer.Size = UDim2.fromScale(1, 0)
                ChildContainer.AutomaticSize = Enum.AutomaticSize.Y
                ChildContainer.BackgroundTransparency = 1
                ChildContainer.BorderSizePixel = 0
                ChildContainer.ZIndex = thisWidget.ZIndex + 1
                ChildContainer.LayoutOrder = thisWidget.ZIndex + 1
                ChildContainer.Visible = false
                -- ChildContainer.ClipsDescendants = true

                widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
                local ChildContainerPadding: UIPadding = widgets.UIPadding(ChildContainer, Vector2.new(0, 0))
                ChildContainerPadding.PaddingTop = UDim.new(0, Iris._config.ItemSpacing.Y)

                ChildContainer.Parent = Tree

                local Header: Frame = Instance.new("Frame")
                Header.Name = "Header"
                Header.Size = UDim2.fromScale(1, 0)
                Header.AutomaticSize = Enum.AutomaticSize.Y
                Header.BackgroundTransparency = 1
                Header.BorderSizePixel = 0
                Header.ZIndex = thisWidget.ZIndex
                Header.LayoutOrder = thisWidget.ZIndex
                Header.Parent = Tree

                local Button: TextButton = Instance.new("TextButton")
                Button.Name = "Button"
                Button.BackgroundTransparency = 1
                Button.BorderSizePixel = 0
                Button.Text = ""
                Button.ZIndex = thisWidget.ZIndex
                Button.LayoutOrder = thisWidget.ZIndex
                Button.AutoButtonColor = false

                widgets.applyInteractionHighlights(Button, Header, {
                    ButtonColor = Color3.fromRGB(0, 0, 0),
                    ButtonTransparency = 1,
                    ButtonHoveredColor = Iris._config.HeaderHoveredColor,
                    ButtonHoveredTransparency = Iris._config.HeaderHoveredTransparency,
                    ButtonActiveColor = Iris._config.HeaderActiveColor,
                    ButtonActiveTransparency = Iris._config.HeaderActiveTransparency,
                })

                local ButtonPadding: UIPadding = widgets.UIPadding(Button, Vector2.zero)
                ButtonPadding.PaddingLeft = UDim.new(0, Iris._config.FramePadding.X)
                local ButtonUIListLayout: UIListLayout = widgets.UIListLayout(Button, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.FramePadding.X))
                ButtonUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                Button.Parent = Header

                local Arrow: ImageLabel = Instance.new("ImageLabel")
                Arrow.Name = "Arrow"
                Arrow.Size = UDim2.fromOffset(Iris._config.TextSize, math.floor(Iris._config.TextSize * 0.7))
                Arrow.BackgroundTransparency = 1
                Arrow.BorderSizePixel = 0
                Arrow.ImageColor3 = Iris._config.TextColor
                Arrow.ImageTransparency = Iris._config.TextTransparency
                Arrow.ScaleType = Enum.ScaleType.Fit
                Arrow.ZIndex = thisWidget.ZIndex
                Arrow.LayoutOrder = thisWidget.ZIndex

                Arrow.Parent = Button

                local TextLabel: TextLabel = Instance.new("TextLabel")
                TextLabel.Name = "TextLabel"
                TextLabel.Size = UDim2.fromOffset(0, 0)
                TextLabel.AutomaticSize = Enum.AutomaticSize.XY
                TextLabel.BackgroundTransparency = 1
                TextLabel.BorderSizePixel = 0
                TextLabel.ZIndex = thisWidget.ZIndex
                TextLabel.LayoutOrder = thisWidget.ZIndex

                local TextPadding: UIPadding = widgets.UIPadding(TextLabel, Vector2.new(0, 0))
                TextPadding.PaddingRight = UDim.new(0, 21)
                widgets.applyTextStyle(TextLabel)

                TextLabel.Parent = Button

                Button.MouseButton1Click:Connect(function()
                    thisWidget.state.isUncollapsed:set(not thisWidget.state.isUncollapsed.value)
                end)

                return Tree
            end,
            Update = function(thisWidget: Types.Widget)
                local Tree = thisWidget.Instance :: Frame
                local Header = Tree.Header :: Frame
                local Button = Header.Button :: TextButton
                local TextLabel: TextLabel = Button.TextLabel
                local ChildContainer = Tree.ChildContainer :: Frame
                local Padding: UIPadding = ChildContainer.UIPadding

                TextLabel.Text = thisWidget.arguments.Text or "Tree"
                if thisWidget.arguments.SpanAvailWidth then
                    Button.AutomaticSize = Enum.AutomaticSize.Y
                    Button.Size = UDim2.fromScale(1, 0)
                else
                    Button.AutomaticSize = Enum.AutomaticSize.XY
                    Button.Size = UDim2.fromScale(0, 0)
                end

                if thisWidget.arguments.NoIndent then
                    Padding.PaddingLeft = UDim.new(0, 0)
                else
                    Padding.PaddingLeft = UDim.new(0, Iris._config.IndentSpacing)
                end
            end,
        })
    )

    Iris.WidgetConstructor(
        "CollapsingHeader",
        widgets.extend(abstractTree, {
            Args = {
                ["Text"] = 1,
            },
            Generate = function(thisWidget: Types.Widget)
                local CollapsingHeader: Frame = Instance.new("Frame")
                CollapsingHeader.Name = "Iris_CollapsingHeader"
                CollapsingHeader.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, 0))
                CollapsingHeader.AutomaticSize = Enum.AutomaticSize.Y
                CollapsingHeader.BackgroundTransparency = 1
                CollapsingHeader.BorderSizePixel = 0
                CollapsingHeader.ZIndex = thisWidget.ZIndex
                CollapsingHeader.LayoutOrder = thisWidget.ZIndex

                widgets.UIListLayout(CollapsingHeader, Enum.FillDirection.Vertical, UDim.new(0, 0))

                local ChildContainer: Frame = Instance.new("Frame")
                ChildContainer.Name = "ChildContainer"
                ChildContainer.Size = UDim2.fromScale(1, 0)
                ChildContainer.AutomaticSize = Enum.AutomaticSize.Y
                ChildContainer.BackgroundTransparency = 1
                ChildContainer.BorderSizePixel = 0
                ChildContainer.ZIndex = thisWidget.ZIndex + 1
                ChildContainer.LayoutOrder = thisWidget.ZIndex + 1
                ChildContainer.Visible = false
                -- ChildContainer.ClipsDescendants = true

                widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
                local ChildContainerPadding: UIPadding = widgets.UIPadding(ChildContainer, Vector2.new(0, 0))
                ChildContainerPadding.PaddingTop = UDim.new(0, Iris._config.ItemSpacing.Y)

                ChildContainer.Parent = CollapsingHeader

                local Header: Frame = Instance.new("Frame")
                Header.Name = "Header"
                Header.Size = UDim2.fromScale(1, 0)
                Header.AutomaticSize = Enum.AutomaticSize.Y
                Header.BackgroundTransparency = 1
                Header.BorderSizePixel = 0
                Header.ZIndex = thisWidget.ZIndex
                Header.LayoutOrder = thisWidget.ZIndex
                Header.Parent = CollapsingHeader

                local Button = Instance.new("TextButton")
                Button.Name = "Button"
                Button.Size = UDim2.new(1, 2 * Iris._config.FramePadding.X, 0, 0)
                Button.Position = UDim2.fromOffset(-4, 0)
                Button.AutomaticSize = Enum.AutomaticSize.Y
                Button.BackgroundColor3 = Iris._config.HeaderColor
                Button.BackgroundTransparency = Iris._config.HeaderTransparency
                Button.BorderSizePixel = 0
                Button.Text = ""
                Button.ZIndex = thisWidget.ZIndex
                Button.LayoutOrder = thisWidget.ZIndex
                Button.AutoButtonColor = false
                Button.ClipsDescendants = true

                widgets.UIPadding(Button, Vector2.new(2 * Iris._config.FramePadding.X, Iris._config.FramePadding.Y)) -- we add a custom padding because it extends on both sides
                widgets.applyFrameStyle(Button, true, true)
                local ButtonUIListLayout: UIListLayout = widgets.UIListLayout(Button, Enum.FillDirection.Horizontal, UDim.new(0, 2 * Iris._config.FramePadding.X))
                ButtonUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                widgets.applyInteractionHighlights(Button, Button, {
                    ButtonColor = Iris._config.HeaderColor,
                    ButtonTransparency = Iris._config.HeaderTransparency,
                    ButtonHoveredColor = Iris._config.HeaderHoveredColor,
                    ButtonHoveredTransparency = Iris._config.HeaderHoveredTransparency,
                    ButtonActiveColor = Iris._config.HeaderActiveColor,
                    ButtonActiveTransparency = Iris._config.HeaderActiveTransparency,
                })

                Button.Parent = Header

                local Arrow: ImageLabel = Instance.new("ImageLabel")
                Arrow.Name = "Arrow"
                Arrow.Size = UDim2.fromOffset(Iris._config.TextSize, math.ceil(Iris._config.TextSize * 0.8))
                Arrow.AutomaticSize = Enum.AutomaticSize.Y
                Arrow.BackgroundTransparency = 1
                Arrow.BorderSizePixel = 0
                Arrow.ImageColor3 = Iris._config.TextColor
                Arrow.ImageTransparency = Iris._config.TextTransparency
                Arrow.ScaleType = Enum.ScaleType.Fit
                Arrow.ZIndex = thisWidget.ZIndex
                Arrow.LayoutOrder = thisWidget.ZIndex

                Arrow.Parent = Button

                local TextLabel: TextLabel = Instance.new("TextLabel")
                TextLabel.Name = "TextLabel"
                TextLabel.Size = UDim2.fromOffset(0, 0)
                TextLabel.AutomaticSize = Enum.AutomaticSize.XY
                TextLabel.BackgroundTransparency = 1
                TextLabel.BorderSizePixel = 0
                TextLabel.ZIndex = thisWidget.ZIndex
                TextLabel.LayoutOrder = thisWidget.ZIndex

                local TextPadding: UIPadding = widgets.UIPadding(TextLabel, Vector2.new(0, 0))
                TextPadding.PaddingRight = UDim.new(0, 21)
                widgets.applyTextStyle(TextLabel)

                TextLabel.Parent = Button

                Button.MouseButton1Click:Connect(function()
                    thisWidget.state.isUncollapsed:set(not thisWidget.state.isUncollapsed.value)
                end)

                return CollapsingHeader
            end,
            Update = function(thisWidget: Types.Widget)
                local Tree = thisWidget.Instance :: Frame
                local Header = Tree.Header :: Frame
                local Button = Header.Button :: TextButton
                local TextLabel: TextLabel = Button.TextLabel

                TextLabel.Text = thisWidget.arguments.Text or "Collapsing Header"
            end,
        })
    )
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Tree

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Window | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
	local function relocateTooltips()
		if Iris._rootInstance == nil then
			return
		end
		local PopupScreenGui = Iris._rootInstance:FindFirstChild("PopupScreenGui")
		if not PopupScreenGui then
			return
		end
		local TooltipContainer = PopupScreenGui.TooltipContainer
		local mouseLocation = widgets.getMouseLocation()
		local newPosition = widgets.findBestWindowPosForPopup(
			mouseLocation,
			TooltipContainer.AbsoluteSize,
			Iris._config.DisplaySafeAreaPadding,
			PopupScreenGui.AbsoluteSize
		)
		TooltipContainer.Position = UDim2.fromOffset(newPosition.X, newPosition.Y)
	end

	widgets.UserInputService.InputChanged:Connect(relocateTooltips)

	Iris.WidgetConstructor("Tooltip", {
		hasState = false,
		hasChildren = false,
		Args = {
			["Text"] = 1,
		},
		Events = {},
		Generate = function(thisWidget: Types.Widget)
			thisWidget.parentWidget = Iris._rootWidget -- only allow root as parent

			local Tooltip: Frame = Instance.new("Frame")
			Tooltip.Name = "Iris_Tooltip"
			Tooltip.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
			Tooltip.AutomaticSize = Enum.AutomaticSize.Y
			Tooltip.BorderSizePixel = 0
			Tooltip.BackgroundTransparency = 1
			Tooltip.ZIndex = thisWidget.ZIndex + 1
			Tooltip.LayoutOrder = thisWidget.ZIndex + 1

			local TooltipText: TextLabel = Instance.new("TextLabel")
			TooltipText.Name = "TooltipText"
			TooltipText.Size = UDim2.fromOffset(0, 0)
			TooltipText.AutomaticSize = Enum.AutomaticSize.XY
			TooltipText.BackgroundColor3 = Iris._config.WindowBgColor
			TooltipText.BackgroundTransparency = Iris._config.WindowBgTransparency
			TooltipText.BorderSizePixel = Iris._config.PopupBorderSize
			TooltipText.TextWrapped = true
			TooltipText.ZIndex = thisWidget.ZIndex + 1
			TooltipText.LayoutOrder = thisWidget.ZIndex + 1

			widgets.applyTextStyle(TooltipText)
			widgets.UIStroke(TooltipText, Iris._config.WindowBorderSize, Iris._config.BorderActiveColor, Iris._config.BorderActiveTransparency)
			widgets.UIPadding(TooltipText, Iris._config.WindowPadding)
			if Iris._config.PopupRounding > 0 then
				widgets.UICorner(TooltipText, Iris._config.PopupRounding)
			end

			TooltipText.Parent = Tooltip

			return Tooltip
		end,
		Update = function(thisWidget: Types.Widget)
			local Tooltip = thisWidget.Instance :: Frame
			local TooltipText: TextLabel = Tooltip.TooltipText
			if thisWidget.arguments.Text == nil then
				error("Iris.Text Text Argument is required", 5)
			end
			TooltipText.Text = thisWidget.arguments.Text
			relocateTooltips()
		end,
		Discard = function(thisWidget: Types.Widget)
			thisWidget.Instance:Destroy()
		end,
	} :: Types.WidgetClass)

	local windowDisplayOrder: number = 0 -- incremental count which is used for determining focused windows ZIndex
	local dragWindow: Types.Widget? -- window being dragged, may be nil
	local isDragging: boolean = false
	local moveDeltaCursorPosition: Vector2 -- cursor offset from drag origin (top left of window)

	local resizeWindow: Types.Widget? -- window being resized, may be nil
	local isResizing = false
	local isInsideResize = false -- is cursor inside of the focused window resize outer padding
	local isInsideWindow = false -- is cursor inside of the focused window
	local resizeFromTopBottom: Enum.TopBottom = Enum.TopBottom.Top
	local resizeFromLeftRight: Enum.LeftRight = Enum.LeftRight.Left

	local lastCursorPosition: Vector2

	local focusedWindow: Types.Widget? -- window with focus, may be nil
	local anyFocusedWindow: boolean = false -- is there any focused window?

	local windowWidgets: { [Types.ID]: Types.Widget } = {} -- array of widget objects of type window

	local function quickSwapWindows()
		-- ctrl + tab swapping functionality
		if Iris._config.UseScreenGUIs == false then
			return
		end

		local lowest: number = 0xFFFF
		local lowestWidget: Types.Widget

		for _, widget: Types.Widget in windowWidgets do
			if widget.state.isOpened.value and not widget.arguments.NoNav then
				if widget.Instance:IsA("ScreenGui") then
					local value: number = widget.Instance.DisplayOrder
					if value < lowest then
						lowest = value
						lowestWidget = widget
					end
				end
			end
		end

		if lowestWidget.state.isUncollapsed.value == false then
			lowestWidget.state.isUncollapsed:set(true)
		end
		Iris.SetFocusedWindow(lowestWidget)
	end

	local function fitSizeToWindowBounds(thisWidget: Types.Widget, intentedSize: Vector2): Vector2
		local windowSize: Vector2 = Vector2.new(thisWidget.state.position.value.X, thisWidget.state.position.value.Y)
		local minWindowSize: number = (Iris._config.TextSize + Iris._config.FramePadding.Y * 2) * 2
		local usableSize: Vector2 = widgets.getScreenSizeForWindow(thisWidget)
		local safeAreaPadding: Vector2 = Vector2.new(
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.X,
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.Y
		)

		local maxWindowSize: Vector2 = (usableSize - windowSize - safeAreaPadding)
		return Vector2.new(
			math.clamp(intentedSize.X, minWindowSize, math.max(maxWindowSize.X, minWindowSize)),
			math.clamp(intentedSize.Y, minWindowSize, math.max(maxWindowSize.Y, minWindowSize))
		)
	end

	local function fitPositionToWindowBounds(thisWidget: Types.Widget, intendedPosition: Vector2): Vector2
		local thisWidgetInstance = thisWidget.Instance
		local usableSize: Vector2 = widgets.getScreenSizeForWindow(thisWidget)
		local safeAreaPadding: Vector2 = Vector2.new(
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.X,
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.Y
		)

		return Vector2.new(
			math.clamp(
				intendedPosition.X,
				safeAreaPadding.X,
				math.max(safeAreaPadding.X, usableSize.X - thisWidgetInstance.WindowButton.AbsoluteSize.X - safeAreaPadding.X)
			),
			math.clamp(
				intendedPosition.Y,
				safeAreaPadding.Y,
				math.max(safeAreaPadding.Y, usableSize.Y - thisWidgetInstance.WindowButton.AbsoluteSize.Y - safeAreaPadding.Y)
			)
		)
	end

	Iris.SetFocusedWindow = function(thisWidget: Types.Widget?)
		if focusedWindow == thisWidget then
			return
		end

		if anyFocusedWindow and focusedWindow ~= nil then
			if windowWidgets[focusedWindow.ID] then
				local Window = focusedWindow.Instance :: Frame
				local WindowButton = Window.WindowButton :: TextButton
				local TitleBar: Frame = WindowButton.TitleBar
				-- update appearance to unfocus
				if focusedWindow.state.isUncollapsed.value then
					TitleBar.BackgroundColor3 = Iris._config.TitleBgColor
					TitleBar.BackgroundTransparency = Iris._config.TitleBgTransparency
				else
					TitleBar.BackgroundColor3 = Iris._config.TitleBgCollapsedColor
					TitleBar.BackgroundTransparency = Iris._config.TitleBgCollapsedTransparency
				end
				WindowButton.UIStroke.Color = Iris._config.BorderColor
			end

			anyFocusedWindow = false
			focusedWindow = nil
		end

		if thisWidget ~= nil then
			-- update appearance to focus
			anyFocusedWindow = true
			focusedWindow = thisWidget
			local Window = thisWidget.Instance :: Frame
			local WindowButton = Window.WindowButton :: TextButton
			local TitleBar: Frame = WindowButton.TitleBar

			TitleBar.BackgroundColor3 = Iris._config.TitleBgActiveColor
			TitleBar.BackgroundTransparency = Iris._config.TitleBgActiveTransparency
			WindowButton.UIStroke.Color = Iris._config.BorderActiveColor

			windowDisplayOrder += 1
			if thisWidget.usesScreenGUI then
				Window.DisplayOrder = windowDisplayOrder + Iris._config.DisplayOrderOffset
			end

			if thisWidget.state.isUncollapsed.value == false then
				thisWidget.state.isUncollapsed:set(true)
			end

			local firstSelectedObject: GuiObject? = widgets.GuiService.SelectedObject
			if firstSelectedObject then
				if TitleBar.Visible then
					widgets.GuiService:Select(TitleBar)
				else
					widgets.GuiService:Select(Window.ChildContainer)
				end
			end
		end
	end

	widgets.UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessedEvent: boolean)
		if not gameProcessedEvent and input.UserInputType == Enum.UserInputType.MouseButton1 then
			Iris.SetFocusedWindow(nil)
		end

		if
			input.KeyCode == Enum.KeyCode.Tab
			and (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl))
		then
			quickSwapWindows()
		end

		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			if isInsideResize and not isInsideWindow and anyFocusedWindow and focusedWindow then
				local midWindow: Vector2 = focusedWindow.state.position.value + (focusedWindow.state.size.value * 0.5)
				local cursorPosition: Vector2 = widgets.getMouseLocation() - midWindow

				-- check which axis its closest to, then check which side is closest with math.sign
				if math.abs(cursorPosition.X) * focusedWindow.state.size.value.Y >= math.abs(cursorPosition.Y) * focusedWindow.state.size.value.X then
					resizeFromTopBottom = Enum.TopBottom.Center
					resizeFromLeftRight = if math.sign(cursorPosition.X) == -1 then Enum.LeftRight.Left else Enum.LeftRight.Right
				else
					resizeFromLeftRight = Enum.LeftRight.Center
					resizeFromTopBottom = if math.sign(cursorPosition.Y) == -1 then Enum.TopBottom.Top else Enum.TopBottom.Bottom
				end
				isResizing = true
				resizeWindow = focusedWindow
			end
		end
	end)

	widgets.UserInputService.TouchTapInWorld:Connect(function(_, gameProcessedEvent: boolean)
		if not gameProcessedEvent then
			Iris.SetFocusedWindow(nil)
		end
	end)

	widgets.UserInputService.InputChanged:Connect(function(input: InputObject)
		if isDragging and dragWindow then
			local mouseLocation: Vector2
			if input.UserInputType == Enum.UserInputType.Touch then
				local location: Vector3 = input.Position
				mouseLocation = Vector2.new(location.X, location.Y)
			else
				mouseLocation = widgets.getMouseLocation()
			end
			local Window = dragWindow.Instance :: Frame
			local dragInstance: TextButton = Window.WindowButton
			local intendedPosition: Vector2 = mouseLocation - moveDeltaCursorPosition
			local newPos: Vector2 = fitPositionToWindowBounds(dragWindow, intendedPosition)

			-- state shouldnt be used like this, but calling :set would run the entire UpdateState function for the window, which is slow.
			dragInstance.Position = UDim2.fromOffset(newPos.X, newPos.Y)
			dragWindow.state.position.value = newPos
		end
		if isResizing and resizeWindow and resizeWindow.arguments.NoResize ~= true then
			local Window = resizeWindow.Instance :: Frame
			local resizeInstance: TextButton = Window.WindowButton
			local windowPosition: Vector2 = Vector2.new(resizeInstance.Position.X.Offset, resizeInstance.Position.Y.Offset)
			local windowSize: Vector2 = Vector2.new(resizeInstance.Size.X.Offset, resizeInstance.Size.Y.Offset)

			local mouseDelta: Vector2 | Vector3
			if input.UserInputType == Enum.UserInputType.Touch then
				mouseDelta = input.Delta
			else
				mouseDelta = widgets.getMouseLocation() - lastCursorPosition
			end

			local intendedPosition: Vector2 = windowPosition
				+ Vector2.new(
					if resizeFromLeftRight == Enum.LeftRight.Left then mouseDelta.X else 0,
					if resizeFromTopBottom == Enum.TopBottom.Top then mouseDelta.Y else 0
				)

			local intendedSize: Vector2 = windowSize
				+ Vector2.new(
					if resizeFromLeftRight == Enum.LeftRight.Left
						then -mouseDelta.X
						elseif resizeFromLeftRight == Enum.LeftRight.Right then mouseDelta.X
						else 0,
					if resizeFromTopBottom == Enum.TopBottom.Top
						then -mouseDelta.Y
						elseif resizeFromTopBottom == Enum.TopBottom.Bottom then mouseDelta.Y
						else 0
				)

			local newSize: Vector2 = fitSizeToWindowBounds(resizeWindow, intendedSize)
			local newPosition: Vector2 = fitPositionToWindowBounds(resizeWindow, intendedPosition)

			resizeInstance.Size = UDim2.fromOffset(newSize.X, newSize.Y)
			resizeWindow.state.size.value = newSize
			resizeInstance.Position = UDim2.fromOffset(newPosition.X, newPosition.Y)
			resizeWindow.state.position.value = newPosition
		end

		lastCursorPosition = widgets.getMouseLocation()
	end)

	widgets.UserInputService.InputEnded:Connect(function(input, _)
		if
			(input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch)
			and isDragging
			and dragWindow
		then
			local Window = dragWindow.Instance :: Frame
			local dragInstance: TextButton = Window.WindowButton
			isDragging = false
			dragWindow.state.position:set(Vector2.new(dragInstance.Position.X.Offset, dragInstance.Position.Y.Offset))
		end
		if
			(input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch)
			and isResizing
			and resizeWindow
		then
			local Window = resizeWindow.Instance :: Frame
			isResizing = false
			resizeWindow.state.size:set(Window.WindowButton.AbsoluteSize)
		end

		if input.KeyCode == Enum.KeyCode.ButtonX then
			quickSwapWindows()
		end
	end)

	Iris.WidgetConstructor("Window", {
		hasState = true,
		hasChildren = true,
		Args = {
			["Title"] = 1,
			["NoTitleBar"] = 2,
			["NoBackground"] = 3,
			["NoCollapse"] = 4,
			["NoClose"] = 5,
			["NoMove"] = 6,
			["NoScrollbar"] = 7,
			["NoResize"] = 8,
			["NoNav"] = 9,
			["NoMenu"] = 10,
		},
		Events = {
			["closed"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastClosedTick == Iris._cycleTick
				end,
			},
			["opened"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastOpenedTick == Iris._cycleTick
				end,
			},
			["collapsed"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastCollapsedTick == Iris._cycleTick
				end,
			},
			["uncollapsed"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastUncollapsedTick == Iris._cycleTick
				end,
			},
			["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
				local Window = thisWidget.Instance :: Frame
				return Window.WindowButton
			end),
		},
		Generate = function(thisWidget: Types.Widget)
			thisWidget.parentWidget = Iris._rootWidget -- only allow root as parent

			thisWidget.usesScreenGUI = Iris._config.UseScreenGUIs
			windowWidgets[thisWidget.ID] = thisWidget

			local Window
			if thisWidget.usesScreenGUI then
				Window = Instance.new("ScreenGui")
				Window.ResetOnSpawn = false
				Window.DisplayOrder = Iris._config.DisplayOrderOffset
				Window.IgnoreGuiInset = Iris._config.IgnoreGuiInset
			else
				Window = Instance.new("Folder")
			end
			Window.Name = "Iris_Window"

			local WindowButton: TextButton = Instance.new("TextButton")
			WindowButton.Name = "WindowButton"
			WindowButton.Size = UDim2.fromOffset(0, 0)
			WindowButton.BackgroundTransparency = 1
			WindowButton.BorderSizePixel = 0
			WindowButton.Text = ""
			WindowButton.ClipsDescendants = false
			WindowButton.AutoButtonColor = false
			WindowButton.Selectable = false
			WindowButton.SelectionImageObject = Iris.SelectionImageObject
			WindowButton.ZIndex = thisWidget.ZIndex + 1
			WindowButton.LayoutOrder = thisWidget.ZIndex + 1

			WindowButton.SelectionGroup = true
			WindowButton.SelectionBehaviorUp = Enum.SelectionBehavior.Stop
			WindowButton.SelectionBehaviorDown = Enum.SelectionBehavior.Stop
			WindowButton.SelectionBehaviorLeft = Enum.SelectionBehavior.Stop
			WindowButton.SelectionBehaviorRight = Enum.SelectionBehavior.Stop

			widgets.UIStroke(WindowButton, Iris._config.WindowBorderSize, Iris._config.BorderColor, Iris._config.BorderTransparency)

			WindowButton.Parent = Window

			WindowButton.InputBegan:Connect(function(input: InputObject)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Keyboard then
					return
				end
				if thisWidget.state.isUncollapsed.value then
					Iris.SetFocusedWindow(thisWidget)
				end
				if not thisWidget.arguments.NoMove and input.UserInputType == Enum.UserInputType.MouseButton1 then
					dragWindow = thisWidget
					isDragging = true
					moveDeltaCursorPosition = widgets.getMouseLocation() - thisWidget.state.position.value
				end
			end)

			local ChildContainer: ScrollingFrame = Instance.new("ScrollingFrame")
			ChildContainer.Name = "ChildContainer"
			ChildContainer.Size = UDim2.fromScale(1, 1)
			ChildContainer.Position = UDim2.fromOffset(0, 0)
			ChildContainer.BackgroundColor3 = Iris._config.WindowBgColor
			ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency
			ChildContainer.BorderSizePixel = 0

			ChildContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
			ChildContainer.ScrollBarImageTransparency = Iris._config.ScrollbarGrabTransparency
			ChildContainer.ScrollBarImageColor3 = Iris._config.ScrollbarGrabColor
			ChildContainer.CanvasSize = UDim2.fromScale(0, 1)
			ChildContainer.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar

			ChildContainer.ZIndex = thisWidget.ZIndex + 3
			ChildContainer.LayoutOrder = thisWidget.ZIndex + 3
			ChildContainer.ClipsDescendants = true

			widgets.UIPadding(ChildContainer, Iris._config.WindowPadding)

			ChildContainer.Parent = WindowButton

			ChildContainer:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
				-- "wrong" use of state here, for optimization
				thisWidget.state.scrollDistance.value = ChildContainer.CanvasPosition.Y
			end)

			ChildContainer.InputBegan:Connect(function(input: InputObject)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Keyboard then
					return
				end
				if thisWidget.state.isUncollapsed.value then
					Iris.SetFocusedWindow(thisWidget)
				end
			end)

			local TerminatingFrame: Frame = Instance.new("Frame")
			TerminatingFrame.Name = "TerminatingFrame"
			TerminatingFrame.Size = UDim2.fromOffset(0, Iris._config.WindowPadding.Y + Iris._config.FramePadding.Y)
			TerminatingFrame.BackgroundTransparency = 1
			TerminatingFrame.BorderSizePixel = 0
			TerminatingFrame.LayoutOrder = 0x7FFFFFF0

			local ChildContainerUIListLayout: UIListLayout =
				widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
			ChildContainerUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top

			TerminatingFrame.Parent = ChildContainer

			local TitleBar: Frame = Instance.new("Frame")
			TitleBar.Name = "TitleBar"
			TitleBar.Size = UDim2.fromScale(1, 0)
			TitleBar.AutomaticSize = Enum.AutomaticSize.Y
			TitleBar.BorderSizePixel = 0
			TitleBar.ZIndex = thisWidget.ZIndex + 1
			TitleBar.LayoutOrder = thisWidget.ZIndex + 1
			TitleBar.ClipsDescendants = true

			TitleBar.Parent = WindowButton

			TitleBar.InputBegan:Connect(function(input: InputObject)
				if input.UserInputType == Enum.UserInputType.Touch then
					if not thisWidget.arguments.NoMove then
						dragWindow = thisWidget
						isDragging = true
						local location: Vector3 = input.Position
						moveDeltaCursorPosition = Vector2.new(location.X, location.Y) - thisWidget.state.position.value
					end
				end
			end)

			local TitleButtonSize: number = Iris._config.TextSize + ((Iris._config.FramePadding.Y - 1) * 2)

			local CollapseButton: TextButton = Instance.new("TextButton")
			CollapseButton.Name = "CollapseButton"
			CollapseButton.AnchorPoint = Vector2.new(0, 0.5)
			CollapseButton.Size = UDim2.fromOffset(TitleButtonSize, TitleButtonSize)
			CollapseButton.Position = UDim2.new(0, Iris._config.FramePadding.X + 1, 0.5, 0)
			CollapseButton.AutomaticSize = Enum.AutomaticSize.None
			CollapseButton.BackgroundTransparency = 1
			CollapseButton.BorderSizePixel = 0
			CollapseButton.AutoButtonColor = false
			CollapseButton.Text = ""
			CollapseButton.ZIndex = thisWidget.ZIndex + 4

			widgets.UICorner(CollapseButton)

			CollapseButton.Parent = TitleBar

			CollapseButton.MouseButton1Click:Connect(function()
				thisWidget.state.isUncollapsed:set(not thisWidget.state.isUncollapsed.value)
			end)

			widgets.applyInteractionHighlights(CollapseButton, CollapseButton, {
				ButtonColor = Iris._config.ButtonColor,
				ButtonTransparency = 1,
				ButtonHoveredColor = Iris._config.ButtonHoveredColor,
				ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
				ButtonActiveColor = Iris._config.ButtonActiveColor,
				ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
			})

			local CollapseArrow: ImageLabel = Instance.new("ImageLabel")
			CollapseArrow.Name = "Arrow"
			CollapseArrow.AnchorPoint = Vector2.new(0.5, 0.5)
			CollapseArrow.Size = UDim2.fromOffset(math.floor(0.7 * TitleButtonSize), math.floor(0.7 * TitleButtonSize))
			CollapseArrow.Position = UDim2.fromScale(0.5, 0.5)
			CollapseArrow.BackgroundTransparency = 1
			CollapseArrow.BorderSizePixel = 0
			CollapseArrow.Image = widgets.ICONS.MULTIPLICATION_SIGN
			CollapseArrow.ImageColor3 = Iris._config.TextColor
			CollapseArrow.ImageTransparency = Iris._config.TextTransparency
			CollapseArrow.ZIndex = thisWidget.ZIndex + 5
			CollapseArrow.Parent = CollapseButton

			local CloseButton: TextButton = Instance.new("TextButton")
			CloseButton.Name = "CloseButton"
			CloseButton.AnchorPoint = Vector2.new(1, 0.5)
			CloseButton.Size = UDim2.fromOffset(TitleButtonSize, TitleButtonSize)
			CloseButton.Position = UDim2.new(1, -(Iris._config.FramePadding.X + 1), 0.5, 0)
			CloseButton.AutomaticSize = Enum.AutomaticSize.None
			CloseButton.BackgroundTransparency = 1
			CloseButton.BorderSizePixel = 0
			CloseButton.Text = ""

			CloseButton.ZIndex = thisWidget.ZIndex + 4
			CloseButton.AutoButtonColor = false

			widgets.UICorner(CloseButton)

			CloseButton.MouseButton1Click:Connect(function()
				thisWidget.state.isOpened:set(false)
			end)

			widgets.applyInteractionHighlights(CloseButton, CloseButton, {
				ButtonColor = Iris._config.ButtonColor,
				ButtonTransparency = 1,
				ButtonHoveredColor = Iris._config.ButtonHoveredColor,
				ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
				ButtonActiveColor = Iris._config.ButtonActiveColor,
				ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
			})

			CloseButton.Parent = TitleBar

			local CloseIcon: ImageLabel = Instance.new("ImageLabel")
			CloseIcon.Name = "Icon"
			CloseIcon.AnchorPoint = Vector2.new(0.5, 0.5)
			CloseIcon.Size = UDim2.fromOffset(math.floor(0.7 * TitleButtonSize), math.floor(0.7 * TitleButtonSize))
			CloseIcon.Position = UDim2.fromScale(0.5, 0.5)
			CloseIcon.BackgroundTransparency = 1
			CloseIcon.BorderSizePixel = 0
			CloseIcon.Image = widgets.ICONS.MULTIPLICATION_SIGN
			CloseIcon.ImageColor3 = Iris._config.TextColor
			CloseIcon.ImageTransparency = Iris._config.TextTransparency
			CloseIcon.ZIndex = thisWidget.ZIndex + 5
			CloseIcon.Parent = CloseButton

			-- allowing fractional titlebar title location dosent seem useful, as opposed to Enum.LeftRight.

			local titleAlign: number
			if Iris._config.WindowTitleAlign == Enum.LeftRight.Left then
				titleAlign = 0
			elseif Iris._config.WindowTitleAlign == Enum.LeftRight.Center then
				titleAlign = 0.5
			else
				titleAlign = 1
			end

			local Title: TextLabel = Instance.new("TextLabel")
			Title.Name = "Title"
			Title.AnchorPoint = Vector2.new(titleAlign, 0)
			Title.Position = UDim2.fromScale(titleAlign, 0)
			Title.AutomaticSize = Enum.AutomaticSize.XY
			Title.BorderSizePixel = 0
			Title.BackgroundTransparency = 1
			Title.ZIndex = thisWidget.ZIndex + 3

			widgets.applyTextStyle(Title)
			widgets.UIPadding(Title, Iris._config.FramePadding)

			Title.Parent = TitleBar

			local ResizeButtonSize: number = Iris._config.TextSize + Iris._config.FramePadding.X

			local ResizeGrip = Instance.new("TextButton")
			ResizeGrip.Name = "ResizeGrip"
			ResizeGrip.AnchorPoint = Vector2.new(1, 1)
			ResizeGrip.Size = UDim2.fromOffset(ResizeButtonSize, ResizeButtonSize)
			ResizeGrip.Position = UDim2.fromScale(1, 1)
			ResizeGrip.AutoButtonColor = false
			ResizeGrip.BorderSizePixel = 0
			ResizeGrip.BackgroundTransparency = 1
			ResizeGrip.Text = widgets.ICONS.BOTTOM_RIGHT_CORNER
			ResizeGrip.TextSize = ResizeButtonSize
			ResizeGrip.TextColor3 = Iris._config.ButtonColor
			ResizeGrip.TextTransparency = Iris._config.ButtonTransparency
			ResizeGrip.LineHeight = 1.10 -- fix mild rendering issue
			ResizeGrip.Selectable = false
			ResizeGrip.ZIndex = thisWidget.ZIndex + 3
			ResizeGrip.Parent = WindowButton

			widgets.applyTextInteractionHighlights(ResizeGrip, ResizeGrip, {
				ButtonColor = Iris._config.ButtonColor,
				ButtonTransparency = Iris._config.ButtonTransparency,
				ButtonHoveredColor = Iris._config.ButtonHoveredColor,
				ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
				ButtonActiveColor = Iris._config.ButtonActiveColor,
				ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
			})

			ResizeGrip.MouseButton1Down:Connect(function()
				if not anyFocusedWindow or not (focusedWindow == thisWidget) then
					Iris.SetFocusedWindow(thisWidget)
					-- mitigating wrong focus when clicking on buttons inside of a window without clicking the window itself
				end
				isResizing = true
				resizeFromTopBottom = Enum.TopBottom.Bottom
				resizeFromLeftRight = Enum.LeftRight.Right
				resizeWindow = thisWidget
			end)

			local ResizeBorder: TextButton = Instance.new("TextButton")
			ResizeBorder.Name = "ResizeBorder"
			ResizeBorder.Size = UDim2.new(1, Iris._config.WindowResizePadding.X * 2, 1, Iris._config.WindowResizePadding.Y * 2)
			ResizeBorder.Position = UDim2.fromOffset(-Iris._config.WindowResizePadding.X, -Iris._config.WindowResizePadding.Y)
			ResizeBorder.BackgroundTransparency = 1
			ResizeBorder.BorderSizePixel = 0
			ResizeBorder.Text = ""
			ResizeBorder.AutoButtonColor = false
			ResizeBorder.Active = true
			ResizeBorder.Selectable = false
			ResizeBorder.ZIndex = thisWidget.ZIndex
			ResizeBorder.LayoutOrder = thisWidget.ZIndex
			ResizeBorder.ClipsDescendants = false
			ResizeBorder.Parent = WindowButton

			ResizeBorder.MouseEnter:Connect(function()
				if focusedWindow == thisWidget then
					isInsideResize = true
				end
			end)
			ResizeBorder.MouseLeave:Connect(function()
				if focusedWindow == thisWidget then
					isInsideResize = false
				end
			end)

			WindowButton.MouseEnter:Connect(function()
				if focusedWindow == thisWidget then
					isInsideWindow = true
				end
			end)
			WindowButton.MouseLeave:Connect(function()
				if focusedWindow == thisWidget then
					isInsideWindow = false
				end
			end)

			return Window
		end,
		Update = function(thisWidget: Types.Widget)
			local WindowGui = thisWidget.Instance :: GuiObject
			local WindowButton = WindowGui.WindowButton :: TextButton
			local TitleBar = WindowButton.TitleBar :: Frame
			local Title: TextLabel = TitleBar.Title
			local MenuBar: Frame? = WindowButton:FindFirstChild("MenuBar")
			local ChildContainer: ScrollingFrame = WindowButton.ChildContainer
			local ResizeGrip: TextButton = WindowButton.ResizeGrip

			local containerHeight: number = 0
			local menuHeight: number = 0

			if thisWidget.arguments.NoResize ~= true then
				ResizeGrip.Visible = true
			else
				ResizeGrip.Visible = false
			end
			if thisWidget.arguments.NoScrollbar then
				ChildContainer.ScrollBarThickness = 0
			else
				ChildContainer.ScrollBarThickness = Iris._config.ScrollbarSize
			end
			if thisWidget.arguments.NoTitleBar then
				TitleBar.Visible = false
			else
				TitleBar.Visible = true
				--local titlebarSize: number = widgets.calculateTextSize(thisWidget.arguments.Title or "").Y + 2 * Iris._config.FramePadding.Y
				local titlebarSize: number = TitleBar.AbsoluteSize.Y
				containerHeight += titlebarSize
				menuHeight += titlebarSize
			end
			if MenuBar then
				if thisWidget.arguments.NoMenu then
					MenuBar.Visible = false
				else
					MenuBar.Visible = true
					containerHeight += MenuBar.AbsoluteSize.Y
				end
				-- we move the menu bar to the correct position.
				MenuBar.Position = UDim2.fromOffset(0, menuHeight)
			end
			if thisWidget.arguments.NoBackground then
				ChildContainer.BackgroundTransparency = 1
			else
				ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency
			end

			-- TitleBar buttons
			local TitleButtonPaddingSize = Iris._config.FramePadding.X + Iris._config.TextSize + Iris._config.FramePadding.X * 2
			if thisWidget.arguments.NoCollapse then
				TitleBar.CollapseButton.Visible = false
				TitleBar.Title.UIPadding.PaddingLeft = UDim.new(0, Iris._config.FramePadding.X)
			else
				TitleBar.CollapseButton.Visible = true
				TitleBar.Title.UIPadding.PaddingLeft = UDim.new(0, TitleButtonPaddingSize)
			end
			if thisWidget.arguments.NoClose then
				TitleBar.CloseButton.Visible = false
				TitleBar.Title.UIPadding.PaddingRight = UDim.new(0, Iris._config.FramePadding.X)
			else
				TitleBar.CloseButton.Visible = true
				TitleBar.Title.UIPadding.PaddingRight = UDim.new(0, TitleButtonPaddingSize)
			end

			ChildContainer.Size = UDim2.new(1, 0, 1, -containerHeight)
			ChildContainer.CanvasSize = UDim2.new(0, 0, 1, -containerHeight)
			ChildContainer.Position = UDim2.fromOffset(0, containerHeight)

			Title.Text = thisWidget.arguments.Title or ""
		end,
		Discard = function(thisWidget: Types.Widget)
			if focusedWindow == thisWidget then
				focusedWindow = nil
				anyFocusedWindow = false
			end
			if dragWindow == thisWidget then
				dragWindow = nil
				isDragging = false
			end
			if resizeWindow == thisWidget then
				resizeWindow = nil
				isResizing = false
			end
			windowWidgets[thisWidget.ID] = nil
			thisWidget.Instance:Destroy()
			widgets.discardState(thisWidget)
		end,
		ChildAdded = function(thisWidget: Types.Widget)
			local Window = thisWidget.Instance :: Frame
			local WindowButton = Window.WindowButton :: TextButton
			return WindowButton.ChildContainer
		end,
		UpdateState = function(thisWidget: Types.Widget)
			local stateSize: Vector2 = thisWidget.state.size.value
			local statePosition: Vector2 = thisWidget.state.position.value
			local stateIsUncollapsed: boolean = thisWidget.state.isUncollapsed.value
			local stateIsOpened: boolean = thisWidget.state.isOpened.value
			local stateScrollDistance: number = thisWidget.state.scrollDistance.value

			local Window = thisWidget.Instance :: Frame
			local WindowButton = Window.WindowButton :: TextButton
			local TitleBar = WindowButton.TitleBar :: Frame
			local ChildContainer: ScrollingFrame = WindowButton.ChildContainer
			local ResizeGrip: TextButton = WindowButton.ResizeGrip

			WindowButton.Size = UDim2.fromOffset(stateSize.X, stateSize.Y)
			WindowButton.Position = UDim2.fromOffset(statePosition.X, statePosition.Y)

			if stateIsOpened then
				if thisWidget.usesScreenGUI then
					Window.Enabled = true
					WindowButton.Visible = true
				else
					WindowButton.Visible = true
				end
				thisWidget.lastOpenedTick = Iris._cycleTick + 1
			else
				if thisWidget.usesScreenGUI then
					Window.Enabled = false
					WindowButton.Visible = false
				else
					WindowButton.Visible = false
				end
				thisWidget.lastClosedTick = Iris._cycleTick + 1
			end

			if stateIsUncollapsed then
				TitleBar.CollapseButton.Arrow.Image = widgets.ICONS.DOWN_POINTING_TRIANGLE
				ChildContainer.Visible = true
				if thisWidget.arguments.NoResize ~= true then
					ResizeGrip.Visible = true
				end
				WindowButton.AutomaticSize = Enum.AutomaticSize.None
				thisWidget.lastUncollapsedTick = Iris._cycleTick + 1
			else
				local collapsedHeight: number = TitleBar.AbsoluteSize.Y -- Iris._config.TextSize + Iris._config.FramePadding.Y * 2
				TitleBar.CollapseButton.Arrow.Image = widgets.ICONS.RIGHT_POINTING_TRIANGLE

				ChildContainer.Visible = false
				ResizeGrip.Visible = false
				WindowButton.Size = UDim2.fromOffset(stateSize.X, collapsedHeight)
				thisWidget.lastCollapsedTick = Iris._cycleTick + 1
			end

			if stateIsOpened and stateIsUncollapsed then
				Iris.SetFocusedWindow(thisWidget)
			else
				TitleBar.BackgroundColor3 = Iris._config.TitleBgCollapsedColor
				TitleBar.BackgroundTransparency = Iris._config.TitleBgCollapsedTransparency
				WindowButton.UIStroke.Color = Iris._config.BorderColor

				Iris.SetFocusedWindow(nil)
			end

			-- cant update canvasPosition in this cycle because scrollingframe isint ready to be changed
			if stateScrollDistance and stateScrollDistance ~= 0 then
				local callbackIndex: number = #Iris._postCycleCallbacks + 1
				local desiredCycleTick: number = Iris._cycleTick + 1
				Iris._postCycleCallbacks[callbackIndex] = function()
					if Iris._cycleTick == desiredCycleTick then
						ChildContainer.CanvasPosition = Vector2.new(0, stateScrollDistance)
						Iris._postCycleCallbacks[callbackIndex] = nil
					end
				end
			end
		end,
		GenerateState = function(thisWidget: Types.Widget)
			if thisWidget.state.size == nil then
				thisWidget.state.size = Iris._widgetState(thisWidget, "size", Vector2.new(400, 300))
			end
			if thisWidget.state.position == nil then
				thisWidget.state.position = Iris._widgetState(
					thisWidget,
					"position",
					if anyFocusedWindow and focusedWindow then focusedWindow.state.position.value + Vector2.new(15, 45) else Vector2.new(150, 250)
				)
			end
			thisWidget.state.position.value = fitPositionToWindowBounds(thisWidget, thisWidget.state.position.value)
			thisWidget.state.size.value = fitSizeToWindowBounds(thisWidget, thisWidget.state.size.value)

			if thisWidget.state.isUncollapsed == nil then
				thisWidget.state.isUncollapsed = Iris._widgetState(thisWidget, "isUncollapsed", true)
			end
			if thisWidget.state.isOpened == nil then
				thisWidget.state.isOpened = Iris._widgetState(thisWidget, "isOpened", true)
			end
			if thisWidget.state.scrollDistance == nil then
				thisWidget.state.scrollDistance = Iris._widgetState(thisWidget, "scrollDistance", 0)
			end
		end,
	} :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Window

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.API | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

return function(Iris: Types.Iris)
	-- basic wrapper for nearly every widget, saves space.
	local function wrapper(name: string): (arguments: Types.WidgetArguments?, states: Types.States?) -> Types.Widget
		return function(arguments: Types.WidgetArguments?, states: Types.States?): Types.Widget
			return Iris.Internal._Insert(name, arguments, states)
		end
	end

	--[[
        ----------------------------
            [SECTION] Window API
        ----------------------------
    ]]

	Iris.Window = wrapper("Window")

	Iris.SetFocusedWindow = Iris.Internal.SetFocusedWindow

	Iris.Tooltip = wrapper("Tooltip")

	Iris.MenuBar = wrapper("MenuBar")

	Iris.Menu = wrapper("Menu")

	Iris.MenuItem = wrapper("MenuItem")

	Iris.MenuToggle = wrapper("MenuToggle")

	Iris.Separator = wrapper("Separator")

	Iris.Indent = wrapper("Indent")

	Iris.SameLine = wrapper("SameLine")

	Iris.Group = wrapper("Group")

	Iris.Text = wrapper("Text")

	Iris.TextWrapped = function(arguments: Types.WidgetArguments): Types.Widget
		arguments[2] = true
		return Iris.Internal._Insert("Text", arguments)
	end

	Iris.TextColored = function(arguments: Types.WidgetArguments): Types.Widget
		arguments[3] = arguments[2]
		arguments[2] = nil
		return Iris.Internal._Insert("Text", arguments)
	end

	Iris.SeparatorText = wrapper("SeparatorText")

	Iris.InputText = wrapper("InputText")

	Iris.Button = wrapper("Button")

	Iris.SmallButton = wrapper("SmallButton")

	Iris.Checkbox = wrapper("Checkbox")

	Iris.RadioButton = wrapper("RadioButton")

	Iris.Tree = wrapper("Tree")

	Iris.CollapsingHeader = wrapper("CollapsingHeader")

	Iris.InputNum = wrapper("InputNum")

	Iris.InputVector2 = wrapper("InputVector2")

	Iris.InputVector3 = wrapper("InputVector3")

	Iris.InputUDim = wrapper("InputUDim")

	Iris.InputUDim2 = wrapper("InputUDim2")

	Iris.InputRect = wrapper("InputRect")

	Iris.DragNum = wrapper("DragNum")

	Iris.DragVector2 = wrapper("DragVector2")

	Iris.DragVector3 = wrapper("DragVector3")

	Iris.DragUDim = wrapper("DragUDim")

	Iris.DragUDim2 = wrapper("DragUDim2")

	Iris.DragRect = wrapper("DragRect")

	Iris.InputColor3 = wrapper("InputColor3")

	Iris.InputColor4 = wrapper("InputColor4")

	Iris.SliderNum = wrapper("SliderNum")

	Iris.SliderVector2 = wrapper("SliderVector2")

	Iris.SliderVector3 = wrapper("SliderVector3")

	Iris.SliderUDim = wrapper("SliderUDim")

	Iris.SliderUDim2 = wrapper("SliderUDim2")

	Iris.SliderRect = wrapper("SliderRect")

	Iris.Selectable = wrapper("Selectable")

	Iris.Combo = wrapper("Combo")

	Iris.ComboArray = function(arguments: Types.WidgetArguments, states: Types.WidgetStates?, selectionArray: { any })
		local defaultState
		if states == nil then
			defaultState = Iris.State(selectionArray[1])
		else
			defaultState = states
		end
		local thisWidget = Iris.Internal._Insert("Combo", arguments, defaultState)
		local sharedIndex: Types.State = thisWidget.state.index
		for _, Selection in selectionArray do
			Iris.Internal._Insert("Selectable", { Selection, Selection }, { index = sharedIndex } :: Types.States)
		end
		Iris.End()

		return thisWidget
	end

	Iris.ComboEnum = function(arguments: Types.WidgetArguments, states: Types.WidgetStates?, enumType: Enum)
		local defaultState
		if states == nil then
			defaultState = Iris.State(enumType[1])
		else
			defaultState = states
		end
		local thisWidget = Iris.Internal._Insert("Combo", arguments, defaultState)
		local sharedIndex = thisWidget.state.index
		for _, Selection in enumType:GetEnumItems() do
			Iris.Internal._Insert("Selectable", { Selection.Name, Selection }, { index = sharedIndex } :: Types.States)
		end
		Iris.End()

		return thisWidget
	end
	Iris.InputEnum = Iris.ComboEnum

	Iris.Table = wrapper("Table")

	Iris.NextColumn = function()
		Iris.Internal._GetParentWidget().RowColumnIndex += 1
	end

	Iris.SetColumnIndex = function(columnIndex: number)
		local ParentWidget: Types.Widget = Iris.Internal._GetParentWidget()
		assert(columnIndex >= ParentWidget.InitialNumColumns, "Iris.SetColumnIndex Argument must be in column range")
		ParentWidget.RowColumnIndex = math.floor(ParentWidget.RowColumnIndex / ParentWidget.InitialNumColumns) + (columnIndex - 1)
	end

	Iris.NextRow = function()
		-- sets column Index back to 0, increments Row
		local ParentWidget: Types.Widget = Iris.Internal._GetParentWidget()
		local InitialNumColumns: number = ParentWidget.InitialNumColumns
		local nextRow: number = math.floor((ParentWidget.RowColumnIndex + 1) / InitialNumColumns) * InitialNumColumns
		ParentWidget.RowColumnIndex = nextRow
	end
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.API

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.config | Enabled: N/A
--------------------------------------------------------------------
local TemplateConfig = {
	colorDark = { -- Dear, ImGui default dark
		TextColor = Color3.fromRGB(255, 255, 255),
		TextTransparency = 0,
		TextDisabledColor = Color3.fromRGB(166, 166, 166),
		TextDisabledTransparency = 0,

		BorderColor = Color3.fromRGB(125, 125, 125),
		-- Dear ImGui uses 110, 110, 125
		-- The Roblox window selection highlight is 67, 191, 254
		BorderActiveColor = Color3.fromRGB(125, 125, 125), -- does not exist in Dear ImGui

		BorderTransparency = 0,
		BorderActiveTransparency = 0,
		-- BorderTransparency will be problematic for non UIStroke border implimentations
		-- is not implimented because of this

		WindowBgColor = Color3.fromRGB(65, 65, 65),
		WindowBgTransparency = 0.047,

		ScrollbarGrabColor = Color3.fromRGB(120, 120, 120),
		ScrollbarGrabTransparency = 0.098,

		TitleBgColor = Color3.fromRGB(89, 89, 89),
		TitleBgTransparency = 0,
		TitleBgActiveColor = Color3.fromRGB(199, 107, 51),
		TitleBgActiveTransparency = 0,
		TitleBgCollapsedColor = Color3.fromRGB(0, 0, 0),
		TitleBgCollapsedTransparency = 0.588,

		MenubarBgColor = Color3.fromRGB(36, 36, 36),
		MenubarBgTransparency = 0,

		FrameBgColor = Color3.fromRGB(46, 46, 46),
		FrameBgTransparency = 0,
		FrameBgHoveredColor = Color3.fromRGB(79, 79, 79),
		FrameBgHoveredTransparency = 0,
		FrameBgActiveColor = Color3.fromRGB(89, 89, 89),
		FrameBgActiveTransparency = 0,

		ButtonColor = Color3.fromRGB(46, 46, 46),
		ButtonTransparency = 0.098,
		ButtonHoveredColor = Color3.fromRGB(109, 109, 109),
		ButtonHoveredTransparency = 0.098,
		ButtonActiveColor = Color3.fromRGB(181, 107, 61),
		ButtonActiveTransparency = 0.098,

		SliderGrabColor = Color3.fromRGB(109, 109, 109),
		SliderGrabTransparency = 0.098,
		SliderGrabActiveColor = Color3.fromRGB(181, 107, 61),
		SliderGrabActiveTransparency = 0.098,

		HeaderColor = Color3.fromRGB(46, 46, 46),
		HeaderTransparency = 0.098,
		HeaderHoveredColor = Color3.fromRGB(109, 109, 109),
		HeaderHoveredTransparency = 0.098,
		HeaderActiveColor = Color3.fromRGB(143, 143, 143),
		HeaderActiveTransparency = 0.098,

		SelectionImageObjectColor = Color3.fromRGB(255, 255, 255),
		SelectionImageObjectTransparency = 0.8,
		SelectionImageObjectBorderColor = Color3.fromRGB(255, 255, 255),
		SelectionImageObjectBorderTransparency = 0,

		TableBorderStrongColor = Color3.fromRGB(53, 53, 53),
		TableBorderStrongTransparency = 0,
		TableBorderLightColor = Color3.fromRGB(169, 169, 169),
		TableBorderLightTransparency = 0,
		TableRowBgColor = Color3.fromRGB(0, 0, 0),
		TableRowBgTransparency = 0.94,
		TableRowBgAltColor = Color3.fromRGB(255, 255, 255),
		TableRowBgAltTransparency = 0.94,

		NavWindowingHighlightColor = Color3.fromRGB(255, 255, 255),
		NavWindowingHighlightTransparency = 0.3,
		NavWindowingDimBgColor = Color3.fromRGB(204, 204, 204),
		NavWindowingDimBgTransparency = 0.65,

		SeparatorColor = Color3.fromRGB(110, 110, 110),
		SeparatorTransparency = 0.196,

		CheckMarkColor = Color3.fromRGB(227, 152, 0),
		CheckMarkTransparency = 0,
	},
	colorLight = { -- Dear, ImGui default light
		TextColor = Color3.fromRGB(0, 0, 0),
		TextTransparency = 0,
		TextDisabledColor = Color3.fromRGB(153, 153, 153),
		TextDisabledTransparency = 0,

		BorderColor = Color3.fromRGB(64, 64, 64),
		-- Dear ImGui uses 0, 0, 0, 77
		-- The Roblox window selection highlight is 67, 191, 254
		BorderActiveColor = Color3.fromRGB(64, 64, 64), -- does not exist in Dear ImGui

		-- BorderTransparency = 0.5,
		-- BorderTransparency will be problematic for non UIStroke border implimentations
		-- will not be implimented because of this

		WindowBgColor = Color3.fromRGB(240, 240, 240),
		WindowBgTransparency = 0,

		TitleBgColor = Color3.fromRGB(245, 245, 245),
		TitleBgTransparency = 0,
		TitleBgActiveColor = Color3.fromRGB(209, 209, 209),
		TitleBgActiveTransparency = 0,
		TitleBgCollapsedColor = Color3.fromRGB(255, 255, 255),
		TitleBgCollapsedTransparency = 0.5,

		MenubarBgColor = Color3.fromRGB(219, 219, 219),
		MenubarBgTransparency = 0,

		ScrollbarGrabColor = Color3.fromRGB(96, 96, 96),
		ScrollbarGrabTransparency = 0,

		FrameBgColor = Color3.fromRGB(255, 255, 255),
		FrameBgTransparency = 0.6,
		FrameBgHoveredColor = Color3.fromRGB(66, 150, 250),
		FrameBgHoveredTransparency = 0.6,
		FrameBgActiveColor = Color3.fromRGB(66, 150, 250),
		FrameBgActiveTransparency = 0.33,

		ButtonColor = Color3.fromRGB(66, 150, 250),
		ButtonTransparency = 0.6,
		ButtonHoveredColor = Color3.fromRGB(66, 150, 250),
		ButtonHoveredTransparency = 0,
		ButtonActiveColor = Color3.fromRGB(15, 135, 250),
		ButtonActiveTransparency = 0,

		HeaderColor = Color3.fromRGB(66, 150, 250),
		HeaderTransparency = 0.31,
		HeaderHoveredColor = Color3.fromRGB(66, 150, 250),
		HeaderHoveredTransparency = 0.2,
		HeaderActiveColor = Color3.fromRGB(66, 150, 250),
		HeaderActiveTransparency = 0,

		SliderGrabColor = Color3.fromRGB(61, 133, 224),
		SliderGrabTransparency = 0,
		SliderGrabActiveColor = Color3.fromRGB(66, 150, 250),
		SliderGrabActiveTransparency = 0,

		SelectionImageObjectColor = Color3.fromRGB(0, 0, 0),
		SelectionImageObjectTransparency = 0.8,
		SelectionImageObjectBorderColor = Color3.fromRGB(0, 0, 0),
		SelectionImageObjectBorderTransparency = 0,

		TableBorderStrongColor = Color3.fromRGB(145, 145, 163),
		TableBorderStrongTransparency = 0,
		TableBorderLightColor = Color3.fromRGB(173, 173, 189),
		TableBorderLightTransparency = 0,
		TableRowBgColor = Color3.fromRGB(0, 0, 0),
		TableRowBgTransparency = 1,
		TableRowBgAltColor = Color3.fromRGB(77, 77, 77),
		TableRowBgAltTransparency = 0.91,

		NavWindowingHighlightColor = Color3.fromRGB(179, 179, 179),
		NavWindowingHighlightTransparency = 0.3,
		NavWindowingDimBgColor = Color3.fromRGB(51, 51, 51),
		NavWindowingDimBgTransparency = 0.8,

		SeparatorColor = Color3.fromRGB(99, 99, 99),
		SeparatorTransparency = 0.38,

		CheckMarkColor = Color3.fromRGB(66, 150, 250),
		CheckMarkTransparency = 0,
	},

	sizeDefault = { -- Dear, ImGui default
		ItemWidth = UDim.new(1, 0),
		ContentWidth = UDim.new(0.65, 0),

		WindowPadding = Vector2.new(8, 8),
		WindowResizePadding = Vector2.new(6, 6),
		FramePadding = Vector2.new(4, 3),
		ItemSpacing = Vector2.new(8, 4),
		ItemInnerSpacing = Vector2.new(4, 4),
		CellPadding = Vector2.new(4, 2),
		DisplaySafeAreaPadding = Vector2.new(0, 0),
		SeparatorTextPadding = Vector2.new(20, 3),
		IndentSpacing = 21,

		TextFont = Font.fromEnum(Enum.Font.RobotoMono),
		TextSize = 13,
		FrameBorderSize = 0,
		FrameRounding = 2,
		GrabRounding = 2,
		WindowRounding = 0, -- these don't actually work but it's nice to have them.
		WindowBorderSize = 1,
		WindowTitleAlign = Enum.LeftRight.Left,
		PopupBorderSize = 1,
		PopupRounding = 0,
		ScrollbarSize = 7,
		GrabMinSize = 10,
		SeparatorTextBorderSize = 3,
	},
	sizeClear = { -- easier to read and manuveure
		ItemWidth = UDim.new(1, 0),
		ContentWidth = UDim.new(0.65, 0),

		WindowPadding = Vector2.new(12, 8),
		WindowResizePadding = Vector2.new(8, 8),
		FramePadding = Vector2.new(6, 4),
		ItemSpacing = Vector2.new(8, 8),
		ItemInnerSpacing = Vector2.new(8, 8),
		CellPadding = Vector2.new(4, 4),
		DisplaySafeAreaPadding = Vector2.new(8, 8),
		SeparatorTextPadding = Vector2.new(24, 6),
		IndentSpacing = 25,

		TextFont = Font.fromEnum(Enum.Font.Ubuntu),
		TextSize = 15,
		FrameBorderSize = 1,
		FrameRounding = 4,
		GrabRounding = 4,
		WindowRounding = 4,
		WindowBorderSize = 1,
		WindowTitleAlign = Enum.LeftRight.Center,
		PopupBorderSize = 1,
		PopupRounding = 4,
		ScrollbarSize = 9,
		GrabMinSize = 14,
		SeparatorTextBorderSize = 4,
	},

	utilityDefault = {
		UseScreenGUIs = true,
		IgnoreGuiInset = true,
		Parent = nil,
		DisplayOrderOffset = 127,
		ZIndexOffset = 0,

		MouseDoubleClickTime = 0.30, -- Time for a double-click, in seconds.
		MouseDoubleClickMaxDist = 6.0, -- Distance threshold to stay in to validate a double-click, in pixels.

		HoverColor = Color3.fromRGB(255, 255, 0),
		HoverTransparency = 0.1,
	},
}

return TemplateConfig

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.config

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.demoWindow | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

return function(Iris: Types.Iris)
	local showMainWindow = Iris.State(true)
	local showRecursiveWindow = Iris.State(false)
	local showRuntimeInfo = Iris.State(false)
	local showStyleEditor = Iris.State(false)
	local showWindowlessDemo = Iris.State(false)
	local showMainMenuBarWindow = Iris.State(false)

    -- stylua: ignore start
    local function helpMarker(helpText)
        Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
        local text = Iris.Text({ "(?)" })
        Iris.PopConfig()

        Iris.PushConfig({ ContentWidth = UDim.new(0, 350) })
        if text.hovered() then
            Iris.Tooltip({ helpText })
        end
        Iris.PopConfig()
    end

    -- shows each widgets functionality
    local widgetDemos = {
        Basic = function()
            Iris.Tree({ "Basic" })
                Iris.SeparatorText({ "Basic" })

                local radioButtonState = Iris.State(1)
                Iris.Button({ "Button" })
                Iris.SmallButton({ "SmallButton" })
                Iris.Text({ "Text" })
                Iris.TextWrapped({ string.rep("Text Wrapped ", 5) })
                Iris.TextColored({ "Colored Text", Color3.fromRGB(255, 128, 0) })
                Iris.Text({ `Rich Text: <b>bold text</b> <i>italic text</i> <u>underline text</u> <s>strikethrough text</s> <font color= "rgb(240, 40, 10)">red text</font> <font size="32">bigger text</font>`, true, nil, true })
                Iris.SameLine()
                    Iris.RadioButton({ "Index '1'", 1 }, { index = radioButtonState })
                    Iris.RadioButton({ "Index 'two'", "two" }, { index = radioButtonState })
                    if Iris.RadioButton({ "Index 'false'", false }, { index = radioButtonState }).active() == false then
                        if Iris.SmallButton({ "Select last" }).clicked() then
                            radioButtonState:set(false)
                        end
                    end
                Iris.End()
                Iris.Text({ "The Index is: " .. tostring(radioButtonState.value) })

                Iris.SeparatorText({ "Inputs" })

                Iris.InputNum({})
                Iris.DragNum({})
                Iris.SliderNum({})

            Iris.End()
        end,

        Tree = function()
            Iris.Tree({ "Trees" })
                Iris.Tree({ "Tree using SpanAvailWidth", [Iris.Args.Tree.SpanAvailWidth] = true })
                    helpMarker("SpanAvailWidth determines if the Tree is selectable from its entire with, or only the text area")
                Iris.End()

                local tree1 = Iris.Tree({ "Tree with Children" })
                    Iris.Text({ "Im inside the first tree!" })
                    Iris.Button({ "Im a button inside the first tree!" })
                    Iris.Tree({ "Im a tree inside the first tree!" })
                        Iris.Text({ "I am the innermost text!" })
                    Iris.End()
                Iris.End()

                Iris.Checkbox({ "Toggle above tree" }, { isChecked = tree1.state.isUncollapsed })

            Iris.End()
        end,

        CollapsingHeader = function()
            Iris.Tree({ "Collapsing Headers" })
                Iris.CollapsingHeader({ "A header" })
                    Iris.Text({ "This is under the first header!" })
                Iris.End()

                local secondHeader = Iris.State(true)
                Iris.CollapsingHeader({ "Another header" }, { isUncollapsed = secondHeader })
                    if Iris.Button({ "Shhh... secret button!" }).clicked() then
                        secondHeader:set(true)
                    end
                Iris.End()
            Iris.End()
        end,

        Group = function()
            Iris.Tree({ "Groups" })
                Iris.SameLine()
                    Iris.Group()
                        Iris.Text({ "I am in group A" })
                        Iris.Button({ "Im also in A" })
                    Iris.End()
                    
                    Iris.Separator()
                    
                    Iris.Group()
                        Iris.Text({ "I am in group B" })
                        Iris.Button({ "Im also in B" })
                        Iris.Button({ "Also group B" })
                    Iris.End()
                Iris.End()
            Iris.End()
        end,

        Indent = function()
            Iris.Tree({ "Indents" })
                Iris.Text({ "Not Indented" })
                Iris.Indent()
                    Iris.Text({ "Indented" })
                    Iris.Indent({ 7 })
                        Iris.Text({ "Indented by 7 more pixels" })
                    Iris.End()

                    Iris.Indent({ -7})
                        Iris.Text({ "Indented by 7 less pixels" })
                    Iris.End()
                Iris.End()
            Iris.End()
        end,

        Input = function()
            Iris.Tree({ "Input" })
                local NoField, NoButtons, Min, Max, Increment, Format = Iris.State(false), Iris.State(false), Iris.State(0), Iris.State(100), Iris.State(1), Iris.State("%d")

                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                local InputNum = Iris.InputNum({
                    "Input Number",
                    -- [Iris.Args.InputNum.NoField] = NoField.value,
                    [Iris.Args.InputNum.NoButtons] = NoButtons.value,
                    [Iris.Args.InputNum.Min] = Min.value,
                    [Iris.Args.InputNum.Max] = Max.value,
                    [Iris.Args.InputNum.Increment] = Increment.value,
                    [Iris.Args.InputNum.Format] = { Format.value },
                })
                Iris.PopConfig()
                Iris.Text({ "The Value is: " .. InputNum.number.value })
                if Iris.Button({ "Randomize Number" }).clicked() then
                    InputNum.number:set(math.random(1, 99))
                end
                local NoFieldCheckbox = Iris.Checkbox({ "NoField" }, { isChecked = NoField })
                local NoButtonsCheckbox = Iris.Checkbox({ "NoButtons" }, { isChecked = NoButtons })
                if NoFieldCheckbox.checked() and NoButtonsCheckbox.isChecked.value == true then
                    NoButtonsCheckbox.isChecked:set(false)
                end
                if NoButtonsCheckbox.checked() and NoFieldCheckbox.isChecked.value == true then
                    NoFieldCheckbox.isChecked:set(false)
                end

                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                Iris.InputVector2({ "InputVector2" })
                Iris.InputVector3({ "InputVector3" })
                Iris.InputUDim({ "InputUDim" })
                Iris.InputUDim2({ "InputUDim2" })
                local UseFloats = Iris.State(false)
                local UseHSV = Iris.State(false)
                local sharedColor = Iris.State(Color3.new())
                local transparency = Iris.State(0)
                Iris.SliderNum({ "Transparency", 0.01, 0, 1 }, { number = transparency })
                Iris.InputColor3({ "InputColor3", UseFloats:get(), UseHSV:get() }, { color = sharedColor })
                Iris.InputColor4({ "InputColor4", UseFloats:get(), UseHSV:get() }, { color = sharedColor, transparency = transparency })
                Iris.SameLine()
                    Iris.Text({ sharedColor:get():ToHex() })
                    Iris.Checkbox({ "Use Floats" }, { isChecked = UseFloats })
                    Iris.Checkbox({ "Use HSV" }, { isChecked = UseHSV })
                Iris.End()

                Iris.PopConfig()

                Iris.Separator()

                Iris.SameLine()
                    Iris.Text({ "Slider Numbers" })
                    helpMarker("ctrl + click slider number widgets to input a number")
                Iris.End()
                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                Iris.SliderNum({ "Slide Int", 1, 1, 8 })
                Iris.SliderNum({ "Slide Float", 0.01, 0, 100 })
                Iris.SliderNum({ "Small Numbers", 0.001, -2, 1, "%f radians" })
                Iris.SliderNum({ "Odd Ranges", 0.001, -math.pi, math.pi, "%f radians" })
                Iris.SliderNum({ "Big Numbers", 1e4, 1e5, 1e7 })
                Iris.SliderNum({ "Few Numbers", 1, 0, 3 })
                Iris.PopConfig()

                Iris.Separator()

                Iris.SameLine()
                    Iris.Text({ "Drag Numbers" })
                    helpMarker("ctrl + click or double click drag number widgets to input a number, hold shift/alt while dragging to increase/decrease speed")
                Iris.End()
                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                Iris.DragNum({ "Drag Int" })
                Iris.DragNum({ "Slide Float", 0.001, -10, 10 })
                Iris.DragNum({ "Percentage", 1, 0, 100, "%d %%" })
                Iris.PopConfig()
            Iris.End()
        end,

        InputText = function()
            Iris.Tree({ "Input Text" })
                Iris.PushConfig({ ContentWidth = UDim.new(0, 250) })
                local InputText = Iris.InputText({ "Input Text Test", [Iris.Args.InputText.TextHint] = "Input Text here" })
                Iris.PopConfig()
                Iris.Text({ "The text is: " .. InputText.text.value })
            Iris.End()
        end,

        MultiInput = function()
            Iris.Tree({"Multi-Component Input"})

                local sharedVector2 = Iris.State(Vector2.new())
                local sharedVector3 = Iris.State(Vector3.new())
                local sharedUDim = Iris.State(UDim.new())
                local sharedUDim2 = Iris.State(UDim2.new())
                local sharedColor3 = Iris.State(Color3.new())
                local SharedRect = Iris.State(Rect.new(0, 0))

                Iris.SeparatorText({"Input"})

                Iris.InputVector2({}, {number = sharedVector2})
                Iris.InputVector3({}, {number = sharedVector3})
                Iris.InputUDim({}, {number = sharedUDim})
                Iris.InputUDim2({}, {number = sharedUDim2})
                Iris.InputRect({}, {number = SharedRect})

                Iris.SeparatorText({"Drag"})

                Iris.DragVector2({}, {number = sharedVector2})
                Iris.DragVector3({}, {number = sharedVector3})
                Iris.DragUDim({}, {number = sharedUDim})
                Iris.DragUDim2({}, {number = sharedUDim2})
                Iris.DragRect({}, {number = SharedRect})

                Iris.SeparatorText({"Slider"})

                Iris.SliderVector2({}, {number = sharedVector2})
                Iris.SliderVector3({}, {number = sharedVector3})
                Iris.SliderUDim({}, {number = sharedUDim})
                Iris.SliderUDim2({}, {number = sharedUDim2})
                Iris.SliderRect({}, {number = SharedRect})

                Iris.SeparatorText({"Color"})

                Iris.InputColor3({}, {color = sharedColor3})
                Iris.InputColor4({}, {color = sharedColor3})

            Iris.End()
        end,

        Tooltip = function()
            Iris.PushConfig({ ContentWidth = UDim.new(0, 250) })
            Iris.Tree({ "Tooltip" })
                if Iris.Text({ "Hover over me to reveal a tooltip" }).hovered() then
                    Iris.Tooltip({ "I am some helpful tooltip text" })
                end
                local dynamicText = Iris.State("Hello ")
                local numRepeat = Iris.State(1)
                if Iris.InputNum({ "# of repeat", 1, 1, 50 }, { number = numRepeat }).numberChanged() then
                    dynamicText:set(string.rep("Hello ", numRepeat:get()))
                end
                if Iris.Checkbox({ "Show dynamic text tooltip" }).isChecked.value then
                    Iris.Tooltip({ dynamicText:get() })
                end
            Iris.End()
            Iris.PopConfig()
        end,

        Selectable = function()
            Iris.Tree({ "Selectable" })
                local sharedIndex = Iris.State(2)
                Iris.Selectable({ "Selectable #1", 1 }, { index = sharedIndex })
                Iris.Selectable({ "Selectable #2", 2 }, { index = sharedIndex })
                if Iris.Selectable({ "Double click Selectable", 3, true }, { index = sharedIndex }).doubleClicked() then
                    sharedIndex:set(3)
                end
                Iris.Selectable({ "Impossible to select", 4, true }, { index = sharedIndex })
                if Iris.Button({ "Select last" }).clicked() then
                    sharedIndex:set(4)
                end
                Iris.Selectable({ "Independent Selectable" })
            Iris.End()
        end,

        Combo = function()
            Iris.Tree({ "Combo" })
                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                local sharedComboIndex = Iris.State("No Selection")
                Iris.SameLine()
                    local NoPreview = Iris.Checkbox({ "No Preview" })
                    local NoButton = Iris.Checkbox({ "No Button" })
                    if NoPreview.checked() and NoButton.isChecked.value == true then
                        NoButton.isChecked:set(false)
                    end
                    if NoButton.checked() and NoPreview.isChecked.value == true then
                        NoPreview.isChecked:set(false)
                    end
                Iris.End()
                Iris.Combo({ "Basic Usage", NoButton.isChecked:get(), NoPreview.isChecked:get() }, { index = sharedComboIndex })
                    Iris.Selectable({ "Select 1", "One" }, { index = sharedComboIndex })
                    Iris.Selectable({ "Select 2", "Two" }, { index = sharedComboIndex })
                    Iris.Selectable({ "Select 3", "Three" }, { index = sharedComboIndex })
                Iris.End()

                Iris.ComboArray({ "Using ComboArray" }, { index = "No Selection" }, { "Red", "Green", "Blue" })

                local sharedComboIndex2 = Iris.State("7 AM")
                Iris.Combo({ "Combo with Inner widgets" }, { index = sharedComboIndex2 })
                    Iris.Tree({ "Morning Shifts" })
                        Iris.Selectable({ "Shift at 7 AM", "7 AM" }, { index = sharedComboIndex2 })
                        Iris.Selectable({ "Shift at 11 AM", "11 AM" }, { index = sharedComboIndex2 })
                        Iris.Selectable({ "Shist at 3 PM", "3 PM" }, { index = sharedComboIndex2 })
                    Iris.End()
                    Iris.Tree({ "Night Shifts" })
                        Iris.Selectable({ "Shift at 6 PM", "6 PM" }, { index = sharedComboIndex2 })
                        Iris.Selectable({ "Shift at 9 PM", "9 PM" }, { index = sharedComboIndex2 })
                    Iris.End()
                Iris.End()

                local ComboEnum = Iris.ComboEnum({ "Using ComboEnum" }, { index = Enum.UserInputState.Begin }, Enum.UserInputState)
                Iris.Text({ "Selected: " .. ComboEnum.index:get().Name })
                Iris.PopConfig()
            Iris.End()
        end,
    }
    local widgetDemosOrder = { "Basic", "Tree", "CollapsingHeader", "Group", "Indent", "Input", "MultiInput", "InputText", "Tooltip", "Selectable", "Combo" }

    local function recursiveTree()
        local theTree = Iris.Tree({ "Recursive Tree" })
        if theTree.state.isUncollapsed.value then
            recursiveTree()
        end
        Iris.End()
    end

    local function recursiveWindow(parentCheckboxState)
        Iris.Window({ "Recursive Window" }, { size = Iris.State(Vector2.new(175, 100)), isOpened = parentCheckboxState })
            local theCheckbox = Iris.Checkbox({ "Recurse Again" })
        Iris.End()
        if theCheckbox.isChecked.value then
            recursiveWindow(theCheckbox.isChecked)
        end
    end

    -- shows list of runtime widgets and states, including IDs. shows other info about runtime and can show widgets/state info in depth.
    local function runtimeInfo()
        local runtimeInfoWindow = Iris.Window({ "Runtime Info" }, { isOpened = showRuntimeInfo })
            local lastVDOM = Iris.Internal._lastVDOM
            local states = Iris.Internal._states

            local numSecondsDisabled = Iris.State(3)
            local rollingDT = Iris.State(0)
            local lastT = Iris.State(os.clock())

            Iris.SameLine()
                Iris.InputNum({ "", [Iris.Args.InputNum.Format] = "%d Seconds", [Iris.Args.InputNum.Max] = 10 }, { number = numSecondsDisabled })
                if Iris.Button({ "Disable" }).clicked() then
                    Iris.Disabled = true
                    task.delay(numSecondsDisabled:get(), function()
                        Iris.Disabled = false
                    end)
                end
            Iris.End()

            local t = os.clock()
            local dt = t - lastT.value
            rollingDT.value += (dt - rollingDT.value) * 0.2
            lastT.value = t
            Iris.Text({ string.format("Average %.3f ms/frame (%.1f FPS)", rollingDT.value * 1000, 1 / rollingDT.value) })

            Iris.Text({
                string.format("Window Position: (%d, %d), Window Size: (%d, %d)", runtimeInfoWindow.position.value.X, runtimeInfoWindow.position.value.Y, runtimeInfoWindow.size.value.X, runtimeInfoWindow.size.value.Y),
            })

            Iris.SameLine()
                Iris.Text({ "Enter an ID to learn more about it." })
                helpMarker("every widget and state has an ID which Iris tracks to remember which widget is which. below lists all widgets and states, with their respective IDs")
            Iris.End()

            Iris.PushConfig({ ItemWidth = UDim.new(1, -150) })
            local enteredText = Iris.InputText({ "ID field" }, { text = Iris.State(runtimeInfoWindow.ID) }).text.value
            Iris.PopConfig()

            Iris.Indent()
                local enteredWidget = lastVDOM[enteredText]
                local enteredState = states[enteredText]
                if enteredWidget then
                    Iris.Table({ 1, [Iris.Args.Table.RowBg] = false })
                        Iris.Text({ string.format('The ID, "%s", is a widget', enteredText) })
                        Iris.NextRow()

                        Iris.Text({ string.format("Widget is type: %s", enteredWidget.type) })
                        Iris.NextRow()

                        Iris.Tree({ "Widget has Args:" }, { isUncollapsed = Iris.State(true) })
                            for i, v in enteredWidget.arguments do
                                Iris.Text({ i .. " - " .. tostring(v) })
                            end
                        Iris.End()
                        Iris.NextRow()

                        if enteredWidget.state then
                            Iris.Tree({ "Widget has State:" }, { isUncollapsed = Iris.State(true) })
                                for i, v in enteredWidget.state do
                                    Iris.Text({ i .. " - " .. tostring(v.value) })
                                end
                            Iris.End()
                        end
                    Iris.End()
                elseif enteredState then
                    Iris.Table({ 1, [Iris.Args.Table.RowBg] = false })
                        Iris.Text({ string.format('The ID, "%s", is a state', enteredText) })
                        Iris.NextRow()

                        Iris.Text({ string.format("Value is type: %s, Value = %s", typeof(enteredState.value), tostring(enteredState.value)) })
                        Iris.NextRow()

                        Iris.Tree({ "state has connected widgets:" }, { isUncollapsed = Iris.State(true) })
                            for i, v in enteredState.ConnectedWidgets do
                                Iris.Text({ i .. " - " .. v.type })
                            end
                        Iris.End()
                        Iris.NextRow()

                        Iris.Text({ string.format("state has: %d connected functions", #enteredState.ConnectedFunctions) })
                    Iris.End()
                else
                    Iris.Text({ string.format('The ID, "%s", is not a state or widget', enteredText) })
                end
            Iris.End()

            if Iris.Tree({ "Widgets" }).isUncollapsed.value then
                local widgetCount = 0
                local widgetStr = ""
                for _, v in lastVDOM do
                    widgetCount += 1
                    widgetStr ..= "\n" .. v.ID .. " - " .. v.type
                end

                Iris.Text({ "Number of Widgets: " .. widgetCount })

                Iris.Text({ widgetStr })
            end
            Iris.End()
            if Iris.Tree({ "States" }).isUncollapsed.value then
                local stateCount = 0
                local stateStr = ""
                for i, v in states do
                    stateCount += 1
                    stateStr ..= "\n" .. i .. " - " .. tostring(v.value)
                end

                Iris.Text({ "Number of States: " .. stateCount })

                Iris.Text({ stateStr })
            end
            Iris.End()
        Iris.End()
    end

    local function recursiveMenu()
        -- stylua: ignore start
        if Iris.Menu({ "Recursive" }).state.isOpened.value then
            Iris.MenuItem({ "New", Enum.KeyCode.N, Enum.ModifierKey.Ctrl })
            Iris.MenuItem({ "Open", Enum.KeyCode.O, Enum.ModifierKey.Ctrl })
            Iris.MenuItem({ "Save", Enum.KeyCode.S, Enum.ModifierKey.Ctrl })
            Iris.Separator()
            Iris.MenuToggle({ "Autosave" })
            Iris.MenuToggle({ "Checked" })
            Iris.Separator()
            Iris.Menu({ "Options" })
                Iris.MenuItem({ "Red" })
                Iris.MenuItem({ "Yellow" })
                Iris.MenuItem({ "Green" })
                Iris.MenuItem({ "Blue" })
                Iris.Separator()
                recursiveMenu()
            Iris.End()
        end
        Iris.End()
        -- stylua: ignore end
        
    end

    local function mainMenuBar()
        Iris.MenuBar()
            Iris.Menu({ "File" })
                Iris.MenuItem({ "New", Enum.KeyCode.N, Enum.ModifierKey.Ctrl })
                Iris.MenuItem({ "Open", Enum.KeyCode.O, Enum.ModifierKey.Ctrl })
                Iris.MenuItem({ "Save", Enum.KeyCode.S, Enum.ModifierKey.Ctrl })
                recursiveMenu()
                Iris.MenuItem({ "Quit", Enum.KeyCode.Q, Enum.ModifierKey.Alt })
            Iris.End()
            
            Iris.Menu({ "Examples" })
                Iris.MenuToggle({ "Recursive Window" }, { isChecked = showRecursiveWindow })
                Iris.MenuToggle({ "Windowless" }, { isChecked = showWindowlessDemo })
                Iris.MenuToggle({ "Main Menu Bar" }, { isChecked = showMainMenuBarWindow })
            Iris.End()

            Iris.Menu({ "Tools" })
                Iris.MenuToggle({ "Runtime Info" }, { isChecked = showRuntimeInfo })
                Iris.MenuToggle({ "Style Editor" }, { isChecked = showStyleEditor })
            Iris.End()
        Iris.End()
    end

    local function mainMenuBarExample()
        local screenSize = Iris.Internal._rootWidget.Instance.PseudoWindowScreenGui.AbsoluteSize
        -- Iris.Window(
        --     {[Iris.Args.Window.NoBackground] = true, [Iris.Args.Window.NoTitleBar] = true, [Iris.Args.Window.NoMove] = true, [Iris.Args.Window.NoResize] = true},
        --     {size = Iris.State(screenSize), position = Iris.State(Vector2.new(0, 0))}
        -- )
        
        mainMenuBar()

        --Iris.End()
    end

    -- allows users to edit state
    local styleEditor
    do
        styleEditor = function()
            local selectedPanel = Iris.State(1)

            local styleList = {
                {
                    "Sizing",
                    function()
                        local UpdatedConfig = Iris.State({})

                        if Iris.Button({ "Update Config" }).clicked() then
                            Iris.UpdateGlobalConfig(UpdatedConfig:get())
                            UpdatedConfig:set({})
                        end

                        local UDims = {
                            { "ItemWidth", nil,  UDim.new(), UDim.new(1, 200) },
                            { "ContentWidth", nil, UDim.new(), UDim.new(1, 200) }
                        }
                        for _, vUDim in UDims do
                            local Input = Iris.SliderUDim({ table.unpack(vUDim) }, { number = Iris.WeakState(Iris._config[vUDim[1] ]) })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vUDim[1] ] = Input.number:get()
                            end
                        end

                        local Vector2s = {
                            { "WindowPadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "WindowResizePadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "FramePadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "ItemSpacing", nil, Vector2.zero, Vector2.one * 20 },
                            { "ItemInnerSpacing", nil, Vector2.zero, Vector2.one * 20 },
                            { "CellPadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "DisplaySafeAreaPadding", nil, Vector2.zero, Vector2.one * 20 },
                        }
                        for _, vVector2 in Vector2s do
                            local Input = Iris.SliderVector2({ table.unpack(vVector2) }, { number = Iris.WeakState(Iris._config[vVector2[1] ]) })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vVector2[1] ] = Input.number:get()
                            end
                        end

                        local Numbers = {
                            { "TextSize", 1, 4, 20 },
                            { "FrameBorderSize", 0.1, 0, 1 },
                            { "FrameRounding", 1, 0, 12 },
                            { "GrabRounding", 1, 0, 12 },
                            { "WindowBorderSize", 0.1, 0, 1 },
                            { "PopupBorderSize", 0.1, 0, 1 },
                            { "PopupRounding", 1, 0, 12 },
                            { "ScrollbarSize", 1, 0, 20 },
                            { "GrabMinSize", 1, 0, 20 },
                        }
                        for _, vNumber in Numbers do
                            local Input = Iris.SliderNum({ table.unpack(vNumber) }, { number = Iris.WeakState(Iris._config[vNumber[1] ]) })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vNumber[1] ] = Input.number:get()
                            end
                        end

                        local Enums = {
                            "WindowTitleAlign",
                            -- "TextFont"
                        }
                        for _, vEnum in Enums do
                            local Input = Iris.ComboEnum({ vEnum }, { index = Iris.WeakState(Iris._config[vEnum]) }, Iris._config[vEnum].EnumType)
                            if Input.closed() then
                                Iris.UpdateGlobalConfig({ [vEnum] = Input.index:get() })
                            end
                        end
                    end,
                },
                {
                    "Colors",
                    function()
                        local UpdatedConfig = Iris.State({})

                        if Iris.Button({ "Update Config" }).clicked() then
                            Iris.UpdateGlobalConfig(UpdatedConfig:get())
                            UpdatedConfig:set({})
                        end
                        
                        local color3s = { "BorderColor", "BorderActiveColor" }

                        for _, vColor in color3s do
                            local Input = Iris.InputColor3({ vColor }, { color = Iris.WeakState(Iris._config[vColor]) })
                            if Input.numberChanged() then
                                Iris.UpdateGlobalConfig({ [vColor] = Input.color:get() })
                            end
                        end

                        local color4s = {
                            "Text",
                            "TextDisabled",
                            "WindowBg",
                            "ScrollbarGrab",
                            "TitleBg",
                            "TitleBgActive",
                            "TitleBgCollapsed",
                            "MenubarBg",
                            "FrameBg",
                            "FrameBgHovered",
                            "FrameBgActive",
                            "Button",
                            "ButtonHovered",
                            "ButtonActive",
                            "SliderGrab",
                            "SliderGrabActive",
                            "Header",
                            "HeaderHovered",
                            "HeaderActive",
                            "SelectionImageObject",
                            "SelectionImageObjectBorder",
                            "TableBorderStrong",
                            "TableBorderLight",
                            "TableRowBg",
                            "TableRowBgAlt",
                            "NavWindowingHighlight",
                            "NavWindowingDimBg",
                            "Separator",
                            "CheckMark",
                        }

                        for _, vColor in color4s do
                            local Input = Iris.InputColor4({ vColor }, {
                                color = Iris.WeakState(Iris._config[vColor .. "Color"]),
                                transparency = Iris.WeakState(Iris._config[vColor .. "Transparency"]),
                            })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vColor .. "Color"] = Input.color:get()
                                UpdatedConfig:get()[vColor .. "Transparency"] = Input.transparency:get()
                            end
                        end
                    end,
                },
            }

            Iris.Window({ "Style Editor" }, { isOpened = showStyleEditor })
                Iris.Text({ "Customize the look of Iris in realtime." })
                Iris.SameLine()
                    if Iris.SmallButton({ "Light Theme" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight)
                    end
                    if Iris.SmallButton({ "Dark Theme" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark)
                    end
                Iris.End()

                Iris.SameLine()
                    if Iris.SmallButton({ "Classic Size" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
                    end
                    if Iris.SmallButton({ "Larger Size" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeClear)
                    end
                Iris.End()

                if Iris.SmallButton({ "Reset Everything" }).clicked() then
                    Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark)
                    Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
                end
                Iris.Separator()

                Iris.SameLine()
                    for i, v in ipairs(styleList) do
                        Iris.RadioButton({ v[1], i }, { index = selectedPanel })
                    end
                Iris.End()

                styleList[selectedPanel:get()][2]()
            Iris.End()
        end
    end

    local function widgetEventInteractivity()
        Iris.CollapsingHeader({ "Widget Event Interactivity" })
        local clickCount = Iris.State(0)
        if Iris.Button({ "Click to increase Number" }).clicked() then
            clickCount:set(clickCount:get() + 1)
        end
        Iris.Text({ "The Number is: " .. clickCount:get() })

        Iris.Separator()

        local showEventText = Iris.State(false)
        local selectedEvent = Iris.State("clicked")
        Iris.SameLine()
        Iris.RadioButton({ "clicked", "clicked" }, { index = selectedEvent })
        Iris.RadioButton({ "rightClicked", "rightClicked" }, { index = selectedEvent })
        Iris.RadioButton({ "doubleClicked", "doubleClicked" }, { index = selectedEvent })
        Iris.RadioButton({ "ctrlClicked", "ctrlClicked" }, { index = selectedEvent })
        Iris.End()
        Iris.SameLine()

        if Iris.Button({ selectedEvent:get() .. " to reveal text" })[selectedEvent:get()]() then
            showEventText:set(not showEventText:get())
        end
        if showEventText:get() then
            Iris.Text({ "Here i am!" })
        end

        Iris.End()

        Iris.Separator()

        local showTextTimer = Iris.State(0)
        Iris.SameLine()
        if Iris.Button({ "Click to show text for 20 frames" }).clicked() then
            showTextTimer:set(20)
        end
        if showTextTimer:get() > 0 then
            Iris.Text({ "Here i am!" })
        end
        Iris.End()
        showTextTimer:set(math.max(0, showTextTimer:get() - 1))
        Iris.Text({ "Text Timer: " .. showTextTimer:get() })

        local checkbox0 = Iris.Checkbox({ "Event-tracked checkbox" })
        Iris.Indent()
        Iris.Text({ "unchecked: " .. tostring(checkbox0.unchecked()) })
        Iris.Text({ "checked: " .. tostring(checkbox0.checked()) })
        Iris.End()
        Iris.SameLine()
        if Iris.Button({ "Hover over me" }).hovered() then
            Iris.Text({ "The button is hovered" })
        end
        Iris.End()
        Iris.End()
    end

    local function widgetStateInteractivity()
        Iris.CollapsingHeader({ "Widget State Interactivity" })
        local checkbox0 = Iris.Checkbox({ "Widget-Generated State" })
       [trimmed]  -  Edit
  18:44:43.942  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Frustum.spec | Enabled: N/A
--------------------------------------------------------------------
local Frustum = require(script.Parent:WaitForChild("Frustum"))

return function()
	local FakeCamera = {
		CFrame = CFrame.identity,
		FieldOfView = 70,
		ViewportSize = Vector2.new(1920, 1080),
	}

	local ReturnedCFrames = {}

	describe("Generates CFrames", function()
		local SolveStart = os.clock()
		local SolveEnd

		ReturnedCFrames = table.pack(Frustum.GetCFrames(FakeCamera, 500))
		SolveEnd = os.clock()

		ReturnedCFrames["n"] = nil

		print(`Solved view frustum in {string.format("%.2f", (SolveEnd - SolveStart) * 1e6)}Î¼s`)
	end)

	describe("Point In View", function()
		local CloseInView = Vector3.new(0, 0, -5)
		local FarPlaneView = Vector3.new(0, 0, -550)
		local OutOfView = Vector3.new(0, 0, 5)

		it("Close In View Point", function()
			expect(Frustum.InViewFrustum(CloseInView, table.unpack(ReturnedCFrames))).to.equal(true)
		end)

		it("Past FarPlane Point", function()
			expect(Frustum.InViewFrustum(FarPlaneView, table.unpack(ReturnedCFrames))).to.equal(false)
		end)

		it("Out Of View Point", function()
			expect(Frustum.InViewFrustum(OutOfView, table.unpack(ReturnedCFrames))).to.equal(false)
		end)
	end)

	describe("Object In View", function()
		local CloseFakeObject = {
			CFrame = CFrame.new(0, 0, -5),
			Size = Vector3.new(1, 1, 3),
		}

		local FarFakeObject = {
			CFrame = CFrame.new(0, 0, -550),
			Size = Vector3.new(1, 1, 3),
		}

		local OutOfViewFakeObject = {
			CFrame = CFrame.new(0, 0, 5),
			Size = Vector3.new(1, 1, 3),
		}

		it("Close In View Object", function()
			expect(Frustum.ObjectInFrustum(CloseFakeObject, table.unpack(ReturnedCFrames))).to.equal(true)
		end)

		it("Past FarPlane Object", function()
			expect(Frustum.ObjectInFrustum(FarFakeObject, table.unpack(ReturnedCFrames))).to.equal(false)
		end)

		it("Out Of View Object", function()
			expect(Frustum.ObjectInFrustum(OutOfViewFakeObject, table.unpack(ReturnedCFrames))).to.equal(false)
		end)
	end)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Frustum.spec

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Runtime | Enabled: true
--------------------------------------------------------------------
local Actor: Actor = script.Parent
local RootObject
local ColliderDescriptions
local SmartboneModule
local SmartboneClass

local Setup = false

local CONNECTIONS = {}

local function c(Conn: RBXScriptConnection)
	table.insert(CONNECTIONS, Conn)
end

local function cleanup()
	for _, Conn: RBXScriptConnection in CONNECTIONS do
		Conn:Disconnect()
	end
end

local Bind
Bind = Actor:BindToMessage("Setup", function(m_Object, m_ColliderDescriptions, m_SmartBone)
	RootObject = m_Object
	ColliderDescriptions = m_ColliderDescriptions
	SmartboneModule = m_SmartBone
	SmartboneClass = require(m_SmartBone)

	Setup = true

	Bind:Disconnect()
end)

repeat
	task.wait()
until Setup

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local BonePhysics = SmartboneClass.new()
local Dependencies = SmartboneModule.Dependencies
local DebugUi = require(Dependencies.Debug.DebugUi)
local Iris
local Config = require(Dependencies.Config)
local Utilities = require(Dependencies.Utilities)
local ShouldDebug = RunService:IsStudio() or Config.ALLOW_LIVE_GAME_DEBUG
local OverlayEvent = SmartboneModule:WaitForChild("OverlayEvent")

local ForceDestroy = false

-- So much work for such a basic debug tool
local ImOverlay = {
	Begin = function(...)
		OverlayEvent:Fire("Begin", ...)
	end,
	End = function(...)
		OverlayEvent:Fire("End", ...)
	end,
	Text = function(...)
		OverlayEvent:Fire("Text", ...)
	end,
}

-- Frame counter for getting animatedworldcframe
shared.FrameCounter = 0
local FrameCounterOverflow = 131072

if ShouldDebug then
	Iris = require(Dependencies.Iris)
	if not Iris.HasInit() then
		Iris = Iris.Init()
	end
end

Actor.Name = `{RootObject.Name} - {BonePhysics.ID}`

BonePhysics:LoadObject(RootObject)

for _, ColliderDescription in ColliderDescriptions do
	BonePhysics:LoadRawCollider(ColliderDescription[1], ColliderDescription[2])
end

local DebugState

if ShouldDebug then
	DebugState = {
		DRAW_BONE = Iris.State(false),
		DRAW_PHYSICAL_BONE = Iris.State(false),
		DRAW_ROOT_PART = Iris.State(false),
		DRAW_BOUNDING_BOX = Iris.State(false),
		DRAW_AXIS_LIMITS = Iris.State(false),
		DRAW_COLLIDERS = Iris.State(false),
		DRAW_COLLIDER_INFLUENCE = Iris.State(false),
		DRAW_COLLIDER_AWAKE = Iris.State(false),
		DRAW_COLLIDER_BROADPHASE = Iris.State(false),
		DRAW_FILL_COLLIDERS = Iris.State(false),
		DRAW_CONTACTS = Iris.State(false),
		DRAW_ROTATION_LIMITS = Iris.State(false),
		DRAW_ACCELERATION_INFO = Iris.State(false),
	}
end

-- ShouldDebug is just if we are in studio or not
if ShouldDebug then
	Iris:Connect(function()
		if RootObject:GetAttribute("Debug") ~= nil then
			DebugUi(Iris, BonePhysics, DebugState)
		end
	end)
end

c(CollectionService:GetInstanceAddedSignal("SmartCollider"):Connect(function(Object: BasePart)
	if not Object:IsA("BasePart") then
		return
	end

	local ColliderKey = Object:GetAttribute("ColliderKey")
	local RootColliderKey = RootObject:GetAttribute("ColliderKey")

	if tostring(ColliderKey) ~= tostring(RootColliderKey) then
		return
	end

	local ColliderObject = Utilities.GetCollider(Object)

	BonePhysics:LoadRawCollider(ColliderObject, Object)
end))

c(Actor:BindToMessage("Destroy", function()
	ForceDestroy = true
end))

c(RunService.Heartbeat:ConnectParallel(function(deltaTime)
	shared.FrameCounter += 1

	if shared.FrameCounter > FrameCounterOverflow then
		shared.FrameCounter = 0
	end

	BonePhysics:StepBoneTrees(deltaTime)

	if BonePhysics.ShouldDestroy or ForceDestroy then
		BonePhysics:Destroy()

		task.synchronize()
		cleanup()
		return
	end

	-- ShouldDebug is just if we are in studio or not
	if ShouldDebug then
		if RootObject:GetAttribute("Debug") ~= nil then
			task.synchronize()
			BonePhysics:DrawDebug(
				DebugState.DRAW_COLLIDERS:get(),
				DebugState.DRAW_CONTACTS:get(),
				DebugState.DRAW_PHYSICAL_BONE:get(),
				DebugState.DRAW_BONE:get(),
				DebugState.DRAW_AXIS_LIMITS:get(),
				DebugState.DRAW_ROOT_PART:get(),
				DebugState.DRAW_FILL_COLLIDERS:get(),
				DebugState.DRAW_COLLIDER_INFLUENCE:get(),
				DebugState.DRAW_COLLIDER_AWAKE:get(),
				DebugState.DRAW_COLLIDER_BROADPHASE:get(),
				DebugState.DRAW_BOUNDING_BOX:get(),
				DebugState.DRAW_ROTATION_LIMITS:get(),
				DebugState.DRAW_ACCELERATION_INFO:get()
			)

			BonePhysics:DrawOverlay(ImOverlay)
		end
	end
end))

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Runtime

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Utilities | Enabled: N/A
--------------------------------------------------------------------
local HttpService = game:GetService("HttpService")
local Config = require(script.Parent:WaitForChild("Config"))
local DefaultObjectSettings = require(script.Parent:WaitForChild("DefaultObjectSettings"))

local ColliderTranslations = {
	Block = "Box",
	Ball = "Sphere",
	Capsule = "Capsule",
	Sphere = "Sphere",
	Box = "Box",
	Cylinder = "Cylinder",
}

local function YAxisSafeUnit(Vector: Vector3): Vector3
	if Vector.Magnitude <= 1e-6 then
		return -Vector3.yAxis
	end

	return Vector.Unit
end

local module = {}
module.LogIndent = 0

function module.GetRotationBetween(U: Vector3, V: Vector3)
	local Cos = U:Dot(V)
	local Sin = U:Cross(V).Magnitude
	local Angle = math.atan2(Sin, Cos)
	local W = YAxisSafeUnit(U:Cross(V))

	if Sin < 1e-6 then
		if Cos > 0 then
			return CFrame.new()
		else
			local Perpendicular = (math.abs(U.X) > math.abs(U.Z)) and Vector3.new(-U.Y, U.X, 0) or Vector3.new(0, -U.Z, U.Y)
			return CFrame.fromAxisAngle(Perpendicular.Unit, math.pi)
		end
	end

	return CFrame.fromAxisAngle(W, Angle)
end

function module.GetCFrameAxis(Transform: CFrame, Axis: string)
	local X, Y, Z = Transform:ToEulerAnglesXYZ()
	if Axis == "X" then
		return X
	elseif Axis == "Y" then
		return Y
	elseif Axis == "Z" then
		return Z
	end
	return nil
end

function module.GatherObjectSettings(Object: BasePart)
	local Settings = {}

	local function Expect(Value: any, Type: string, Name: string): boolean
		if typeof(Value) ~= Type then
			warn(`[SmartBone][Object] Expected attribute {Name} on {Object.Name} to be of type {Type}, got type {typeof(Value)}`)
			return false
		end

		return true
	end

	for k, v in DefaultObjectSettings do
		local Attrib = Object:GetAttribute(k)

		if Attrib ~= nil then
			if not Expect(Attrib, typeof(v), k) then
				Attrib = nil
			end
		end

		Settings[k] = Attrib == nil and v or Attrib
	end

	return Settings
end

function module.GatherBoneSettings(Bone: Bone)
	local function Attrib(Name: string): any?
		return Bone:GetAttribute(Name)
	end

	local function Expect(Value: any, Type: string, Name: string)
		if typeof(Value) ~= Type then
			warn(`[SmartBone][Bone] Expected attribute {Name} on {Bone.Name} to be of type {Type}, got type {typeof(Value)}`)
		end
	end

	local Anchored = Attrib("Anchored") or false

	local XAxisLocked = Attrib("XAxisLocked") or false
	local YAxisLocked = Attrib("YAxisLocked") or false
	local ZAxisLocked = Attrib("ZAxisLocked") or false

	local XAxisLimits = Attrib("XAxisLimits") or NumberRange.new(-math.huge, math.huge)
	local YAxisLimits = Attrib("YAxisLimits") or NumberRange.new(-math.huge, math.huge)
	local ZAxisLimits = Attrib("ZAxisLimits") or NumberRange.new(-math.huge, math.huge)

	local Radius = Attrib("Radius") or 0.25

	local RotationLimit = Attrib("RotationLimit") or 180

	local Force = Attrib("Force") or "Â¬"
	local Gravity = Attrib("Gravity") or "Â¬"

	Expect(Anchored, "boolean", "Anchored")

	Expect(XAxisLocked, "boolean", "XAxisLocked")
	Expect(YAxisLocked, "boolean", "YAxisLocked")
	Expect(ZAxisLocked, "boolean", "ZAxisLocked")

	Expect(XAxisLimits, "NumberRange", "XAxisLimits")
	Expect(YAxisLimits, "NumberRange", "YAxisLimits")
	Expect(ZAxisLimits, "NumberRange", "ZAxisLimits")

	Expect(Radius, "number", "Radius")
	Expect(RotationLimit, "number", "RotationLimit")

	if Force ~= "Â¬" then
		Expect(Force, "Vector3", "Force")
	end

	if Force ~= "Â¬" then
		Expect(Gravity, "Vector3", "Gravity")
	end

	local Settings = {
		Anchored = Anchored,
		AxisLocked = { XAxisLocked, YAxisLocked, ZAxisLocked },
		XAxisLimits = XAxisLimits,
		YAxisLimits = YAxisLimits,
		ZAxisLimits = ZAxisLimits,
		RotationLimit = RotationLimit,
		Radius = Radius,
		Force = Force,
		Gravity = Gravity,
	}

	return Settings
end

function module.ClosestPointOnLine(p0: Vector3, d0: Vector3, len: number, p1: Vector3): Vector3
	local v = p1 - p0
	local k = v:Dot(d0)
	k = math.clamp(k, -len, len)
	return p0 + d0 * k
end

function module.ClosestPointInBox(cframe: CFrame, size: Vector3, point: Vector3): (boolean, Vector3, Vector3)
	local rel = cframe:PointToObjectSpace(point)
	local sx, sy, sz = size.X, size.X, size.Z
	local rx, ry, rz = rel.X, rel.Y, rel.Z

	if rel ~= rel or size ~= size then 
		return false, cframe.Position, Vector3.yAxis
	end

	local cx = math.clamp(rx, -sx * 0.5, sx * 0.5)
	local cy = math.clamp(ry, -sy * 0.5, sy * 0.5)
	local cz = math.clamp(rz, -sz * 0.5, sz * 0.5)

	if not (cx == rx and cy == ry and cz == rz) then
		local closestPoint = cframe * Vector3.new(cx, cy, cz)
		local normal = (point - closestPoint).unit
		return false, closestPoint, normal
	end

	local posX = rx - sx * 0.5
	local posY = ry - sy * 0.5
	local posZ = rz - sz * 0.5
	local negX = -rx - sx * 0.5
	local negY = -ry - sy * 0.5
	local negZ = -rz - sz * 0.5

	local max = math.max(posX, posY, posZ, negX, negY, negZ)
	if max == posX then
		local closestPoint = cframe * Vector3.new(sx * 0.5, ry, rz)
		return true, closestPoint, cframe.XVector
	elseif max == posY then
		local closestPoint = cframe * Vector3.new(rx, sy * 0.5, rz)
		return true, closestPoint, cframe.YVector
	elseif max == posZ then
		local closestPoint = cframe * Vector3.new(rx, ry, sz * 0.5)
		return true, closestPoint, cframe.ZVector
	elseif max == negX then
		local closestPoint = cframe * Vector3.new(-sx * 0.5, ry, rz)
		return true, closestPoint, -cframe.XVector
	elseif max == negY then
		local closestPoint = cframe * Vector3.new(rx, -sy * 0.5, rz)
		return true, closestPoint, -cframe.YVector
	elseif max == negZ then
		local closestPoint = cframe * Vector3.new(rx, ry, -sz * 0.5)
		return true, closestPoint, -cframe.ZVector
	end

	warn("CLOSEST POINT ON BOX FAIL")
	return false, Vector3.zero, Vector3.yAxis
end

function module.GetCollider(Object: BasePart)
	local ColliderModule = Object:FindFirstChild("self.Collider")
	local ColliderDescription

	if ColliderModule and ColliderModule:IsA("ModuleScript") then
		local RawColliderData = require(ColliderModule)
		local ColliderData
		pcall(function()
			ColliderData = HttpService:JSONDecode(RawColliderData)
		end)

		ColliderDescription = ColliderData
	end

	if ColliderDescription then
		return ColliderDescription
	end

	local function GetShapeName(obj)
		local ShapeAttribute = obj:GetAttribute("ColliderShape")

		if ShapeAttribute then
			return ShapeAttribute
		end

		if obj:IsA("Part") then 
			return obj.Shape.Name
		end

		return "Box"
	end

	local ColliderType = ColliderTranslations[GetShapeName(Object)] or "Box"

	ColliderDescription = {
		{
			Type = ColliderType,
			ScaleX = 1,
			ScaleY = 1,
			ScaleZ = 1,
			OffsetX = 0,
			OffsetY = 0,
			OffsetZ = 0,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
		},
	}

	return ColliderDescription
end

function module.SB_INDENT_LOG()
	module.LogIndent += 1
end

function module.SB_UNINDENT_LOG()
	module.LogIndent -= 1
	module.LogIndent = math.max(module.LogIndent, 0)
end

function module.SB_ASSERT_CB(condition, callback, ...)
	if condition == false or condition == nil then
		callback(...)
	end
end

function module.SB_VERBOSE_LOG(message: string)
	if not Config.LOG_VERBOSE then
		return
	end

	local Indent = string.rep("    ", module.LogIndent)

	print(`{Indent}[SmartBone][Log]: {message}`)
end

function module.SB_VERBOSE_WARN(message: string)
	if not Config.LOG_VERBOSE then
		return
	end

	local Indent = string.rep("    ", module.LogIndent)

	warn(`{Indent}[SmartBone][Warn]: {message}`)
end

function module.SB_VERBOSE_ERROR(message: string)
	if not Config.LOG_VERBOSE then
		return
	end

	local Indent = string.rep("    ", module.LogIndent)

	error(`{Indent}[SmartBone][Error]: {message}`)
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Utilities

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo | Enabled: N/A
--------------------------------------------------------------------
--[[

    Acts as a wrapper for Gizmo.lua, respects IsStudio and AllowLiveGameDebug

]]

local Dependencies = script.Parent.Parent

local Config = require(Dependencies:WaitForChild("Config"))
local Gizmo = require(script:WaitForChild("Gizmo"))

local IsStudio = game:GetService("RunService"):IsStudio()
local IsEnabled = IsStudio or Config.ALLOW_LIVE_GAME_DEBUG
if IsEnabled then
	Gizmo.Init()
end

type ICeive = Gizmo.ICeive & { Init: nil }

local Wrapper: ICeive = setmetatable({}, {
	__index = function(_, Index)
		if IsEnabled then
			return Gizmo[Index]
		else
			local GizmoFunctions = {
				SetStyle = true,
				AddDebrisInSeconds = true,
				PushProperty = true,
				PopProperty = true,
				AddDebrisInFrames = true,
				SetEnabled = true,
				DoCleaning = true,
				ScheduleCleaning = true,
				TweenProperties = true,
			}

			if GizmoFunctions[Index] then
				return function() end
			end

			return {
				Draw = function() end,
				Create = function() end,
			}
		end
	end,
}) :: any

return table.freeze(Wrapper)

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmo | Enabled: N/A
--------------------------------------------------------------------
--!nocheck

-- CeiveImGizmo
-- https://github.com/JakeyWasTaken/CeiveImGizmo

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Terrain = workspace:WaitForChild("Terrain")
local TargetParent = workspace:WaitForChild("Terrain") -- Change this if you wish to have gizmos under a different location, e.g CoreGui

assert(Terrain, "No terrain object found under workspace")
assert(TargetParent, "No target parent found.")

local AOTWireframeHandle: WireframeHandleAdornment = TargetParent:FindFirstChild("AOTGizmoAdornment")
local WireframeHandle: WireframeHandleAdornment = TargetParent:FindFirstChild("GizmoAdornment")

if not AOTWireframeHandle then
	AOTWireframeHandle = Instance.new("WireframeHandleAdornment")
	AOTWireframeHandle.Adornee = Terrain
	AOTWireframeHandle.ZIndex = 1
	AOTWireframeHandle.AlwaysOnTop = true
	AOTWireframeHandle.Name = "AOTGizmoAdornment"
	AOTWireframeHandle.Parent = TargetParent
end

if not WireframeHandle then
	WireframeHandle = Instance.new("WireframeHandleAdornment")
	WireframeHandle.Adornee = Terrain
	WireframeHandle.ZIndex = 1
	WireframeHandle.AlwaysOnTop = false
	WireframeHandle.Name = "GizmoAdornment"
	WireframeHandle.Parent = TargetParent
end

local Gizmos = script.Parent:WaitForChild("Gizmos")

local ActiveObjects = {}
local RetainObjects = {}
local Debris = {}
local Tweens = {}
local PropertyTable = { AlwaysOnTop = true, Color3 = Color3.fromRGB(13, 105, 172), Transparency = 0 } -- Defaults
local Pool = {}

local CleanerScheduled = false

local function Retain(Gizmo, GizmoProperties)
	table.insert(RetainObjects, { Gizmo, GizmoProperties })
end

local function Register(object)
	object.Parent = TargetParent
	table.insert(ActiveObjects, object)
end

local function Release(object)
	local ClassName = object.ClassName

	if not Pool[ClassName] then
		Pool[ClassName] = {}
	end

	object:Remove()
	table.insert(Pool[ClassName], object)
end

local function Request(ClassName)
	if not Pool[ClassName] then
		return Instance.new(ClassName)
	end

	local Object = table.remove(Pool[ClassName])

	if not Object then
		return Instance.new(ClassName)
	end

	return Object
end

local function Lerp(a, b, t)
	return a + (b - a) * t
end

local function deepCopy(original)
	local copy = {}
	for k, v in pairs(original) do
		if type(v) == "table" then
			v = deepCopy(v)
		end
		copy[k] = v
	end
	return copy
end

-- Types

type IRay = {
	Draw: (self: IRay, Origin: Vector3, End: Vector3) -> (),
	Create: (
		self: IRay,
		Origin: Vector3,
		End: Vector3
	) -> { Origin: Vector3, End: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number }
}

type IBox = {
	Draw: (self: IBox, Transform: CFrame, Size: Vector3, DrawTriangles: boolean) -> (),
	Create: (
		self: IBox,
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean
	) -> {
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IPlane = {
	Draw: (self: IPlane, Position: Vector3, Normal: Vector3, Size: Vector3) -> (),
	Create: (
		self: IPlane,
		Position: Vector3,
		Normal: Vector3,
		Size: Vector3
	) -> {
		Position: Vector3,
		Normal: Vector3,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IWedge = {
	Draw: (self: IWedge, Transform: CFrame, Size: Vector3, DrawTriangles: boolean) -> (),
	Create: (
		self: IWedge,
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean
	) -> {
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type ICircle = {
	Draw: (self: ICircle, Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?) -> (),
	Create: (
		self: ICircle,
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		Angle: number,
		ConnectToStart: boolean?
	) -> {
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		ConnectToStart: boolean?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type ISphere = {
	Draw: (self: ISphere, Transform: CFrame, Radius: number, Subdivisions: number, Angle: number) -> (),
	Create: (
		self: ISphere,
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		Angle: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		Angle: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type ICylinder = {
	Draw: (self: ICylinder, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: ICylinder,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type ICapsule = {
	Draw: (self: ICapsule, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: ICapsule,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type ICone = {
	Draw: (self: ICone, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: ICone,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IArrow = {
	Draw: (self: IArrow, Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: IArrow,
		Origin: Vector3,
		End: Vector3,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Origin: Vector3,
		End: Vector3,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IMesh = {
	Draw: (self: IMesh, Transform: CFrame, Size: Vector3, Vertices: {}, Faces: {}) -> (),
	Create: (
		self: IMesh,
		Transform: CFrame,
		Size: Vector3,
		Vertices: {},
		Faces: {}
	) -> {
		Transform: CFrame,
		Size: Vector3,
		Vertices: {},
		Faces: {},
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type ILine = {
	Draw: (self: ILine, Transform: CFrame, Length: number) -> (),
	Create: (
		self: ILine,
		Transform: CFrame,
		Length: number
	) -> { Transform: CFrame, Length: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean }
}

type IVolumeCone = {
	Draw: (self: IVolumeCone, Transform: CFrame, Radius: number, Length: number) -> (),
	Create: (
		self: IVolumeCone,
		Transform: CFrame,
		Radius: number,
		Length: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IVolumeBox = {
	Draw: (self: IVolumeBox, Transform: CFrame, Size: Vector3) -> (),
	Create: (
		self: IVolumeBox,
		Transform: CFrame,
		Size: Vector3
	) -> { Transform: CFrame, Size: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean }
}

type IVolumeSphere = {
	Draw: (self: IVolumeSphere, Transform: CFrame, Radius: number) -> (),
	Create: (
		self: IVolumeSphere,
		Transform: CFrame,
		Radius: number
	) -> { Transform: CFrame, Radius: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean }
}

type IVolumeCylinder = {
	Draw: (self: IVolumeCylinder, Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?) -> (),
	Create: (
		self: IVolumeCylinder,
		Transform: CFrame,
		Radius: number,
		Length: number,
		InnerRadius: number?,
		Angle: number?
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		InnerRadius: number?,
		Angle: number?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IVolumeArrow = {
	Draw: (
		self: IVolumeArrow,
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?
	) -> (),
	Create: (
		self: IVolumeArrow,
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?
	) -> {
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IText = {
	Draw: (self: IText, Origin: Vector3, Text: string, Size: number?) -> (),
	Create: (
		self: IText,
		Origin: Vector3,
		Text: string,
		Size: number?
	) -> {
		Origin: Vector3,
		Text: string,
		Size: number?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean	
}
}

type IStyles = {
	Color: string,
	Transparency: number,
	AlwaysOnTop: boolean
}

type IStyle = "Color3" | "Transparency" | "AlwaysOnTop"

export type ICeive = {
	ActiveRays: number,
	ActiveInstances: number,

	PushProperty: (Property: IStyle, Value: any?) -> (),
	PopProperty: (Property: IStyle) -> any?,
	SetStyle: (Color: Color3?, Transparency: number?, AlwaysOnTop: boolean?) -> (),
	AddDebrisInSeconds: (Seconds: number, Callback: () -> ()) -> (),
	AddDebrisInFrames: (Frames: number, Callback: () -> ()) -> (),
	SetEnabled: (Value: boolean) -> (),
	RemoveAdornments: () -> (),
	DoCleaning: () -> (),
	ScheduleCleaning: () -> (),
	TweenProperies: (Properties: {}, Goal: {}, TweenInfo: TweenInfo) -> () -> (),
	Init: () -> (),

	Styles: IStyles,

	Ray: IRay,
	Line: ILine,
	Box: IBox,
	Plane: IPlane,
	Wedge: IWedge,
	Circle: ICircle,
	Sphere: ISphere,
	Cylinder: ICylinder,
	Capsule: ICapsule,
	Cone: ICone,
	Arrow: IArrow,
	Mesh: IMesh,
	Text: IText,
	VolumeCone: IVolumeCone,
	VolumeBox: IVolumeBox,
	VolumeSphere: IVolumeSphere,
	VolumeCylinder: IVolumeCylinder,
	VolumeArrow: IVolumeArrow
}

-- Ceive

--- @class CEIVE
--- Root class for all the gizmos.

local Styles = {
	Color = "Color3",
	Transparency = "Transparency",
	AlwaysOnTop = "AlwaysOnTop",
}

local Ceive: ICeive = {
	Enabled = true,
	ActiveRays = 0,
	ActiveInstances = 0,

	Styles = Styles,

	AOTWireframeHandle = AOTWireframeHandle,
	WireframeHandle = WireframeHandle,
}

--- @within CEIVE
--- @function GetPoolSize
--- @return number
function Ceive.GetPoolSize(): number
	local n = 0

	for _, t in Pool do
		n += #t
	end

	return n
end

--- @within CEIVE
--- @function PushProperty
--- Push Property sets the value of a property.
--- @param Property string
--- @param Value any
function Ceive.PushProperty(Property, Value)
	PropertyTable[Property] = Value

	if Property == "AlwaysOnTop" then
		return
	end

	pcall(function()
		AOTWireframeHandle[Property] = Value
		WireframeHandle[Property] = Value
	end)
end

--- @within CEIVE
--- @function PopProperty
--- Pop Property returns the property value.
--- @param Property string
--- @return any
function Ceive.PopProperty(Property)
	if PropertyTable[Property] then
		return PropertyTable[Property]
	end

	return AOTWireframeHandle[Property]
end

--- @within CEIVE
--- @function SetStyle
--- Sets the style of all properties.
--- @param Color Color3?
--- @param Transparency number?
--- @param AlwaysOnTop boolean?
function Ceive.SetStyle(Color, Transparency, AlwaysOnTop)
	if Color ~= nil and typeof(Color) == "Color3" then
		Ceive.PushProperty("Color3", Color)
	end

	if Transparency ~= nil and typeof(Transparency) == "number" then
		Ceive.PushProperty("Transparency", Transparency)
	end

	if AlwaysOnTop ~= nil and typeof(AlwaysOnTop) == "boolean" then
		Ceive.PushProperty("AlwaysOnTop", AlwaysOnTop)
	end
end

--- @within CEIVE
--- @function DoCleaning
function Ceive.DoCleaning()
	AOTWireframeHandle:Clear()
	WireframeHandle:Clear()

	for _, Object in ActiveObjects do
		Release(Object)
	end

	ActiveObjects = {}

	Ceive.ActiveRays = 0
	Ceive.ActiveInstances = 0
end

--- @within CEIVE
--- @function ScheduleCleaning
function Ceive.ScheduleCleaning()
	if CleanerScheduled then
		return
	end

	CleanerScheduled = true

	task.delay(0, function()
		Ceive.DoCleaning()

		CleanerScheduled = false
	end)
end

--- @within CEIVE
--- @function AddDebrisInSeconds
--- Acts as a wrapper for your code that runs for a provided amount of seconds.
--- @param Seconds number
--- @param Callback function
function Ceive.AddDebrisInSeconds(Seconds: number, Callback)
	table.insert(Debris, { "Seconds", Seconds, os.clock(), Callback })
end

--- @within CEIVE
--- @function AddDebrisInFrames
--- Acts as a wrapper for your code that runs for a provided amount of frames.
--- @param Frames number
--- @param Callback function
function Ceive.AddDebrisInFrames(Frames: number, Callback)
	table.insert(Debris, { "Frames", Frames, 0, Callback })
end

--- @within CEIVE
--- @function TweenProperties
--- Tweens the property table to the goal with the provided TweenInfo, returns a function which can be used to cancel.
--- @param Properties table
--- @param Goal table
--- @param TweenInfo TweenInfo
--- @return CancelFunction
function Ceive.TweenProperties(Properties: {}, Goal: {}, TweenInfo: TweenInfo): () -> ()
	local p_Properties = Properties
	local c_Properties = deepCopy(Properties)

	local Tween = {
		p_Properties = p_Properties,
		Properties = c_Properties,
		Goal = Goal,
		TweenInfo = TweenInfo,
		Time = 0,
	}

	Tweens[Tween] = true

	return function()
		Tweens[Tween] = nil
	end
end

--- @within CEIVE
--- @function Init
function Ceive.Init()
	RunService.RenderStepped:Connect(function(dt)
		if Ceive.Enabled then
			-- Add our gizmos if they were removed for whatever reasons
			if not TargetParent:FindFirstChild("AOTGizmoAdornment") then
				AOTWireframeHandle = Instance.new("WireframeHandleAdornment")
				AOTWireframeHandle.Adornee = Terrain
				AOTWireframeHandle.ZIndex = 1
				AOTWireframeHandle.AlwaysOnTop = true
				AOTWireframeHandle.Name = "AOTGizmoAdornment"
				AOTWireframeHandle.Parent = TargetParent

				Ceive.AOTWireframeHandle = AOTWireframeHandle
			end

			if not TargetParent:FindFirstChild("GizmoAdornment") then
				WireframeHandle = Instance.new("WireframeHandleAdornment")
				WireframeHandle.Adornee = Terrain
				WireframeHandle.ZIndex = 1
				WireframeHandle.AlwaysOnTop = false
				WireframeHandle.Name = "GizmoAdornment"
				WireframeHandle.Parent = TargetParent

				Ceive.WireframeHandle = WireframeHandle
			end
		end

		for Tween in Tweens do
			Tween.Time += dt
			local Alpha = Tween.Time / Tween.TweenInfo.Time

			if Alpha > 1 then
				Alpha = 1
			end

			local function LerpProperty(Start, End, Time)
				if type(Start) == "number" then
					return Lerp(Start, End, Time)
				end

				return Start:Lerp(End, Time)
			end

			for k, v in Tween.Properties do
				if not Tween.Goal[k] then
					continue
				end

				local TweenAlpha = TweenService:GetValue(Alpha, Tween.TweenInfo.EasingStyle, Tween.TweenInfo.EasingDirection)
				local PropertyValue = LerpProperty(v, Tween.Goal[k], TweenAlpha)

				Tween.p_Properties[k] = PropertyValue
			end

			if Alpha == 1 then
				Tweens[Tween] = nil
			end
		end

		for i = #Debris, 1, -1 do
			local DebrisObject = Debris[i]
			local DebrisType = DebrisObject[1]
			local DebrisLifetime = DebrisObject[2]
			local DebrisBirth = DebrisObject[3]
			local DebrisCallback = DebrisObject[4]

			if DebrisType == "Seconds" then
				if os.clock() - DebrisBirth > DebrisLifetime then
					table.remove(Debris, i)
					continue
				end

				DebrisCallback()

				continue
			end

			if DebrisBirth > DebrisLifetime then
				table.remove(Debris, i)
				continue
			end

			DebrisObject[2] += 1 -- Add 1 frame to the counter

			DebrisCallback()
		end

		for i = #RetainObjects, 1, -1 do
			local Gizmo = RetainObjects[i]
			local GizmoPropertys = Gizmo[2]

			if not GizmoPropertys.Enabled then
				continue
			end

			if GizmoPropertys.Destroy then
				table.remove(RetainObjects, i)
			end

			Gizmo[1]:Update(GizmoPropertys)
		end
	end)
end

--- @within CEIVE
--- @function SetEnabled
--- @param Value boolean
function Ceive.SetEnabled(Value)
	Ceive.Enabled = Value

	if Value == false then
		Ceive.DoCleaning()
	end
end

--- @within CEIVE
--- @function RemoveAdornments
--- Removes adornments, will be added back next frame if Ceive is enabled
function Ceive.RemoveAdornments()
	if TargetParent:FindFirstChild("AOTGizmoAdornment") then
		TargetParent:FindFirstChild("AOTGizmoAdornment"):Destroy()
	end

	if TargetParent:FindFirstChild("GizmoAdornment") then
		TargetParent:FindFirstChild("GizmoAdornment"):Destroy()
	end
end

-- Load Gizmos

for _, Gizmo in Gizmos:GetChildren() do
	Ceive[Gizmo.Name] = require(Gizmo).Init(Ceive, PropertyTable, Request, Release, Retain, Register)
end

return Ceive

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmo

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Arrow | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Ceive.Ray:Draw(Origin, End)

	local ArrowCFrame = CFrame.lookAt(End + ((Origin - End).Unit * (Length * 0.5)), End)
	Ceive.Cone:Draw(ArrowCFrame, Radius, Length, Subdivisions)
end

function Gizmo:Create(Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Arrow

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Box | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Position = Transform.Position
	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size * 0.5
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local function CalculateYFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (lUv - lRv - lLv)
		local BottomRight = Position + (lUv + lRv - lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateXFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv - lLv)
		local TopRight = Position + (lUv - lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv - lLv)
		local BottomRight = Position + (-lUv - lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateXFace(sUv, sRv, sLv)
	CalculateXFace(sUv, -sRv, sLv)

	CalculateYFace(sUv, sRv, sLv)
	CalculateYFace(-sUv, sRv, sLv)

	CalculateZFace(sUv, sRv, sLv)
	CalculateZFace(sUv, sRv, -sLv)
end

function Gizmo:Create(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		DrawTriangles = DrawTriangles,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.DrawTriangles)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Box

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Capsule | Enabled: N/A
--------------------------------------------------------------------
local Rad180D = math.rad(180)

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	-- Draw top and bottom of cylinder
	local TopOfCylinder = Transform.Position + (Transform.UpVector * (Length * 0.5))
	local BottomOfCylinder = Transform.Position - (Transform.UpVector * (Length * 0.5))

	TopOfCylinder = CFrame.lookAt(TopOfCylinder, TopOfCylinder + Transform.UpVector)
	BottomOfCylinder = CFrame.lookAt(BottomOfCylinder, BottomOfCylinder - Transform.UpVector)

	-- Draw Cylinder Lines

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local LastTop
	local LastBottom

	local FirstTop
	local FirstBottom

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local TopVertexPosition = TopOfCylinder.Position + VertexOffset
		local BottomVertexPosition = BottomOfCylinder.Position + VertexOffset

		Ceive.Ray:Draw(TopVertexPosition, BottomVertexPosition)

		Ceive.Circle:Draw(
			CFrame.new(TopOfCylinder.Position) * Transform.Rotation * CFrame.Angles(0, math.rad(i), 0),
			Radius,
			Subdivisions * 0.5,
			90,
			false
		)
		Ceive.Circle:Draw(
			CFrame.new(BottomOfCylinder.Position) * Transform.Rotation * CFrame.Angles(Rad180D, math.rad(i), 0),
			Radius,
			Subdivisions * 0.5,
			90,
			false
		)

		if not LastTop then
			LastTop = TopVertexPosition
			LastBottom = BottomVertexPosition

			FirstTop = TopVertexPosition
			FirstBottom = BottomVertexPosition

			continue
		end

		Ceive.Ray:Draw(LastTop, TopVertexPosition)
		Ceive.Ray:Draw(LastBottom, BottomVertexPosition)

		LastTop = TopVertexPosition
		LastBottom = BottomVertexPosition
	end

	Ceive.Ray:Draw(LastTop, FirstTop)
	Ceive.Ray:Draw(LastBottom, FirstBottom)
end

function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Capsule

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Circle | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local AnglePerChunk = math.floor(Angle / Subdivisions)

	local PreviousVertex 	
local FirstVertex 
	
local FinishingAngle = 0

	for i = 0, Angle, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexPosition = Transform.Position + ((Transform.UpVector * YMagnitude) + (Transform.RightVector * XMagnitude))

		if PreviousVertex == nil then
			PreviousVertex = VertexPosition
			FirstVertex = VertexPosition
			FinishingAngle = i
			continue
		end

		Ceive.Ray:Draw(PreviousVertex, VertexPosition)
		PreviousVertex = VertexPosition
		FinishingAngle = i
	end

	if FinishingAngle ~= Angle then
		local XMagnitude = math.sin(math.rad(Angle)) * Radius
		local YMagnitude = math.cos(math.rad(Angle)) * Radius

		local VertexPosition = Transform.Position + ((Transform.UpVector * YMagnitude) + (Transform.RightVector * XMagnitude))

		Ceive.Ray:Draw(PreviousVertex, VertexPosition)
	end

	if ConnectToStart ~= false then
		Ceive.Ray:Draw(PreviousVertex, FirstVertex)
	end

	return PreviousVertex
end

function Gizmo:Create(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Subdivisions = Subdivisions,
		Angle = Angle,
		ConnectToStart = ConnectToStart,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Subdivisions, PropertyTable.Angle, PropertyTable.ConnectToStart)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Circle

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Cone | Enabled: N/A
--------------------------------------------------------------------
local Rad90D = math.rad(90)

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Transform *= CFrame.Angles(-Rad90D, 0, 0)

	local TopOfCone = Transform.Position + Transform.UpVector * (Length * 0.5)
	local BottomOfCone = Transform.Position + -Transform.UpVector * (Length * 0.5)

	TopOfCone = CFrame.lookAt(TopOfCone, TopOfCone + Transform.UpVector)
	BottomOfCone = CFrame.lookAt(BottomOfCone, BottomOfCone - Transform.UpVector)

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local Last
	local First

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local VertexPosition = BottomOfCone.Position + VertexOffset

		if not Last then
			Last = VertexPosition
			First = VertexPosition

			Ceive.Ray:Draw(VertexPosition, TopOfCone.Position)

			continue
		end

		Ceive.Ray:Draw(VertexPosition, TopOfCone.Position)
		Ceive.Ray:Draw(Last, VertexPosition)

		Last = VertexPosition
	end

	Ceive.Ray:Draw(Last, First)
end

function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Cone
  -  Edit
  18:44:44.300  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Cylinder | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	-- Draw top and bottom of cylinder
	local TopOfCylinder = Transform.Position + (Transform.UpVector * (Length * 0.5))
	local BottomOfCylinder = Transform.Position - (Transform.UpVector * (Length * 0.5))

	TopOfCylinder = CFrame.lookAt(TopOfCylinder, TopOfCylinder + Transform.UpVector)
	BottomOfCylinder = CFrame.lookAt(BottomOfCylinder, BottomOfCylinder - Transform.UpVector)

	-- Draw Cylinder Lines

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local LastTop
	local LastBottom

	local FirstTop
	local FirstBottom

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local TopVertexPosition = TopOfCylinder.Position + VertexOffset
		local BottomVertexPosition = BottomOfCylinder.Position + VertexOffset

		Ceive.Ray:Draw(TopVertexPosition, BottomVertexPosition)

		if not LastTop then
			LastTop = TopVertexPosition
			LastBottom = BottomVertexPosition

			FirstTop = TopVertexPosition
			FirstBottom = BottomVertexPosition

			continue
		end

		Ceive.Ray:Draw(LastTop, TopVertexPosition)
		Ceive.Ray:Draw(LastBottom, BottomVertexPosition)

		LastTop = TopVertexPosition
		LastBottom = BottomVertexPosition
	end

	Ceive.Ray:Draw(LastTop, FirstTop)
	Ceive.Ray:Draw(LastBottom, FirstBottom)
end

function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Cylinder

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Line | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Origin = Transform.Position + (Transform.LookVector * (-Length * 0.5))
	local End = Transform.Position + (Transform.LookVector * (Length * 0.5))

	Ceive.Ray:Draw(Origin, End)
end

function Gizmo:Create(Transform: CFrame, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Length)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Line

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Mesh | Enabled: N/A
--------------------------------------------------------------------
local function Map(n, start, stop, newStart, newStop)
	return ((n - start) / (stop - start)) * (newStop - newStart) + newStart
end

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local maxX = -math.huge
	local maxY = -math.huge
	local maxZ = -math.huge

	local minX = math.huge
	local minY = math.huge
	local minZ = math.huge

	for _, vertex in Vertices do
		maxX = math.max(maxX, vertex.x)
		maxY = math.max(maxY, vertex.y)
		maxZ = math.max(maxZ, vertex.z)

		minX = math.min(minX, vertex.x)
		minY = math.min(minY, vertex.y)
		minZ = math.min(minZ, vertex.z)
	end

	for i, vertex in Vertices do
		local vX = Map(vertex.x, minX, maxX, -0.5, 0.5)
		local vY = Map(vertex.y, minY, maxY, -0.5, 0.5)
		local vZ = Map(vertex.z, minZ, maxZ, -0.5, 0.5)

		local vertexCFrame = Transform * CFrame.new(Vector3.new(vX, vY, vZ) * Size)
		Vertices[i] = vertexCFrame
	end

	for _, face in Faces do
		if #face == 3 then
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
			Ceive.Ray:Draw(vCF3.Position, vCF1.Position)
		else
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]
			local vCF4 = Vertices[face[4].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF1.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF4.Position, vCF2.Position)

			Ceive.Ray:Draw(vCF3.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
		end
	end
end

function Gizmo:Create(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		Vertices = Vertices,
		Faces = Faces,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.Vertices, PropertyTable.Faces)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Mesh

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Plane | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Position: Vector3, Normal: Vector3, Size: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Size *= Vector3.new(1, 1, 0)

	local Transform = CFrame.lookAt(Position, Position + Normal)

	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size * 0.5
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		Ceive.Ray:Draw(TopRight, BottomLeft)

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateZFace(sUv, sRv, sLv)
end

function Gizmo:Create(Position: Vector3, Normal: Vector3, Size: Vector3)
	local PropertyTable = {
		Position = Position,
		Normal = Normal,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Position, PropertyTable.Normal, PropertyTable.Size)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Plane

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Ray | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Origin: Vector3, End: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	if self.Propertys.AlwaysOnTop then
		Ceive.AOTWireframeHandle:AddLine(Origin, End)
	else
		Ceive.WireframeHandle:AddLine(Origin, End)
	end

	self.Ceive.ActiveRays += 1

	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Origin: Vector3, End: Vector3)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Ray

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Sphere | Enabled: N/A
--------------------------------------------------------------------
local Rad90D = math.rad(90)

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Ceive.Circle:Draw(Transform, Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(0, Rad90D, 0), Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(Rad90D, 0, 0), Radius, Subdivisions, Angle)
end

function Gizmo:Create(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Subdivisions = Subdivisions,
		Angle = Angle,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Subdivisions, PropertyTable.Angle)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Sphere

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Text | Enabled: N/A
--------------------------------------------------------------------
local DROP_SHADOW = true
local OFFSET_PERCENTAGE = 0.00175

local Camera = workspace.CurrentCamera

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Origin: Vector3, Text: string, Size: number?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	if self.Propertys.AlwaysOnTop then
		if DROP_SHADOW then
			local DistanceToCamera = (Origin - Camera.CFrame.Position).Magnitude
			local PrevColor = Ceive.PopProperty("Color3")

			Ceive.PushProperty("Color3", Color3.new())
			local Offset = -(Vector3.xAxis + Vector3.yAxis).Unit
			Ceive.AOTWireframeHandle:AddText(Origin + Offset * (DistanceToCamera * OFFSET_PERCENTAGE), Text, Size)
			Ceive.PushProperty("Color3", PrevColor)
		end

		Ceive.AOTWireframeHandle:AddText(Origin, Text, Size)
	else
		if DROP_SHADOW then
			local DistanceToCamera = (Origin - Camera.CFrame.Position).Magnitude
			local PrevColor = Ceive.PopProperty("Color3")

			Ceive.PushProperty("Color3", Color3.new())
			local Offset = -(Vector3.xAxis + Vector3.yAxis).Unit
			Ceive.WireframeHandle:AddText(Origin + Offset * (DistanceToCamera * OFFSET_PERCENTAGE), Text, Size)
			Ceive.PushProperty("Color3", PrevColor)
		end

		Ceive.WireframeHandle:AddText(Origin, Text, Size)
	end

	-- Should text count to active rays?
	--self.Ceive.ActiveRays += 1

	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Origin: Vector3, Text: string, Size: number?)
	local PropertyTable = {
		Origin = Origin,
		Text = Text,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.Text, PropertyTable.Size)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Text

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeArrow | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number, UseCylinder: boolean?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local ArrowCFrame = CFrame.lookAt(End - (End - Origin).Unit * (Length * 0.5), End)

	if UseCylinder == true then
		local BottomCone = ArrowCFrame.Position
		local CylinderLength = (BottomCone - Origin).Magnitude
		local CylinderCFrame = CFrame.lookAt((Origin + BottomCone) * 0.5, End)

		Ceive.VolumeCylinder:Draw(CylinderCFrame, CylinderRadius, CylinderLength)
	else
		Ceive.Ray:Draw(Origin, End)
	end

	Ceive.VolumeCone:Draw(ArrowCFrame, ConeRadius, Length)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number, UseCylinder: boolean?)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		CylinderRadius = CylinderRadius,
		ConeRadius = ConeRadius,
		Length = Length,
		UseCylinder = UseCylinder,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End, PropertyTable.Radius, PropertyTable.Length, PropertyTable.UseCylinder)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeArrow

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeBox | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Size: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Box = self.Request("BoxHandleAdornment")
	Box.Color3 = self.Propertys.Color3
	Box.Transparency = self.Propertys.Transparency

	Box.CFrame = Transform
	Box.Size = Size
	Box.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Box.ZIndex = 1
	Box.Adornee = Terrain
	Box.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Box)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Size: Vector3)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeBox

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCone | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cone = self.Request("ConeHandleAdornment")
	Cone.Color3 = self.Propertys.Color3
	Cone.Transparency = self.Propertys.Transparency

	Cone.CFrame = Transform
	Cone.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cone.ZIndex = 1
	Cone.Height = Length
	Cone.Radius = Radius
	Cone.Adornee = Terrain
	Cone.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cone)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Radius: number, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCone
  -  Edit
  18:44:44.520  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCylinder | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cylinder = self.Request("CylinderHandleAdornment")
	Cylinder.Color3 = self.Propertys.Color3
	Cylinder.Transparency = self.Propertys.Transparency

	Cylinder.CFrame = Transform
	Cylinder.Height = Length
	Cylinder.Radius = Radius
	Cylinder.InnerRadius = InnerRadius or 0
	Cylinder.Angle = Angle or 360
	Cylinder.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cylinder.ZIndex = 1
	Cylinder.Adornee = Terrain
	Cylinder.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cylinder)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		InnerRadius = InnerRadius or 0,
		Angle = Angle or 360,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.InnerRadius, PropertyTable.Angle)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCylinder

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeSphere | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Sphere = self.Request("SphereHandleAdornment")
	Sphere.Color3 = self.Propertys.Color3
	Sphere.Transparency = self.Propertys.Transparency

	Sphere.CFrame = Transform
	Sphere.Radius = Radius
	Sphere.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Sphere.ZIndex = 1
	Sphere.Adornee = Terrain
	Sphere.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Sphere)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Radius: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeSphere

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Wedge | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Position = Transform.Position
	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size * 0.5
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local YTopLeft
	local YTopRight

	local ZBottomLeft
	local ZBottomRight

	local function CalculateYFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (lUv - lRv - lLv)
		local BottomRight = Position + (lUv + lRv - lLv)

		YTopLeft = TopLeft
		YTopRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		ZBottomLeft = TopLeft
		ZBottomRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateYFace(-sUv, sRv, sLv)

	CalculateZFace(sUv, sRv, -sLv)

	Ceive.Ray:Draw(YTopLeft, ZBottomLeft)
	Ceive.Ray:Draw(YTopRight, ZBottomRight)
	if DrawTriangles ~= false then
		Ceive.Ray:Draw(YTopRight, ZBottomLeft)
	end
end

function Gizmo:Create(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		DrawTriangles = DrawTriangles,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.DrawTriangles)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Wedge

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay | Enabled: N/A
--------------------------------------------------------------------
-- TODO: Figure out the metatable stuff we should do here
return require(script.CeiveImOverlay)

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay.CeiveImOverlay | Enabled: N/A
--------------------------------------------------------------------
local GuiService = game:GetService("GuiService")

export type ImOverlay = {
	DefaultY: number,
	TextSize: number,
	BackFrame: Frame,
	ListLayout: UIListLayout,
	DidUpdate: boolean,
	Begin: (self: ImOverlay, Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: (self: ImOverlay) -> (),
	Text: (self: ImOverlay, Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	Render: (self: ImOverlay) -> (),
	Destroy: (self: ImOverlay) -> ()
}

local Font = Font.new("rbxasset://fonts/families/PressStart2P.json")
local UseScrollingFrame = false

local ImOverlay = {}
ImOverlay.__index = ImOverlay

function ImOverlay.new(DefaultY: number?, TextSize: number?, UseInset: boolean?): ImOverlay
	DefaultY = DefaultY or 5
	TextSize = TextSize or 11
	UseInset = (UseInset == nil and true or UseInset)

	-- Magic numbers
	local InsetPosition = UDim2.fromOffset(25, 5 + GuiService:GetGuiInset().Y)
	local InsetSize = UDim2.new(1, -25, 1, -5)

	local DefaultPosition = UDim2.fromOffset(0, 0)
	local DefaultSize = UDim2.fromScale(1, 1)

	local self = setmetatable({}, ImOverlay)

	self.DefaultY = DefaultY
	self.TextSize = TextSize

	self.BackFrame = UseScrollingFrame and Instance.new("ScrollingFrame") or Instance.new("Frame")
	self.BackFrame.Position = (UseInset and InsetPosition or DefaultPosition)
	self.BackFrame.Size = (UseInset and InsetSize or DefaultSize)
	self.BackFrame.Name = "BackFrame"
	self.BackFrame.Transparency = 1

	self.ListLayout = Instance.new("UIListLayout")
	self.ListLayout.Padding = UDim.new(0, 2)
	self.ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	self.ListLayout.Parent = self.BackFrame

	self.m_Indent = 0

	self.DidUpdate = false

	-- Decide if we should re-render this frame
	self.m_State = ""
	self.m_PreviousState = ""

	self.m_RenderGroup = {}
	self.m_ItemPool = {}

	return self
end

function ImOverlay:Begin(Text: string, BackgroundColor: Color3?, TextColor: Color3?)
	if not Text or type(Text) ~= "string" then
		warn("Expected text to ImOverlay::Begin", debug.traceback())
		return
	end

	if BackgroundColor and typeof(BackgroundColor) ~= "Color3" then
		warn("BackgroundColor should be a Color3", debug.traceback())
		return
	end

	if TextColor and typeof(TextColor) ~= "Color3" then
		warn("TextColor should be a Color3", debug.traceback())
		return
	end

	self:Text(Text, BackgroundColor, TextColor)
	self.m_Indent += 1
end

function ImOverlay:End()
	if self.m_Indent - 1 < 0 then
		error("Too many callbacks to ImOverlay::End")
		return
	end

	self.m_Indent -= 1
end

function ImOverlay:Text(Text: string, BackgroundColor: Color3?, TextColor: Color3?)
	if not Text or type(Text) ~= "string" then
		warn("Expected text to ImOverlay::Text", debug.traceback())
		return
	end

	if BackgroundColor and typeof(BackgroundColor) ~= "Color3" then
		warn("BackgroundColor should be a Color3", debug.traceback())
		return
	end

	if TextColor and typeof(TextColor) ~= "Color3" then
		warn("TextColor should be a Color3", debug.traceback())
		return
	end

	BackgroundColor = BackgroundColor or Color3.new()
	TextColor = TextColor or Color3.new(1, 1, 1)

	table.insert(self.m_RenderGroup, {
		Text = Text,
		TextColor = TextColor,
		BackgroundColor = BackgroundColor,
		Indent = self.m_Indent,
	})

	self.m_State ..= `{Text}|{TextColor}|{BackgroundColor}|{self.m_Indent}`
end

function ImOverlay:m_Pool()

	
for _, Obj in self.BackFrame:GetChildren() do
		if Obj:IsA("UIListLayout") or not Obj.Visible then
			continue
		end

		-- Quicker to change visibility than to re-parent
		Obj.Visible = false
		table.insert(self.m_ItemPool, Obj)
	end

end

function ImOverlay:m_Cleanup()
	
self.m_State = ""
	self.m_Indent = 0
	self.m_RenderGroup = {}

end

function ImOverlay:m_CreateLabel(Text: string, TextColor: Color3, BackgroundColor: Color3, Indent: number): Frame
	
local background = Instance.new("Frame")
	background.Name = "Background"
	background.AutomaticSize = Enum.AutomaticSize.XY
	background.BackgroundColor3 = BackgroundColor
	background.BackgroundTransparency = 0.4
	background.BorderSizePixel = 0

	local taskText = Instance.new("TextLabel")
	taskText.Name = "TaskText"
	taskText.FontFace = Font
	taskText.Text = Text
	taskText.TextColor3 = TextColor
	taskText.TextSize = self.TextSize
	taskText.TextXAlignment = Enum.TextXAlignment.Left
	taskText.AutomaticSize = Enum.AutomaticSize.XY
	taskText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	taskText.BackgroundTransparency = 1
	taskText.Position = UDim2.fromOffset(50 * Indent, 0)
	taskText.Size = UDim2.fromOffset(0, self.DefaultY)
	taskText.Parent = background

	local uIPadding2 = Instance.new("UIPadding")
	uIPadding2.Name = "UIPadding"
	uIPadding2.PaddingBottom = UDim.new(0, 2)
	uIPadding2.Parent = taskText

	local uIPadding = Instance.new("UIPadding")
	uIPadding.Name = "UIPadding"
	uIPadding.PaddingRight = UDim.new(0, 5)
	uIPadding.PaddingLeft = UDim.new(0, 5)
	uIPadding.Parent = background
	
return background
end

function ImOverlay:Render()
	-- We arent doing anything this frame
	
if self.m_State == "" then
		self:m_Pool()
		self:m_Cleanup()
		self.DidUpdate = false
		
return
	end

	self.m_State ..= `{self.DefaultY}|{self.TextSize}`

	if self.m_State == self.m_PreviousState then
		self:m_Cleanup()
		self.DidUpdate = false
		
return
	else
		self:m_Pool()
	end

	self.m_PreviousState = self.m_State
	self.DidUpdate = true

	for i, Render in self.m_RenderGroup do
		
if #self.m_ItemPool == 0 then
			local Label = self:m_CreateLabel(Render.Text, Render.TextColor, Render.BackgroundColor, Render.Indent)
			Label.LayoutOrder = i
			Label.Parent = self.BackFrame
			
continue
		end
		

local Label = table.remove(self.m_ItemPool, #self.m_ItemPool)
		local TaskText = Label.TaskText

		Label.LayoutOrder = i
		Label.BackgroundColor3 = Render.BackgroundColor
		TaskText.Text = Render.Text
		TaskText.TextColor3 = Render.TextColor
		TaskText.Position = UDim2.fromOffset(50 * Render.Indent, 0)

		Label.Visible = true
		Label.Parent = self.BackFrame
	


end

	self:m_Cleanup()


end

function ImOverlay:Destroy()
	self.BackFrame:Destroy()

	setmetatable(self, nil)
end

return ImOverlay

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay.CeiveImOverlay

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.DebugUi | Enabled: N/A
--------------------------------------------------------------------
-- -------------------------------------------------------------------------- --
--                      Iris runtime editor for SmartBone                     --
-- -------------------------------------------------------------------------- --

local EditingBones = {}
local EditingColliders = {}

-- Title, Description, Flag
local DebugFlags = {
	{ "Draw Internal Bone", "Draws a sphere with the specified radius of the bone around where SmartBone believes the bone is.", "DRAW_BONE" },
	{ "Draw Physical Bone", "Draws the actual bone objects CFrame with axis arrows.", "DRAW_PHYSICAL_BONE" },
	{ "Draw Root Part", "Draws a bounding box and fills in the root part.", "DRAW_ROOT_PART" },
	{ "Draw Bounding Box", "Draws the bounding box used for frustum culling.", "DRAW_BOUNDING_BOX" },
	{ "Draw Axis Limits", "Draws the axis limits for each bone.", "DRAW_AXIS_LIMITS" },
	{ "Draw Rotation Limits", "Draws the rotation limits for each bone.", "DRAW_ROTATION_LIMITS" },
	{ "Draw Acceleration Info", "Draws the acceleration and the required values to derive it.", "DRAW_ACCELERATION_INFO" },
	{ "Draw Colliders", "Draws all the colliders this root object can collide with.", "DRAW_COLLIDERS" },
	{ "Draw Collider Influence", "Shows the sphere of influence around each collider.", "DRAW_COLLIDER_INFLUENCE" },
	{ "Draw Collider Awake", "Shows if a collider is awake or asleep.", "DRAW_COLLIDER_AWAKE" },
	{ "Draw Collider BroadPhase", "Shows if a collider isn't reaching NarrowPhase.", "DRAW_COLLIDER_BROADPHASE" },
	{ "Draw Fill Colliders", "Fills all colliders this root object can collide with.", "DRAW_FILL_COLLIDERS" },
	{ "Draw Contacts", "Draws the position and normal of the points which bones collide with colliders.", "DRAW_CONTACTS" },
}

local function infoText(Iris, text)
	Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
	Iris.Text({ text })
	Iris.PopConfig()
end

local function helpMarker(Iris, helpText)
	Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
	local text = Iris.Text({ "(?)" })
	Iris.PopConfig()

	Iris.PushConfig({ ContentWidth = UDim.new(0, 350) })
	if text.hovered() then
		Iris.Tooltip({ helpText })
	end
	Iris.PopConfig()
end

local function BoneEditor(Iris, BoneObject)
	local Window = Iris.Window({ `Editing bone: {BoneObject.Bone.Name}` })
	Window.isOpened.value = true

	local Radius = Iris.InputNum({ "Radius", 0.1, 0, math.huge, "%.3f" }, { number = BoneObject.Radius })
	BoneObject.Radius = Radius.number.value

	local RotationLimit = Iris.InputNum({ "Rotation Limit", 0.1, 0, 180, "%.3f" }, { number = BoneObject.RotationLimit })
	BoneObject.RotationLimit = RotationLimit.number.value

	local IsAnchored = Iris.Checkbox({ "Anchored" }, { isChecked = BoneObject.Anchored })
	BoneObject.Anchored = IsAnchored.isChecked.value

	Iris.Text("Axis Lock")
	Iris.Indent()

	Iris.SameLine()
	Iris.Text("X: ")
	local XLock = Iris.Checkbox({ "" }, { isChecked = BoneObject.AxisLocked[1] })
	Iris.Text("Y: ")
	local YLock = Iris.Checkbox({ "" }, { isChecked = BoneObject.AxisLocked[2] })
	Iris.Text("Z: ")
	local ZLock = Iris.Checkbox({ "" }, { isChecked = BoneObject.AxisLocked[3] })
	Iris.End()

	Iris.End()

	local XLimit = Iris.State(Vector2.new(BoneObject.XAxisLimits.Min, BoneObject.XAxisLimits.Max))
	local YLimit = Iris.State(Vector2.new(BoneObject.YAxisLimits.Min, BoneObject.YAxisLimits.Max))
	local ZLimit = Iris.State(Vector2.new(BoneObject.ZAxisLimits.Min, BoneObject.ZAxisLimits.Max))

	Iris.Text("Axis Limits")
	Iris.Indent()

	Iris.DragVector2({ "X Axis Limit", 0.05, nil, nil, { "Min: %.2f", "Max: %.2f" } }, { number = XLimit })
	Iris.DragVector2({ "Y Axis Limit", 0.05, nil, nil, { "Min: %.2f", "Max: %.2f" } }, { number = YLimit })
	Iris.DragVector2({ "Z Axis Limit", 0.05, nil, nil, { "Min: %.2f", "Max: %.2f" } }, { number = ZLimit })

	Iris.End()

	Iris.End()

	BoneObject.AxisLocked[1] = XLock.isChecked.value
	BoneObject.AxisLocked[2] = YLock.isChecked.value
	BoneObject.AxisLocked[3] = ZLock.isChecked.value

	BoneObject.XAxisLimits = NumberRange.new(XLimit:get().X, XLimit:get().Y)
	BoneObject.YAxisLimits = NumberRange.new(YLimit:get().X, YLimit:get().Y)
	BoneObject.ZAxisLimits = NumberRange.new(ZLimit:get().X, ZLimit:get().Y)

	if Window.closed() then
		EditingBones[BoneObject] = nil
	end
end

local function ColliderEditor(Iris, Collider)
	local Window = Iris.Window({ `Editing collider of type: {Collider.Type}` })
	Window.isOpened.value = true

	local ColliderType = Iris.State(Collider.Type)
	local ColliderScale = Iris.State(Collider.Scale)
	local ColliderOffset = Iris.State(Collider.Offset)
	local ColliderRotation = Iris.State(Collider.Rotation)

	Iris.Combo({ "Collider Type" }, { index = ColliderType })
	Iris.Selectable({ "Box", "Box" }, { index = ColliderType })
	Iris.Selectable({ "Sphere", "Sphere" }, { index = ColliderType })
	Iris.Selectable({ "Capsule", "Capsule" }, { index = ColliderType })
	Iris.End()

	Iris.DragVector3({ "Scale", 0.1, 0, nil }, { number = ColliderScale })
	Iris.DragVector3({ "Offset", 0.1, nil, nil }, { number = ColliderOffset })
	Iris.DragVector3({ "Rotation", 0.5, -180, 180 }, { number = ColliderRotation })

	Collider.Type = ColliderType:get()
	Collider.Scale = ColliderScale:get()
	Collider.Offset = ColliderOffset:get()
	Collider.Rotation = ColliderRotation:get()

	Iris.End()

	if Window.closed() then
		EditingColliders[Collider] = nil
	end
end

return function(Iris, RootObject, DebugState)
	local BoneObjects = {}

	for _, BoneTree in RootObject.BoneTrees do
		local RootPart = BoneTree.RootPart

		local TreeTable = BoneObjects[RootPart]

		if not TreeTable then
			BoneObjects[RootPart] = {}
			TreeTable = BoneObjects[RootPart]
		end

		table.insert(TreeTable, BoneTree)
	end

	for Bone, _ in EditingBones do
		local BoneId = `{RootObject.ID} - {Bone.ParentIndex + 1}`

		Iris.PushId(BoneId)
		BoneEditor(Iris, Bone)
		Iris.PopId()
	end

	for Collider, _ in EditingColliders do
		local ColliderId = Collider.GUID

		Iris.PushId(ColliderId)
		ColliderEditor(Iris, Collider)
		Iris.PopId()
	end

	local BoneTreeCount = #RootObject.BoneTrees
	local ColliderCount = #RootObject.ColliderObjects

	local BoneTreeText = `{BoneTreeCount} BoneTree{BoneTreeCount == 1 and "" or "s"}`
	local ColliderText = `{ColliderCount} Collider{ColliderCount == 1 and "" or "s"}`

	Iris.Window({ `SmartBone Runtime Editor. {BoneTreeText}, {ColliderText}`, [Iris.Args.Window.NoClose] = true })

	Iris.Tree({ "Debug Gizmos", true }, { isUncollapsed = true })

	for _, Flag in DebugFlags do
		Iris.SameLine()
		Iris.Checkbox({ Flag[1] }, { isChecked = DebugState[Flag[3] ] })
		helpMarker(Iris, Flag[2])
		Iris.End()
	end

	Iris.End()

	Iris.Separator()

	infoText(Iris, "Simulated Objects")

	for RootPart, TreeTable in BoneObjects do
		Iris.Tree(`{RootPart.Name} - Root Part`)

		for i, BoneTree in TreeTable do
			Iris.Tree(`BoneTree #{i}`)
			local ThrottledFps = string.format("%.1f", BoneTree.UpdateRate)
			local TargetFps = string.format("%.1f", BoneTree.Settings.UpdateRate)

			infoText(Iris, `Throttled Update Rate: {ThrottledFps} / {TargetFps} fps`)
			infoText(Iris, `In View: {BoneTree.InView}`)

			local ConstraintIndex = Iris.State(BoneTree.Settings.Constraint)
			local WindIndex = Iris.State(BoneTree.Settings.WindType)

			local UpdateRate = Iris.State(BoneTree.Settings.UpdateRate)
			local ActivationDistance = Iris.State(BoneTree.Settings.ActivationDistance)
			local ThrottleDistance = Iris.State(BoneTree.Settings.ThrottleDistance)

			Iris.SameLine()
			helpMarker(Iris, "The constraint used, distance is more flowy while spring is more rigid.")
			Iris.Combo({ "Constraint Type" }, { index = ConstraintIndex })
			Iris.Selectable({ "Distance", "Distance" }, { index = ConstraintIndex })
			Iris.Selectable({ "Spring", "Spring" }, { index = ConstraintIndex })
			Iris.End()
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The wind solver used, sine is a smoother wind, noise is more chaotic and hybrid is a mix of the two.")
			Iris.Combo({ "Wind Type" }, { index = WindIndex })
			Iris.Selectable({ "Sine", "Sine" }, { index = WindIndex })
			Iris.Selectable({ "Noise", "Noise" }, { index = WindIndex })
			Iris.Selectable({ "Hybrid", "Hybrid" }, { index = WindIndex })
			Iris.End()
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The target update rate for the bone tree")
			Iris.SliderNum({ "Update Rate", 5, 0, 120 }, { number = UpdateRate })
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The distance at which the bone tree stops updating")
			Iris.SliderNum({ "Activation Distance", 1, 0, 500 }, { number = ActivationDistance })
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The distance at which the bone tree starts throttling its update rate")
			Iris.SliderNum({ "Throttle Distance", 1, 0, 500 }, { number = ThrottleDistance })
			Iris.End()

			BoneTree.Settings.Constraint = ConstraintIndex:get()
			BoneTree.Settings.WindType = WindIndex:get()
			BoneTree.Settings.UpdateRate = UpdateRate:get()
			BoneTree.Settings.ActivationDistance = ActivationDistance:get()
			BoneTree.Settings.ThrottleDistance = ThrottleDistance:get()

			Iris.Table({ 4, false, false, false })

			Iris.NextColumn()
			Iris.Text("Bone #")
			Iris.NextColumn()
			Iris.Text("Bone Name")
			Iris.NextColumn()
			Iris.Text("Parent #")
			Iris.NextColumn()
			Iris.Text("Edit")

			Iris.End()

			Iris.Table({ 4 })

			for Index, Bone in BoneTree.Bones do
				-- if Index == #BoneTree.Bones then
				-- 	break
				-- end

				Iris.NextColumn()
				Iris.Text(tostring(Index))
				Iris.NextColumn()
				Iris.Text(Bone.Bone.Name)
				Iris.NextColumn()
				Iris.Text(tostring(Bone.ParentIndex))
				Iris.NextColumn()
				Iris.SameLine()
				Iris.Text("")
				if Iris.SmallButton({ "Edit" }).clicked() then
					EditingBones[Bone] = true
				end
				Iris.End()
			end

			Iris.End()
			Iris.End()
		end

		Iris.End()
	end

	infoText(Iris, "Active Colliders")

	for _, ColliderObject in RootObject.ColliderObjects do
		Iris.Tree({ ColliderObject.m_Object.Name })

		infoText(Iris, "Colliders adorned to this object")

		Iris.Table({ 5, false, false, false })
		Iris.NextColumn()
		Iris.Text("Type")
		Iris.NextColumn()
		Iris.Text("Scale")
		Iris.NextColumn()
		Iris.Text("Offset")
		Iris.NextColumn()
		Iris.Text("Rotation")
		Iris.NextColumn()
		Iris.Text("Edit")
		Iris.End()

		Iris.Table({ 5 })

		for _, Collider in ColliderObject.Colliders do
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Type))
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Scale))
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Offset))
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Rotation))
			Iris.NextColumn()
			Iris.SameLine()
			Iris.Text("")
			if Iris.SmallButton({ "Edit" }).clicked() then
				EditingColliders[Collider] = true
			end
			Iris.End()
		end

		Iris.End()

		Iris.End()
	end

	Iris.End()
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.DebugUi

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Bone | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
--!native
local Dependencies = script.Parent.Parent:WaitForChild("Dependencies")
local Config = require(Dependencies:WaitForChild("Config"))
local Gizmo = require(Dependencies:WaitForChild("Debug"):WaitForChild("Gizmo"))
local Utilities = require(Dependencies:WaitForChild("Utilities"))

local Constraints = script.Parent:WaitForChild("Constraints")
local AxisConstraint = require(Constraints:WaitForChild("AxisConstraint"))
local CollisionConstraint = require(Constraints:WaitForChild("CollisionConstraint"))
local DistanceConstraint = require(Constraints:WaitForChild("DistanceConstraint"))
local FrictionConstraint = require(Constraints:WaitForChild("FrictionConstraint"))
local RopeConstraint = require(Constraints:WaitForChild("RopeConstraint"))
local RotationConstraint = require(Constraints:WaitForChild("RotationConstraint"))
local SpringConstraint = require(Constraints:WaitForChild("SpringConstraint"))

local SB_ASSERT_CB = Utilities.SB_ASSERT_CB
--local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG

-- HACK
local MAX_SPEED = 50

local function SafeUnit(Vector: Vector3): Vector3
	if Vector.Magnitude == 0 then
		return Vector3.zero
	else
		return Vector.Unit
	end
end

type bool = boolean

type ImOverlay = {
	Begin: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: () -> (),
	Text: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> ()
}

export type IBone = {
	Bone: Bone,
	RootBone: Bone,
	RootPart: BasePart,
	FreeLength: number,
	Weight: number,
	ParentIndex: number,
	HeirarchyLength: number,
	Transform: CFrame,
	LocalTransform: CFrame,
	Radius: number,
	Friction: number,
	RotationLimit: number,
	Force: Vector3?,
	Gravity: Vector3?,

	SolvedAnimatedCFrame: bool,
	HasChild: bool,
	--NumberOfChildren: number,
	IsSkippingUpdates: bool,

	--RotationSum: Vector3,

	AnimatedWorldCFrame: CFrame,
	TransformOffset: CFrame,
	LocalTransformOffset: CFrame,
	RestPosition: Vector3,
	CalculatedWorldCFrame: CFrame,

	Position: Vector3,
	LastPosition: Vector3,

	ActiveWeld: bool,
	WeldPosition: Vector3,
	WeldCFrame: CFrame,

	Anchored: bool,
	AxisLocked: { [number]: bool },
	XAxisLimits: NumberRange,
	YAxisLimits: NumberRange,
	ZAxisLimits: NumberRange,

	CollisionHits: { [number]: BasePart }
}

local function IsNaN(Value: any): bool
	if Value ~= Value then
		return true
	end

	return false
end

local SolvedTransformedCFrames = {}

-- I beg roblox to make TransformedWorldCFrame parallel safe
local function QueryTransformedWorldCFrameNonSmartbone(OriginBone: Bone): CFrame
	
local Solved = SolvedTransformedCFrames[OriginBone]
	if Solved then
		if Solved.Frame == shared.FrameCounter then
			return Solved.CFrame
		end
	end

	local Parent = OriginBone.Parent :: Bone | BasePart
	local ParentCFrame

	if Parent:IsA("Bone") then
		ParentCFrame = QueryTransformedWorldCFrameNonSmartbone(Parent)
	else -- This should always be a basepart unless someone has the weirdest model setup ever. If that person is you, why?
		ParentCFrame = Parent.CFrame
	end

	local Result = ParentCFrame * OriginBone.TransformedCFrame

	SolvedTransformedCFrames[OriginBone] = { Frame = shared.FrameCounter, CFrame = Result }
	

return Result
end

-- Gets transformedworldcframe using the parents animatedcframe instead of traversing the tree of bones for each bone, increases performance a ton
local function QueryTransformedWorldCFrame(BoneTree, Bone: IBone): CFrame
	
Bone.SolvedAnimatedCFrame = true

	local ParentIndex = Bone.ParentIndex
	local BoneObject = Bone.Bone

	if ParentIndex < 1 then -- We are no longer in the smartbone tree
		
return QueryTransformedWorldCFrameNonSmartbone(BoneObject)
	end

	local ParentBone: IBone = BoneTree.Bones[ParentIndex]

	if not ParentBone.SolvedAnimatedCFrame then
		ParentBone.AnimatedWorldCFrame = QueryTransformedWorldCFrame(BoneTree, ParentBone)
	end
	

return ParentBone.AnimatedWorldCFrame * BoneObject.TransformedCFrame
end

local function ClipVector(LastPosition: Vector3, Position: Vector3, Vector: Vector3): Vector3
	LastPosition *= (Vector3.one - Vector)
	LastPosition += (Position * Vector)
	return LastPosition
end

local function GetFriction(Object0: BasePart, Object1: BasePart): number
	local Prop0 = Object0.CurrentPhysicalProperties
	local Prop1 = Object1.CurrentPhysicalProperties

	local f0 = Prop0.Friction
	local w0 = Prop0.FrictionWeight

	local f1 = Prop1.Friction
	local w1 = Prop1.FrictionWeight

	return (f0 * w0 + f1 * w1) / (w0 + w1)
end

local function SolveWind(self: IBone, BoneTree: any, Velocity: Vector3): Vector3
	
local Settings = BoneTree.Settings
	local WindType = Settings.WindType

	if WindType ~= "Sine" and WindType ~= "Noise" and WindType ~= "Hybrid" then
		
return Vector3.zero -- If the wind type the user inputted doesn't exist, I would throw an error / warn but that would crash studio :(
	end

	local TimeModifier = BoneTree.WindOffset
		+ (
			((os.clock() - (self.HeirarchyLength * 0.2)) + (self.TransformOffset.Position - BoneTree.Root.WorldPosition).Magnitude * 0.2) -- * 0.2 is / 5
			* Settings.WindInfluence
		)

	local WindSpeed = Settings.WindSpeed
	local WindStrength = Settings.WindStrength

	if WindSpeed <= 1e-6 or WindStrength <= 1e-6 then
		
return Vector3.zero
	end

	-- Velocity multiplier
	local WindDirection = Settings.WindDirection
	local VelocityDirection = SafeUnit(Velocity)
	


local WindDamper = 1 - math.abs(VelocityDirection:Dot(WindDirection))

	-- This section of code manages the following:
	-- If we are going into the wind then if our bone speed is the same as the wind speed then we should apply double the wind speed, contrary
	-- If we are going with the wind if our bone speed is the same as the wind speed then we wind speed should be zero for this bone.
	if WindSpeed > 0 then
		if VelocityDirection:Dot(WindDirection) > 0 then -- Going with the wind
			local SpeedMatch = 1 - Velocity.Magnitude / WindSpeed
			WindDamper *= math.abs(SpeedMatch)
		else -- Going against the wind
			local SpeedMatch = 1 + Velocity.Magnitude / WindSpeed
			WindDamper *= SpeedMatch
		end
	end

	
WindSpeed *= WindDamper

	local function EaseInExpo(x: number): number
		return x == 0 and 0 or 2 ^ (10 * x - 10)
	end

	local SpeedAlpha = Velocity.Magnitude < 100 and Velocity.Magnitude or 100
	local SpeedMultiplier = math.min(EaseInExpo(SpeedAlpha), 100)
	TimeModifier *= math.max(SpeedMultiplier, 1)

	if WindSpeed < 1 then
		WindSpeed *= SpeedMultiplier
	else
		local Mult = SpeedMultiplier / 2
		WindSpeed *= (Mult > 1 and Mult or 1)
	end

	local WindMove

	local function GetNoise(X, Y, Z, Map) -- Returns noise between 0, 1
		
local Value = math.noise(X, Y, Z)
		Value = math.clamp(Value, -1, 1)

		if Map then
			Value ^= 2
		end
		
return Value
	end

	local function SampleGust()
		local Length = 0.3
		local Freq = 1
		return math.sin(TimeModifier * Freq) * Length + (1 - Length)
	end

	local function SampleSin()
		
local Freq = WindStrength ^ 0.8
		local Power = WindSpeed * 2

		-- Multiple octaves of sin waves
		local Sin0 = math.sin(TimeModifier * Freq)
		local Sin1 = math.cos(TimeModifier / 10 * Freq)
		local Sin2 = math.sin(TimeModifier * 2 * Freq)
		local Sin3 = math.cos(TimeModifier * 3 * Freq)
		local Wave = (Sin0 + Sin1 + Sin2 + Sin3) / 4
		local ScaledWave = Wave * 0.5 + 0.5
		Wave *= Power
		ScaledWave *= Power
		
return WindDirection * (ScaledWave > Wave and ScaledWave or Wave)
	end

	local function SampleNoise(CustomAmp, Map)
		
CustomAmp = CustomAmp or 0

		local Freq = WindStrength ^ 0.8
		local Power = WindSpeed * 2
		local Seed = BoneTree.WindOffset

		local X = GetNoise(Freq, 0, Seed, Map) * (Power + CustomAmp)
		local Y = GetNoise(0, Freq, Seed, Map) * (Power + CustomAmp)
		local Z = GetNoise(Seed, 0, Freq, Map) * (Power + CustomAmp)
		
return WindDirection * Vector3.new(X, Y, Z)
	end
	

if Settings.WindType == "Sine" then
		
WindMove = SampleSin() * SampleGust()
	
elseif Settings.WindType == "Noise" then
		
WindMove = SampleNoise(0, true) * SampleGust()
	
elseif Settings.WindType == "Hybrid" then
		
WindMove = SampleSin() * SampleGust()
		WindMove += SampleNoise(0.5, true) * SampleGust()
		WindMove *= 0.5
	
end

	
WindMove /= self.FreeLength < 0.01 and 0.01 or self.FreeLength
	WindMove *= (Settings.WindInfluence * (WindStrength * 0.01)) * (math.clamp(self.HeirarchyLength, 1, 10) * 0.1)
	WindMove *= self.Weight
	

return WindMove
end

--- @class Bone
--- Internal class for all bones
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within Bone
--- @readonly
--- @prop Bone Bone

--- @within Bone
--- @prop FreeLength number

--- @within Bone
--- @prop Weight number

--- @within Bone
--- @readonly
--- @prop ParentIndex number

--- @within Bone
--- @readonly
--- @prop HeirarchyLength number

--- @within Bone
--- @prop Transform CFrame

--- @within Bone
--- @prop LocalTransform CFrame

--- @within Bone
--- @readonly
--- @prop RootPart BasePart

--- @within Bone
--- @readonly
--- @prop RootBone Bone

--- @within Bone
--- @prop Radius number

--- @within Bone
--- @prop Friction number

--- @within Bone
--- @prop RotationLimit number

--- @within Bone
--- @prop Force Vector3?

--- @within Bone
--- @prop Gravity Vector3?

--- @within Bone
--- @prop SolvedAnimatedCFrame boolean
--- Describes if this bone has already solved its animated world cframe, this is used for optimization.

--- @within Bone
--- @prop HasChild boolean

--- @within Bone
--- @readonly
--- @prop AnimatedWorldCFrame CFrame
--- Bone.TransformedWorldCFrame

--- @within Bone
--- @prop StartingCFrame CFrame

--- @within Bone
--- @readonly
--- @prop TransformOffset CFrame

--- @within Bone
--- @readonly
--- @prop LocalTransformOffset CFrame

--- @within Bone
--- @readonly
--- @prop RestPosition Vector3

--- @within Bone
--- @readonly
--- @prop CalculatedWorldCFrame CFrame

--- @within Bone
--- @prop Position Vector3
--- Internal representation of the bone

--- @within Bone
--- @prop LastPosition Vector3
--- Internal representation of the bone's position last frame

--- @within Bone
--- @prop WeldPosition Vector3

--- @within Bone
--- @prop WeldCFrame CFrame

--- @within Bone
--- @prop ActiveWeld boolean
--- Describes if this bone has a weld

--- @within Bone
--- @prop RigidWeld boolean
--- If the bone has a weld, is it rigid

--- @within Bone
--- @prop Anchored boolean

--- @within Bone
--- @prop AxisLocked { boolean, boolean, boolean }
--- XYZ order

--- @within Bone
--- @prop XAxisLimits NumberRange

--- @within Bone
--- @prop YAxisLimits NumberRange

--- @within Bone
--- @prop ZAxisLimits NumberRange

--- @within Bone
--- @prop IsSkippingUpdates boolean

--- @within Bone
--- @prop CollisionHits {}

--- @within Bone
--- @prop CollisionData {}
--- Debug property, holds information about the collisions that the bone had this frame

local Class = {}
Class.__index = Class

function Class.new(Bone: Bone, RootBone: Bone, RootPart: BasePart): IBone
	local ParentCFrame = Bone.Parent:IsA("Bone") and Bone.Parent.TransformedWorldCFrame or RootPart.CFrame

	local self = setmetatable({
		Bone = Bone,
		FreeLength = -1,
		Weight = 0.7,
		ParentIndex = -1,
		HeirarchyLength = 0,
		Transform = Bone.TransformedWorldCFrame:ToObjectSpace(ParentCFrame):Inverse(),
		LocalTransform = Bone.TransformedCFrame:ToObjectSpace(RootBone.TransformedCFrame):Inverse(),
		RootPart = RootPart,
		RootBone = RootBone,
		Radius = 0,
		Friction = 0,
		RotationLimit = 0,
		Force = nil,
		Gravity = nil,

		SolvedAnimatedCFrame = false,
		HasChild = false,
		--NumberOfChildren = 0,
		--RotationSum = Vector3.zero,

		AnimatedWorldCFrame = Bone.TransformedWorldCFrame,
		StartingCFrame = Bone.TransformedCFrame,
		TransformOffset = CFrame.identity,
		LocalTransformOffset = CFrame.identity,
		RestPosition = Vector3.zero,
		CalculatedWorldCFrame = Bone.TransformedWorldCFrame,

		Position = Bone.TransformedWorldCFrame.Position,
		LastPosition = Bone.TransformedWorldCFrame.Position,

		WeldPosition = Vector3.zero,
		WeldCFrame = CFrame.identity,
		ActiveWeld = false,
		RigidWeld = false,

		Anchored = false,
		AxisLocked = { false, false, false },
		XAxisLimits = NumberRange.new(-math.huge, math.huge),
		YAxisLimits = NumberRange.new(-math.huge, math.huge),
		ZAxisLimits = NumberRange.new(-math.huge, math.huge),

		IsSkippingUpdates = false,

		CollisionHits = {},

		-- Debug
		CollisionsData = {},
	}, Class)

	self.AttributeConnection = Bone.AttributeChanged:Connect(function(Attribute)
		-- Do this cause of axis lock
		local Settings = Utilities.GatherBoneSettings(Bone)

		for k, v in Settings do
			-- Â¬ represents a nil value, this is done so we can delete attributes at runtime.
			self[k] = (v ~= "Â¬") and v or nil
		end
	end)

	return self :: IBone
end

--- @within Bone
--- @param Position Vector3
--- @param Vector Vector3
--- Clips velocity on specified vector, Position is where we are at our current physics step (Before we set self.Position)
function Class:ClipVelocity(Position: Vector3, Vector: Vector3)
	self.LastPosition = ClipVector(self.LastPosition, Position, Vector)
end

--- @within Bone
--- @param BoneTree BoneTree
function Class:PreUpdate(BoneTree) -- Parallel safe
	
local Root = BoneTree.Bones[1]
	local Parent = BoneTree.Bones[self.ParentIndex]

	self.AnimatedWorldCFrame = QueryTransformedWorldCFrame(BoneTree, self)

	local SmartWeld = self.Bone:FindFirstChild("SmartWeld")

	-- Pyramid of weld
	self.ActiveWeld = false
	if SmartWeld then
		if SmartWeld:IsA("ObjectValue") then
			local WeldTo = SmartWeld.Value

			self.RigidWeld = (SmartWeld:GetAttribute("Rigid") == true) or false

			if WeldTo then
				if WeldTo:IsA("Attachment") then -- Attachment also covers bones
					self.WeldPosition = WeldTo.WorldPosition
					self.WeldCFrame = WeldTo.WorldCFrame
					self.ActiveWeld = true
				elseif WeldTo:IsA("BasePart") then
					self.WeldPosition = WeldTo.Position
					self.WeldCFrame = WeldTo.CFrame
					self.ActiveWeld = true
				end
			end
		end
	end

	if self.ParentIndex < 1 then -- Force anchor the root bone
		self.Anchored = true
	end

	if self.Bone == self.RootBone then
		-- Curse Non-SmartBone Objects!
		local ParentCFrame

		if self.Bone.Parent:IsA("Bone") then
			ParentCFrame = QueryTransformedWorldCFrameNonSmartbone(self.Bone.Parent)
		else
			ParentCFrame = self.RootPart.CFrame
		end

		self.TransformOffset = ParentCFrame * self.Transform
	else
		self.TransformOffset = Parent.AnimatedWorldCFrame * self.Transform
	end

	self.LocalTransformOffset = Root.Bone.CFrame * self.LocalTransform

end

--- @within Bone
--- @param BoneTree BoneTree
--- @param Force Vector3
--- @param Delta number -- Î”t
--- Force passed in via BoneTree:StepPhysics()
function Class:StepPhysics(BoneTree, Force: Vector3, Delta: number) -- Parallel safe
	
if self.Anchored then
		self.LastPosition = self.AnimatedWorldCFrame.Position
		self.Position = self.AnimatedWorldCFrame.Position
		

return
	end

	-- Custom forces per bone
	if self.Force or self.Gravity then
		
Force = (self.Gravity or BoneTree.Settings.Gravity)

		Force = (Force + (self.Force or BoneTree.Settings.Force))
	
end
	

local Settings = BoneTree.Settings

	local Velocity = (self.Position - self.LastPosition) / Delta
	Velocity = (Velocity.Magnitude > MAX_SPEED and Velocity.Unit * MAX_SPEED or Velocity)

	local Move = BoneTree.ObjectAcceleration * Settings.Inertia
	local WindMove = SolveWind(self, BoneTree, Velocity)
	local Acceleration = Force + Move

	self.LastPosition = self.Position
	--self.Position += (Velocity * (1 - Settings.Damping) + Force + Move) * Delta + WindMove
	self.Position += Velocity * (1 - Settings.Damping) * Delta + Acceleration * Delta * Delta + WindMove


end

--- @within Bone
--- @param BoneTree BoneTree
--- @param ColliderObjects { ColliderObject }
--- @param Delta number -- Î”t
function Class:Constrain(BoneTree, ColliderObjects, Delta: number) -- Parallel safe
	
if self.Anchored then
		
return
	end

	local Position = self.Position
	local RootPart = self.RootPart
	local RootCFrame: CFrame = RootPart.CFrame

	-- Friction must be first
	Position = FrictionConstraint(self, Position, self.LastPosition)

	if #ColliderObjects ~= 0 then
		Position = CollisionConstraint(self, Position, ColliderObjects)
	end

	if BoneTree.Settings.Constraint == "Spring" then
		Position = SpringConstraint(self, Position, nil, BoneTree, Delta)
	elseif BoneTree.Settings.Constraint == "Distance" then
		Position = DistanceConstraint(self, Position, BoneTree)
	elseif BoneTree.Settings.Constraint == "Rope" then
		Position = RopeConstraint(self, Position, BoneTree)
	else
		-- Go to anchored position if our constraint type is incorrect
		Position = self.AnimatedWorldCFrame.Position
	end

	Position = AxisConstraint(self, Position, self.LastPosition, RootCFrame)

	Position = RotationConstraint(self, Position, BoneTree)

	if self.ActiveWeld then
		if self.RigidWeld then
			-- Solve Transform has the rest of this implementation.
			Position = self.WeldPosition
		else
			Position = SpringConstraint(self, Position, self.WeldPosition, BoneTree, Delta)
		end
	end

	self.Friction = 0

	for _, HitPart in self.CollisionHits do
		-- Use whatever object has the higher friction
		local Friction = GetFriction(self.RootPart, HitPart)
		self.Friction = Friction < self.Friction and self.Friction or Friction
	end

	self.Position = Position

end

--- @within Bone
--- Returns bone to rest position
function Class:SkipUpdate()
	if self.IsSkippingUpdates == false and Config.RESET_TRANSFORM_ON_SKIP then
		--SB_VERBOSE_LOG("Skipping bone, resetting transform.")
		self.CalculatedWorldCFrame = self.AnimatedWorldCFrame
		self.IsSkippingUpdates = true
	end

	self.LastPosition = self.AnimatedWorldCFrame.Position + (self.LastPosition - self.Position)
	self.Position = self.AnimatedWorldCFrame.Position
end

--- @within Bone
--- @param BoneTree BoneTree
--- @param Delta number -- Î”t
--- Solves the cframe of the bones
function Class:SolveTransform(BoneTree, Delta: number) -- Parallel safe
	
if self.ParentIndex < 1 then
		
return
	end

	self.IsSkippingUpdates = false

	local ParentBone: IBone = BoneTree.Bones[self.ParentIndex]
	local BoneParent = ParentBone.Bone

	if ParentBone and BoneParent then
		local ReferenceCFrame = ParentBone.TransformOffset
		local v1 = self.Position - ParentBone.Position
		local Rotation = Utilities.GetRotationBetween(ReferenceCFrame.UpVector, v1).Rotation * ReferenceCFrame.Rotation

		local factor = 0.00001
		local alpha = math.min(1 - factor ^ Delta, 1)

		--local ShouldAverage = ParentBone.NumberOfChildren > 1

		if ParentBone.ActiveWeld and ParentBone.RigidWeld then
			ParentBone.CalculatedWorldCFrame = ParentBone.WeldCFrame
		--elseif ShouldAverage then
		--	ParentBone.RotationSum += Vector3.new(Rotation:ToEulerAnglesXYZ())
		else
			ParentBone.CalculatedWorldCFrame = BoneParent.WorldCFrame:Lerp(CFrame.new(ParentBone.Position) * Rotation, alpha)
			--ParentBone.CalculatedWorldCFrame = CFrame.new(ParentBone.Position) * Rotation
		end

		SB_ASSERT_CB(not IsNaN(ParentBone.CalculatedWorldCFrame.Position), warn, "If you see this report this as a bug, (NaN Calc world cframe)")
	end

end

--- @within Bone
--- @param BoneTree BoneTree
--- Sets the world cframes of the bones to the calculated world cframe (solved in Bone:SolveTransform())
function Class:ApplyTransform(BoneTree)

	
self.SolvedAnimatedCFrame = false

	if self.ParentIndex < 1 then
		
return
	end

	local ParentBone: IBone = BoneTree.Bones[self.ParentIndex]
	local BoneParent = ParentBone.Bone

	-- We check if the magnitude of rotation sum is zero because that tells us if it has already been averaged by another bone.
	-- if ParentBone.NumberOfChildren > 1 and ParentBone.RotationSum.Magnitude ~= 0 then
	-- 	local AverageRotation = ParentBone.RotationSum / ParentBone.NumberOfChildren
	-- 	ParentBone.CalculatedWorldCFrame = CFrame.new(ParentBone.Position)
	-- 		* CFrame.fromEulerAnglesXYZ(AverageRotation.X, AverageRotation.Y, AverageRotation.Z)
	-- 	ParentBone.RotationSum = Vector3.zero
	-- end

	if ParentBone and BoneParent then
		if ParentBone.Anchored and not BoneTree.Settings.AnchorsRotate then -- Anchored and anchors do not rotate
			BoneParent.WorldCFrame = ParentBone.TransformOffset
		elseif ParentBone.Anchored then -- Anchored and anchors rotate
			BoneParent.WorldCFrame = CFrame.new(ParentBone.Position) * ParentBone.CalculatedWorldCFrame.Rotation
		else -- Not anchored
			BoneParent.WorldCFrame = ParentBone.CalculatedWorldCFrame
		end
	end

end

--- @client
--- @within Bone
--- @param BoneTree any
--- @param DRAW_CONTACTS boolean
--- @param DRAW_PHYSICAL_BONE boolean
--- @param DRAW_BONE boolean
--- @param DRAW_AXIS_LIMITS boolean
--- @param DRAW_ROTATION_LIMIT boolean
function Class:DrawDebug(BoneTree, DRAW_CONTACTS: bool, DRAW_PHYSICAL_BONE: bool, DRAW_BONE: bool, DRAW_AXIS_LIMITS: bool, DRAW_ROTATION_LIMIT: bool)
	
local BONE_POSITION_COLOR = Color3.fromRGB(255, 0, 0)
	local BONE_LAST_POSITION_COLOR = Color3.fromRGB(255, 94, 0)
	local BONE_POSITION_RAY_COLOR = Color3.fromRGB(234, 1, 255)
	local BONE_SPHERE_COLOR = Color3.fromRGB(0, 255, 255)
	local BONE_FRONT_ARROW_COLOR = Color3.fromRGB(255, 0, 0)
	local BONE_UP_ARROW_COLOR = Color3.fromRGB(0, 255, 0)
	local BONE_RIGHT_ARROW_COLOR = Color3.fromRGB(0, 0, 255)
	local ROTATION_CONE_COLOR = Color3.fromRGB(0, 183, 255)
	local AXIS_X_COLOR = Color3.fromRGB(255, 0, 0)
	local AXIS_Y_COLOR = Color3.fromRGB(0, 255, 0)
	local AXIS_Z_COLOR = Color3.fromRGB(0, 0, 255)
	local AXIS_ARROW_RADIUS = 0.05
	local AXIS_ARROW_LENGTH = 0.15

	local COLLISION_CONTACT_SPHERE_COLOR = Color3.fromRGB(28, 41, 224)
	local COLLISION_CONTACT_NORMAL_COLOR = Color3.fromRGB(255, 27, 27)
	local COLLISION_CONTACT_SPHERE_RADIUS = 0.08
	local COLLISION_CONTACT_ARROW_LENGTH = 0.15
	local COLLISION_CONTACT_ARROW_RADIUS = 0.05
	local COLLISION_CONTACT_ARROW_EXPANSION = 0.5

	local BONE_ARROW_LENGTH = 0.05
	local BONE_ARROW_RADIUS = 0.015
	local BONE_CYLINDER_RADIUS = 0.005
	local BONE_ARROW_EXPANSION = 0.25
	local BONE_RADIUS = 0.08

	local ROTATION_CONE_LENGTH = 1

	local BoneCFrame = self.AnimatedWorldCFrame
	local BonePosition = BoneCFrame.Position
	local BonePositionCFrame = CFrame.new(self.Position)
	local BoneLastPositionCFrame = CFrame.new(self.LastPosition)

	-- Draw our internal bone

	if DRAW_BONE then
		Gizmo.PushProperty("AlwaysOnTop", false)

		Gizmo.PushProperty("Color3", BONE_POSITION_COLOR)
		Gizmo.Sphere:Draw(BonePositionCFrame, self.Radius, 10, 360)

		Gizmo.PushProperty("Color3", BONE_LAST_POSITION_COLOR)
		Gizmo.Sphere:Draw(BoneLastPositionCFrame, self.Radius, 10, 360)

		Gizmo.PushProperty("Color3", BONE_POSITION_RAY_COLOR)
		Gizmo.Ray:Draw(self.Position, self.LastPosition)
	end

	-- Draw our axis Limits

	if DRAW_AXIS_LIMITS and not self.Anchored then
		local XLock = self.AxisLocked[1]
		local YLock = self.AxisLocked[2]
		local ZLock = self.AxisLocked[3]

		local RootPart = self.RootPart
		local Offset = RootPart.CFrame:PointToObjectSpace(BonePosition)

		local XVector = RootPart.CFrame.RightVector
		local YVector = RootPart.CFrame.UpVector
		local ZVector = RootPart.CFrame.LookVector

		local Size = Vector3.new(5, 5, 0)

		if not XLock then
			Gizmo.PushProperty("Color3", AXIS_X_COLOR)
			Gizmo.Arrow:Draw(BonePosition - XVector * 2, BonePosition + XVector * 2, AXIS_ARROW_RADIUS, AXIS_ARROW_LENGTH, 9)

			local MinXLimit = self.XAxisLimits.Min - Offset.X
			local MaxXLimit = self.XAxisLimits.Max - Offset.X

			Gizmo.Plane:Draw(BonePosition + XVector * MinXLimit, XVector, Size)
			Gizmo.Plane:Draw(BonePosition + XVector * MaxXLimit, XVector, Size)
		end

		if not YLock then
			Gizmo.PushProperty("Color3", AXIS_Y_COLOR)
			Gizmo.Arrow:Draw(BonePosition - YVector * 2, BonePosition + YVector * 2, AXIS_ARROW_RADIUS, AXIS_ARROW_LENGTH, 9)

			local MinYLimit = self.YAxisLimits.Min - Offset.Y
			local MaxYLimit = self.YAxisLimits.Max - Offset.Y

			Gizmo.Plane:Draw(BonePosition + YVector * MinYLimit, YVector, Size)
			Gizmo.Plane:Draw(BonePosition + YVector * MaxYLimit, YVector, Size)
		end

		if not ZLock then
			Gizmo.PushProperty("Color3", AXIS_Z_COLOR)
			Gizmo.Arrow:Draw(BonePosition - ZVector * 2, BonePosition + ZVector * 2, AXIS_ARROW_RADIUS, AXIS_ARROW_LENGTH, 9)

			local MinZLimit = self.ZAxisLimits.Min - Offset.Z
			local MaxZLimit = self.ZAxisLimits.Max - Offset.Z

			Gizmo.Plane:Draw(BonePosition - ZVector * MinZLimit, ZVector, Size)
			Gizmo.Plane:Draw(BonePosition - ZVector * MaxZLimit, ZVector, Size)
		end
	end

	-- Draw the physical bone object

	if DRAW_PHYSICAL_BONE then
		Gizmo.PushProperty("Color3", BONE_SPHERE_COLOR)
		Gizmo.Sphere:Draw(BoneCFrame, BONE_RADIUS, 5, 360)

		Gizmo.PushProperty("Color3", BONE_FRONT_ARROW_COLOR)
		Gizmo.VolumeArrow:Draw(
			BonePosition,
			BonePosition + BoneCFrame.LookVector * BONE_ARROW_EXPANSION,
			BONE_CYLINDER_RADIUS,
			BONE_ARROW_RADIUS,
			BONE_ARROW_LENGTH,
			true
		)

		Gizmo.PushProperty("Color3", BONE_UP_ARROW_COLOR)
		Gizmo.VolumeArrow:Draw(
			BonePosition,
			BonePosition + BoneCFrame.UpVector * BONE_ARROW_EXPANSION,
			BONE_CYLINDER_RADIUS,
			BONE_ARROW_RADIUS,
			BONE_ARROW_LENGTH,
			true
		)

		Gizmo.PushProperty("Color3", BONE_RIGHT_ARROW_COLOR)
		Gizmo.VolumeArrow:Draw(
			BonePosition,
			BonePosition + BoneCFrame.RightVector * BONE_ARROW_EXPANSION,
			BONE_CYLINDER_RADIUS,
			BONE_ARROW_RADIUS,
			BONE_ARROW_LENGTH,
			true
		)
	end

	-- Draw our collision contacts

	if DRAW_CONTACTS and not self.Anchored then
		for _, Collision in self.CollisionsData do
			Gizmo.PushProperty("Color3", COLLISION_CONTACT_SPHERE_COLOR)
			Gizmo.Sphere:Draw(CFrame.new(Collision.ClosestPoint), COLLISION_CONTACT_SPHERE_RADIUS, 5, 360)

			Gizmo.PushProperty("Color3", COLLISION_CONTACT_NORMAL_COLOR)
			Gizmo.Arrow:Draw(
				Collision.ClosestPoint,
				Collision.ClosestPoint + Collision.Normal * COLLISION_CONTACT_ARROW_EXPANSION,
				COLLISION_CONTACT_ARROW_RADIUS,
				COLLISION_CONTACT_ARROW_LENGTH,
				9
			)
		end
	end

	-- Draw rotation limit

	if DRAW_ROTATION_LIMIT and self.RotationLimit < 180 and self.RotationLimit > 0 and self.ParentIndex > 0 and self.HasChild then
		local ConeRadius
		local InverseDirection = 1
		if self.RotationLimit < 89.5 then
			ConeRadius = ROTATION_CONE_LENGTH * math.tan(math.rad(self.RotationLimit))
		elseif self.RotationLimit > 90 then
			InverseDirection = -1			
ConeRadius = ROTATION_CONE_LENGTH * math.tan(math.rad(180 - self.RotationLimit))
		else
			ROTATION_CONE_LENGTH = 0
			ConeRadius = 5
		end

		ConeRadius = math.min(ConeRadius, 5)

		if ConeRadius == 5 then
			ROTATION_CONE_LENGTH = 0
		end

		local ConeDirection = (self.Position - BoneTree.Bones[self.ParentIndex].Position).Unit * InverseDirection

		local NewBoneCFrame =
			CFrame.lookAt(BonePosition + ConeDirection * (ROTATION_CONE_LENGTH * 0.5), BonePosition + -ConeDirection * 500, BoneCFrame.LookVector)

		Gizmo.PushProperty("Color3", ROTATION_CONE_COLOR)
		Gizmo.Cone:Draw(NewBoneCFrame, ConeRadius, ROTATION_CONE_LENGTH, 8 + ConeRadius * 2)
	end


end

--- @client
--- @within Bone
function Class:DrawOverlay(Overlay: ImOverlay)
	Overlay.Text(`Bone: {self.Bone.Name}`)

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_NUMERICS then
		Overlay.Text(`Free Length: {self.FreeLength}`)
		Overlay.Text(`Weight: {self.Weight}`)
		Overlay.Text(`Parent Index: {self.ParentIndex}`)
		Overlay.Text(`Heirarchy Length: {self.HeirarchyLength}`)
		Overlay.Text(`Radius: {self.Radius}`)
		Overlay.Text(`Friction: {self.Friction}`)
		Overlay.Text(`Rotation Limit: {self.RotationLimit}`)
	end

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_CONSTRAIN then
		Overlay.Text(`Anchored: {self.Anchored}`)
		Overlay.Text(`Axis Locked: {self.AxisLocked[1]}, {self.AxisLocked[2]}, {self.AxisLocked[3]}`)
		Overlay.Text(`X Axis Limit: {self.XAxisLimits}`)
		Overlay.Text(`Y Axis Limit: {self.YAxisLimits}`)
		Overlay.Text(`Z Axis Limit: {self.ZAxisLimits}`)
	end

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_WELD then
		Overlay.Text(`Active Weld: {self.ActiveWeld}`)
		Overlay.Text(`Rigid Weld: {self.RigidWeld}`)
		Overlay.Text(`Weld Position: {string.format("%.3f, %.3f, %.3f", self.WeldPosition.X, self.WeldPosition.Y, self.WeldPosition.Z)}`)
	end

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_FORCES then
		local Force = self.Force and string.format("%.3f, %.3f, %.3f", self.Force.X, self.Force.Y, self.Force.Z) or "-, -, -"
		local Gravity = self.Gravity and string.format("%.3f, %.3f, %.3f", self.Gravity.X, self.Gravity.Y, self.Gravity.Z) or "-, -, -"

		Overlay.Text(`Force: {Force}`)
		Overlay.Text(`Gravity: {Gravity}`)
	end
end

function Class:Destroy()
	if Config.RESET_BONE_ON_DESTROY then
		task.synchronize()
		self.Bone.CFrame = self.StartingCFrame
	end

	self.AttributeConnection:Disconnect()

	setmetatable(self, nil)
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Bone

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.BoneTree | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
--!native

local Lighting = game:GetService("Lighting")
local Dependencies = script.Parent.Parent:WaitForChild("Dependencies")
local BoneClass = require(script.Parent:WaitForChild("Bone"))
local Config = require(Dependencies:WaitForChild("Config"))
local DefaultObjectSettings = require(Dependencies:WaitForChild("DefaultObjectSettings"))
local Gizmo = require(Dependencies:WaitForChild("Debug"):WaitForChild("Gizmo"))
local Utilities = require(Dependencies:WaitForChild("Utilities"))
local MaxVector = Vector3.new(math.huge, math.huge, math.huge)

local WIND_SEED = 1029410295159813
local WIND_RNG = Random.new(WIND_SEED)
local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG

local CollectionService = game:GetService("CollectionService")

export type IBoneTree = {
	WindOffset: number,
	Root: Bone,
	RootPart: BasePart,
	RootPartSize: Vector3,
	Bones: { BoneClass.IBone },
	Settings: { [string]: any },
	UpdateRate: number,
	AccumulatedDelta: number,
	BoundingBoxCFrame: CFrame,
	BoundingBoxSize: Vector3,

	InView: bool,
	Destroyed: bool,
	IsSkippingUpdates: bool,
	InWorkspace: bool,

	Force: Vector3,
	ObjectMove: Vector3,
	ObjectVelocity: Vector3,
	ObjectAcceleration: Vector3,
	ObjectPreviousPosition: Vector3
}

type ImOverlay = {
	Begin: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: () -> (),
	Text: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> ()
}

type bool = boolean

local function SafeUnit(v3: Vector3): Vector3
	if v3.Magnitude == 0 then
		--warn("Vector was saved")
		return Vector3.zero
	end

	return v3.Unit
end

local function map(n: number, start: number, stop: number, newStart: number, newStop: number, withinBounds: bool): number
	local value = ((n - start) / (stop - start)) * (newStop - newStart) + newStart

	--// Returns basic value
	if not withinBounds then
		return value
	end

	--// Returns values constrained to exact range
	if newStart < newStop then
		return (value < newStop and value or newStop) > newStart and (value < newStop and value or newStop) or newStart
	else
		return (value < newStart and value or newStart) > newStop and (value < newStart and value or newStart) or newStop
	end
end

--- @class BoneTree
--- Internal class for all bone trees
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within BoneTree
--- @readonly
--- @prop WindOffset number
--- Used in wind calculations so each bone tree has a different solution.

--- @within BoneTree
--- @readonly
--- @prop Root Bone
--- Root bone of the bone tree

--- @within BoneTree
--- @readonly
--- @prop RootPart BasePart

--- @within BoneTree
--- @readonly
--- @prop RootPartSize Vector3
--- Constant value of the root parts size at the start of the simulation

--- @within BoneTree
--- @prop Bones table

--- @within BoneTree
--- @prop Settings {}

--- @within BoneTree
--- @readonly
--- @prop UpdateRate number
--- Throttled update rate

--- @within BoneTree
--- @readonly
--- @prop InView boolean

--- @within BoneTree
--- @readonly
--- @prop BoundingBoxCFrame CFrame

--- @within BoneTree
--- @readonly
--- @prop BoundingBoxSize Size

--- @within BoneTree
--- @readonly
--- @prop AccumulatedDelta number
--- Used in the runtime

--- @within BoneTree
--- @readonly
--- @prop Destroyed boolean
--- True if the root part has been destroyed

--- @within BoneTree
--- @readonly
--- @prop IsSkippingUpdates boolean
--- True if the bone tree is currently skipping updates

--- @within BoneTree
--- @readonly
--- @prop InWorkspace boolean
--- Boolean describing if the rootpart is a descendant of workspace

--- @within BoneTree
--- @readonly
--- @prop Force Vector3

--- @within BoneTree
--- @prop ObjectMove Vector3
--- Difference between root parts last position and current position

--- @within BoneTree
--- @prop ObjectVelocity Vector3
--- Velocity at which the root part is traveling at, calculated via object move.

--- @within BoneTree
--- @prop ObjectPreviousPosition Vector3
--- Root parts previous position

local Class = {}
Class.__index = Class

--- @within BoneTree
--- @param RootBone Bone
--- @param RootPart BasePart
--- @param Settings {any}
--- @return BoneTree
function Class.new(RootBone: Bone, RootPart: BasePart, Settings: { any }): IBoneTree
	local self = setmetatable({
		WindOffset = WIND_RNG:NextNumber(0, 1e6),
		Root = RootBone:IsA("Bone") and RootBone or nil,
		RootPart = RootPart,
		RootPartSize = RootPart.Size,
		Bones = {},
		Settings = Settings,
		UpdateRate = 0,
		InView = true,
		AccumulatedDelta = 0,
		BoundingBoxCFrame = RootPart.CFrame,
		BoundingBoxSize = RootPart.Size,

		Destroyed = false,
		IsSkippingUpdates = false,
		InWorkspace = false,

		Force = Vector3.zero,
		ObjectMove = Vector3.zero,
		ObjectVelocity = Vector3.zero,
		ObjectAcceleration = Vector3.zero,
		ObjectPreviousPosition = RootPart.Position,
	}, Class)

	self.InWorkspace = RootPart:IsDescendantOf(workspace)

	-- TODO: Revisit optimising :IsDescendantOf calls
	self.DestroyConnection = RootPart.AncestryChanged:ConnectParallel(function()
		if not RootPart:IsDescendantOf(game) then
			self.Destroyed = true
		end

		self.InWorkspace = RootPart:IsDescendantOf(workspace)
	end)

	self.AttributeConnection = RootPart.AttributeChanged:ConnectParallel(function(Attribute)
		-- No need validating
		Settings[Attribute] = RootPart:GetAttribute(Attribute) or DefaultObjectSettings[Attribute]
	end)

	self.TagConnection = CollectionService:GetInstanceRemovedSignal("SmartBone"):Connect(function(Object)
		if Object ~= RootPart then
			return
		end

		self.Destroyed = true
	end)

	-- FIXME:
	-- if Settings.MatchWorkspaceWind then
	-- 	self.GlobalWindConnection = workspace:GetPropertyChangedSignal("GlobalWind"):ConnectParallel(function()
	-- 		local GlobalWind = workspace.GlobalWind
	-- 		Settings.WindDirection = SafeUnit(GlobalWind)
	-- 		Settings.WindSpeed = GlobalWind.Magnitude
	-- 	end)
	-- else
	-- 	self.WindDirectionConnection = Lighting:GetAttributeChangedSignal("WindDirection"):ConnectParallel(function()
	-- 		Settings.WindDirection = Lighting:GetAttribute("WindDirection")
	-- 	end)

	-- 	self.WindSpeedConnection = Lighting:GetAttributeChangedSignal("WindSpeed"):ConnectParallel(function()
	-- 		Settings.WindSpeed = Lighting:GetAttribute("WindSpeed")
	-- 	end)

	-- 	self.WindStrengthConnection = Lighting:GetAttributeChangedSignal("WindStrength"):ConnectParallel(function()
	-- 		Settings.WindStrength = Lighting:GetAttribute("WindStrength")
	-- 	end)
	-- end

	return self :: IBoneTree
end

--- @within BoneTree
--- Called in BoneTree:PreUpdate(),
--- Computes the bounding box of all the bones
function Class:UpdateBoundingBox()

	
if not self.InView then
		self.BoundingBoxCFrame = self.RootPart.CFrame
		self.BoundingBoxSize = self.RootPart.Size
		

return
	end

	local BottomCorner = MaxVector
	local TopCorner = -MaxVector
	

for _, Bone in self.Bones do
		
local Velocity = (Bone.Position - Bone.LastPosition)
		local Position = Bone.Position + Velocity

		BottomCorner = BottomCorner:Min(Position)
		TopCorner = TopCorner:Max(Position)
	
end

	
local CenterOfMass = (BottomCorner + TopCorner) * 0.5

	self.BoundingBoxCFrame = CFrame.new(CenterOfMass)
	self.BoundingBoxSize = self.RootPartSize:Max(TopCorner - BottomCorner)


end

--- @within BoneTree
--- @param RootPosition Vector3 -- Position of the root part (Micro Optimization)
--- Called in BoneTree:PreUpdate()
function Class:UpdateThrottling(RootPosition: Vector3)
	
local Settings = self.Settings

	local Camera = workspace.CurrentCamera
	local Distance = (RootPosition - Camera.CFrame.Position).Magnitude

	if Distance > Settings.ActivationDistance then
		self.UpdateRate = 0
		
return
	end

	local UpdateRate = 1 - map(Distance, Settings.ThrottleDistance, Settings.ActivationDistance, 0, 1, true)
	self.UpdateRate = Settings.UpdateRate * UpdateRate

end

--- @within BoneTree
--- @param Delta number -- Î”t
--- Calculates object move, gravity and throttled update rate. Also calls Bone:PreUpdate()
function Class:PreUpdate(Delta: number)
	
local RootPartCFrame = self.RootPart.CFrame
	local RootPartPosition = RootPartCFrame.Position

	local PreviousVelocity = self.ObjectVelocity

	self.ObjectMove = (RootPartPosition - self.ObjectPreviousPosition)
	self.ObjectVelocity = self.ObjectMove
	self.ObjectAcceleration = (PreviousVelocity - self.ObjectVelocity)
	self.ObjectPreviousPosition = RootPartPosition
	self.RootPartSize = self.RootPart.Size

	self:UpdateThrottling(RootPartPosition)
	self:UpdateBoundingBox()

	for _, Bone in self.Bones do
		Bone:PreUpdate(self)
	end

end

--- @within BoneTree
--- @param Delta number -- Î”t
--- Calculates forces and updates wind. Also calls Bone:StepPhysics()
function Class:StepPhysics(Delta: number)
	
local Settings = self.Settings
	local Force = (Settings.Gravity + Settings.Force)

	if Settings.MatchWorkspaceWind == true then
		local GlobalWind = workspace.GlobalWind
		Settings.WindDirection = SafeUnit(GlobalWind)
		Settings.WindSpeed = GlobalWind.Magnitude
	else
		local WindDirection = Lighting:GetAttribute("WindDirection") or DefaultObjectSettings.WindDirection
		local WindSpeed = Lighting:GetAttribute("WindSpeed") or DefaultObjectSettings.WindSpeed

		Settings.WindDirection = SafeUnit(WindDirection)
		Settings.WindSpeed = WindSpeed
	end

	local WindStrength = Lighting:GetAttribute("WindStrength") or DefaultObjectSettings.WindStrength

	Settings.WindStrength = WindStrength

	for _, Bone in self.Bones do
		Bone:StepPhysics(self, Force, Delta)
	end

end

--- @within BoneTree
--- @param ColliderObjects table
--- @param Delta number -- Î”t
function Class:Constrain(ColliderObjects, Delta: number)
	
for _, Bone in self.Bones do
		Bone:Constrain(self, ColliderObjects, Delta)
	end

end

--- @within BoneTree
--- Resets all bones to their rest positions, and sets skipping updates to true,
function Class:SkipUpdate()
	
for _, Bone in self.Bones do
		Bone:SkipUpdate()
	end

	self.IsSkippingUpdates = true

end

--- @within BoneTree
--- @param Delta number -- Î”t
function Class:SolveTransform(Delta: number)
	
for _, Bone in self.Bones do
		Bone:SolveTransform(self, Delta)
	end

	self.IsSkippingUpdates = false

end

--- @within BoneTree
--- Applys all the transforms to bones in serial context.
function Class:ApplyTransform()
	
for _, Bone in self.Bones do
		Bone:ApplyTransform(self)
	end

end

--- @client
--- @within BoneTree
--- @param DRAW_CONTACTS boolean
--- @param DRAW_PHYSICAL_BONE boolean
--- @param DRAW_BONE boolean
--- @param DRAW_AXIS_LIMITS boolean
--- @param DRAW_ROOT_PART boolean
--- @param DRAW_BOUNDING_BOX boolean
--- @param DRAW_ROTATION_LIMITS boolean
--- @param DRAW_ACCELERATION_INFO boolean
function Class:DrawDebug(
	DRAW_CONTACTS: bool,
	DRAW_PHYSICAL_BONE: bool,
	DRAW_BONE: bool,
	DRAW_AXIS_LIMITS: bool,
	DRAW_ROOT_PART: bool,
	DRAW_BOUNDING_BOX: bool,
	DRAW_ROTATION_LIMITS: bool,
	DRAW_ACCELERATION_INFO: bool
)
	
local LINE_CONNECTING_COLOR = Color3.fromRGB(248, 168, 20)
	local ROOT_PART_BOUNDING_BOX_COLOR = Color3.fromRGB(76, 208, 223)
	local ROOT_PART_FILL_COLOR = Color3.fromRGB(255, 89, 89)
	local OBJECT_MOVE_COLOR = Color3.new(1, 0, 0)
	local OBJECT_VELOCITY_COLOR = Color3.new(0, 1, 0)
	local OBJECT_ACCELERATION_COLOR = Color3.new(0, 0, 1)

	if DRAW_ACCELERATION_INFO then
		local Raised = self.RootPart.Position + Vector3.new(0, self.RootPart.Size.Y * 0.5 + 1, 0)

		Gizmo.SetStyle(OBJECT_MOVE_COLOR, 0, true)
		Gizmo.Arrow:Draw(Raised, Raised + self.ObjectMove, 0.025, 0.1, 6)

		Gizmo.SetStyle(OBJECT_VELOCITY_COLOR, 0, true)
		Gizmo.Arrow:Draw(Raised, Raised + self.ObjectVelocity, 0.025, 0.1, 6)

		Gizmo.SetStyle(OBJECT_ACCELERATION_COLOR, 0, true)
		Gizmo.Arrow:Draw(Raised, Raised + self.ObjectAcceleration, 0.025, 0.1, 6)
	end

	Gizmo.PushProperty("AlwaysOnTop", false)

	if DRAW_BOUNDING_BOX then
		Gizmo.PushProperty("Color3", ROOT_PART_BOUNDING_BOX_COLOR)
		Gizmo.Box:Draw(self.BoundingBoxCFrame, self.BoundingBoxSize, true)
	end

	if DRAW_ROOT_PART then
		Gizmo.PushProperty("Color3", ROOT_PART_BOUNDING_BOX_COLOR)
		Gizmo.Box:Draw(self.RootPart.CFrame, self.RootPart.Size, true)

		Gizmo.SetStyle(ROOT_PART_FILL_COLOR, 0.75, false)
		Gizmo.VolumeBox:Draw(self.RootPart.CFrame, self.RootPart.Size)

		Gizmo.PushProperty("Transparency", 0)
	end

	for i, Bone in self.Bones do
		local BonePosition = Bone.Bone.TransformedWorldCFrame.Position
		local ParentBone = self.Bones[Bone.ParentIndex]

		Bone:DrawDebug(self, DRAW_CONTACTS, DRAW_PHYSICAL_BONE, DRAW_BONE, DRAW_AXIS_LIMITS, DRAW_ROTATION_LIMITS)

		if DRAW_PHYSICAL_BONE and i ~= 1 then
			Gizmo.PushProperty("Color3", LINE_CONNECTING_COLOR)
			Gizmo.Ray:Draw(ParentBone.Bone.TransformedWorldCFrame.Position, BonePosition)
		end
	end

end

--- @client
--- @within SmartBone
--- @param Overlay ImOverlay
function Class:DrawOverlay(Overlay: ImOverlay)
	if Config.DEBUG_OVERLAY_TREE_INFO or Config.DEBUG_OVERLAY_TREE_OBJECTS then
		Overlay.Text(`Root Part: {self.RootPart.Name}`)
		Overlay.Text(`Root Bone: {self.Root.Name}`)
		Overlay.Text(`Root Part Size: {string.format("%.3f, %.3f, %.3f", self.RootPart.Size.X, self.RootPart.Size.Y, self.RootPart.Size.Z)}`)
	end

	if Config.DEBUG_OVERLAY_TREE_INFO or Config.DEBUG_OVERLAY_TREE_NUMERICS then
		Overlay.Text(`Update Rate: {string.format("%.3f", self.UpdateRate)}`)
		Overlay.Text(`In View: {self.InView}`)
		Overlay.Text(`Accumulated Delta: {string.format("%.3f", self.AccumulatedDelta)}`)
		Overlay.Text(`Force: {string.format("%.3f, %.3f, %.3f", self.Force.X, self.Force.Y, self.Force.Z)}`)
	end

	local ROOT_BACKGROUND_COLOR = Color3.new(0.486275, 0.431373, 1.000000)
	local ROOT_TEXT_COLOR = Color3.new(1, 1, 1)

	if Config.DEBUG_OVERLAY_BONE then
		for i, Bone in self.Bones do
			if Config.DEBUG_OVERLAY_MAX_BONES > 0 then
				if Config.DEBUG_OVERLAY_BONE_OFFSET + Config.DEBUG_OVERLAY_MAX_BONES <= i then
					break
				end
			end

			if Config.DEBUG_OVERLAY_BONE_OFFSET > i then
				continue
			end

			Overlay.Begin(`Bone {i}`, ROOT_BACKGROUND_COLOR, ROOT_TEXT_COLOR)
			Bone:DrawOverlay(Overlay)
			Overlay.End()
		end
	end
end

function Class:Destroy()
	SB_VERBOSE_LOG("Destroy BoneTree")

	task.synchronize()
	self.DestroyConnection:Disconnect()
	self.AttributeConnection:Disconnect()
	self.TagConnection:Disconnect()

	-- if self.Settings.MatchWorkspaceWind then
	-- 	self.GlobalWindConnection:Disconnect()
	-- else
	-- 	self.WindDirectionConnection:Disconnect()
	-- 	self.WindSpeedConnection:Disconnect()
	-- 	self.WindStrengthConnection:Disconnect()
	-- end

	for _, Bone in self.Bones do
		Bone:Destroy()
	end

	setmetatable(self, nil)
	task.desynchronize()
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.BoneTree

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Collider | Enabled: N/A
--------------------------------------------------------------------
--!nocheck

local HttpService = game:GetService("HttpService")

local Dependencies = script.Parent.Parent.Parent:WaitForChild("Dependencies")
local CollisionSolvers = script.Parent:WaitForChild("Colliders")
local BoxSolver = require(CollisionSolvers:WaitForChild("Box"))
local CapsuleSolver = require(CollisionSolvers:WaitForChild("Capsule"))
local CylinderSolver = require(CollisionSolvers:WaitForChild("Cylinder"))
local SphereSolver = require(CollisionSolvers:WaitForChild("Sphere"))

local Utilities = require(script.Parent.Parent.Parent:WaitForChild("Dependencies"):WaitForChild("Utilities"))

local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG

local Radians = 0.017453
local Gizmo = require(Dependencies:WaitForChild("Debug"):WaitForChild("Gizmo"))

--- @class Collider
--- Internal class for colliders
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within Collider
--- @prop Type string

--- @within Collider
--- @prop Scale Vector3

--- @within Collider
--- @prop Offset Vector3

--- @within Collider
--- @prop Rotation Vector3

--- @within Collider
--- @prop PreviousScale Vector3

--- @within Collider
--- @prop PreviousOffset Vector3

--- @within Collider
--- @prop PreviousRotation Vector3

--- @within Collider
--- @private
--- @readonly
--- @prop m_Object BasePart

--- @within Collider
--- @prop InNarrowphase boolean

--- @within Collider
--- @prop ObjectConnection RBXScriptConnection

--- @within Collider
--- @prop Transform CFrame

--- @within Collider
--- @prop Size Vector3

--- @within Collider
--- @prop GUID string

local Class = {}
Class.__index = Class

--- @within Collider
function Class.new()
	local self = setmetatable({
		Type = "Box",
		Scale = Vector3.zero,
		Offset = Vector3.zero,
		Rotation = Vector3.zero,
		Radius = 0,

		PreviousScale = Vector3.zero,
		PreviousOffset = Vector3.zero,
		PreviousRotation = Vector3.zero,
		PreviousObjectPosition = Vector3.zero,
		PreviousObjectRotation = Vector3.zero,

		m_Object = nil,

		InNarrowphase = false,

		Transform = CFrame.identity,
		Size = Vector3.zero,

		GUID = HttpService:GenerateGUID(false),
	}, Class)

	return self
end

--- @within Collider
--- @param Object BasePart
function Class:SetObject(Object: BasePart)
	self.m_Object = Object

	self:UpdateTransform()
end

--- @within Collider
function Class:UpdateTransform()
	
local Object = self.m_Object
	local ObjectCFrame = Object.CFrame
	local ObjectSize = Object.Size

	local Scale = self.Scale
	local Offset = self.Offset
	local Rotation = self.Rotation

	local ScaledOffset = ObjectSize * Offset
	local ScaledSize = ObjectSize * Scale

	local RotationCFrame = CFrame.Angles(Rotation.X * Radians, Rotation.Y * Radians, Rotation.Z * Radians)

	self.Transform = ObjectCFrame * CFrame.new(ScaledOffset) * RotationCFrame
	self.Size = ScaledSize
	self.Radius = math.sqrt((math.max(ScaledSize.X, ScaledSize.Y, ScaledSize.Z) * 0.5) ^ 2 * 2)

end

--- @within Collider
--- @param Point Vector3
--- @param Radius number
--- @return Vector3 | nil -- Returns nil if specified collider shape is invalid
function Class:GetClosestPoint(Point, Radius)
	if self.m_Object == nil then
		return
	end

	self.InNarrowphase = false

	-- Broadphase influence detection
	local PointDistance = (Point - self.Transform.Position).Magnitude - Radius

	if PointDistance > self.Radius then
		return
	end

	

self.InNarrowphase = true

	local Type = self.Type

	-- Determine which collision solver we should send this off to
	local IsInside, ClosestPoint, Normal

	if Type == "Box" then
		IsInside, ClosestPoint, Normal = BoxSolver(self.Transform, self.Size, Point, Radius)
	end

	if Type == "Capsule" then
		IsInside, ClosestPoint, Normal = CapsuleSolver(self.Transform, self.Size, Point, Radius)
	end

	if Type == "Sphere" then
		IsInside, ClosestPoint, Normal = SphereSolver(self.Transform, self.Size, Point, Radius)
	end

	if Type == "Cylinder" then
		IsInside, ClosestPoint, Normal = CylinderSolver(self.Transform, self.Size, Point, Radius)
	end

	

return IsInside, ClosestPoint, Normal
end

--- @within Collider
function Class:Step()
	
self:UpdateTransform()

end

--- @within Collider
--- @param ColliderObject ColliderObject
--- @param FILL_COLLIDER boolean
--- @param SHOW_INFLUENCE boolean
--- @param SHOW_AWAKE boolean
--- @param SHOW_BROADPHASE boolean
function Class:DrawDebug(ColliderObject, FILL_COLLIDER, SHOW_INFLUENCE, SHOW_AWAKE, SHOW_BROADPHASE)
	local COLLIDER_COLOR = Color3.new(0.509803, 0.933333, 0.427450)
	local FILL_COLOR = Color3.new(0.901960, 0.784313, 0.513725)
	local SLEEP_COLOR = Color3.new(1, 0, 1)
	local BROADPHASE_COLOR = Color3.new(0, 1, 1)
	local INFLUENCE_COLOR = Color3.new(1, 0.3, 0.3)

	local Type = self.Type
	local Transform = self.Transform
	local Size = self.Size

	if not ColliderObject.m_Awake and SHOW_AWAKE then
		COLLIDER_COLOR = SLEEP_COLOR
	end

	if self.InNarrowphase == false and SHOW_BROADPHASE then
		FILL_COLOR = BROADPHASE_COLOR
	end

	if SHOW_INFLUENCE then
		Gizmo.SetStyle(INFLUENCE_COLOR, 0, false)
		Gizmo.Sphere:Draw(Transform, self.Radius, 25, 360)
	end

	if Type == "Box" then
		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Box:Draw(Transform, Size)

		if FILL_COLLIDER then
			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeBox:Draw(Transform, Size)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end

	if Type == "Capsule" then
		local CapsuleRadius = (Size.Y < Size.Z and Size.Y or Size.Z) * 0.5
		local CapsuleLength = Size.X

		local TransformedTransform = Transform * CFrame.Angles(math.rad(90), -math.rad(90), 0)

		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Capsule:Draw(TransformedTransform, CapsuleRadius, CapsuleLength, 15)

		if FILL_COLLIDER then
			local Top = TransformedTransform.Position + TransformedTransform.UpVector * (CapsuleLength * 0.5)
			local Bottom = TransformedTransform.Position - TransformedTransform.UpVector * (CapsuleLength * 0.5)

			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeCylinder:Draw(Transform, CapsuleRadius, CapsuleLength)
			Gizmo.VolumeSphere:Draw(CFrame.new(Top), CapsuleRadius)
			Gizmo.VolumeSphere:Draw(CFrame.new(Bottom), CapsuleRadius)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end

	if Type == "Sphere" then
		local Radius = math.min(Size.X, Size.Y, Size.Z) * 0.5

		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Sphere:Draw(Transform, Radius, 15, 360)

		if FILL_COLLIDER then
			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeSphere:Draw(Transform, Radius)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end

	if Type == "Cylinder" then
		local Radius = (Size.Y < Size.Z and Size.Y or Size.Z) * 0.5

		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Cylinder:Draw(Transform * CFrame.Angles(0, 0, math.rad(90)), Radius, Size.X, 15)

		if FILL_COLLIDER then
			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeCylinder:Draw(Transform * CFrame.Angles(0, -math.rad(90), 0), Radius, Size.X, 0, 360)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end
end

--- @within Collider
function Class:Destroy()
	SB_VERBOSE_LOG(`Collider destroying, object: {self.m_Object}`)

	setmetatable(self, nil)
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Collider

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.ColliderObject | Enabled: N/A
--------------------------------------------------------------------
local ColliderClass = require(script.Parent:WaitForChild("Collider"))
local Utilities = require(script.Parent.Parent.Parent:WaitForChild("Dependencies"):WaitForChild("Utilities"))

local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG
local SleepCycleInterval = 0.2

type IRawCollider = {
	Type: string,
	ScaleX: number,
	ScaleY: number,
	ScaleZ: number,
	OffsetX: number,
	OffsetY: number,
	OffsetZ: number,
	RotationX: number,
	RotationY: number,
	RotationZ: number
}

type bool = boolean

export type IColliderTable = { [number]: IRawCollider }
export type IColliderObject = {
	m_Object: BasePart,
	m_Awake: bool,
	m_LastSleepCycle: number,
	Destroyed: bool,
	Colliders: IColliderTable
}

--- @class ColliderObject
--- Internal class for collider
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within ColliderObject
--- @private
--- @readonly
--- @prop m_Object BasePart

--- @within ColliderObject
--- @readonly
--- @prop Destroyed boolean

--- @within ColliderObject
--- @readonly
--- @prop Colliders {}

local Class = {}
Class.__index = Class

--- @within ColliderObject
--- @param ColliderTable {[number]: {Type: string, ScaleX: number, ScaleY: number, ScaleZ: number, OffsetX: number, OffsetY: number, OffsetZ: number, RotationX: number, RotationY: number, RotationZ: number}}
--- @param Object BasePart
--- @return ColliderObject
function Class.new(ColliderTable: IColliderTable, Object: BasePart): IColliderObject
	local self = setmetatable({
		m_Object = Object,
		m_Awake = true,
		m_LastSleepCycle = 0,
		Destroyed = false,
		Colliders = {},
	}, Class)

	self:m_LoadColliderTable(ColliderTable)

	self.DestroyConnection = Object:GetPropertyChangedSignal("Parent"):Connect(function()
		if Object.Parent == nil then
			self.Destroyed = true
		end
	end)

	return self :: IColliderObject
end

--- @within ColliderObject
--- @private
--- @param Collider {Type: string, ScaleX: number, ScaleY: number, ScaleZ: number, OffsetX: number, OffsetY: number, OffsetZ: number, RotationX: number, RotationY: number, RotationZ: number}
function Class:m_LoadCollider(Collider: IRawCollider)
	local FormattedScale = Vector3.new(Collider.ScaleX, Collider.ScaleY, Collider.ScaleZ)
	local FormattedOffset = Vector3.new(Collider.OffsetX, Collider.OffsetY, Collider.OffsetZ)
	local FormattedRotation = Vector3.new(Collider.RotationX, Collider.RotationY, Collider.RotationZ)

	local ColliderSolver = ColliderClass.new()
	ColliderSolver.Scale = FormattedScale
	ColliderSolver.Offset = FormattedOffset
	ColliderSolver.Rotation = FormattedRotation
	ColliderSolver.Type = Collider.Type
	ColliderSolver:SetObject(self.m_Object)

	table.insert(self.Colliders, ColliderSolver)
end

--- @within ColliderObject
--- @private
--- @param ColliderTable {[number]: {Type: string, ScaleX: number, ScaleY: number, ScaleZ: number, OffsetX: number, OffsetY: number, OffsetZ: number, RotationX: number, RotationY: number, RotationZ: number}}
function Class:m_LoadColliderTable(ColliderTable: IColliderTable)
	for _, Collider in ColliderTable do
		self:m_LoadCollider(Collider)
	end
end

-- Public

--- @within ColliderObject
--- @return BasePart
function Class:GetObject()
	return self.m_Object
end

--- @within ColliderObject
--- @param Point Vector3
--- @param Radius number -- Radius of bone
--- @return {[number]: {ClosestPoint: Vector3, Normal: Vector3}}
function Class:GetCollisions(Point, Radius)
	
if not self.m_Object then
		
return {}
	end

	if #self.Colliders == 0 then
		
return {}
	end
	

if os.clock() - self.m_LastSleepCycle >= SleepCycleInterval then -- Run sleep conditions every 5th of a second
		self.m_LastSleepCycle = os.clock()

		if self.m_Object:IsDescendantOf(workspace) then -- If our object is not a descendant of workspace put it to sleep
			self.m_Awake = true
		else
			self.m_Awake = false
		end
	end

	
if not self.m_Awake then
		
return {}
	end

	local Collisions = {}
	

for _, Collider in self.Colliders do
		
local IsInside, ClosestPoint, Normal = Collider:GetClosestPoint(Point, Radius)

		
if IsInside then
			table.insert(Collisions, { ClosestPoint = ClosestPoint, Normal = Normal })
		end
	end

	

return Collisions
end

--- @within ColliderObject
function Class:Step()
	
for _, Collider in self.Colliders do
		Collider:Step()
	end

end

--- @within ColliderObject
--- @param FILL_COLLIDERS boolean
--- @param SHOW_INFLUENCE boolean
--- @param SHOW_AWAKE boolean
--- @param SHOW_BROADPHASE boolean
function Class:DrawDebug(FILL_COLLIDERS, SHOW_INFLUENCE, SHOW_AWAKE, SHOW_BROADPHASE)
	for _, Collider in self.Colliders do
		Collider:DrawDebug(self, FILL_COLLIDERS, SHOW_INFLUENCE, SHOW_AWAKE, SHOW_BROADPHASE)
		Collider.InNarrowphase = false
	end
end

--- @within ColliderObject
function Class:Destroy()
	task.synchronize()
	SB_VERBOSE_LOG(`Collider object destroying, object: {self.m_Object}`)

	self.DestroyConnection:Disconnect()

	if #self.Colliders ~= 0 then
		for _, Collider in self.Colliders do
			Collider:Destroy()
		end
	end

	setmetatable(self, nil)
	task.desynchronize()
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.ColliderObject
  -  Edit
  18:44:44.872  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Box | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function ClosestPointFunc(cframe, size, point)
	local rel = cframe:pointToObjectSpace(point)
	local sx, sy, sz = size.x, size.y, size.z
	local rx, ry, rz = rel.x, rel.y, rel.z

	-- constrain to within the box
	local cx = math.clamp(rx, -sx * 0.5, sx * 0.5)
	local cy = math.clamp(ry, -sy * 0.5, sy * 0.5)
	local cz = math.clamp(rz, -sz * 0.5, sz * 0.5)

	if not (cx == rx and cy == ry and cz == rz) then
		local closestPoint = cframe * Vector3.new(cx, cy, cz)
		local normal = SafeUnit(point - closestPoint)
		return false, closestPoint, normal
	end

	-- else, they are intersecting, find the surface the point is closest to

	local posX = rx - sx * 0.5
	local posY = ry - sy * 0.5
	local posZ = rz - sz * 0.5
	local negX = -rx - sx * 0.5
	local negY = -ry - sy * 0.5
	local negZ = -rz - sz * 0.5

	local max = math.max(posX, posY, posZ, negX, negY, negZ)
	if max == posX then
		local closestPoint = cframe * Vector3.new(sx * 0.5, ry, rz)
		return true, closestPoint, cframe.XVector
	elseif max == posY then
		local closestPoint = cframe * Vector3.new(rx, sy * 0.5, rz)
		return true, closestPoint, cframe.YVector
	elseif max == posZ then
		local closestPoint = cframe * Vector3.new(rx, ry, sz * 0.5)
		return true, closestPoint, cframe.ZVector
	elseif max == negX then
		local closestPoint = cframe * Vector3.new(-sx * 0.5, ry, rz)
		return true, closestPoint, -cframe.XVector
	elseif max == negY then
		local closestPoint = cframe * Vector3.new(rx, -sy * 0.5, rz)
		return true, closestPoint, -cframe.YVector
	elseif max == negZ then
		local closestPoint = cframe * Vector3.new(rx, ry, -sz * 0.5)
		return true, closestPoint, -cframe.ZVector
	end

	-- Shouldnt reach
	warn("CLOSEST POINT ON BOX FAIL")
	return false, cframe.Position, Vector3.zero
end

return function(BoxCFrame, BoxSize, Point, Radius) -- Sphere vs Box
	
local IsInside, ClosestPoint, Normal = ClosestPointFunc(BoxCFrame, BoxSize, Point)

	if IsInside then
		return IsInside, ClosestPoint, Normal
	end

	local DistanceToCp = (ClosestPoint - Point).Magnitude

	IsInside = (DistanceToCp < Radius)
	
return IsInside, ClosestPoint, Normal
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Box

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Capsule | Enabled: N/A
--------------------------------------------------------------------
--!native
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function solve(p0, d0, len, p1)
	local v = p1 - p0
	local k = v:Dot(d0)
	k = math.clamp(k, -len, len)
	return p0 + d0 * k
end

local function ClosestPointFunc(cframe, length, radius, point)
	local l0 = solve(cframe.Position, cframe.UpVector, length * 0.5, point)

	local distance = (l0 - point).Magnitude
	local normal = SafeUnit(point - l0)
	local is_inside = (distance <= radius)

	return is_inside, l0 + (normal * radius), normal
end

return function(CapsuleCFrame, CapsuleSize, Point, Radius)
	
local CapsuleRadius = (CapsuleSize.Y < CapsuleSize.Z and CapsuleSize.Y or CapsuleSize.Z) * 0.5
	local CapsuleLength = CapsuleSize.X

	CapsuleCFrame *= CFrame.Angles(math.rad(90), -math.rad(90), 0) -- Optomize

	local IsInside, ClosestPoint, Normal = ClosestPointFunc(CapsuleCFrame, CapsuleLength, CapsuleRadius, Point)

	if IsInside then
		return IsInside, ClosestPoint, Normal
	end

	local DistanceToCp = (ClosestPoint - Point).Magnitude

	IsInside = (DistanceToCp < Radius)
	
return IsInside, ClosestPoint, Normal
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Capsule

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Cylinder | Enabled: N/A
--------------------------------------------------------------------
--!native
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function solve(p0, d0, len, p1)
	local v = p1 - p0
	local k = v:Dot(d0)
	k = math.clamp(k, -len, len)
	return p0 + d0 * k, k
end

local function ProjectOnPlane(pos, normal, point)
	local d = point - pos
	local v_dot = d:Dot(normal)
	local v = point - v_dot * normal

	return v
end

local function ClosestPointFunc(cframe, size, point)
	local radius = (size.Y < size.Z and size.Y or size.Z) * 0.5
	local length = size.X * 0.5
	local l0, k = solve(cframe.Position, cframe.RightVector, length, point)

	local endPlane = cframe.Position + -cframe.RightVector * length
	local topPlane = cframe.Position + cframe.RightVector * length

	local endPlaneN = -cframe.RightVector
	local topPlaneN = cframe.RightVector

	local projEnd = ProjectOnPlane(endPlane, endPlaneN, point)
	local projTop = ProjectOnPlane(topPlane, topPlaneN, point)

	local function GetFinalProj(proj, o)
		local projDir = SafeUnit(proj - o)
		local projDistance = (proj - o).Magnitude
		return o + projDir * (projDistance < radius and projDistance or radius)
	end

	projEnd = GetFinalProj(projEnd, endPlane)
	projTop = GetFinalProj(projTop, topPlane)

	local radiusDistance = (l0 - point).Magnitude
	local radiusNormal = SafeUnit(point - l0)
	local radiusInside = (radiusDistance <= radius)
	local radiusPosition = l0 + (radiusNormal * radius)

	local d0 = (projTop - point).Magnitude
	local d1 = (projEnd - point).Magnitude
	local d2 = (radiusPosition - point).Magnitude

	local d = math.min(d0, d1, d2)

	if k == length or d == d0 then
		local dot = SafeUnit(point - projTop):Dot(topPlaneN)
		return dot < 0, projTop, topPlaneN
	elseif k == -length or d == d1 then
		local dot = SafeUnit(point - projEnd):Dot(endPlaneN)
		return dot < 0, projEnd, endPlaneN
	end

	return radiusInside, radiusPosition, radiusNormal
end

return function(CylinderCFrame, CylinderSize, Point, Radius) -- IsInside, PushPosition, PushNormal
	
local IsInside, PushPosition, PushNormal = ClosestPointFunc(CylinderCFrame, CylinderSize, Point)

	if IsInside then
		return IsInside, PushPosition, PushNormal
	end

	local PointDistance = (PushPosition - Point).Magnitude

	IsInside = PointDistance < Radius
	
return IsInside, PushPosition, PushNormal
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Cylinder

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Sphere | Enabled: N/A
--------------------------------------------------------------------
--!native
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function ClosestPointFunc(position, radius, point)
	local distance = (position - point).Magnitude
	local normal = SafeUnit(point - position)
	local is_inside = (distance <= radius)

	return is_inside, position + (normal * radius), normal
end

return function(Sphere0Point, Sphere0Radius, Sphere1Point, Sphere1Radius)
	
Sphere0Point = Sphere0Point.Position
	Sphere0Radius = math.min(Sphere0Radius.X, Sphere0Radius.Y, Sphere0Radius.Z) * 0.5

	local IsInside, ClosestPoint, Normal = ClosestPointFunc(Sphere0Point, Sphere0Radius, Sphere1Point)

	if IsInside then
		return IsInside, ClosestPoint, Normal
	end

	local DistanceToCp = (ClosestPoint - Sphere1Point).Magnitude

	IsInside = (DistanceToCp < Sphere1Radius)
	
return IsInside, ClosestPoint, Normal
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Sphere

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Triangle | Enabled: N/A
--------------------------------------------------------------------
--[[

    !! THIS IS NOT MEANT TO BE USED AS A COLLIDER SOLVER, ITS MEANT TO BE USED IN OTHER COLLIDER SOLVERS !!

]]

--!native
local dot = Vector3.new().Dot
local cross = Vector3.new().Cross
local clamp = math.clamp

local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function ClosestPointOnLineSegment(A, B, P)
	local AB = B - A
	local t = dot(P - A, AB) / dot(AB, AB)
	return A + clamp(t, 0, 1) * AB
end

local function ProjectOnPlane(pos, normal, point)
	local d = point - pos
	local v_dot = d:Dot(normal)
	local v = point - v_dot * normal

	return v
end

local function SameSide(p1, p2, a, b)
	local cp1 = cross(b - a, p1 - a)
	local cp2 = cross(b - a, p2 - a)
	if dot(cp1, cp2) >= 0 then
		return true
	else
		return false
	end
end

local function PointInTriangle(p, a, b, c)
	if SameSide(p, a, b, c) and SameSide(p, b, a, c) and SameSide(p, c, a, b) then
		return true
	end

	return false
end

local function ClosestPointOnTri(v0, v1, v2, point) -- ClosestPoint, Normal
	
local Edge0 = ClosestPointOnLineSegment(v0, v1, point)
	local Edge1 = ClosestPointOnLineSegment(v1, v2, point)
	local Edge2 = ClosestPointOnLineSegment(v2, v0, point)

	local Normal = SafeUnit(cross(v1 - v0, v2 - v0))
	local Center = (v0 + v1 + v2) * 0.3333
	local Projected = ProjectOnPlane(Center, Normal, point)

	if PointInTriangle(point, v0, v1, v2) then
		
return Projected, Normal
	end

	local d0 = (Edge0 - point).Magnitude
	local d1 = (Edge1 - point).Magnitude
	local d2 = (Edge2 - point).Magnitude

	local d = math.min(d0, d1, d2)

	if d == d0 then
		
return Edge0, Normal
	elseif d == d1 then
		
return Edge1, Normal
	elseif d == d2 then
		
return Edge2, Normal
	end
	

return point, Normal
end

return ClosestPointOnTri

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Triangle

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local inf = math.huge

return function(self, Position, LastPosition, RootCFrame)
	
local RootOffset = RootCFrame:Inverse() * Position

	local X = RootOffset.X
	local Y = RootOffset.Y
	local Z = RootOffset.Z

	local XLimit = self.XAxisLimits
	local YLimit = self.YAxisLimits
	local ZLimit = self.ZAxisLimits

	local XLock = self.AxisLocked[1] and 0 or 1
	local YLock = self.AxisLocked[2] and 0 or 1
	local ZLock = self.AxisLocked[3] and 0 or 1

	-- Most bones probably wont have an axis limit, this allows us to skip all the other stuff
	if XLimit.Min == -inf and XLimit.Max == inf and YLimit.Min == -inf and YLimit.Max == inf and ZLimit.Min == -inf and ZLimit.Max == inf then
		if XLock == 1 and YLock == 1 and ZLock == 1 then
			
return Position
		else
			return RootCFrame * Vector3.new(X * XLock, Y * YLock, Z * ZLock)
		end
	end

	-- If our radius is > than the diff between min and max
	-- We do this because its faster than math.min() Â¯\_(ãƒ„)_/Â¯
	local XMin = XLimit.Min + self.Radius
	local XMax = XMin <= (XLimit.Max - self.Radius) and XLimit.Max - self.Radius or XMin

	local YMin = YLimit.Min + self.Radius
	local YMax = YMin <= (YLimit.Max - self.Radius) and YLimit.Max - self.Radius or YMin

	local ZMin = ZLimit.Min + self.Radius
	local ZMax = ZMin <= (ZLimit.Max - self.Radius) and ZLimit.Max - self.Radius or ZMin

	X = X < XMin and XMin or (X > XMax and XMax or X)
	Y = Y < YMin and YMin or (Y > YMax and YMax or Y)
	Z = Z < ZMin and ZMin or (Z > ZMax and ZMax or Z)

	X *= XLock
	Y *= YLock
	Z *= ZLock

	local WorldSpace = RootCFrame * Vector3.new(X, Y, Z)

	Position = WorldSpace

	local XAxis = RootCFrame.RightVector
	local YAxis = RootCFrame.UpVector
	local ZAxis = RootCFrame.LookVector

	local DifferenceDirection = SafeUnit(Position - LastPosition)

	-- Remove our velocity on the vectors we collided with, stops any weird jittering.
	if X ~= RootOffset.X then
		local Normal = XAxis:Dot(DifferenceDirection) < 0 and -XAxis or XAxis
		self:ClipVelocity(Position, Normal)
	end

	if Y ~= RootOffset.Y then
		local Normal = YAxis:Dot(DifferenceDirection) < 0 and -YAxis or YAxis
		self:ClipVelocity(Position, Normal)
	end

	if Z ~= RootOffset.Z then
		local Normal = ZAxis:Dot(DifferenceDirection) > 0 and -ZAxis or ZAxis
		self:ClipVelocity(Position, Normal)
	end

	
return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint.spec | Enabled: N/A
--------------------------------------------------------------------
local AxisConstraint = require(script.Parent:WaitForChild("AxisConstraint"))

return function()
	local Bone = {
		Radius = 0,
		XAxisLimits = NumberRange.new(-math.huge, math.huge),
		YAxisLimits = NumberRange.new(-math.huge, math.huge),
		ZAxisLimits = NumberRange.new(-math.huge, math.huge),
		AxisLocked = { false, false, false },
		ClipVelocity = function() end,
	}

	afterEach(function()
		Bone.AxisLocked = { false, false, false }
	end)

	describe("Axis Lock", function()
		it("Should lock X Axis", function()
			Bone.AxisLocked = { true, false, false }

			local Result = AxisConstraint(Bone, Vector3.new(-10, 0, 0), Vector3.zero, CFrame.identity)

			expect(Result.X).to.equal(0)
		end)

		it("Should lock Y Axis", function()
			Bone.AxisLocked = { false, true, false }

			local Result = AxisConstraint(Bone, Vector3.new(0, -10, 0), Vector3.zero, CFrame.identity)

			expect(Result.Y).to.equal(0)
		end)

		it("Should lock Z Axis", function()
			Bone.AxisLocked = { false, false, true }

			local Result = AxisConstraint(Bone, Vector3.new(0, 0, -10), Vector3.zero, CFrame.identity)

			expect(Result.Z).to.equal(0)
		end)
	end)

	describe("Axis Limit", function()
		describe("Should limit X Axis", function()
			it("Min Limit", function()
				Bone.XAxisLimits = NumberRange.new(-5, math.huge)

				local Result = AxisConstraint(Bone, Vector3.new(-10, 0, 0), Vector3.zero, CFrame.identity)

				expect(Result.X).to.equal(-5)
			end)

			it("Max Limit", function()
				Bone.XAxisLimits = NumberRange.new(-math.huge, 5)

				local Result = AxisConstraint(Bone, Vector3.new(10, 0, 0), Vector3.zero, CFrame.identity)

				expect(Result.X).to.equal(5)
			end)
		end)

		describe("Should limit Y Axis", function()
			it("Min Limit", function()
				Bone.YAxisLimits = NumberRange.new(-5, math.huge)

				local Result = AxisConstraint(Bone, Vector3.new(0, -10, 0), Vector3.zero, CFrame.identity)

				expect(Result.Y).to.equal(-5)
			end)

			it("Max Limit", function()
				Bone.YAxisLimits = NumberRange.new(-math.huge, 5)

				local Result = AxisConstraint(Bone, Vector3.new(0, 10, 0), Vector3.zero, CFrame.identity)

				expect(Result.Y).to.equal(5)
			end)
		end)

		describe("Should limit Z Axis", function()
			it("Min Limit", function()
				Bone.ZAxisLimits = NumberRange.new(-5, math.huge)

				local Result = AxisConstraint(Bone, Vector3.new(0, 0, -10), Vector3.zero, CFrame.identity)

				expect(Result.Z).to.equal(-5)
			end)

			it("Max Limit", function()
				Bone.ZAxisLimits = NumberRange.new(-math.huge, 5)

				local Result = AxisConstraint(Bone, Vector3.new(0, 0, 10), Vector3.zero, CFrame.identity)

				expect(Result.Z).to.equal(5)
			end)
		end)
	end)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint.spec

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.CollisionConstraint | Enabled: N/A
--------------------------------------------------------------------
return function(self, Position, Colliders)
	
local Collisions = {}
	local HitParts = {}

	for _, Collider in Colliders do
		local ColliderCollisions = Collider:GetCollisions(Position, self.Radius)

		if #ColliderCollisions > 0 then
			table.insert(HitParts, Collider:GetObject())
		end

		for _, Collision in ColliderCollisions do
			table.insert(Collisions, Collision)
		end
	end

	for _, Collision in Collisions do
		Position = Collision.ClosestPoint + (Collision.Normal * self.Radius)
		-- self:ClipVelocity(Position, Collision.Normal) -- This causes some weird glitching issues, not sure why tbh
	end

	self.CollisionsData = Collisions
	self.CollisionHits = HitParts

	
return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.CollisionConstraint

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

return function(self, Position, BoneTree)
	
local ParentBone = BoneTree.Bones[self.ParentIndex]

	if ParentBone then
		local RestLength = self.FreeLength
		local BoneDirection = SafeUnit(Position - ParentBone.Position)

		local RestPosition = ParentBone.Position + (BoneDirection * RestLength)
		

return RestPosition
	end
	

return
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceConstraint

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceContraint.spec | Enabled: N/A
--------------------------------------------------------------------
local DistanceConstraint = require(script.Parent:WaitForChild("DistanceConstraint"))

local function CreateBone(Position, FreeLength, Parent)
	return {
		Position = Position,
		FreeLength = FreeLength,
		ParentIndex = Parent,
	}
end

return function()
	local BoneTree = {
		Bones = {
			CreateBone(Vector3.zero, 3, 0),
			CreateBone(Vector3.yAxis, 3, 1),
		},
	}

	describe("Distance Constraint", function()
		local Bone = BoneTree.Bones[2]

		local function Callback()
			local NewPosition = DistanceConstraint(Bone, Bone.Position, BoneTree)

			expect(NewPosition.Magnitude).to.equal(Bone.FreeLength)

			Bone.Position = NewPosition
		end

		for i = 1, 10 do
			it(`Should limit to {Bone.FreeLength} studs #{i}`, Callback)
			Bone.FreeLength = math.random(1, 20)
		end
	end)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceContraint.spec
  -  Edit
  18:44:45.122  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.FrictionConstraint | Enabled: N/A
--------------------------------------------------------------------
return function(self, Position, LastPosition)
	local Alpha = 1 - self.Friction

	return LastPosition:Lerp(Position, Alpha)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.FrictionConstraint

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

return function(self, Position, BoneTree)
	
local ParentBone = BoneTree.Bones[self.ParentIndex]

	if ParentBone then
		local RestLength = self.FreeLength
		local BoneSub = (Position - ParentBone.Position)
		local BoneDirection = SafeUnit(BoneSub)
		local BoneDistance = BoneSub.Magnitude < RestLength and BoneSub.Magnitude or RestLength

		local RestPosition = ParentBone.Position + (BoneDirection * BoneDistance)
		

return RestPosition
	end
	

return
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint.spec | Enabled: N/A
--------------------------------------------------------------------
local RopeConstraint = require(script.Parent:WaitForChild("RopeConstraint"))

local function CreateBone(Position, FreeLength, Parent)
	return {
		Position = Position,
		FreeLength = FreeLength,
		ParentIndex = Parent,
	}
end

return function()
	local BoneTree = {
		Bones = {
			CreateBone(Vector3.zero, 3, 0),
			CreateBone(Vector3.yAxis * 10, 3, 1),
		},
	}

	describe("Rope Constraint", function()
		local Bone = BoneTree.Bones[2]
		local i = 0

		local ReRun

		local function LimitCallback()
			local NewPosition = RopeConstraint(Bone, Bone.Position, BoneTree)

			expect(NewPosition.Magnitude).to.equal(Bone.FreeLength)

			Bone.FreeLength = math.random(1, 20)

			ReRun()
		end

		local function SameCallback()
			local NewPosition = RopeConstraint(Bone, Bone.Position, BoneTree)

			expect(NewPosition.Magnitude).to.equal(Bone.Position.Magnitude)

			Bone.FreeLength = math.random(1, 20)

			ReRun()
		end

		ReRun = function()
			if i >= 10 then
				return
			end

			i += 1

			if Bone.Position.Magnitude < Bone.FreeLength then
				it(`Should stay the same #{i}`, SameCallback)
			else
				it(`Should limit to {Bone.FreeLength} studs #{i}`, LimitCallback)
			end
		end

		ReRun()
	end)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint.spec

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RotationConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

return function(self, Position, BoneTree)
	
local ParentIndex = self.ParentIndex
	local ParentBone = BoneTree.Bones[ParentIndex]

	if not ParentBone then
		
return Position
	end

	local ParentBoneLimit = ParentBone.RotationLimit

	if ParentBoneLimit >= 180 then
		
return Position
	end

	local GrandParentBone = BoneTree.Bones[ParentBone.ParentIndex]

	if not GrandParentBone then
		
return Position
	end

	local ParentBonePosition = ParentBone.Position
	local DefaultDirection = SafeUnit(ParentBone.Position - GrandParentBone.Position)

	local DistanceToParent = (Position - ParentBonePosition).Magnitude
	local DirectionToSelf = SafeUnit(Position - ParentBonePosition)

	if ParentBoneLimit <= 0 then
		
return ParentBonePosition + DefaultDirection * DistanceToParent
	end

	local RotationLimit = math.rad(self.RotationLimit)
	local VectorAngle = math.acos(DefaultDirection:Dot(DirectionToSelf))
	local LimitedVector

	if VectorAngle >= RotationLimit then
		local Cross = SafeUnit(DefaultDirection:Cross(DirectionToSelf))
		LimitedVector = CFrame.fromAxisAngle(Cross, RotationLimit) * DefaultDirection
	else
		LimitedVector = DirectionToSelf
	end

	if LimitedVector ~= LimitedVector then -- Somewhat hacky fix
		LimitedVector = DefaultDirection
	end

	Position = ParentBonePosition + LimitedVector * DistanceToParent
	

return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RotationConstraint

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.SpringConstraint | Enabled: N/A
--------------------------------------------------------------------
--!native
return function(self, Position, RestPosition, BoneTree, Delta)

	
local Settings = BoneTree.Settings
	local Stiffness = Settings.Stiffness
	local Elasticity = Settings.Elasticity

	local ParentBone = BoneTree.Bones[self.ParentIndex]

	if ParentBone then
		local RestLength = self.FreeLength

		if Stiffness > 0 or Elasticity > 0 then
			local ParentBoneCFrame = CFrame.new(ParentBone.Position) * ParentBone.TransformOffset.Rotation
			RestPosition = RestPosition or (ParentBoneCFrame * CFrame.new(self.LocalTransformOffset.Position)).Position

			local ElasticDifference = RestPosition - Position
			Position += ElasticDifference * (Elasticity * Delta)

			if Stiffness > 0 then
				local StiffDifference = RestPosition - Position
				local Length = StiffDifference.Magnitude
				local MaxLength = RestLength * (1 - Stiffness) * 2
				if Length > MaxLength then
					Position += StiffDifference * ((Length - MaxLength) / Length)
				end
			end
		end

		local Difference = ParentBone.Position - Position
		local Length = Difference.Magnitude
		if Length > 0 then
			Position += Difference * ((Length - RestLength) / Length)
		end
	end

	
return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.SpringConstraint

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair | Enabled: N/A
--------------------------------------------------------------------
--[[
FUNCTION LIST:

DynamicCrosshair.new()
DynamicCrosshair:Enable()
DynamicCrosshair:Disable()
DynamicCrosshair:Lock()
DynamicCrosshair:Size()
DynamicCrosshair:Destroy()
DynamicCrosshair:Display()
DynamicCrosshair:Set()
DynamicCrosshair:SmoothSet()
DynamicCrosshair:Shove()
DynamicCrosshair:FollowMouse()
DynamicCrosshair:HitMarker()
DynamicCrosshair:Update() (OUTDATED)
]]

local CrosshairModule 		= {}
local Crosshairs			= {}
CrosshairModule.__index 	= CrosshairModule

local GetService			= game.GetService

local TweenService			= GetService(game, "TweenService")
local RunService			= GetService(game, "RunService")
local UserInputService		= GetService(game, "UserInputService")
local GuiService 			= GetService(game, "GuiService")
local Players				= GetService(game, "Players")

local LocalPlayer			= Players.LocalPlayer
local Camera				= workspace.CurrentCamera

local Functions				= require(script:WaitForChild("Functions"))

function CrosshairModule.New(UI, MinSpread, MaxSpread, DecreasePerSecond, IncreasePerSecond, MouseFollow) 
	local self 				= {}

	self.UI 					= UI or Instance.new('ScreenGui', LocalPlayer.PlayerGui)
		
	self.SizeX 					= 5
	self.SizeY 					= 1

	self.Top, self.Bottom, self.Left, self.Right, self.HitMarker, self.CenterDot, self.ImageCrosshair = Functions:CreateHairs(UI, self.SizeX, self.SizeY)
		
	self.Spreading = {
		Spread 					= MinSpread or 20,
		MaxSpread 				= MaxSpread or 60,
		MinSpread 				= MinSpread or 20,
		DecreasePerSecond 		= DecreasePerSecond or 40,
		IncreasePerSecond 		= IncreasePerSecond or 30
	}
		
	self.FollowingMouse			= ((MouseFollow and type(MouseFollow) == "boolean") and MouseFollow) or false
	self.Locked 				= false
	
	
	self.Hairs 					= {
		self.Top,
		self.Bottom,
		self.Left,
		self.Right
	}

	self.EasingStyle 			= Enum.EasingStyle.Linear
	self.EasingDirection 		= Enum.EasingDirection.InOut
	
	self.HitMarker = {
		hitmarker = self.HitMarker;
		size = UDim2.fromOffset(50, 50);
		default = Color3.fromRGB(255, 255, 255);
		headshot = Color3.fromRGB(255, 0, 0);
		fadeTime = 0.25;
		easingStyle = Enum.EasingStyle.Linear;
		easingDirection = Enum.EasingDirection.InOut;
		Image = {
			default = 'rbxassetid://118682730809232';
			headshot = 'rbxassetid://102213744787573';
		};
	}
	
	self.CenterDot = {
		centerdot = self.CenterDot;
		size = UDim2.fromOffset(7.5,7.5);
		enabled = false;
		transparency = 0;
		Image = 'rbxassetid://11003529439';
	}
	
	self.ImageCrosshair = {
		crosshair = self.ImageCrosshair;
		enabled = false;
		Image = 'rbxassetid://12550071496';
	}
	
	table.insert(Crosshairs, self)

	Functions:UpdateEnabled(self.Hairs, false)
	
	return setmetatable(self, CrosshairModule)
end

function CrosshairModule:Enable()
	self.Enabled 						= true
	UserInputService.MouseIconEnabled 	= false
	
	Functions:UpdateEnabled(self.Hairs, self.Enabled)
end
					
function CrosshairModule:Disable()
	self.Enabled 						= false
	UserInputService.MouseIconEnabled 	= true
	
	Functions:UpdateEnabled(self.Hairs, self.Enabled)
end

function CrosshairModule:Lock(Bool : boolean)
	self.Locked 				= Bool or true
end

function CrosshairModule:FollowMouse(Bool : boolean)
	self.FollowingMouse 		= Bool or true
end

function CrosshairModule:Hitmarker(headshot : boolean, fadeTime, easingStyle, easingDirection)
	if headshot then
		self.HitMarker.hitmarker.ImageColor3 = self.HitMarker.headshot
	else
		self.HitMarker.hitmarker.ImageColor3 = self.HitMarker.default
	end
	
	
	self.HitMarker.hitmarker.Size = self.HitMarker.size 
	self.HitMarker.hitmarker.ImageTransparency = 0
	
	TweenService:Create(
		self.HitMarker.hitmarker, 
		TweenInfo.new(fadeTime or self.HitMarker.fadeTime, easingStyle or self.HitMarker.easingStyle, easingDirection or self.HitMarker.easingDirection),
		{ImageTransparency = 1}
	):Play()
end

function CrosshairModule:Size(X : number, Y : number)
	self.SizeX 					= X or self.SizeX
	self.SizeY 					= Y or self.SizeY

	X = self.SizeX; Y = self.SizeY;

	self.Top	.Size 			= UDim2.fromOffset(Y, X)
	self.Bottom	.Size 			= UDim2.fromOffset(Y, X)
	self.Left	.Size 			= UDim2.fromOffset(X, Y)
	self.Right	.Size 			= UDim2.fromOffset(X, Y)
end

function CrosshairModule:Destroy()
	for Index, Value in pairs(self.Hairs) do
		Value:Destroy()
	end
	self.CenterDot.centerdot:Destroy()
	self.ImageCrosshair.crosshair:Destroy()
	table.remove(Crosshairs, table.find(Crosshairs, self))
	table.clear(self)
end

function CrosshairModule:Display(SettingsTable)
	local function ApplyAll(Setting, Value)
		for i, Hair in pairs(self.Hairs) do
			Hair[Setting] = Value
		end
	end

	for Setting, Value in pairs(SettingsTable) do
		local Success = pcall(function() local Check = self.Top[Setting] end)

		if Success then
			ApplyAll(Setting, Value)
		end
	end
end

function CrosshairModule:Set(Radius)
	self.Spreading.Spread 		= tonumber(Radius)
end

function CrosshairModule:SmoothSet(Spread : number, Seconds : number, UpdateMin : boolean)
	local StartTick 	= tick()
	local StartSpread 	= self.Spreading.Spread

	while ( tick() - StartTick ) < Seconds do
		
		local Alpha 	= (tick() - StartTick) / Seconds
		
		Alpha = TweenService:GetValue(
			Alpha,
			self.EasingStyle or Enum.EasingStyle.Linear,
			self.EasingDirection or Enum.EasingDirection.InOut
		)
		
		self.Spreading.Spread = StartSpread + (Spread - StartSpread) * Alpha 

		RunService.Heartbeat:Wait()
	end
	
	if UpdateMin then self.Spreading.MinSpread = self.Spreading.Spread end
	
	self.Spreading.Spread = Spread
end

function CrosshairModule:Shove()
	self.Spreading.Spread += self.Spreading.IncreasePerSecond
end

function CrosshairModule:Update(DeltaTime)
	if not self.Enabled then return end
	if not self.Locked then
		self.Spreading.Spread -= self.Spreading.DecreasePerSecond * DeltaTime
	end

	self.Spreading.Spread = math.clamp(self.Spreading.Spread, self.Spreading.MinSpread, self.Spreading.MaxSpread)

	local originX, originY

	if self.FollowingMouse then
		local mousePos = UserInputService:GetMouseLocation()
		originX = mousePos.X
		originY = mousePos.Y

		if self.UI:IsA("ScreenGui") and not self.UI.IgnoreGuiInset then
			local guiInset = GuiService:GetGuiInset()
			originY -= guiInset.Y
		end
	else
		if self.UI:IsA("ScreenGui") then
			local camera = workspace.CurrentCamera
			local size = camera.ViewportSize

			originX = size.X / 2
			originY = size.Y / 2

			if not self.UI.IgnoreGuiInset then
				local guiInset = GuiService:GetGuiInset()
				originY -= guiInset.Y
			end
		else
			local absPos = self.UI.AbsolutePosition
			local absSize = self.UI.AbsoluteSize

			originX = absPos.X + absSize.X / 2
			originY = absPos.Y + absSize.Y / 2
		end
	end

	local offsetX = originX
	local offsetY = originY

	if not self.UI:IsA("ScreenGui") then
		local uiAbsPos = self.UI.AbsolutePosition
		offsetX -= uiAbsPos.X
		offsetY -= uiAbsPos.Y
	end

	local Origin = UDim2.fromOffset(offsetX, offsetY)
	local VerticalOffset = UDim2.fromOffset(0, self.Spreading.Spread)
	local HorizontalOffset = UDim2.fromOffset(self.Spreading.Spread, 0)

	self.Top.Position 		= Origin - VerticalOffset
	self.Bottom.Position 	= Origin + VerticalOffset
	self.Right.Position 	= Origin - HorizontalOffset
	self.Left.Position 		= Origin + HorizontalOffset
	self.HitMarker.hitmarker.Position = Origin

	if self.CenterDot.enabled then
		local cd = self.CenterDot.centerdot
		cd.Visible = true
		cd.Image = self.CenterDot.Image
		cd.Size = self.CenterDot.size
		cd.ImageTransparency = self.CenterDot.transparency
		cd.Position = Origin
	else
		self.CenterDot.centerdot.Visible = false
	end

	if self.ImageCrosshair.enabled then
		local ic = self.ImageCrosshair.crosshair
		ic.Visible = true
		ic.Image = self.ImageCrosshair.Image
		ic.Size = UDim2.fromOffset(
			(self.SizeX * 2) + self.Spreading.Spread,
			(self.SizeX * 2) + self.Spreading.Spread
		)
		ic.Position = Origin
		Functions:UpdateEnabled(self.Hairs, false)
	else
		self.ImageCrosshair.crosshair.Visible = false
		Functions:UpdateEnabled(self.Hairs, true)
	end
end

function CrosshairModule:Raycast()
	local X, Y = Functions:RandomPointsInsideCrosshair(self.Spreading.Spread - (self.SizeX * 4))
	local Camera = workspace.CurrentCamera
	local ViewportSize = Camera.ViewportSize
	local mousePos = UserInputService:GetMouseLocation()

	local screenX, screenY

	if self.FollowingMouse then
		screenX = mousePos.X
		screenY = mousePos.Y
	else
		screenX = ViewportSize.X / 2
		screenY = ViewportSize.Y / 2
	end

	local raycastX = screenX + X
	local raycastY = screenY + Y

	local unitRay = Camera:ViewportPointToRay(raycastX, raycastY)
	return unitRay.Origin, unitRay.Direction
end


RunService.RenderStepped:Connect(function(Delta)
	for i, v in pairs(Crosshairs) do
		v:Update(Delta)
	end
end)

return CrosshairModule
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair.Functions | Enabled: N/A
--------------------------------------------------------------------
local Functions = {}

function Functions:CreateHairs(Parent, X, Y)
	local Hairs 	= {}

	for I = 1, 7 do
		local Frame 		= Instance.new("ImageLabel")
		Frame.Image 		= ''
		Frame.Name 			= "_hair"
		Frame.Parent 		= Parent
		Frame.AnchorPoint 	= Vector2.new(0.5, 0.5)

		if I < 3 then
			Frame.Size 		= UDim2.fromOffset(Y, X)
		elseif I > 2 and I < 5 then
			Frame.Size 		= UDim2.fromOffset(X, Y)
		elseif I == 5 then
			Frame.BackgroundTransparency	= 1
			Frame.Size 						= UDim2.fromOffset(50, 50)
			Frame.Image 					= 'rbxassetid://285779644'
			Frame.Name 						= "HitMarker"
			Frame.ImageTransparency			= 1
		elseif I == 6 then
			Frame.BackgroundTransparency	= 1
			Frame.Size 						= UDim2.fromOffset(10, 10)
			Frame.Image 					= 'rbxassetid://11003529439'
			Frame.Name 						= "CenterDot"
			Frame.ImageTransparency			= 0
			Frame.Visible 					= false
		else
			Frame.BackgroundTransparency	= 1
			Frame.Name 						= 'ImageCrosshair'
			Frame.Visible 					= false
		end

		table.insert(Hairs, I, Frame)
	end

	return unpack(Hairs)
end

function Functions:RandomPointsInsideCrosshair(Offset)
	local R 			= Offset * math.sqrt(math.random())
	local Theta 		= math.random() * 2 * math.pi
	local X 			= R * math.cos(Theta)
	local Y 			= R * math.sin(Theta)

	return X, Y
end


function Functions:UpdateEnabled(UI, Bool)
	for _, Item in pairs(UI) do
		Item.Visible = Bool
	end
end

return Functions
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair.Functions

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.CrosshairHandler | Enabled: N/A
--------------------------------------------------------------------
--- @ Crosshair Handler
local CrosshairHandler = {}

--- @ Crosshair Handler > Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")

--- @ Crosshair Handler > Dependencies
local DynamicCrosshair = require(ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair)

--- @ Crosshair Handler > Configuration
local CrosshairStyles = {
	["Circle"] = {
		Image = "rbxassetid://6707322206",
		MinSpread = 10,
		MaxSpread = 80,
		Decrease = 0, -- increase and decrease will always be left at 0.
		Increase = 0,
		ImageEnabled = true
	},
	["Dot"] = {
		Image = "rbxassetid://13413677345",
		MinSpread = 5,
		MaxSpread = 40,
		Decrease = 0,
		Increase = 0,
		ImageEnabled = true
	},
}

--- @ Crosshair Handler > Variables
local CrosshairInstance = nil
local CrosshairGUI = nil

--- @ Crosshair Handler > Logic
function CrosshairHandler.Init(player)
	if CrosshairInstance then return end

	local assetsToLoad = {}
	for _, style in pairs(CrosshairStyles) do
		if style.Image then
			table.insert(assetsToLoad, style.Image)
		end
	end

	task.spawn(function()
		local tempInstances = {}
		for _, id in ipairs(assetsToLoad) do
			local img = Instance.new("ImageLabel")
			img.Image = id
			table.insert(tempInstances, img)
		end
		ContentProvider:PreloadAsync(tempInstances)
		for _, img in ipairs(tempInstances) do
			img:Destroy()
		end
	end)

	CrosshairGUI = Instance.new("ScreenGui")
	CrosshairGUI.Name = "CrosshairGUI"
	CrosshairGUI.ResetOnSpawn = false
	CrosshairGUI.IgnoreGuiInset = true
	CrosshairGUI.DisplayOrder = 100 
	CrosshairGUI.Parent = player:WaitForChild("PlayerGui")

	CrosshairInstance = DynamicCrosshair.New(CrosshairGUI, 10, 80, 60, 40, false)
	CrosshairInstance:Disable()

	CrosshairHandler.SetStyle("Circle")
end

function CrosshairHandler.SetStyle(styleName)
	if not CrosshairInstance then return end

	local style = CrosshairStyles[styleName] or CrosshairStyles["Circle"]

	CrosshairInstance.Spreading.MinSpread = style.MinSpread
	CrosshairInstance.Spreading.MaxSpread = style.MaxSpread
	CrosshairInstance.Spreading.Spread = style.MinSpread 
	CrosshairInstance.Spreading.DecreasePerSecond = style.Decrease
	CrosshairInstance.Spreading.IncreasePerSecond = style.Increase

	CrosshairInstance.ImageCrosshair.enabled = style.ImageEnabled
	CrosshairInstance.ImageCrosshair.Image = style.Image

	if CrosshairInstance.ImageCrosshair.crosshair then
		CrosshairInstance.ImageCrosshair.crosshair.Image = style.Image
	end
end

function CrosshairHandler.SetVisible(visible)
	if not CrosshairInstance then return end

	if visible then
		CrosshairInstance:Enable()
	end

	local targetAlpha = visible and 0 or 1
	local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

	local tween = TweenService:Create(CrosshairInstance.ImageCrosshair.crosshair, tweenInfo, {ImageTransparency = targetAlpha})
	tween:Play()

	if not visible then
		task.delay(0.2, function()
			if CrosshairInstance.ImageCrosshair.crosshair.ImageTransparency >= 0.9 then
				CrosshairInstance:Disable()
			end
		end)
	end
end

function CrosshairHandler.SetSpread(value)
	if CrosshairInstance then
		CrosshairInstance:Set(value)
	end
end

return CrosshairHandler
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.CrosshairHandler

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.ClothingLoading | Enabled: N/A
--------------------------------------------------------------------
local CosmeticLoader = {}
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local CosmeticAssets = ReplicatedStorage.Peak.Assets.Clothing.Player.Backpacks

local function WaitForTorso(character)
	-- R6 Torso or R15 UpperTorso
	local torso = character:FindFirstChild("Torso")
		or character:FindFirstChild("UpperTorso")

	if torso then return torso end

	return character:WaitForChild("Torso", 3)
		or character:WaitForChild("UpperTorso", 3)
end


function CosmeticLoader.ApplyBackpack(player, character, backpackId)
	if not backpackId then return end

	local template = CosmeticAssets:FindFirstChild(backpackId)
	if not template then
		warn("Backpack not found:", backpackId)
		return
	end

	local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
	if not torso then
		warn("No torso for:", character.Name)
		return
	end

	local backpackClone = template:Clone()
	local bpPart = backpackClone:WaitForChild("TestBP")

	local motor = Instance.new("Motor6D")
	motor.Name = "BackpackMotor"
	motor.Part0 = torso
	motor.Part1 = bpPart
	motor.C0 = CFrame.new(0, 0.04, 0)
	motor.Parent = torso

	backpackClone.Parent = character

	print("Backpack attached:", backpackId)
	return backpackClone
end


function CosmeticLoader.LoadCosmetics(player, profileData)
	local character = player.Character
	if not character then return end

	local equipped = profileData.Cosmetics and profileData.Cosmetics.Equipped
	if not equipped then
		-- Retry once cosmetics finish loading
		task.delay(0.1, function()
			if player.Character then
				CosmeticLoader.LoadCosmetics(player, profileData)
			end
		end)
		return
	end

	if equipped.Backpack then
		CosmeticLoader.ApplyBackpack(player, character, equipped.Backpack)
	end
end


function CosmeticLoader.ConnectPlayer(player, profile)
	player.CharacterAdded:Connect(function(character)
		-- wait for character fully loaded
		character:WaitForChild("Humanoid")
		task.wait(0.25) -- More reliable than 0.1

		CosmeticLoader.LoadCosmetics(player, profile.Data)
	end)
end

return CosmeticLoader

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.ClothingLoading

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.ModuleScript | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.ModuleScript
  -  Edit
  18:44:45.355  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.CraftingRecipe | Enabled: N/A
--------------------------------------------------------------------

local module = {}

-- Each recipe:
-- name: string
-- ingredients: array of strings (types: "Alcohol", "Rag", "Binding", "Blade", "Explosive", "Canister", "Sugar", "Melee")
-- games: table of which game(s) this recipe appears in ("TLOU1", "TLOU2")
-- note: optional extra (e.g. upgrade behavior / quantity notes)

module.recipes = {
	{
		name = "Health Kit",
		ingredients = { "Alcohol", "Rag" },
		games = { "TLOU1", "TLOU2" },
		note = "Restores player health."
	},
	{
		name = "Molotov",
		ingredients = { "Alcohol", "Rag" },
		games = { "TLOU1", "TLOU2" },
		note = "Thrown incendiary; area damage."
	},
	{
		name = "Shiv",
		ingredients = { "Binding", "Blade" },
		games = { "TLOU1", "TLOU2" },
		note = "Used for stealth kills and unlocking shiv doors (TLOU1)."
	},
	{
		name = "Melee Upgrade",
		ingredients = { "Binding", "Blade", "Melee" },
		games = { "TLOU1", "TLOU2" },
		note = "Applied to melee weapons to increase durability / instant-kill chance."
	},
	{
		name = "Nail Bomb",
		ingredients = { "Blade", "Explosive" },
		games = { "TLOU1" },
		note = "High-damage explosive used in TLOU1."
	},
	{
		name = "Smoke Bomb",
		ingredients = { "Sugar", "Explosive" },
		games = { "TLOU1" },
		note = "Creates smoke to hide movement (TLOU1)."
	},
	{
		name = "Stun Bomb",
		ingredients = { "Canister", "Explosive" },
		games = { "TLOU2" },
		note = "In TLOU2 it's the stun bomb; can become Smoke Bomb if upgraded in-game."
	},
	{
		name = "Trap Mine",
		ingredients = { "Canister", "Explosive" },
		games = { "TLOU2" },
		note = "Placed proximity explosive in TLOU2."
	},
	{
		name = "Silencer",
		ingredients = { "Rag", "Canister" },
		games = { "TLOU2" },
		note = "Attach to pistols/shotguns to reduce sound (TLOU2)."
	},
	{
		name = "Arrows",
		ingredients = { "Binding", "Blade" },
		games = { "TLOU2" },
		note = "Craft ammunition for the bow."
	},
	{
		name = "Explosive Arrows",
		ingredients = { "Explosive", "Binding" },
		games = { "TLOU2" },
		note = "Arrows rigged with explosive for area damage."
	},
	{
		name = "Pipe Bomb",
		ingredients = { "Alcohol", "Canister", "Explosive" },
		games = { "TLOU2" },
		note = "Powerful thrown explosive (TLOU2)."
	},
	{
		name = "Incendiary Shells",
		ingredients = { "Alcohol", "Explosive" },
		games = { "TLOU2" },
		note = "Special shotgun ammo that ignites targets."
	},
	{
		name = "Hunting Pistol Ammo",
		ingredients = { "Explosive", "Blade" },
		games = { "TLOU2" },
		note = "Crafted ammo for hunting pistol in TLOU2."
	},
	{
		name = "Pipe Bomb (legacy/nail-style)",
		ingredients = { "Blade", "Explosive", "Canister" },
		games = { "TLOU1", "TLOU2" },
		note = "If you prefer a single 'pipe-style' explosive entry (some guides vary in naming)."
	},
}

-- Helper: find recipe by name (case-insensitive)
function module.findRecipe(name)
	local lower = name:lower()
	for _, r in ipairs(module.recipes) do
		if r.name:lower() == lower then
			return r
		end
	end
	return nil
end

-- Helper: list recipes available for a given game id ("TLOU1" or "TLOU2")
function module.listForGame(gameId)
	local out = {}
	for _, r in ipairs(module.recipes) do
		for _, g in ipairs(r.games) do
			if g == gameId then
				table.insert(out, r)
				break
			end
		end
	end
	return out
end

-- Helper: check craftable given an inventory (table with counts keyed by material name)
-- inventory example: { Alcohol = 1, Rag = 2, Binding = 1, Blade = 1, Explosive = 0, Canister = 1, Sugar = 0, Melee = 1 }
function module.canCraft(recipe, inventory)
	for _, mat in ipairs(recipe.ingredients) do
		if not inventory[mat] or inventory[mat] <= 0 then
			return false
		end
	end
	return true
end

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.CraftingRecipe

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.HitmarkerHandler | Enabled: N/A
--------------------------------------------------------------------
-- HitmarkerCrosshairModule.lua
local HitmarkerCrosshair = {}
HitmarkerCrosshair.__index = HitmarkerCrosshair

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

--====================================================
-- Constructor
--====================================================
function HitmarkerCrosshair.new(parentGui)
	local self = setmetatable({}, HitmarkerCrosshair)

	self.UI = parentGui or Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
	self.UI.Name = "HitmarkerCrosshair"
	self.UI.IgnoreGuiInset = true

	--============================
	-- CROSSHAIR
	--============================
	local cross = Instance.new("ImageLabel")
	cross.Name = "Crosshair"
	cross.BackgroundTransparency = 1
	cross.Image = "rbxassetid://11003529439" -- white dot
	cross.Size = UDim2.fromOffset(6,6)
	cross.AnchorPoint = Vector2.new(.5,.5)
	cross.Visible = false
	cross.Parent = self.UI
	self.Crosshair = cross

	self.FollowMouse = false

	--============================
	-- HITMARKER
	--============================
	local hit = Instance.new("ImageLabel")
	hit.Name = "Hitmarker"
	hit.BackgroundTransparency = 1
	hit.Image = "rbxassetid://118682730809232" -- default
	hit.AnchorPoint = Vector2.new(.5,.5)
	hit.Size = UDim2.fromOffset(50,50)
	hit.ImageTransparency = 1
	hit.Parent = self.UI
	self.Hitmarker = hit

	self.Styles = {
		DefaultImage = "rbxassetid://118682730809232",
		HeadshotImage = "rbxassetid://102213744787573",
		DefaultColor = Color3.new(1,1,1),
		HeadshotColor = Color3.new(1,0,0),
		FadeTime = 0.25
	}

	-- Listen every frame
	RunService.RenderStepped:Connect(function()
		self:_update()
	end)

	return self
end

--====================================================
-- Enable/Disable Crosshair
--====================================================
function HitmarkerCrosshair:EnableCrosshair()
	self.Crosshair.Visible = true
end

function HitmarkerCrosshair:DisableCrosshair()
	self.Crosshair.Visible = false
end

--====================================================
-- Follow Mouse vs Stay Centered
--====================================================
function HitmarkerCrosshair:FollowMouse(bool)
	self.FollowMouse = bool
end

--====================================================
-- HITMARKER
--====================================================
function HitmarkerCrosshair:HitMarker(isHeadshot)
	local hit = self.Hitmarker

	if isHeadshot then
		hit.Image = self.Styles.HeadshotImage
		hit.ImageColor3 = self.Styles.HeadshotColor
	else
		hit.Image = self.Styles.DefaultImage
		hit.ImageColor3 = self.Styles.DefaultColor
	end

	hit.ImageTransparency = 0
	hit.Size = UDim2.fromOffset(50, 50)

	-- Fade out tween
	TweenService:Create(
		hit,
		TweenInfo.new(self.Styles.FadeTime, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),
		{ ImageTransparency = 1 }
	):Play()
end

--====================================================
-- UPDATE LOOP
--====================================================
function HitmarkerCrosshair:_update()
	local x, y

	if self.FollowMouse then
		local pos = UserInputService:GetMouseLocation()
		x = pos.X
		y = pos.Y
	else
		local cam = workspace.CurrentCamera
		local size = cam.ViewportSize
		x = size.X / 2
		y = size.Y / 2
	end

	self.Crosshair.Position = UDim2.fromOffset(x, y)
	self.Hitmarker.Position = UDim2.fromOffset(x, y)
end

return HitmarkerCrosshair

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.HitmarkerHandler

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.LeanController | Enabled: N/A
--------------------------------------------------------------------
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LeanController = {}

--- @ Core System
local remotes = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes")
local ReplicateLean = remotes:WaitForChild("ReplicateLean")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local character = nil
local rootPart, rootJoint, neck = nil, nil, nil

local isRunning = false
local renderConnection = nil

--- @ Core System > Configuration
local Config = {
	bodyHorizontalFactor = 0.2, 
	bodyVerticalFactor = 0.2,
	headHorizontalFactor = 0.6, 
	headVerticalFactor = 0.6,
	frequency = 36,
	damping = 0.2,
	ReplicationRate = 1/20,
	InterpolationSpeed = 15,
}

--- @ Core System > State
local allOriginalC0s = setmetatable({}, {__mode = "k"})
local foreignState = {} 

local globalStrength = 1.0
local intensities = {
	bodyHorizontal = 1.0, 
	bodyVertical = 1.0,
	headHorizontal = 1.0, 
	headVertical = 1.0,
}

local bodyRoll, bodyRoll_v = 0, 0
local bodyPitch, bodyPitch_v = 0, 0
local headRoll, headRoll_v = 0, 0
local headPitch, headPitch_v = 0, 0

local lastReplicationTime = 0

--- @ Core System > Logic
local function lerp(a, b, t)
	return a + (b - a) * t
end

local function updateSpring(current, velocity, target, f, d, dt)
	local acceleration = (target - current) * f * dt
	velocity = (velocity + acceleration) / (1 + d * dt)
	return current + velocity * dt, velocity
end

local function getOriginalC0s(char)
	if not allOriginalC0s[char] then
		local rp = char:FindFirstChild("HumanoidRootPart")
		local torso = char:FindFirstChild("Torso")
		if rp and torso then
			local rj = rp:FindFirstChild("RootJoint")
			local nk = torso:FindFirstChild("Neck")
			if rj and nk then
				allOriginalC0s[char] = {
					root = rj.C0,
					neck = nk.C0
				}
			end
		end
	end
	return allOriginalC0s[char]
end

--- @ Core System > Logic > Render Loop
local function onRenderStep(deltaTime)
	deltaTime = math.min(deltaTime, 1/30)

	-- 1. Handle Local Player Spring Physics
	if isRunning and rootPart then
		local camDir = rootPart.CFrame:VectorToObjectSpace(camera.CFrame.LookVector)

		-- Apply Config multipliers AND Dynamic Intensities AND Global Strength
		local targetBR = -camDir.X * Config.bodyHorizontalFactor * intensities.bodyHorizontal * globalStrength
		local targetBP = -camDir.Y * Config.bodyVerticalFactor * intensities.bodyVertical * globalStrength
		local targetHR = -camDir.X * Config.headHorizontalFactor * intensities.headHorizontal * globalStrength
		local targetHP = -camDir.Y * Config.headVerticalFactor * intensities.headVertical * globalStrength

		local f = Config.frequency * 2 * math.pi
		local d = Config.damping * f

		bodyRoll, bodyRoll_v = updateSpring(bodyRoll, bodyRoll_v, targetBR, f, d, deltaTime)
		bodyPitch, bodyPitch_v = updateSpring(bodyPitch, bodyPitch_v, targetBP, f, d, deltaTime)
		headRoll, headRoll_v = updateSpring(headRoll, headRoll_v, targetHR, f, d, deltaTime)
		headPitch, headPitch_v = updateSpring(headPitch, headPitch_v, targetHP, f, d, deltaTime)

		local orig = getOriginalC0s(character)
		if orig and rootJoint and neck then
			rootJoint.C0 = orig.root * CFrame.Angles(bodyPitch, 0, bodyRoll)
			neck.C0 = orig.neck * CFrame.Angles(headPitch, 0, headRoll)
		end

		-- Replication Throttling
		local now = os.clock()
		if now - lastReplicationTime > Config.ReplicationRate then
			ReplicateLean:FireServer(bodyPitch, bodyRoll, headPitch, headRoll)
			lastReplicationTime = now
		end
	end

	-- 2. Handle Foreign Players Interpolation
	for plr, data in pairs(foreignState) do
		if plr.Character and plr.Character.Parent then
			data.current.bp = lerp(data.current.bp, data.target.bp, deltaTime * Config.InterpolationSpeed)
			data.current.br = lerp(data.current.br, data.target.br, deltaTime * Config.InterpolationSpeed)
			data.current.hp = lerp(data.current.hp, data.target.hp, deltaTime * Config.InterpolationSpeed)
			data.current.hr = lerp(data.current.hr, data.target.hr, deltaTime * Config.InterpolationSpeed)

			local orig = getOriginalC0s(plr.Character)
			local rj = plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.HumanoidRootPart:FindFirstChild("RootJoint")
			local nk = plr.Character:FindFirstChild("Torso") and plr.Character.Torso:FindFirstChild("Neck")

			if orig and rj and nk then
				rj.C0 = orig.root * CFrame.Angles(data.current.bp, 0, data.current.br)
				nk.C0 = orig.neck * CFrame.Angles(data.current.hp, 0, data.current.hr)
			end
		else
			foreignState[plr] = nil 
		end
	end
end

--- @ Core System > Networking
ReplicateLean.OnClientEvent:Connect(function(playerWhoSent, bp, br, hp, hr)
	if playerWhoSent == player then return end

	if not foreignState[playerWhoSent] then
		foreignState[playerWhoSent] = {
			current = {bp=bp, br=br, hp=hp, hr=hr},
			target = {bp=bp, br=br, hp=hp, hr=hr}
		}
	end

	local state = foreignState[playerWhoSent]
	state.target.bp = bp
	state.target.br = br
	state.target.hp = hp
	state.target.hr = hr
end)

--- @ Core System > API
function LeanController.SetIntensity(leanType, value)
	if intensities[leanType] then
		intensities[leanType] = math.clamp(value, 0, 100) / 100
	else
		warn("LeanController: Invalid leanType '" .. tostring(leanType) .. "'")
	end
end

function LeanController.SetGlobalStrength(value)
	globalStrength = math.clamp(value, 0, 100) / 100
end

--- @ Core System > Lifecycle
function LeanController.Start()
	if isRunning then return end

	character = player.Character or player.CharacterAdded:Wait()
	rootPart = character:WaitForChild("HumanoidRootPart")
	rootJoint = rootPart:WaitForChild("RootJoint")
	local torso = character:WaitForChild("Torso")
	neck = torso:WaitForChild("Neck")

	getOriginalC0s(character)

	isRunning = true
	renderConnection = RunService.RenderStepped:Connect(onRenderStep)
end

function LeanController.Stop()
	if not isRunning then return end
	isRunning = false
	if renderConnection then renderConnection:Disconnect() end

	local orig = getOriginalC0s(character)
	if orig and rootJoint and neck then
		rootJoint.C0 = orig.root
		neck.C0 = orig.neck
	end
end

return LeanController
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.LeanController

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.R6IK | Enabled: N/A
--------------------------------------------------------------------
local R6IK = {}
R6IK.__index = R6IK

local function clamp(val, min, max)
	return math.max(min, math.min(max, val))
end

local function SolveIK(originCF, targetPos, l1, l2, poleVector)
	local planeWorld = CFrame.lookAt(originCF.Position, targetPos, originCF:VectorToWorldSpace(poleVector))
	local planeLocal = originCF:ToObjectSpace(planeWorld)

	local localizedPos = originCF:PointToObjectSpace(targetPos)
	local dist = localizedPos.Magnitude
	local maxReach = l1 + l2
	local minReach = math.abs(l1 - l2)

	if dist >= maxReach - 0.001 then
		return planeLocal, math.pi/2, 0
	elseif dist <= minReach + 0.001 then
		local pushBack = maxReach - dist
		return planeLocal * CFrame.new(0, 0, -pushBack), -math.pi/2, math.pi
	else
		local cosA1 = (-(l2 * l2) + (l1 * l1) + (dist * dist)) / (2 * l1 * dist)
		local a1 = -math.acos(clamp(cosA1, -1, 1))
		local cosA2 = ((l2 * l2) - (l1 * l1) + (dist * dist)) / (2 * l2 * dist)
		local a2 = math.acos(clamp(cosA2, -1, 1))
		return planeLocal, a1 + math.pi/2, a2 - a1
	end
end

local function WorldCFrameToC0ObjectSpace(motor6DJoint, worldCFrame)
	local part0 = motor6DJoint.Part0
	local c1Store = motor6DJoint.C1
	local relativeToPart0 = part0.CFrame:Inverse() * worldCFrame * c1Store
	return relativeToPart0
end

function R6IK.New(Character)
	local self = setmetatable({}, R6IK)

	self.Character = Character
	self.Torso = Character:WaitForChild("Torso")
	self.LeftArm = Character:WaitForChild("Left Arm")
	self.RightArm = Character:WaitForChild("Right Arm")
	self.LeftLeg = Character:WaitForChild("Left Leg")
	self.RightLeg = Character:WaitForChild("Right Leg")

	self.Motor6Ds = {
		["Left Shoulder"] = self.Torso["Left Shoulder"],
		["Right Shoulder"] = self.Torso["Right Shoulder"],
		["Left Hip"] = self.Torso["Left Hip"],
		["Right Hip"] = self.Torso["Right Hip"],
	}

	self.OriginalC0s = {}
	self.C1s = {}

	for name, motor in pairs(self.Motor6Ds) do
		self.OriginalC0s[name] = motor.C0
		self.C1s[name] = motor.C1
	end

	self.UpperLen = 1
	self.LowerLen = 1

	return self
end

function R6IK:ApplyC0(motorName, finalWorldCF, rigidMode, influence)
	local motor = self.Motor6Ds[motorName]
	local originalC0 = self.OriginalC0s[motorName]

	local targetC0 = WorldCFrameToC0ObjectSpace(motor, finalWorldCF)

	if rigidMode then
		targetC0 = targetC0 * motor.Transform:Inverse()
	end

	influence = clamp(influence or 1, 0, 1)

	if influence >= 0.99 then
		motor.C0 = targetC0
	elseif influence <= 0.01 then
		motor.C0 = originalC0
	else
		motor.C0 = originalC0:Lerp(targetC0, influence)
	end
end

function R6IK:ArmIK(Side, Position, rigidMode, influence)
	local motorName = Side .. " Shoulder"
	local arm = (Side == "Left") and self.LeftArm or self.RightArm
	local motor = self.Motor6Ds[motorName]
	if not motor then return end

	local baseOffset = (Side == "Left") and self.C1s[motorName].X or -self.C1s[motorName].X
	local originCF = self.Torso.CFrame * self.OriginalC0s[motorName] * CFrame.new(0, 0, baseOffset)

	local poleVector = Vector3.yAxis 
	local planeLocal, shoulderAng, elbowAng = SolveIK(originCF, Position, self.UpperLen, self.LowerLen, poleVector)

	local shoulderAngleCF = CFrame.Angles(shoulderAng, 0, 0)
	local elbowAngleCF = CFrame.Angles(elbowAng, 0, 0)

	local localArmCF = planeLocal 
		* shoulderAngleCF 
		* CFrame.new(0, -self.UpperLen * 0.5, 0)
		* elbowAngleCF 
		* CFrame.new(0, -self.LowerLen * 0.5, 0)
		* CFrame.new(0, (arm.Size.Y - self.LowerLen)*0.5, 0)

	local finalWorldCF = originCF * localArmCF

	self:ApplyC0(motorName, finalWorldCF, rigidMode, influence)
end

function R6IK:LegIK(Side, Position, rigidMode, influence)
	local motorName = Side .. " Hip"
	local leg = (Side == "Left") and self.LeftLeg or self.RightLeg
	local motor = self.Motor6Ds[motorName]
	if not motor then return end

	local rotOffset = (Side == "Left") and CFrame.Angles(0, math.pi/2, 0) or CFrame.Angles(0, -math.pi/2, 0)
	local originCF = self.Torso.CFrame * self.OriginalC0s[motorName] * rotOffset

	local poleVector = Vector3.new(0, 0, -1)
	local planeLocal, hipAng, kneeAng = SolveIK(originCF, Position, self.UpperLen, self.LowerLen, poleVector)

	local hipAngleCF = CFrame.Angles(hipAng, 0, 0)
	local kneeAngleCF = CFrame.Angles(kneeAng, 0, 0)

	local localLegCF = planeLocal 
		* hipAngleCF 
		* CFrame.new(0, -self.UpperLen * 0.5, 0) 
		* kneeAngleCF 
		* CFrame.new(0, -self.LowerLen * 0.5, 0) 
		* CFrame.new(0, (leg.Size.Y - self.LowerLen)*0.5, 0)

	local finalWorldCF = originCF * localLegCF

	self:ApplyC0(motorName, finalWorldCF, rigidMode, influence)
end

function R6IK:Stop(Side)
	if Side == "Left" or Side == "Right" then
		local armName = Side .. " Shoulder"
		local legName = Side .. " Hip"
		if self.Motor6Ds[armName] then self.Motor6Ds[armName].C0 = self.OriginalC0s[armName] end
		if self.Motor6Ds[legName] then self.Motor6Ds[legName].C0 = self.OriginalC0s[legName] end
	else
		for name, motor in pairs(self.Motor6Ds) do
			motor.C0 = self.OriginalC0s[name]
		end
	end
end

return R6IK
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.R6IK

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.FootPlanting | Enabled: N/A
--------------------------------------------------------------------
local FootPlanting = {}

--- @ Core System
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

--- @ Core System > Configuration
local Config = {
	LegLength = 2,
	RayDistance = 5,
	MaxStretch = 0.4,
	MaxCrouch = -0.2,
	Smoothing = 8,

	Influence = 70,
	RotationInfluence = 30,

	StepForwardRatio = 0.3,
	StepTiltRatio = 0.8, 
}

--- @ Core System > State
local character
local torso
local rightHip, leftHip
local originalRightC0, originalLeftC0
local raycastParams
local connection
local isEnabled = false

--- @ Core System > Logic
local function updateLeg(motor, originalC0, dt)
	if not motor or not character then return end

	local hipWorldCFrame = torso.CFrame * originalC0
	local rayOrigin = hipWorldCFrame.Position
	local rayDirection = Vector3.new(0, -Config.RayDistance, 0)

	local ignoreList = {character}
	raycastParams.FilterDescendantsInstances = ignoreList

	local result
	for i = 1, 10 do
		result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
		if not result then break end

		local part = result.Instance

		if part:IsDescendantOf(character) or part.CanCollide == false or part.Transparency == 1 then
			table.insert(ignoreList, part)
			raycastParams.FilterDescendantsInstances = ignoreList
			result = nil
		else
			break
		end
	end

	local goalC0 = originalC0

	if result then
		local distanceToGround = (rayOrigin - result.Position).Magnitude
		local offset = distanceToGround - Config.LegLength

		if offset > Config.MaxStretch then offset = Config.MaxStretch end
		if offset < Config.MaxCrouch then offset = Config.MaxCrouch end

		local raise = math.max(0, -offset)
		local forwardShift = raise * Config.StepForwardRatio
		local hipBend = raise * Config.StepTiltRatio

		local localNormal = torso.CFrame:VectorToObjectSpace(result.Normal)
		local upVector = Vector3.new(0, 1, 0)
		local axis = upVector:Cross(localNormal)
		local angle = math.acos(math.clamp(localNormal.Y, -1, 1))
		local rotationCF = CFrame.fromAxisAngle(axis, angle)

		local hipPos = originalC0.Position
		local hipRot = originalC0.Rotation

		local posCF = CFrame.new(hipPos) * CFrame.new(0, -offset, -forwardShift)
		local targetRotC0 = posCF * rotationCF * CFrame.Angles(hipBend, 0, 0) * hipRot
		local heightOnlyC0 = posCF * CFrame.Angles(hipBend, 0, 0) * hipRot
		local blendedC0 = heightOnlyC0:Lerp(targetRotC0, Config.RotationInfluence / 100)

		goalC0 = originalC0:Lerp(blendedC0, Config.Influence / 100)
	end

	motor.C0 = motor.C0:Lerp(goalC0, 1 - math.exp(-dt * Config.Smoothing))
end

local function onRenderStep(dt)
	if not character or not torso then return end
	updateLeg(rightHip, originalRightC0, dt)
	updateLeg(leftHip, originalLeftC0, dt)
end

--- @ Core System > API
function FootPlanting.Start()
	if isEnabled then return end
	isEnabled = true

	local player = Players.LocalPlayer
	character = player.Character or player.CharacterAdded:Wait()
	torso = character:WaitForChild("Torso")
	rightHip = torso:WaitForChild("Right Hip")
	leftHip = torso:WaitForChild("Left Hip")

	originalRightC0 = rightHip.C0
	originalLeftC0 = leftHip.C0

	raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	if connection then connection:Disconnect() end
	connection = RunService.RenderStepped:Connect(onRenderStep)
end

function FootPlanting.Stop()
	if not isEnabled then return end
	isEnabled = false

	if connection then connection:Disconnect() end

	local resetTime = 0
	local tempConnection
	tempConnection = RunService.RenderStepped:Connect(function(dt)
		resetTime += dt
		if resetTime > 0.2 then
			if rightHip then rightHip.C0 = originalRightC0 end
			if leftHip then leftHip.C0 = originalLeftC0 end
			tempConnection:Disconnect()
			return
		end

		if rightHip then rightHip.C0 = rightHip.C0:Lerp(originalRightC0, 0.2) end
		if leftHip then leftHip.C0 = leftHip.C0:Lerp(originalLeftC0, 0.2) end
	end)
end

function FootPlanting.SetEnabled(state)
	if state then
		FootPlanting.Start()
	else
		FootPlanting.Stop()
	end
end

function FootPlanting.SetInfluence(value)
	Config.Influence = math.clamp(value, 0, 100)
end

function FootPlanting.SetRotationInfluence(value)
	Config.RotationInfluence = math.clamp(value, 0, 100)
end

return FootPlanting
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.FootPlanting

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule | Enabled: N/A
--------------------------------------------------------------------
local PlayerService = game:GetService("Players")
local RunService = game:GetService("RunService")

local Client = PlayerService.LocalPlayer

local CollisionParams = RaycastParams.new()
CollisionParams.IgnoreWater = true
CollisionParams.RespectCanCollide = true
CollisionParams.FilterType = Enum.RaycastFilterType.Exclude

local CollisionParams2 = OverlapParams.new()
CollisionParams2.RespectCanCollide = true
CollisionParams2.FilterType = Enum.RaycastFilterType.Exclude

local RootMotionModule = {}
local TemporaryParts = {
	["Connection"] = nil :: RBXScriptConnection?,
	["AutoStopThread"] = nil :: thread?
}

local activeCharacter = nil
local activeHumanoid = nil
local activeTorso = nil
local activeHead = nil

local function VerifyCollision(OldCFrame, NewCFrame, Size)
	local BlockRay = workspace:Blockcast(OldCFrame, Size, (NewCFrame.Position - OldCFrame.Position), CollisionParams)
	local TouchingParts = workspace:GetPartBoundsInBox(NewCFrame, Size, CollisionParams2)

	if (BlockRay and BlockRay.Instance :: Instance? ~= nil) then
		return false        
	end

	if #TouchingParts >= 1 then
		return false
	end

	return true
end

function RootMotionModule:StartCorrection(Configuration)
	self:DestroyDependencies(false, false)

	local Character = Client.Character
	if not Character then return end

	local Humanoid = Character:WaitForChild("Humanoid", 10)
	local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 10)
	local Head = Character:WaitForChild("Head", 10)

	if not Humanoid or not HumanoidRootPart then return end

	activeCharacter = Character
	activeHumanoid = Humanoid
	activeHead = Head

	local HRPSize = HumanoidRootPart.Size
	local Motor = nil :: Motor6D?
	local Torso = nil

	if Humanoid.RigType == Enum.HumanoidRigType.R15 then
		Torso = Character:FindFirstChild("LowerTorso") :: Part
		Motor = (Torso :: Part):FindFirstChild("Root") :: Motor6D
	else
		Torso = Character:FindFirstChild("Torso") :: Part
		Motor = HumanoidRootPart:FindFirstChild("RootJoint") :: Motor6D
	end

	activeTorso = Torso

	local CFrameToRead = HumanoidRootPart.CFrame

	if Configuration.AlignHRPCFrame then
		local LookDirection = (Vector3.yAxis:Cross(HumanoidRootPart.CFrame.RightVector)).Unit 
		CFrameToRead = CFrame.lookAt(HumanoidRootPart.Position, HumanoidRootPart.Position + LookDirection * Vector3.new(1, 0, 1)) 
	end

	CollisionParams:AddToFilter(Character)
	CollisionParams2:AddToFilter(Character)

	if Configuration.Whitelist ~= nil then
		CollisionParams:AddToFilter(Configuration.Whitelist :: {Instance}) 
		CollisionParams2:AddToFilter(Configuration.Whitelist :: {Instance})
	end

	if Motor ~= nil then
		Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		Humanoid.AutoRotate = false

		for Index, Limbs in Character:GetChildren() do
			if Limbs:IsA("BasePart") then
				(Limbs :: Part).CanCollide = false 
			end
		end

		Torso.Anchored = true 

		HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
		HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero
		Torso.AssemblyLinearVelocity = Vector3.zero
		Torso.AssemblyAngularVelocity = Vector3.zero

		HumanoidRootPart.CFrame = CFrameToRead

		local OldPosition = CFrameToRead.Position
		local OldXRotation, OldYRotation, OldZRotation = CFrameToRead:ToOrientation()

		local C0 = Motor.C0
		local C1 = Motor.C1

		TemporaryParts.Connection = RunService.PreSimulation:Connect(function(DeltaTime) 
			debug.profilebegin("Root motion")

			if not HumanoidRootPart or not Motor then return end

			local Transform = Motor.Transform
			local NewCFrame = CFrame.identity

			local NewTorsoCFrame = HumanoidRootPart.CFrame * C0 * Transform * C1:Inverse()
			local CurrentTorsoCFrame = HumanoidRootPart.CFrame

			local RootMotionDelta = CurrentTorsoCFrame:ToObjectSpace(NewTorsoCFrame)

			if Configuration.TranslationScale then
				local scaledPos = RootMotionDelta.Position * Configuration.TranslationScale
				RootMotionDelta = CFrame.new(scaledPos) * RootMotionDelta.Rotation
			end

			NewCFrame = CFrameToRead * RootMotionDelta

			if not Configuration.IgnoreCollision and not VerifyCollision(HumanoidRootPart.CFrame, NewCFrame, HRPSize) then 
				NewCFrame = CFrame.new(HumanoidRootPart.Position) * NewCFrame.Rotation
			end

			HumanoidRootPart.CFrame = NewCFrame
			Motor.Transform = CFrame.identity

			if Configuration.MaintainVelocity then
				local NewPosition = NewCFrame.Position
				local NewXRotation, NewYRotation, NewZRotation = NewCFrame:ToOrientation()
				local LinearVelocity = (NewPosition - OldPosition) / DeltaTime
				local AngularVelocity = Vector3.new(math.deg(NewXRotation - OldXRotation), math.deg(NewYRotation - OldYRotation), math.deg(NewZRotation - OldZRotation)) * 0.02

				HumanoidRootPart.AssemblyLinearVelocity = LinearVelocity
				HumanoidRootPart.AssemblyAngularVelocity = AngularVelocity
				Torso.AssemblyLinearVelocity = LinearVelocity
				Torso.AssemblyAngularVelocity = AngularVelocity

				OldPosition = NewPosition
				OldXRotation, OldYRotation, OldZRotation = NewXRotation, NewYRotation, NewZRotation 
			end

			debug.profileend()
		end) 

		if Configuration.Track then
			Configuration.Track:Play()

			task.spawn(function()
				local track = Configuration.Track

				while track.Length == 0 do
					task.wait()
				end

				local stopTime = math.max(0, track.Length - 0.1)

				TemporaryParts.AutoStopThread = task.delay(stopTime, function()
					TemporaryParts.AutoStopThread = nil 
					self:DestroyDependencies(true, false)
					track:Stop(0) 
				end)
			end)
		end
	end
end

function RootMotionModule:DestroyDependencies(ReverseAllEffects : boolean, Replicate : boolean)    
	if TemporaryParts.Connection ~= nil then
		TemporaryParts.Connection:Disconnect()
		TemporaryParts.Connection = nil
	end

	if TemporaryParts.AutoStopThread then
		task.cancel(TemporaryParts.AutoStopThread)
		TemporaryParts.AutoStopThread = nil
	end

	CollisionParams.FilterDescendantsInstances = {}
	CollisionParams2.FilterDescendantsInstances = {}

	if activeTorso ~= nil then
		activeTorso.Anchored = false
	end

	if ReverseAllEffects and activeHumanoid then
		activeHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		activeHumanoid.AutoRotate = true

		if activeTorso ~= nil then
			activeTorso.CanCollide = true
		end

		if activeHead ~= nil then
			activeHead.CanCollide = true
		end
	end
end

return RootMotionModule
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule.DebugDraw | Enabled: N/A
--------------------------------------------------------------------
local Debris = game:GetService("Debris")
local DebugDraw = {}

local DEFAULT_COLOR = Color3.fromRGB(255, 0, 0)
local DEFAULT_DURATION = 3

function DebugDraw.Line(origin: Vector3, endPos: Vector3, color: Color3?, duration: number?)
	local distance = (endPos - origin).Magnitude
	local p = Instance.new("Part")

	p.Name = "DebugLine"
	p.Anchored = true
	p.CanCollide = false
	p.CanQuery = false
	p.CastShadow = false
	p.Material = Enum.Material.Neon
	p.Color = color or DEFAULT_COLOR
	p.Size = Vector3.new(0.1, 0.1, distance)

	p.CFrame = CFrame.lookAt(origin, endPos) * CFrame.new(0, 0, -distance/2)
	p.Parent = workspace.Terrain

	Debris:AddItem(p, duration or DEFAULT_DURATION)
end

function DebugDraw.Sphere(position: Vector3, radius: number?, color: Color3?, duration: number?)
	local p = Instance.new("Part")
	local size = radius or 0.5

	p.Name = "DebugSphere"
	p.Anchored = true
	p.CanCollide = false
	p.CanQuery = false
	p.CastShadow = false
	p.Shape = Enum.PartType.Ball
	p.Material = Enum.Material.Neon
	p.Color = color or DEFAULT_COLOR
	p.Size = Vector3.new(size, size, size)
	p.Position = position
	p.Parent = workspace.Terrain

	Debris:AddItem(p, duration or DEFAULT_DURATION)
end

return DebugDraw
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule.DebugDraw

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.Animations.Animations | Enabled: N/A
--------------------------------------------------------------------
local Animations = {}

--- @ Core System
local ContentProvider = game:GetService("ContentProvider")

--- @ Core System > Configuration
--- @ Core System > Animations
local AnimationList = {
	-- movement
	Idle = { Id = "rbxassetid://78425065897558", Priority = Enum.AnimationPriority.Idle },
	Walk = { Id = "rbxassetid://113803262890384", Priority = Enum.AnimationPriority.Movement },
	Run  = { Id = "rbxassetid://121673499241134", Priority = Enum.AnimationPriority.Movement },

	CrouchIdle  = { Id = "rbxassetid://93492672587360", Priority = Enum.AnimationPriority.Idle },
	CrouchWalk  = { Id = "rbxassetid://108247959331945", Priority = Enum.AnimationPriority.Movement },

	ProneIdle  = { Id = "rbxassetid://92202783591585", Priority = Enum.AnimationPriority.Idle },
	ProneWalk  = { Id = "rbxassetid://102031427994404", Priority = Enum.AnimationPriority.Movement },

	--stance actions
	CrouchToProne  = { Id = "rbxassetid://93314542735298", Priority = Enum.AnimationPriority.Action },
	StandToCrouch  = { Id = "rbxassetid://88598341349330", Priority = Enum.AnimationPriority.Action },

	--backpack -standing
	BpStandingOn = { Id = "rbxassetid://114052209660012", Priority = Enum.AnimationPriority.Action },
	BpStandingOff = { Id = "rbxassetid://140198126915613", Priority = Enum.AnimationPriority.Action },
	--backpack -crouching
	BpCrouchingOn = { Id = "rbxassetid://123040051320408", Priority = Enum.AnimationPriority.Action },
	BpCrouchingOff = { Id = "rbxassetid://112277920930681", Priority = Enum.AnimationPriority.Action },
	--backpack -prone
	BpProneOn = { Id = "rbxassetid://101870072841274", Priority = Enum.AnimationPriority.Action },
	BpProneOff = { Id = "rbxassetid://92038037938033", Priority = Enum.AnimationPriority.Action },
	
	--base idles / actions
	BpIdle = { Id = "rbxassetid://94593828210874", Priority = Enum.AnimationPriority.Action },
	BpCraftLoop = { Id = "rbxassetid://125069610495737", Priority = Enum.AnimationPriority.Action2 },
	BpProneIdle = { Id = "rbxassetid://114584694505649", Priority = Enum.AnimationPriority.Action },
	BpProneCraftLoop = { Id = "rbxassetid://85991541209761", Priority = Enum.AnimationPriority.Action2 },
	--vaulting
	Vault = { Id = "rbxassetid://107592423336646", Priority = Enum.AnimationPriority.Action, BaseDistance = 6, ForwardOffset = 3.5 },

}

--STANDING ANIMATIONS
--backpackoff - 71289003009549
--backpack on - 87321975347140
--backpack idle - 99116978113436
--backpack crafting loop - 76209966750178

--CROUCHING ANIMATIONS
--backpack off - 80991751202429
--backpack on - 110632590807070


--unarmed
--crouch idle - 86995006751357
--crouch walk - 112781589825536
-- crouch2prone - 105749305366297
--stand2crouch - 80817862725486

--prone idle - 135865185555412
--prone crawl - 98524457967574


--- @ Core System > API
function Animations.GetData(name)
	return AnimationList[name]
end

function Animations.GetId(name)
	local data = AnimationList[name]
	return data and data.Id or nil
end

function Animations.GetList()
	return AnimationList
end


return Animations
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.Animations.Animations

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Camera.CameraController | Enabled: N/A
--------------------------------------------------------------------
local CameraController = {}

--- @ Services
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

--- @ Utilities
local function getOrCreate(parent, className, name)
	local child = parent:FindFirstChild(name)
	if not child then
		child = Instance.new(className)
		child.Name = name
		child.Parent = parent
	end
	return child
end

--- @ Remotes
local RemotesFolder = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes")
local CameraApiFolder = getOrCreate(RemotesFolder, "Folder", "CameraAPI")
local setControlEvent = getOrCreate(CameraApiFolder, "BindableEvent", "SetCameraExternalControl")
local releaseControlEvent = getOrCreate(CameraApiFolder, "BindableEvent", "ReleaseCameraExternalControl")

--- @ Variables
local player, mouse, character, humanoid, hrp, head
local camera = Workspace.CurrentCamera
local CameraPart

--- @ Configuration
local Config = {
	BaseFOV = 60,
	CurrentFOV = 60,

	Offset = Vector3.new(2, 0.5, 7), 
	LookSensitivity = 1,
	AimSensitivityMultiplier = 0.8, 

	SideFactor = 1, 

	MinPitch = -80,
	MaxPitch = 80,

	ObstructionBuffer = 0.2,
	ExclusionTag = "CameraExclude",

	DefaultAnchorSpeed = 15, 

	RecoilSpeed = 60,

	PositionalLagAmount = 0.05,
	PositionalLagSpeed = 10,
}

--- @ State
local cameraAngleX, cameraAngleY = 0, 0
local recoilPendingX, recoilPendingY = 0, 0
local isMouseForceUnlocked = false
local isCameraExternallyControlled = false

local cameraAnchor
local transitionOffset = Vector3.zero
local lagOffset = Vector3.zero
local currentAnchorSpeed = Config.DefaultAnchorSpeed

local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Exclude
raycastParams.IgnoreWater = true

local OffsetValue = Instance.new("Vector3Value")
OffsetValue.Value = Config.Offset
OffsetValue.Parent = Workspace.Game
OffsetValue.Name = "Offset"

local FOVValue = Instance.new("NumberValue") 
FOVValue.Value = Config.BaseFOV

local currentRawOffset = Config.Offset

--- @ Logic
local function isInstanceExcluded(instance)
	if not instance then return false end
	local current = instance
	while current do
		if CollectionService:HasTag(current, Config.ExclusionTag) then
			return true
		end
		current = current.Parent
	end
	return false
end

function CameraController:TweenOffset(newOffset, tweenInfo)
	if not newOffset then return end
	currentRawOffset = newOffset 

	local actualOffset = Vector3.new(newOffset.X * Config.SideFactor, newOffset.Y, newOffset.Z)

	local tween = TweenService:Create(
		OffsetValue,
		tweenInfo or TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
		{ Value = actualOffset }
	)

	tween.Completed:Connect(function()
		Config.Offset = OffsetValue.Value
	end)

	tween:Play()
	return tween
end

function CameraController:TweenFOV(targetFOV, tweenInfo)
	if not targetFOV then return end
	local tween = TweenService:Create(
		FOVValue,
		tweenInfo or TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
		{ Value = targetFOV }
	)

	tween.Completed:Connect(function()
		Config.CurrentFOV = FOVValue.Value
	end)

	tween:Play()
	return tween
end

function CameraController:AddRecoil(x, y)
	if not x or not y then return end
	recoilPendingX -= x
	recoilPendingY += y
end

function CameraController:SwapShoulder()
	Config.SideFactor = Config.SideFactor * -1
	self:TweenOffset(currentRawOffset, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
end

local function forceUnlockMouse()
	isMouseForceUnlocked = true
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true
end

local function forceLockMouse()
	if isCameraExternallyControlled then return end
	isMouseForceUnlocked = false
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseIconEnabled = false
end

local function handleMouseInput(input, gameProcessed)
	if gameProcessed or isMouseForceUnlocked or isCameraExternallyControlled then return end
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Delta

		local isAiming = character and character:GetAttribute("IsAiming")
		local aimMult = isAiming and Config.AimSensitivityMultiplier or 1

		local sensitivity = UserInputService.MouseDeltaSensitivity * Config.LookSensitivity * aimMult

		cameraAngleX -= delta.X * sensitivity
		cameraAngleY = math.clamp(cameraAngleY - delta.Y * sensitivity, Config.MinPitch, Config.MaxPitch)
	end
end

local function updateCamera(deltaTime)
	if isCameraExternallyControlled then 
		if CameraPart then camera.CFrame = CameraPart.CFrame end
		return 
	end

	if not character or not character.Parent or not humanoid or humanoid.Health <= 0 or not head or not head.Parent then return end
	if not cameraAnchor or not cameraAnchor.Parent then cameraAnchor = head end

	Config.Offset = OffsetValue.Value
	Config.CurrentFOV = FOVValue.Value
	camera.FieldOfView = Config.CurrentFOV

	if transitionOffset.Magnitude > 0.001 then
		transitionOffset = transitionOffset:Lerp(Vector3.zero, 1 - math.exp(-deltaTime * currentAnchorSpeed))
	else
		transitionOffset = Vector3.zero
	end

	local velocity = cameraAnchor.AssemblyLinearVelocity
	local targetLag = -velocity * Config.PositionalLagAmount

	targetLag = Vector3.new(targetLag.X, math.clamp(targetLag.Y, -0.5, 0.5), targetLag.Z)

	lagOffset = lagOffset:Lerp(targetLag, 1 - math.exp(-deltaTime * Config.PositionalLagSpeed))

	local recoilFactor = 1 - math.exp(-deltaTime * Config.RecoilSpeed)
	local moveX = recoilPendingX * recoilFactor
	local moveY = recoilPendingY * recoilFactor

	cameraAngleX += moveX
	cameraAngleY += moveY

	recoilPendingX -= moveX
	recoilPendingY -= moveY

	cameraAngleY = math.clamp(cameraAngleY, Config.MinPitch, Config.MaxPitch)

	local rotation = CFrame.Angles(0, math.rad(cameraAngleX), 0) * CFrame.Angles(math.rad(cameraAngleY), 0, 0)

	local anchorPos = cameraAnchor.Position
	local effectiveOrigin = anchorPos + transitionOffset + lagOffset

	local currentOffset = Config.Offset

	local desiredPosition = (CFrame.new(effectiveOrigin) * rotation):PointToWorldSpace(currentOffset)
	local direction = (desiredPosition - effectiveOrigin)
	local finalPosition = desiredPosition

	if direction.Magnitude > 0.01 then
		local ignoreList = {character, CameraPart}
		raycastParams.FilterDescendantsInstances = ignoreList

		local result = Workspace:Raycast(effectiveOrigin, direction, raycastParams)
		if result then
			if not isInstanceExcluded(result.Instance) and result.Instance.Transparency < 1 then
				finalPosition = effectiveOrigin + direction.Unit * math.max(0.5, (result.Position - effectiveOrigin).Magnitude - Config.ObstructionBuffer)
			end
		end
	end

	local finalCFrame = CFrame.new(finalPosition) * rotation

	if CameraPart then
		CameraPart.CFrame = finalCFrame
		camera.CFrame = CameraPart.CFrame
	end
end

local function setExternalControl(enabled, targetCFrame, tweenInfo)
	isCameraExternallyControlled = enabled
	if enabled then
		forceUnlockMouse()
		if targetCFrame and CameraPart then TweenService:Create(CameraPart, tweenInfo or TweenInfo.new(0), {CFrame = targetCFrame}):Play() end
	else
		forceLockMouse()
	end
end

local function initCameraPart()
	if CameraPart then return end
	CameraPart = Instance.new("Part")
	CameraPart.Name = "PlayerCameraPart"
	CameraPart.Size = Vector3.one * 0.1
	CameraPart.Transparency = 1
	CameraPart.Anchored = true
	CameraPart.CanCollide = false
	CameraPart.CanTouch = false
	CameraPart.CanQuery = false
	CameraPart.Parent = camera
	raycastParams.FilterDescendantsInstances = {character, CameraPart}
end

local function onCharacterAdded(newChar)
	if not newChar then return end

	character = newChar
	humanoid = newChar:WaitForChild("Humanoid", 10)
	hrp = newChar:WaitForChild("HumanoidRootPart", 10)
	head = newChar:WaitForChild("Head", 10)

	if hrp and humanoid and head then
		humanoid.AutoRotate = true
		raycastParams.FilterDescendantsInstances = {newChar, CameraPart}

		cameraAnchor = head
		transitionOffset = Vector3.zero
		lagOffset = Vector3.zero
	end
end

--- @ API
function CameraController:SetAnchor(instance, transitionSpeed)
	if instance and instance:IsA("BasePart") and instance ~= cameraAnchor then
		if cameraAnchor then
			local diff = cameraAnchor.Position - instance.Position
			transitionOffset = transitionOffset + diff
		end

		cameraAnchor = instance
		currentAnchorSpeed = transitionSpeed or Config.DefaultAnchorSpeed
	end
end

function CameraController:Init(localPlayer)
	player = localPlayer
	mouse = player:GetMouse()
	character = player.Character or player.CharacterAdded:Wait()
	initCameraPart()

	local requestMouseUnlock = getOrCreate(CameraApiFolder, "BindableEvent", "RequestMouseUnlock")
	local requestMouseLock = getOrCreate(CameraApiFolder, "BindableEvent", "RequestMouseLock")

	requestMouseUnlock.Event:Connect(forceUnlockMouse)
	requestMouseLock.Event:Connect(forceLockMouse)

	UserInputService.InputChanged:Connect(handleMouseInput)
	player.CharacterAdded:Connect(onCharacterAdded)

	setControlEvent.Event:Connect(function(targetCFrame, tweenInfo) 
		setExternalControl(true, targetCFrame, tweenInfo) 
	end)

	releaseControlEvent.Event:Connect(function(syncCFrame)
		if syncCFrame and typeof(syncCFrame) == "CFrame" then
			local lookVector = syncCFrame.LookVector
			cameraAngleX = math.deg(math.atan2(-lookVector.X, -lookVector.Z))
			local pitch = math.asin(-lookVector.Y)
			cameraAngleY = math.deg(pitch)
		end
		setExternalControl(false)
	end)

	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.LeftAlt then
			if isMouseForceUnlocked then forceLockMouse() else forceUnlockMouse() end
		end
	end)

	RunService:BindToRenderStep("PeakCameraUpdate", Enum.RenderPriority.Camera.Value + 1, updateCamera)

	onCharacterAdded(character)
	forceLockMouse()
end

return CameraController
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Camera.CameraController

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Camera.CameraFX | Enabled: N/A
--------------------------------------------------------------------
local Visuals = {}

--- @ Services
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- run CameraFX.Start() to start the camera effects

--- @ Internal Storage
local effects = {
	blur = nil,
	color = nil
}

--- @ Configuration
local Config = {
	OutdoorExposure = 0,
	IndoorExposure = 1.5,
	CheckDistance = 500,
	CloseWallDist = 6,
	WallDarkness = -2.0,
	NeonReaction = -0.7,
	SunReaction = -5.0,
	SunLookThreshold = 0.90,
	SunBlurSize = 20,
	OutdoorTint = Color3.fromRGB(255, 255, 255),
	OutdoorContrast = 0,
	IndoorTint = Color3.fromRGB(255, 240, 220),
	IndoorContrast = 0.15,
	SunLerpSpeed = 0.2,
	GeneralLerpSpeed = 1.0,
	NoiseSpeed = 0.5,
	NoiseAmount = 0.1,
}

--- @ State Variables
local currentExposure = Lighting.ExposureCompensation
local targetExposure = Config.OutdoorExposure
local currentTint = Config.OutdoorTint
local currentContrast = Config.OutdoorContrast
local noiseSeed = math.random(1000)

--- @ State Variables > Master Toggle
local masterAlpha = 1 
local targetMasterAlpha = 1
local fadeSpeed = 1 

--- @ Asset Management
local function GetOrCreateEffect(className, name)
	local existing = Lighting:FindFirstChild(name)
	if existing and existing:IsA(className) then
		return existing
	end

	local newEffect = Instance.new(className)
	newEffect.Name = name
	newEffect.Parent = Lighting
	return newEffect
end

local function CreateAssets()
	effects.blur = GetOrCreateEffect("BlurEffect", "Visuals_SunBlur")
	effects.blur.Size = 0 -- Start invisible

	effects.color = GetOrCreateEffect("ColorCorrectionEffect", "Visuals_ColorCorrection")
end

--- @ Utility Functions > Raycasting
local function getRayParams()
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	local ignoreList = {}
	if player.Character then table.insert(ignoreList, player.Character) end
	params.FilterDescendantsInstances = ignoreList
	params.IgnoreWater = true
	return params
end

--- @ Utility Functions > Environment
local function checkEnvironment()
	local char = player.Character
	if not char or not char:FindFirstChild("Head") then return false end
	local result = workspace:Raycast(char.Head.Position, Vector3.new(0, 50, 0), getRayParams())
	return result ~= nil
end

--- @ Utility Functions > Camera Look
local function getCameraLookData()
	local rayDir = camera.CFrame.LookVector * Config.CheckDistance
	local result = workspace:Raycast(camera.CFrame.Position, rayDir, getRayParams())
	if result then
		return result.Instance.Material, (result.Position - camera.CFrame.Position).Magnitude
	end
	return nil, 9999
end

--- @ Utility Functions > Sun Check
local function checkSun()
	local sunDir = Lighting:GetSunDirection()
	local lookDir = camera.CFrame.LookVector
	if lookDir:Dot(sunDir) > Config.SunLookThreshold then
		local result = workspace:Raycast(camera.CFrame.Position, sunDir * 1000, getRayParams())
		return result == nil
	end
	return false
end

--- @ Core System > Controls
function Visuals.SetEnabled(enabled, duration)
	targetMasterAlpha = enabled and 1 or 0
	if duration and duration > 0 then
		fadeSpeed = 1 / duration
	else
		masterAlpha = targetMasterAlpha
		fadeSpeed = 0
	end
end

--- @ Core System > Start
function Visuals.Start()
	CreateAssets() -- ! Generate effects on start

	RunService.RenderStepped:Connect(function(dt)
		local char = player.Character
		if not char then return end

		--- @ Core System > Master Fader
		if masterAlpha ~= targetMasterAlpha then
			local change = fadeSpeed * dt
			if targetMasterAlpha > masterAlpha then
				masterAlpha = math.min(masterAlpha + change, 1)
			else
				masterAlpha = math.max(masterAlpha - change, 0)
			end
		end

		-- If fully disabled, reset everything and stop processing
		if masterAlpha <= 0 then
			Lighting.ExposureCompensation = 0
			if effects.blur then effects.blur.Size = 0 end
			if effects.color then 
				effects.color.TintColor = Color3.new(1,1,1)
				effects.color.Contrast = 0 
			end
			return 
		end

		--- @ Core System > Checks
		local isIndoors = checkEnvironment()
		local hitMat, hitDist = getCameraLookData()
		local lookingAtSun = checkSun()

		local targetTint = Config.OutdoorTint
		local targetContrast = Config.OutdoorContrast
		local targetBlur = 0

		--- @ Core System > Logic Calculation
		if isIndoors then
			targetExposure = Config.IndoorExposure
			targetTint = Config.IndoorTint
			targetContrast = Config.IndoorContrast
		else
			targetExposure = Config.OutdoorExposure
		end

		local currentSpeed = Config.GeneralLerpSpeed

		if lookingAtSun then
			targetExposure = targetExposure + Config.SunReaction
			targetBlur = Config.SunBlurSize
			currentSpeed = Config.SunLerpSpeed
		elseif hitDist < Config.CloseWallDist then
			local proximityFactor = 1 - (hitDist / Config.CloseWallDist)
			targetExposure = targetExposure + (Config.WallDarkness * proximityFactor)
		elseif hitMat == Enum.Material.Neon then
			targetExposure = targetExposure + Config.NeonReaction
		end

		local timeVal = tick() * Config.NoiseSpeed
		local drift = math.noise(timeVal, noiseSeed, 0) * Config.NoiseAmount
		targetExposure = targetExposure + drift

		--- @ Core System > Apply Visuals
		currentExposure = currentExposure + (targetExposure - currentExposure) * (currentSpeed * dt)
		Lighting.ExposureCompensation = currentExposure * masterAlpha

		local blurSpeed = (targetBlur > effects.blur.Size) and 0.5 or 2.0
		local rawBlur = effects.blur.Size + (targetBlur - effects.blur.Size) * (blurSpeed * dt)
		effects.blur.Size = rawBlur * masterAlpha

		currentTint = currentTint:Lerp(targetTint, currentSpeed * dt)
		currentContrast = currentContrast + (targetContrast - currentContrast) * (currentSpeed * dt)

		effects.color.TintColor = Color3.new(1,1,1):Lerp(currentTint, masterAlpha)
		effects.color.Contrast = currentContrast * masterAlpha
	end)
end

return Visuals
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Camera.CameraFX
  -  Edit
  18:44:45.653  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Loot.LootModule | Enabled: N/A
--------------------------------------------------------------------
local LootModule = {}




LootModule.Pools = {
	Common = {
		{ Item = "Sugar", Chance = 30 },
		{ Item = "Rag", Chance = 25 },
		{ Item = "Explosive", Chance = 20 },
		{ Item = "Blade", Chance = 15 },
		{ Item = "Binding", Chance = 5 },
		{ Item = "Alcohol", Chance = 5 },
	},
}

function LootModule:RollLoot(poolName)
	local pool = self.Pools[poolName]
	if not pool then return nil end

	local totalChance = 0
	for _, entry in ipairs(pool) do
		totalChance = totalChance + entry.Chance
	end

	local roll = math.random(1, totalChance)
	local currentChance = 0

	for _, entry in ipairs(pool) do
		currentChance = currentChance + entry.Chance
		if roll <= currentChance then
			return entry.Item
		end
	end

	return nil
end

return LootModule

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Loot.LootModule

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris | Enabled: N/A
--------------------------------------------------------------------
--!optimize 2
local Types = require(script.Types)

--[=[
    @class Iris

    Iris; contains the all user-facing functions and properties.
    A set of internal functions can be found in `Iris.Internal` (only use if you understand).

    In its simplest form, users may start Iris by using
    ```lua
    Iris.Init()

    Iris:Connect(function()
        Iris.Window({"My First Window!"})
            Iris.Text({"Hello, World"})
            Iris.Button({"Save"})
            Iris.InputNum({"Input"})
        Iris.End()
    end)
    ```
]=]
local Iris = {} :: Types.Iris

local Internal: Types.Internal = require(script.Internal)(Iris)

--[=[
    @within Iris
    @prop Disabled boolean

    While Iris.Disabled is true, execution of Iris and connected functions will be paused.
    The widgets are not destroyed, they are just frozen so no changes will happen to them.
]=]
Iris.Disabled = false

--[=[
    @within Iris
    @prop Args { [string]: { [string]: any } }

    Provides a list of every possible Argument for each type of widget to it's index.
    For instance, `Iris.Args.Window.NoResize`.
    The Args table is useful for using widget Arguments without remembering their order.
    ```lua
    Iris.Window({"My Window", [Iris.Args.Window.NoResize] = true})
    ```
]=]
Iris.Args = {}

--[=[
    @ignore
    @within Iris
    @prop Events table

    -todo: work out what this is used for.
]=]
Iris.Events = {}

--[=[
    @within Iris
    @function Init
    @param parentInstance Instance? -- where Iris will place widgets UIs under, defaulting to [PlayerGui]
    @param eventConnection (RBXScriptSignal | () -> () | false)? -- the event to determine an Iris cycle, defaulting to [Heartbeat]
    @return Iris

    Initializes Iris and begins rendering. Can only be called once.
    See [Iris.Shutdown] to stop Iris, or [Iris.Disabled] to temporarily disable Iris.

    Once initialized, [Iris:Connect] can be used to create a widget.

    If the `eventConnection` is `false` then Iris will not create a cycle loop and the user will need to call [Internal._cycle] every frame.
]=]
function Iris.Init(parentInstance: Instance?, eventConnection: (RBXScriptSignal | () -> () | false)?): Types.Iris
    assert(Internal._started == false, "Iris.Init can only be called once.")
    assert(Internal._shutdown == false, "Iris.Init cannot be called once shutdown.")

    if parentInstance == nil then
        -- coalesce to playerGui
        parentInstance = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
    end
    if eventConnection == nil then
        -- coalesce to Heartbeat
        eventConnection = game:GetService("RunService").Heartbeat
    end
    Internal.parentInstance = parentInstance :: Instance
    Internal._started = true

    Internal._generateRootInstance()
    Internal._generateSelectionImageObject()

    for _, callback: () -> () in Internal._initFunctions do
        callback()
    end

    -- spawns the connection to call `Internal._cycle()` within.
    task.spawn(function()
        if typeof(eventConnection) == "function" then
            while Internal._started do
                eventConnection()
                Internal._cycle()
            end
        elseif eventConnection ~= nil and eventConnection ~= false then
            Internal._eventConnection = eventConnection:Connect(function()
                Internal._cycle()
            end)
        end
    end)

    return Iris
end

--[=[
    @within Iris
    @function Shutdown

    Shuts Iris down. This can only be called once, and Iris cannot be started once shut down.
]=]
function Iris.Shutdown()
    Internal._started = false
    Internal._shutdown = true

    if Internal._eventConnection then
        Internal._eventConnection:Disconnect()
    end
    Internal._eventConnection = nil

    if Internal._rootWidget then
        if Internal._rootWidget.Instance then
            Internal._widgets["Root"].Discard(Internal._rootWidget)
        end
        Internal._rootInstance = nil
    end

    if Internal.SelectionImageObject then
        Internal.SelectionImageObject:Destroy()
    end

    for _, connection: RBXScriptConnection in Internal._connections do
        connection:Disconnect()
    end
end

--[=[
    @within Iris
    @method Connect
    @param callback () -> () -- the callback containg the Iris code
    @return () -> () -- call to disconnect it
    
    Connects a function which will execute every Iris cycle. [Iris.Init] must be called before connecting.

    A cycle is determined by the `eventConnection` passed to [Iris.Init] (default to [RunService.Heartbeat]).

    Multiple callbacks can be added to Iris from many different scripts or modules.
]=]
function Iris:Connect(callback: () -> ()): () -> () -- this uses method syntax for no reason.
    if Internal._started == false then
        warn("Iris:Connect() was called before calling Iris.Init(), the connected function will never run")
    end
    local connectionIndex: number = #Internal._connectedFunctions + 1
    Internal._connectedFunctions[connectionIndex] = callback
    return function()
        Internal._connectedFunctions[connectionIndex] = nil
    end
end

--[=[
    @within Iris
    @function Append
    @param userInstance GuiObject -- the Roblox [Instance] to insert into Iris

    Inserts any Roblox [Instance] into Iris.
    
    The parent of the inserted instance can either be determined by the `_config.Parent`
    property or by the current parent widget from the stack.
]=]
function Iris.Append(userInstance: GuiObject)
    local parentWidget: Types.ParentWidget = Internal._GetParentWidget()
    local widgetInstanceParent: GuiObject
    if Internal._config.Parent then
        widgetInstanceParent = Internal._config.Parent :: any
    else
        widgetInstanceParent = Internal._widgets[parentWidget.type].ChildAdded(parentWidget, { type = "userInstance" } :: Types.Widget)
    end
    userInstance.Parent = widgetInstanceParent
end

--[=[
    @within Iris
    @function End

    Marks the end of any widgets which contain children. For example:
    ```lua
    -- Widgets placed here **will not** be inside the tree
    Iris.Text({"Above and outside the tree"})

    -- A Tree widget can contain children.
    -- We must therefore remember to call `Iris.End()` 
    Iris.Tree({"My First Tree"})
        -- Widgets placed here **will** be inside the tree
        Iris.Text({"Tree item 1"})
        Iris.Text({"Tree item 2"})
    Iris.End()

    -- Widgets placed here **will not** be inside the tree
    Iris.Text({"Below and outside the tree"})
    ```
    :::caution Caution: Error
    Seeing the error `Callback has too few calls to Iris.End()` or `Callback has too many calls to Iris.End()`?
    Using the wrong amount of `Iris.End()` calls in your code will lead to an error.
    
    Each widget called which might have children should be paired with a call to `Iris.End()`, **even if the Widget doesnt currently have any children**.
    :::
]=]
function Iris.End()
    if Internal._stackIndex == 1 then
        error("Callback has too many calls to Iris.End()", 2)
    end

    Internal._IDStack[Internal._stackIndex] = nil
    Internal._stackIndex -= 1
end

--[[
    ------------------------
        [SECTION] Config
    ------------------------
]]

--[=[
    @within Iris
    @function ForceRefresh

    Destroys and regenerates all instances used by Iris. Useful if you want to propogate state changes.
    :::caution Caution: Performance
    Because this function Deletes and Initializes many instances, it may cause **performance issues** when used with many widgets.
    In **no** case should it be called every frame.
    :::
]=]
function Iris.ForceRefresh()
    Internal._globalRefreshRequested = true
end

--[=[
    @within Iris
    @function UpdateGlobalConfig
    @param deltaStyle { [string]: any } -- a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`

    Customizes the configuration which **every** widget will inherit from.

    It can be used along with [Iris.TemplateConfig] to easily swap styles, for example:
    ```lua
    Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) -- use light theme
    ```
    :::caution Caution: Performance
    This function internally calls [Iris.ForceRefresh] so that style changes are propogated.

    As such, it may cause **performance issues** when used with many widgets.
    In **no** case should it be called every frame.
    :::
]=]
function Iris.UpdateGlobalConfig(deltaStyle: { [string]: any })
    for index, style in deltaStyle do
        Internal._rootConfig[index] = style
    end
    Iris.ForceRefresh()
end

--[=[
    @within Iris
    @function PushConfig
    @param deltaStyle { [string]: any } -- a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`

    Allows cascading of a style by allowing styles to be locally and hierarchically applied.

    Each call to Iris.PushConfig must be paired with a call to [Iris.PopConfig], for example:
    ```lua
    Iris.Text({"boring text"})

    Iris.PushConfig({TextColor = Color3.fromRGB(128, 0, 256)})
        Iris.Text({"Colored Text!"})
    Iris.PopConfig()

    Iris.Text({"boring text"})
    ```
]=]
function Iris.PushConfig(deltaStyle: { [string]: any })
    local ID = Iris.State(-1)
    if ID.value == -1 then
        ID:set(deltaStyle)
    else
        -- compare tables
        if Internal._deepCompare(ID:get(), deltaStyle) == false then
            -- refresh local
            Internal._localRefreshActive = true
            ID:set(deltaStyle)
        end
    end

    Internal._config = setmetatable(deltaStyle, {
        __index = Internal._config,
    }) :: any
end

--[=[
    @within Iris
    @function PopConfig

    Ends a [Iris.PushConfig] style.

    Each call to [Iris.PopConfig] should match a call to [Iris.PushConfig].
]=]
function Iris.PopConfig()
    Internal._localRefreshActive = false
    Internal._config = getmetatable(Internal._config :: any).__index
end

--[=[
    @within Iris
    @prop TemplateConfig { [string]: { [string]: any } }

    TemplateConfig provides a table of default styles and configurations which you may apply to your UI.
]=]
Iris.TemplateConfig = require(script.config)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark) -- use colorDark and sizeDefault themes by default
Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.utilityDefault)
Internal._globalRefreshRequested = false -- UpdatingGlobalConfig changes this to true, leads to Root being generated twice.

--[[
    --------------------
        [SECTION] ID
    --------------------
]]

--[=[
    @within Iris
    @function PushId
    @param id ID -- custom id

    Sets the id discriminator for the next widgets. Use [Iris.PopId] to remove it.
]=]
function Iris.PushId(ID: Types.ID)
    assert(typeof(ID) == "string", "Iris expected Iris.PushId id to PushId to be a string.")

    Internal._pushedId = tostring(ID)
end

--[=[
    @within Iris
    @function PopID

    Removes the id discriminator set by [Iris.PushId].
]=]
function Iris.PopId()
    Internal._pushedId = nil
end

--[=[
    @within Iris
    @function SetNextWidgetID
    @param id ID -- custom id.

    Sets the id for the next widget. Useful for using [Iris.Append] on the same widget.
    ```lua
    Iris.SetNextWidgetId("demo_window")
    Iris.Window({ "Window" })
        Iris.Text({ "Text one placed here." })
    Iris.End()

    -- later in the code

    Iris.SetNextWidgetId("demo_window")
    Iris.Window()
        Iris.Text({ "Text two placed here." })
    Iris.End()

    -- both text widgets will be placed under the same window despite being called separately.
    ```
]=]
function Iris.SetNextWidgetID(ID: Types.ID)
    Internal._nextWidgetId = ID
end

--[[
    -----------------------
        [SECTION] State
    -----------------------
]]

--[=[
    @within Iris
    @function State<T>
    @param initialValue T -- the initial value for the state
    @return State<T>
    @tag State

    Constructs a new [State] object. Subsequent ID calls will return the same object.
    :::info
    Iris.State allows you to create "references" to the same value while inside your UI drawing loop.
    For example:
    ```lua
    Iris:Connect(function()
        local myNumber = 5
        myNumber = myNumber + 1
        Iris.Text({"The number is: " .. myNumber})
    end)
    ```
    This is problematic. Each time the function is called, a new myNumber is initialized, instead of retrieving the old one.
    The above code will always display 6.
    ***
    Iris.State solves this problem:
    ```lua
    Iris:Connect(function()
        local myNumber = Iris.State(5)
        myNumber:set(myNumber:get() + 1)
        Iris.Text({"The number is: " .. myNumber})
    end)
    ```
    In this example, the code will work properly, and increment every frame.
    :::
]=]
function Iris.State<T>(initialValue: T): Types.State<T>
    local ID: Types.ID = Internal._getID(2)
    if Internal._states[ID] then
        return Internal._states[ID]
    end
    Internal._states[ID] = {
        ID = ID,
        value = initialValue,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: any
    setmetatable(Internal._states[ID], Internal.StateClass)
    return Internal._states[ID]
end

--[=[
    @within Iris
    @function WeakState<T>
    @param initialValue T -- the initial value for the state
    @return State<T>
    @tag State

    Constructs a new state object, subsequent ID calls will return the same object, except all widgets connected to the state are discarded, the state reverts to the passed initialValue
]=]
function Iris.WeakState<T>(initialValue: T): Types.State<T>
    local ID: Types.ID = Internal._getID(2)
    if Internal._states[ID] then
        if next(Internal._states[ID].ConnectedWidgets) == nil then
            Internal._states[ID] = nil
        else
            return Internal._states[ID]
        end
    end
    Internal._states[ID] = {
        ID = ID,
        value = initialValue,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: any
    setmetatable(Internal._states[ID], Internal.StateClass)
    return Internal._states[ID]
end

--[=[
    @within Iris
    @function VariableState<T>
    @param variable T -- the variable to track
    @param callback (T) -> () -- a function which sets the new variable locally
    @return State<T>
    @tag State

    Returns a state object linked to a local variable.
    
    The passed variable is used to check whether the state object should update. The callback method is used to change the local variable when the state changes.

    The existence of such a function is to make working with local variables easier.
    Since Iris cannot directly manipulate the memory of the variable, like in C++, it must instead rely on the user updating it through the callback provided.
    Additionally, because the state value is not updated when created or called we cannot return the new value back, instead we require a callback for the user to update.

    ```lua
    local myNumber = 5

    local state = Iris.VariableState(myNumber, function(value)
        myNumber = value
    end)
    Iris.DragNum({ "My number" }, { number = state })
    ```

    This is how Dear ImGui does the same in C++ where we can just provide the memory location to the variable which is then updated directly.
    ```cpp
    static int myNumber = 5;
    ImGui::DragInt("My number", &myNumber); // Here in C++, we can directly pass the variable.
    ```
    
    :::warning Update Order
    If the variable and state value are different when calling this, the variable value takes precedence.

    Therefore, if you update the state using `state.value = ...` then it will be overwritten by the variable value.
    You must use `state:set(...)` if you want the variable to update to the state's value.
    :::
]=]
function Iris.VariableState<T>(variable: T, callback: (T) -> ()): Types.State<T>
    local ID: Types.ID = Internal._getID(2)
    local state: Types.State<T>? = Internal._states[ID]

    if state then
        if variable ~= state.value then
            state:set(variable)
        end
        return state
    end

    local newState = {
        ID = ID,
        value = variable,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: Types.State<T>
    setmetatable(newState, Internal.StateClass)
    Internal._states[ID] = newState

    newState:onChange(callback)

    return newState
end

--[=[
    @within Iris
    @function TableState<K, V>
    @param table { [K]: V } -- the table containing the value
    @param key K -- the key to the value in table
    @param callback ((newValue: V) -> false?)? -- a function called when the state is changed
    @return State<V>
    @tag State

    Similar to Iris.VariableState but takes a table and key to modify a specific value and a callback to determine whether to update the value.
    
    The passed table and key are used to check the value. The callback is called when the state changes value and determines whether we update the table.
    This is useful if we want to monitor a table value which needs to call other functions when changed.
    
    Since tables are pass-by-reference, we can modify the table anywhere and it will update all other instances. Therefore, we don't need a callback by default.
    ```lua
    local data = {
        myNumber = 5
    }

    local state = Iris.TableState(data, "myNumber")
    Iris.DragNum({ "My number" }, { number = state })
    ```

    Here the `data._started` should never be updated directly, only through the `toggle` function. However, we still want to monitor the value and be able to change it.
    Therefore, we use the callback to toggle the function for us and prevent Iris from updating the table value by returning false.
    ```lua
    local data ={
        _started = false
    }

    local function toggle(enabled: boolean)
        data._started = enabled
        if data._started then
            start(...)
        else
            stop(...)
        end
    end

    local state = Iris.TableState(data, "_started", function(stateValue: boolean)
       toggle(stateValue)
       return false
    end)
    Iris.Checkbox({ "Started" }, { isChecked = state })
    ```

    :::warning Update Order
    If the table value and state value are different when calling this, the table value value takes precedence.

    Therefore, if you update the state using `state.value = ...` then it will be overwritten by the table value.
    You must use `state:set(...)` if you want the table value to update to the state's value.
    :::
]=]
function Iris.TableState<K, V>(tab: { [K]: V }, key: K, callback: ((newValue: V) -> false?)?): Types.State<V>
    local value: V = tab[key]
    local ID: Types.ID = Internal._getID(2)
    local state: Types.State<V>? = Internal._states[ID]

    -- If the table values changes, then we update the state to match.
    if state then
        if value ~= state.value then
            state:set(value)
        end
        return state
    end

    local newState = {
        ID = ID,
        value = value,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: Types.State<V>
    setmetatable(newState, Internal.StateClass)
    Internal._states[ID] = newState

    -- When a change happens to the state, we update the table value.
    newState:onChange(function()
        if callback ~= nil then
            if callback(newState.value) then
                tab[key] = newState.value
            end
        else
            tab[key] = newState.value
        end
    end)
    return newState
end

--[=[
    @within Iris
    @function ComputedState<T, U>
    @param firstState State<T> -- State to bind to.
    @param onChangeCallback (firstValue: T) -> U -- callback which should return a value transformed from the firstState value
    @return State<U>

    Constructs a new State object, but binds its value to the value of another State.
    :::info
    A common use case for this constructor is when a boolean State needs to be inverted:
    ```lua
    Iris.ComputedState(otherState, function(newValue)
        return not newValue
    end)
    ```
    :::
]=]
function Iris.ComputedState<T, U>(firstState: Types.State<T>, onChangeCallback: (firstValue: T) -> U): Types.State<U>
    local ID: Types.ID = Internal._getID(2)

    if Internal._states[ID] then
        return Internal._states[ID]
    else
        Internal._states[ID] = {
            ID = ID,
            value = onChangeCallback(firstState.value),
            ConnectedWidgets = {},
            ConnectedFunctions = {},
        } :: Types.State<U>
        firstState:onChange(function(newValue: T)
            Internal._states[ID]:set(onChangeCallback(newValue))
        end)
        setmetatable(Internal._states[ID], Internal.StateClass)
        return Internal._states[ID]
    end
end

--[=[
    @within Iris
    @function ShowDemoWindow

    ShowDemoWindow is a function which creates a Demonstration window. this window contains many useful utilities for coders,
    and serves as a refrence for using each part of the library. Ideally, the DemoWindow should always be available in your UI.
    It is the same as any other callback you would connect to Iris using [Iris.Connect]
    ```lua
    Iris:Connect(Iris.ShowDemoWindow)
    ```
]=]

require(script.widgets)(Internal)
require(script.API)(Iris)

return Iris

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.API | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

return function(Iris: Types.Iris)
    -- basic wrapper for nearly every widget, saves space.
    local function wrapper(name: string)
        return function(arguments: Types.WidgetArguments?, states: Types.WidgetStates?): Types.Widget
            return Iris.Internal._Insert(name, arguments, states)
        end
    end

    --[[
        ----------------------------
            [SECTION] Window API
        ----------------------------
    ]]
    --[=[
        @class Window
        
        Windows are the fundamental widget for Iris. Every other widget must be a descendant of a window.

        ```lua
        Iris.Window({ "Example Window" })
            Iris.Text({ "This is an example window!" })
        Iris.End()
        ```

        ![Example window](../assets/basicWindow.png)

        If you do not want the code inside a window to run unless it is open then you can use the following:
        ```lua
        local window = Iris.Window({ "Many Widgets Window" })

        if window.state.isOpened.value and window.state.isUncollapsed.value then
            Iris.Text({ "I will only be created when the window is open." })
        end
        Iris.End() -- must always call Iris.End(), regardless of whether the window is open or not.
        ```
    ]=]

    --[=[
        @within Window
        @prop Window Iris.Window
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        The top-level container for all other widgets to be created within.
        Can be moved and resized across the screen. Cannot contain embedded windows.
        Menus can be appended to windows creating a menubar.
        
        ```lua
        hasChildren = true
        hasState = true
        Arguments = {
            Title: string,
            NoTitleBar: boolean? = false,
            NoBackground: boolean? = false, -- the background behind the widget container.
            NoCollapse: boolean? = false,
            NoClose: boolean? = false,
            NoMove: boolean? = false,
            NoScrollbar: boolean? = false, -- the scrollbar if the window is too short for all widgets.
            NoResize: boolean? = false,
            NoNav: boolean? = false, -- unimplemented.
            NoMenu: boolean? -- whether the menubar will show if created.
        }
        Events = {
            opened: () -> boolean, -- once when opened.
            closed: () -> boolean, -- once when closed.
            collapsed: () -> boolean, -- once when collapsed.
            uncollapsed: () -> boolean, -- once when uncollapsed.
            hovered: () -> boolean -- fires when the mouse hovers over any of the window.
        }
        States = {
            size = State<Vector2>? = Vector2.new(400, 300),
            position = State<Vector2>?,
            isUncollapsed = State<boolean>? = true,
            isOpened = State<boolean>? = true,
            scrollDistance = State<number>? -- vertical scroll distance, if too short.
        }
        ```
    ]=]
    Iris.Window = wrapper("Window")

    --[=[
        @within Iris
        @function SetFocusedWindow
        @param window Types.Window -- the window to focus.

        Sets the focused window to the window provided, which brings it to the front and makes it active.
    ]=]
    Iris.SetFocusedWindow = Iris.Internal.SetFocusedWindow

    --[=[
        @within Window
        @prop Tooltip Iris.Tooltip
        @tag Widget

        Displays a text label next to the cursor

        ```lua
        Iris.Tooltip({"My custom tooltip"})
        ```

        ![Basic tooltip example](../assets/basicTooltip.png)
        
        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string
        }
        ```
    ]=]
    Iris.Tooltip = wrapper("Tooltip")

    --[[
        ---------------------------------
            [SECTION] Menu Widget API
        ---------------------------------
    ]]
    --[=[
        @class Menu
        Menu API
    ]=]

    --[=[
        @within Menu
        @prop MenuBar Iris.MenuBar
        @tag Widget
        @tag HasChildren
        
        Creates a MenuBar for the current window. Must be called directly under a Window and not within a child widget.
        :::info
            This does not create any menus, just tells the window that we going to add menus within.
        :::
        
        ```lua
        hasChildren = true
        hasState = false
        ```
    ]=]
    Iris.MenuBar = wrapper("MenuBar")

    --[=[
        @within Menu
        @prop Menu Iris.Menu
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        Creates an collapsable menu. If the Menu is created directly under a MenuBar, then the widget will
        be placed horizontally below the window title. If the menu Menu is created within another menu, then
        it will be placed vertically alongside MenuItems and display an arrow alongside.

        The opened menu will be a vertically listed box below or next to the button.

        :::info
        There are widgets which are designed for being parented to a menu whilst other happens to work. There is nothing
        preventing you from adding any widget as a child, but the behaviour is unexplained and not intended, despite allowed.
        :::
        
        ```lua
        hasChildren = true
        hasState = true
        Arguments = {
            Text: string -- menu text.
        }
        Events = {
            clicked: () -> boolean,
            opened: () -> boolean, -- once when opened.
            closed: () -> boolean, -- once when closed.
            hovered: () -> boolean
        }
        States = {
            isOpened: State<boolean>? -- whether the menu is open, including any sub-menus within.
        }
        ```
    ]=]
    Iris.Menu = wrapper("Menu")

    --[=[
        @within Menu
        @prop MenuItem Iris.MenuItem
        @tag Widget
        
        Creates a button within a menu. The optional KeyCode and ModiferKey arguments will show the keys next
        to the title, but **will not** bind any connection to them. You will need to do this yourself.
        
        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string,
            KeyCode: Enum.KeyCode? = nil, -- an optional keycode, does not actually connect an event.
            ModifierKey: Enum.ModifierKey? = nil -- an optional modifer key for the key code.
        }
        Events = {
            clicked: () -> boolean,
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.MenuItem = wrapper("MenuItem")

    --[=[
        @within Menu
        @prop MenuToggle Iris.MenuToggle
        @tag Widget
        @tag HasState
        
        Creates a togglable button within a menu. The optional KeyCode and ModiferKey arguments act the same
        as the MenuItem. It is not visually the same as a checkbox, but has the same functionality.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string,
            KeyCode: Enum.KeyCode? = nil, -- an optional keycode, does not actually connect an event.
            ModifierKey: Enum.ModifierKey? = nil -- an optional modifer key for the key code.
        }
        Events = {
            checked: () -> boolean, -- once on check.
            unchecked: () -> boolean, -- once on uncheck.
            hovered: () -> boolean
        }
        States = {
            isChecked: State<boolean>?
        }
        ```
    ]=]
    Iris.MenuToggle = wrapper("MenuToggle")

    --[[
        -----------------------------------
            [SECTION] Format Widget Iris
        -----------------------------------
    ]]
    --[=[
        @class Format
        Format API
    ]=]

    --[=[
        @within Format
        @prop Separator Iris.Separator
        @tag Widget

        A vertical or horizonal line, depending on the context, which visually seperates widgets.
        
        ```lua
        hasChildren = false
        hasState = false
        ```
    ]=]
    Iris.Separator = wrapper("Separator")

    --[=[
        @within Format
        @prop Indent Iris.Indent
        @tag Widget
        @tag HasChildren
        
        Indents its child widgets.
        
        ```lua
        hasChildren = true
        hasState = false
        Arguments = {
            Width: number? = Iris._config.IndentSpacing -- indent width ammount.
        }
        ```
    ]=]
    Iris.Indent = wrapper("Indent")

    --[=[
        @within Format
        @prop SameLine Iris.SameLine
        @tag Widget
        @tag HasChildren
        
        Positions its children in a row, horizontally.
        
        ```lua
        hasChildren = true
        hasState = false
        Arguments = {
            Width: number? = Iris._config.ItemSpacing.X, -- horizontal spacing between child widgets.
            VerticalAlignment: Enum.VerticalAlignment? = Enum.VerticalAlignment.Center -- how widgets vertically to each other.
            HorizontalAlignment: Enum.HorizontalAlignment? = Enum.HorizontalAlignment.Center -- how widgets are horizontally.
        }
        ```
    ]=]
    Iris.SameLine = wrapper("SameLine")

    --[=[
        @within Format
        @prop Group Iris.Group
        @tag Widget
        @tag HasChildren
        
        Layout widget which contains its children as a single group.
        
        ```lua
        hasChildren = true
        hasState = false
        ```
    ]=]
    Iris.Group = wrapper("Group")

    --[[
        ---------------------------------
            [SECTION] Text Widget API
        ---------------------------------
    ]]
    --[=[
        @class Text
        Text Widget API
    ]=]

    --[=[
        @within Text
        @prop Text Iris.Text
        @tag Widget
        
        A text label to display the text argument.
        The Wrapped argument will make the text wrap around if it is cut off by its parent.
        The Color argument will change the color of the text, by default it is defined in the configuration file.
        The RichText argument will 

        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string,
            Wrapped: boolean? = [CONFIG] = false, -- whether the text will wrap around inside the parent container. If not specified, then equal to the config
            Color: Color3? = Iris._config.TextColor, -- the colour of the text.
            RichText: boolean? = [CONFIG] = false -- enable RichText. If not specified, then equal to the config
        }
        Events = {
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.Text = wrapper("Text")

    --[=[
        @within Text
        @prop TextWrapped Iris.Text
        @tag Widget
        @deprecated v2.0.0 -- Use 'Text' with the Wrapped argument or change the config.

        An alias for [Iris.Text](Text#Text) with the Wrapped argument set to true, and the text will wrap around if cut off by its parent.

        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string,
        }
        Events = {
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.TextWrapped = function(arguments: Types.WidgetArguments): Types.Text
        arguments[2] = true
        return Iris.Internal._Insert("Text", arguments) :: Types.Text
    end

    --[=[
        @within Text
        @prop TextColored Iris.Text
        @tag Widget
        @deprecated v2.0.0 -- Use 'Text' with the Color argument or change the config.
        
        An alias for [Iris.Text](Text#Text) with the color set by the Color argument.

        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string,
            Color: Color3 -- the colour of the text.
        }
        Events = {
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.TextColored = function(arguments: Types.WidgetArguments): Types.Text
        arguments[3] = arguments[2]
        arguments[2] = nil
        return Iris.Internal._Insert("Text", arguments) :: Types.Text
    end

    --[=[
        @within Text
        @prop SeparatorText Iris.SeparatorText
        @tag Widget
        
        Similar to [Iris.Separator](Format#Separator) but with a text label to be used as a header
        when an [Iris.Tree](Tree#Tree) or [Iris.CollapsingHeader](Tree#CollapsingHeader) is not appropriate.

        Visually a full width thin line with a text label clipping out part of the line.
        
        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string
        }
        ```
    ]=]
    Iris.SeparatorText = wrapper("SeparatorText")

    --[=[
        @within Text
        @prop InputText Iris.InputText
        @tag Widget
        @tag HasState

        A field which allows the user to enter text.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputText",
            TextHint: string? = "", -- a hint to display when the text box is empty.
            ReadOnly: boolean? = false,
            MultiLine: boolean? = false
        }
        Events = {
            textChanged: () -> boolean, -- whenever the textbox looses focus and a change was made.
            hovered: () -> boolean
        }
        States = {
            text: State<string>?
        }
        ```
    ]=]
    Iris.InputText = wrapper("InputText")

    --[[
        ----------------------------------
            [SECTION] Basic Widget API
        ----------------------------------
    ]]
    --[=[
        @class Basic
        Basic Widget API
    ]=]

    --[=[
        @within Basic
        @prop Button Iris.Button
        @tag Widget
        
        A clickable button the size of the text with padding. Can listen to the `clicked()` event to determine if it was pressed.

        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string,
            Size: UDim2? = 0,
        }
        Events = {
            clicked: () -> boolean,
            rightClicked: () -> boolean,
            doubleClicked: () -> boolean,
            ctrlClicked: () -> boolean, -- when the control key is down and clicked.
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.Button = wrapper("Button")

    --[=[
        @within Basic
        @prop SmallButton Iris.SmallButton
        @tag Widget
        
        A smaller clickable button, the same as a [Iris.Button](Basic#Button) but without padding. Can listen to the `clicked()` event to determine if it was pressed.

        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string,
            Size: UDim2? = 0,
        }
        Events = {
            clicked: () -> boolean,
            rightClicked: () -> boolean,
            doubleClicked: () -> boolean,
            ctrlClicked: () -> boolean, -- when the control key is down and clicked.
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.SmallButton = wrapper("SmallButton")

    --[=[
        @within Basic
        @prop Checkbox Iris.Checkbox
        @tag Widget
        @tag HasState
        
        A checkable box with a visual tick to represent a boolean true or false state.

        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string
        }
        Events = {
            checked: () -> boolean, -- once when checked.
            unchecked: () -> boolean, -- once when unchecked.
            hovered: () -> boolean
        }
        State = {
            isChecked = State<boolean>? -- whether the box is checked.
        }
        ```
    ]=]
    Iris.Checkbox = wrapper("Checkbox")

    --[=[
        @within Basic
        @prop RadioButton Iris.RadioButton
        @tag Widget
        @tag HasState
        
        A circular selectable button, changing the state to its index argument. Used in conjunction with multiple other RadioButtons sharing the same state to represent one value from multiple options.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string,
            Index: any -- the state object is set to when clicked.
        }
        Events = {
            selected: () -> boolean,
            unselected: () -> boolean,
            active: () -> boolean, -- if the state index equals the RadioButton's index.
            hovered: () -> boolean
        }
        State = {
            index = State<any>? -- the state set by the index of a RadioButton.
        }
        ```
    ]=]
    Iris.RadioButton = wrapper("RadioButton")

    --[[
        ----------------------------------
            [SECTION] Image Widget API
        ----------------------------------
    ]]

    --[=[
        @class Image
        Image Widget API

        Provides two widgets for Images and ImageButtons, which provide the same control as a an ImageLabel instance.
    ]=]

    --[=[
        @within Image
        @prop Image Iris.Image
        @tag Widget

        An image widget for displaying an image given its texture ID and a size. The widget also supports Rect Offset and Size allowing cropping of the image and the rest of the ScaleType properties.
        Some of the arguments are only used depending on the ScaleType property, such as TileSize or Slice which will be ignored.

        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Image: string, -- the texture asset id
            Size: UDim2,
            Rect: Rect? = Rect.new(), -- Rect structure which is used to determine the offset or size. An empty, zeroed rect is equivalent to nil
            ScaleType: Enum.ScaleType? = Enum.ScaleType.Stretch, -- used to determine whether the TileSize, SliceCenter and SliceScale arguments are used
            ResampleMode: Enum.ResampleMode? = Enum.ResampleMode.Default,
            TileSize: UDim2? = UDim2.fromScale(1, 1), -- only used if the ScaleType is set to Tile
            SliceCenter: Rect? = Rect.new(), -- only used if the ScaleType is set to Slice
            SliceScale: number? = 1 -- only used if the ScaleType is set to Slice
        }
        Events = {
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.Image = wrapper("Image")

    --[=[
        @within Image
        @prop ImageButton Iris.ImageButton
        @tag Widget

        An image button widget for a button as an image given its texture ID and a size. The widget also supports Rect Offset and Size allowing cropping of the image, and the rest of the ScaleType properties.
        Supports all of the events of a regular button.

        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Image: string, -- the texture asset id
            Size: UDim2,
            Rect: Rect? = Rect.new(), -- Rect structure which is used to determine the offset or size. An empty, zeroed rect is equivalent to nil
            ScaleType: Enum.ScaleType? = Enum.ScaleType.Stretch, -- used to determine whether the TileSize, SliceCenter and SliceScale arguments are used
            ResampleMode: Enum.ResampleMode? = Enum.ResampleMode.Default,
            TileSize: UDim2? = UDim2.fromScale(1, 1), -- only used if the ScaleType is set to Tile
            SliceCenter: Rect? = Rect.new(), -- only used if the ScaleType is set to Slice
            SliceScale: number? = 1 -- only used if the ScaleType is set to Slice
        }
        Events = {
            clicked: () -> boolean,
            rightClicked: () -> boolean,
            doubleClicked: () -> boolean,
            ctrlClicked: () -> boolean, -- when the control key is down and clicked.
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.ImageButton = wrapper("ImageButton")

    --[[
        ---------------------------------
            [SECTION] Tree Widget API
        ---------------------------------
    ]]
    --[=[
        @class Tree
        Tree Widget API
    ]=]

    --[=[
        @within Tree
        @prop Tree Iris.Tree
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        A collapsable container for other widgets, to organise and hide widgets when not needed. The state determines whether the child widgets are visible or not. Clicking on the widget will collapse or uncollapse it.
        
        ```lua
        hasChildren: true
        hasState: true
        Arguments = {
            Text: string,
            SpanAvailWidth: boolean? = false, -- the tree title will fill all horizontal space to the end its parent container.
            NoIndent: boolean? = false -- the child widgets will not be indented underneath.
        }
        Events = {
            collapsed: () -> boolean,
            uncollapsed: () -> boolean,
            hovered: () -> boolean
        }
        State = {
            isUncollapsed: State<boolean>? -- whether the widget is collapsed.
        }
        ```
    ]=]
    Iris.Tree = wrapper("Tree")

    --[=[
        @within Tree
        @prop CollapsingHeader Iris.CollapsingHeader
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        The same as a Tree Widget, but with a larger title and clearer, used mainly for organsing widgets on the first level of a window.
        
        ```lua
        hasChildren: true
        hasState: true
        Arguments = {
            Text: string
        }
        Events = {
            collapsed: () -> boolean,
            uncollapsed: () -> boolean,
            hovered: () -> boolean
        }
        State = {
            isUncollapsed: State<boolean>? -- whether the widget is collapsed.
        }
        ```
    ]=]
    Iris.CollapsingHeader = wrapper("CollapsingHeader")

    --[[
        ----------------------------------
            [SECTION] Input Widget API
        ----------------------------------
    ]]
    --[=[
        @class Input
        Input Widget API

        Input Widgets are textboxes for typing in specific number values. See [Drag], [Slider] or [InputText](Text#InputText) for more input types.

        Iris provides a set of specific inputs for the datatypes:
        Number,
        [Vector2](https://create.roblox.com/docs/reference/engine/datatypes/Vector2),
        [Vector3](https://create.roblox.com/docs/reference/engine/datatypes/Vector3),
        [UDim](https://create.roblox.com/docs/reference/engine/datatypes/UDim),
        [UDim2](https://create.roblox.com/docs/reference/engine/datatypes/UDim2),
        [Rect](https://create.roblox.com/docs/reference/engine/datatypes/Rect),
        [Color3](https://create.roblox.com/docs/reference/engine/datatypes/Color3)
        and the custom [Color4](https://create.roblox.com/docs/reference/engine/datatypes/Color3).
        
        Each Input widget has the same arguments but the types depend of the DataType:
        1. Text: string? = "Input{type}" -- the text to be displayed to the right of the textbox.
        2. Increment: DataType? = nil, -- the increment argument determines how a value will be rounded once the textbox looses focus.
        3. Min: DataType? = nil, -- the minimum value that the widget will allow, no clamping by default.
        4. Max: DataType? = nil, -- the maximum value that the widget will allow, no clamping by default.
        5. Format: string | { string }? = [DYNAMIC] -- uses `string.format` to customise visual display.

        The format string can either by a single value which will apply to every box, or a table allowing specific text.

        :::note
        If you do not specify a format option then Iris will dynamically calculate a relevant number of sigifs and format option.
        For example, if you have Increment, Min and Max values of 1, 0 and 100, then Iris will guess that you are only using integers
        and will format the value as an integer.
        As another example, if you have Increment, Min and max values of 0.005, 0, 1, then Iris will guess you are using a float of 3
        significant figures.

        Additionally, for certain DataTypes, Iris will append an prefix to each box if no format option is provided.
        For example, a Vector3 box will have the append values of "X: ", "Y: " and "Z: " to the relevant input box.
        :::
    ]=]

    --[=[
        @within Input
        @prop InputNum Iris.InputNum
        @tag Widget
        @tag HasState
        
        An input box for numbers. The number can be either an integer or a float.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputNum",
            Increment: number? = nil,
            Min: number? = nil,
            Max: number? = nil,
            Format: string? | { string }? = [DYNAMIC], -- Iris will dynamically generate an approriate format.
            NoButtons: boolean? = false -- whether to display + and - buttons next to the input box.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<number>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputNum = wrapper("InputNum")

    --[=[
        @within Input
        @prop InputVector2 Iris.InputVector2
        @tag Widget
        @tag HasState
        
        An input box for Vector2. The numbers can be either integers or floats.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputVector2",
            Increment: Vector2? = nil,
            Min: Vector2? = nil,
            Max: Vector2? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Vector2>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputVector2 = wrapper("InputVector2")

    --[=[
        @within Input
        @prop InputVector3 Iris.InputVector3
        @tag Widget
        @tag HasState
        
        An input box for Vector3. The numbers can be either integers or floats.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputVector3",
            Increment: Vector3? = nil,
            Min: Vector3? = nil,
            Max: Vector3? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Vector3>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputVector3 = wrapper("InputVector3")

    --[=[
        @within Input
        @prop InputUDim Iris.InputUDim
        @tag Widget
        @tag HasState
        
        An input box for UDim. The Scale box will be a float and the Offset box will be
        an integer, unless specified differently.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputUDim",
            Increment: UDim? = nil,
            Min: UDim? = nil,
            Max: UDim? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<UDim>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputUDim = wrapper("InputUDim")

    --[=[
        @within Input
        @prop InputUDim2 Iris.InputUDim2
        @tag Widget
        @tag HasState
        
        An input box for UDim2. The Scale boxes will be floats and the Offset boxes will be
        integers, unless specified differently.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputUDim2",
            Increment: UDim2? = nil,
            Min: UDim2? = nil,
            Max: UDim2? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<UDim2>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputUDim2 = wrapper("InputUDim2")

    --[=[
        @within Input
        @prop InputRect Iris.InputRect
        @tag Widget
        @tag HasState
        
        An input box for Rect. The numbers will default to integers, unless specified differently.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputRect",
            Increment: Rect? = nil,
            Min: Rect? = nil,
            Max: Rect? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Rect>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputRect = wrapper("InputRect")

    --[[
        ---------------------------------
            [SECTION] Drag Widget API
        ---------------------------------
    ]]
    --[=[
        @class Drag
        Drag Widget API

        A draggable widget for each datatype. Allows direct typing input but also dragging values by clicking and holding.
        
        See [Input] for more details on the arguments.
    ]=]

    --[=[
        @within Drag
        @prop DragNum Iris.DragNum
        @tag Widget
        @tag HasState
        
        A field which allows the user to click and drag their cursor to enter a number.
        You can ctrl + click to directly input a number, like InputNum.
        You can hold Shift to increase speed, and Alt to decrease speed when dragging.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "DragNum",
            Increment: number? = nil,
            Min: number? = nil,
            Max: number? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<number>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.DragNum = wrapper("DragNum")

    --[=[
        @within Drag
        @prop DragVector2 Iris.DragVector2
        @tag Widget
        @tag HasState
        
        A field which allows the user to click and drag their cursor to enter a Vector2.
        You can ctrl + click to directly input a Vector2, like InputVector2.
        You can hold Shift to increase speed, and Alt to decrease speed when dragging.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "DragVector2",
            Increment: Vector2? = nil,
            Min: Vector2? = nil,
            Max: Vector2? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Vector2>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.DragVector2 = wrapper("DragVector2")

    --[=[
        @within Drag
        @prop DragVector3 Iris.DragVector3
        @tag Widget
        @tag HasState
        
        A field which allows the user to click and drag their cursor to enter a Vector3.
        You can ctrl + click to directly input a Vector3, like InputVector3.
        You can hold Shift to increase speed, and Alt to decrease speed when dragging.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "DragVector3",
            Increment: Vector3? = nil,
            Min: Vector3? = nil,
            Max: Vector3? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Vector3>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.DragVector3 = wrapper("DragVector3")

    --[=[
        @within Drag
        @prop DragUDim Iris.DragUDim
        @tag Widget
        @tag HasState
        
        A field which allows the user to click and drag their cursor to enter a UDim.
        You can ctrl + click to directly input a UDim, like InputUDim.
        You can hold Shift to increase speed, and Alt to decrease speed when dragging.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "DragUDim",
            Increment: UDim? = nil,
            Min: UDim? = nil,
            Max: UDim? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<UDim>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.DragUDim = wrapper("DragUDim")

    --[=[
        @within Drag
        @prop DragUDim2 Iris.DragUDim2
        @tag Widget
        @tag HasState
        
        A field which allows the user to click and drag their cursor to enter a UDim2.
        You can ctrl + click to directly input a UDim2, like InputUDim2.
        You can hold Shift to increase speed, and Alt to decrease speed when dragging.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "DragUDim2",
            Increment: UDim2? = nil,
            Min: UDim2? = nil,
            Max: UDim2? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<UDim2>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.DragUDim2 = wrapper("DragUDim2")

    --[=[
        @within Drag
        @prop DragRect Iris.DragRect
        @tag Widget
        @tag HasState
        
        A field which allows the user to click and drag their cursor to enter a Rect.
        You can ctrl + click to directly input a Rect, like InputRect.
        You can hold Shift to increase speed, and Alt to decrease speed when dragging.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "DragRect",
            Increment: Rect? = nil,
            Min: Rect? = nil,
            Max: Rect? = nil,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Rect>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.DragRect = wrapper("DragRect")

    --[=[
        @within Input
        @prop InputColor3 Iris.InputColor3
        @tag Widget
        @tag HasState
        
        An input box for Color3. The input boxes are draggable between 0 and 255 or if UseFloats then between 0 and 1.
        Input can also be done using HSV instead of the default RGB.
        If no format argument is provided then a default R, G, B or H, S, V prefix is applied.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputColor3",
            UseFloats: boolean? = false, -- constrain the values between floats 0 and 1 or integers 0 and 255.
            UseHSV: boolean? = false, -- input using HSV instead.
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            color: State<Color3>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputColor3 = wrapper("InputColor3")

    --[=[
        @within Input
        @prop InputColor4 Iris.InputColor4
        @tag Widget
        @tag HasState
        
        An input box for Color4. Color4 is a combination of Color3 and a fourth transparency argument.
        It has two states for this purpose.
        The input boxes are draggable between 0 and 255 or if UseFloats then between 0 and 1.
        Input can also be done using HSV instead of the default RGB.
        If no format argument is provided then a default R, G, B, T or H, S, V, T prefix is applied.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputColor4",
            UseFloats: boolean? = false, -- constrain the values between floats 0 and 1 or integers 0 and 255.
            UseHSV: boolean? = false, -- input using HSV instead.
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            color: State<Color3>?,
            transparency: State<number>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.InputColor4 = wrapper("InputColor4")

    --[[
        -----------------------------------
            [SECTION] Slider Widget API
        -----------------------------------
    ]]
    --[=[
        @class Slider
        Slider Widget API

        A draggable widget with a visual bar constrained between a min and max for each datatype.
        Allows direct typing input but also dragging the slider by clicking and holding anywhere in the box.
        
        See [Input] for more details on the arguments.
    ]=]

    --[=[
        @within Slider
        @prop SliderNum Iris.SliderNum
        @tag Widget
        @tag HasState
        
        A field which allows the user to slide a grip to enter a number within a range.
        You can ctrl + click to directly input a number, like InputNum.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "SliderNum",
            Increment: number? = 1,
            Min: number? = 0,
            Max: number? = 100,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<number>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.SliderNum = wrapper("SliderNum")

    --[=[
        @within Slider
        @prop SliderVector2 Iris.SliderVector2
        @tag Widget
        @tag HasState
        
        A field which allows the user to slide a grip to enter a Vector2 within a range.
        You can ctrl + click to directly input a Vector2, like InputVector2.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "SliderVector2",
            Increment: Vector2? = { 1, 1 },
            Min: Vector2? = { 0, 0 },
            Max: Vector2? = { 100, 100 },
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Vector2>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.SliderVector2 = wrapper("SliderVector2")

    --[=[
        @within Slider
        @prop SliderVector3 Iris.SliderVector3
        @tag Widget
        @tag HasState
        
        A field which allows the user to slide a grip to enter a Vector3 within a range.
        You can ctrl + click to directly input a Vector3, like InputVector3.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "SliderVector3",
            Increment: Vector3? = { 1, 1, 1 },
            Min: Vector3? = { 0, 0, 0 },
            Max: Vector3? = { 100, 100, 100 },
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Vector3>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.SliderVector3 = wrapper("SliderVector3")

    --[=[
        @within Slider
        @prop SliderUDim Iris.SliderUDim
        @tag Widget
        @tag HasState
        
        A field which allows the user to slide a grip to enter a UDim within a range.
        You can ctrl + click to directly input a UDim, like InputUDim.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "SliderUDim",
            Increment: UDim? = { 0.01, 1 },
            Min: UDim? = { 0, 0 },
            Max: UDim? = { 1, 960 },
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<UDim>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.SliderUDim = wrapper("SliderUDim")

    --[=[
        @within Slider
        @prop SliderUDim2 Iris.SliderUDim2
        @tag Widget
        @tag HasState
        
        A field which allows the user to slide a grip to enter a UDim2 within a range.
        You can ctrl + click to directly input a UDim2, like InputUDim2.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "SliderUDim2",
            Increment: UDim2? = { 0.01, 1, 0.01, 1 },
            Min: UDim2? = { 0, 0, 0, 0 },
            Max: UDim2? = { 1, 960, 1, 960 },
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<UDim2>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.SliderUDim2 = wrapper("SliderUDim2")

    --[=[
        @within Slider
        @prop SliderRect Iris.SliderRect
        @tag Widget
        @tag HasState
        
        A field which allows the user to slide a grip to enter a Rect within a range.
        You can ctrl + click to directly input a Rect, like InputRect.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "SliderRect",
            Increment: Rect? = { 1, 1, 1, 1 },
            Min: Rect? = { 0, 0, 0, 0 },
            Max: Rect? = { 960, 960, 960, 960 },
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<Rect>?,
            editingText: State<boolean>?
        }
        ```
    ]=]
    Iris.SliderRect = wrapper("SliderRect")

    --[[
        ----------------------------------
            [SECTION] Combo Widget API
        ----------------------------------
    ]]
    --[=[
        @class Combo
        Combo Widget API
    ]=]

    --[=[
        @within Combo
        @prop Selectable Iris.Selectable
        @tag Widget
        @tag HasState
        
        An object which can be selected.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string,
            Index: any, -- index of selectable value.
            NoClick: boolean? = false -- prevents the selectable from being clicked by the user.
        }
        Events = {
            selected: () -> boolean,
            unselected: () -> boolean,
            active: () -> boolean,
            clicked: () -> boolean,
            rightClicked: () -> boolean,
            doubleClicked: () -> boolean,
            ctrlClicked: () -> boolean,
            hovered: () -> boolean,
        }
        States = {
            index: State<any> -- a shared state between all selectables.
        }
        ```
    ]=]
    Iris.Selectable = wrapper("Selectable")

    --[=[
        @within Combo
        @prop Combo Iris.Combo
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        A selection box to choose a value from a range of values.
        
        ```lua
        hasChildren = true
        hasState = true
        Arguments = {
            Text: string,
            NoButton: boolean? = false, -- hide the dropdown button.
            NoPreview: boolean? = false -- hide the preview field.
        }
        Events = {
            opened: () -> boolean,
            closed: () -> boolean,
            clicked: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            index: State<any>,
            isOpened: State<boolean>?
        }
        ```
    ]=]
    Iris.Combo = wrapper("Combo")

    --[=[
        @within Combo
        @prop ComboArray Iris.Combo
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        A selection box to choose a value from an array.
        
        ```lua
        hasChildren = true
        hasState = true
        Arguments = {
            Text: string,
            NoButton: boolean? = false, -- hide the dropdown button.
            NoPreview: boolean? = false -- hide the preview field.
        }
        Events = {
            opened: () -> boolean,
            closed: () -> boolean,
            clicked: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            index: State<any>,
            isOpened: State<boolean>?
        }
        Extra = {
            selectionArray: { any } -- the array to generate a combo from.
        }
        ```
    ]=]
    Iris.ComboArray = function<T>(arguments: Types.WidgetArguments, states: Types.WidgetStates?, selectionArray: { T })
        local defaultState
        if states == nil then
            defaultState = Iris.State(selectionArray[1])
        else
            defaultState = states
        end
        local thisWidget = Iris.Internal._Insert("Combo", arguments, defaultState)
        local sharedIndex: Types.State<T> = thisWidget.state.index
        for _, Selection in selectionArray do
            Iris.Internal._Insert("Selectable", { Selection, Selection }, { index = sharedIndex } :: Types.States)
        end
        Iris.End()

        return thisWidget
    end

    --[=[
        @within Combo
        @prop ComboEnum Iris.Combo
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        A selection box to choose a value from an Enum.
        
        ```lua
        hasChildren = true
        hasState = true
        Arguments = {
            Text: string,
            NoButton: boolean? = false, -- hide the dropdown button.
            NoPreview: boolean? = false -- hide the preview field.
        }
        Events = {
            opened: () -> boolean,
            closed: () -> boolean,
            clicked: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            index: State<any>,
            isOpened: State<boolean>?
        }
        Extra = {
            enumType: Enum -- the enum to generate a combo from.
        }
        ```
    ]=]
    Iris.ComboEnum = function(arguments: Types.WidgetArguments, states: Types.WidgetStates?, enumType: Enum)
        local defaultState
        if states == nil then
            defaultState = Iris.State(enumType:GetEnumItems()[1])
        else
            defaultState = states
        end
        local thisWidget = Iris.Internal._Insert("Combo", arguments, defaultState)
        local sharedIndex = thisWidget.state.index
        for _, Selection in enumType:GetEnumItems() do
            Iris.Internal._Insert("Selectable", { Selection.Name, Selection }, { index = sharedIndex } :: Types.States)
        end
        Iris.End()

        return thisWidget
    end

    --[=[
        @private
        @within Slider
        @prop InputEnum Iris.InputEnum
        @tag Widget
        @tag HasState
        
        A field which allows the user to slide a grip to enter a number within a range.
        You can ctrl + click to directly input a number, like InputNum.
        
        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "InputEnum",
            Increment: number? = 1,
            Min: number? = 0,
            Max: number? = 100,
            Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format.
        }
        Events = {
            numberChanged: () -> boolean,
            hovered: () -> boolean
        }
        States = {
            number: State<number>?,
            editingText: State<boolean>?,
            enumItem: EnumItem
        }
        ```
    ]=]
    Iris.InputEnum = Iris.ComboEnum

    --[[
        ---------------------------------
            [SECTION] Plot Widget API
        ---------------------------------
    ]]
    --[=[
        @class Plot
        Plot Widget API
    ]=]

    --[=[
        @within Plot
        @prop ProgressBar Iris.PrograssBar
        @tag Widget
        @tag HasState

        A progress bar line with a state value to show the current state.

        ```lua
        hasChildren = false
        hasState = true
        Arguments = {
            Text: string? = "Progress Bar",
            Format: string? = nil -- optional to override with a custom progress such as `29/54`
        }
        Events = {
            hovered: () -> boolean,
            changed: () -> boolean
        }
        States = {
            progress: State<number>?
        }
        ```
    ]=]
    Iris.ProgressBar = wrapper("ProgressBar")

    --[[
        ----------------------------------
            [SECTION] Table Widget API
        ----------------------------------
    ]]
    --[=[
        @class Table
        Table Widget API
    ]=]

    --[=[
        @within Table
        @prop Table Iris.Table
        @tag Widget
        @tag HasChildren
        
        A layout widget which allows children to be displayed in configurable columns and rows.
        
        ```lua
        hasChildren = true
        hasState = false
        Arguments = {
            NumColumns = number,
            RowBg = boolean? = false, -- whether the row backgrounds alternate a background fill.
            BordersOuter = boolean? = false,
            BordersInner = boolean? = false, -- borders on each cell.
        }
        Events = {
            hovered: () -> boolean
        }
        ```
    ]=]
    Iris.Table = wrapper("Table")

    --[=[
        @within Table
        @function NextColumn
        
        In a table, moves to the next available cell. if the current cell is in the last column,
        then the next cell will be the first column of the next row.
    ]=]
    Iris.NextColumn = function()
        local parentWidget = Iris.Internal._GetParentWidget() :: Types.Table
        assert(parentWidget.type == "Table", "Iris.NextColumn can only be called within a table.")
        parentWidget.RowColumnIndex += 1
    end

    --[=[
        @within Table
        @function SetColumnIndex
        @param index number
        
        In a table, directly sets the index of the column.
    ]=]
    Iris.SetColumnIndex = function(columnIndex: number)
        local parentWidget = Iris.Internal._GetParentWidget() :: Types.Table
        assert(parentWidget.type == "Table", "Iris.SetColumnIndex can only be called within a table.")
        assert(columnIndex >= parentWidget.InitialNumColumns, "Iris.SetColumnIndex Argument must be in column range")
        parentWidget.RowColumnIndex = math.floor(parentWidget.RowColumnIndex / parentWidget.InitialNumColumns) + (columnIndex - 1)
    end

    --[=[
        @within Table
        @function NextRow
        
        In a table, moves to the next available row,
        skipping cells in the previous column if the last cell wasn't in the last column
    ]=]
    Iris.NextRow = function()
        -- sets column Index back to 0, increments Row
        local parentWidget = Iris.Internal._GetParentWidget() :: Types.Table
        assert(parentWidget.type == "Table", "Iris.NextColumn can only be called within a table.")
        local InitialNumColumns: number = parentWidget.InitialNumColumns
        local nextRow: number = math.floor((parentWidget.RowColumnIndex + 1) / InitialNumColumns) * InitialNumColumns
        parentWidget.RowColumnIndex = nextRow
    end
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.API

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.Internal | Enabled: N/A
--------------------------------------------------------------------
local HttpService: HttpService = game:GetService("HttpService")

local Types = require(script.Parent.Types)

return function(Iris: Types.Iris): Types.Internal
    --[=[
        @class Internal
        An internal class within Iris containing all the backend data and functions for Iris to operate.
        It is recommended that you don't generally interact with Internal unless you understand what you are doing.
    ]=]
    local Internal = {} :: Types.Internal

    --[[
        ---------------------------------
            [SECTION] Properties
        ---------------------------------
    ]]

    Internal._version = [[ 2.3.1 ]]

    Internal._started = false -- has Iris.connect been called yet
    Internal._shutdown = false
    Internal._cycleTick = 0 -- increments for each call to Cycle, used to determine the relative age and freshness of generated widgets

    -- Refresh
    Internal._globalRefreshRequested = false -- refresh means that all GUI is destroyed and regenerated, usually because a style change was made and needed to be propogated to all UI
    Internal._localRefreshActive = false -- if true, when _Insert is called, the widget called will be regenerated

    -- Widgets & Instances
    Internal._widgets = {}
    Internal._stackIndex = 1 -- Points to the index that IDStack is currently in, when computing cycle
    Internal._rootInstance = nil
    Internal._rootWidget = {
        ID = "R",
        type = "Root",
        Instance = Internal._rootInstance,
        ZIndex = 0,
        ZOffset = 0,
    }
    Internal._lastWidget = Internal._rootWidget -- widget which was most recently rendered

    -- Config
    Internal._rootConfig = {} -- root style which all widgets derive from
    Internal._config = Internal._rootConfig

    -- ID
    Internal._IDStack = { "R" }
    Internal._usedIDs = {} -- hash of IDs which are already used in a cycle, value is the # of occurances so that getID can assign a unique ID for each occurance
    Internal._pushedId = nil
    Internal._nextWidgetId = nil

    -- State
    Internal._states = {} -- Iris.States

    -- Callback
    Internal._postCycleCallbacks = {}
    Internal._connectedFunctions = {} -- functions which run each Iris cycle, connected by the user
    Internal._connections = {}
    Internal._initFunctions = {}

    -- Error
    Internal._fullErrorTracebacks = game:GetService("RunService"):IsStudio()

    --[=[
        @within Internal
        @prop _cycleCoroutine thread

        The thread which handles all connected functions. Each connection is within a pcall statement which prevents
        Iris from crashing and instead stopping at the error.
    ]=]
    Internal._cycleCoroutine = coroutine.create(function()
        while Internal._started do
            for _, callback: () -> string in Internal._connectedFunctions do
                debug.profilebegin("Iris/Connection")
                local status: boolean, _error: string = pcall(callback)
                debug.profileend()
                if not status then
                    -- any error reserts the _stackIndex for the next frame and yields the error.
                    Internal._stackIndex = 1
                    coroutine.yield(false, _error)
                end
            end
            -- after all callbacks, we yeild so it only runs once a frame.
            coroutine.yield(true)
        end
    end)

    --[[
        -----------------------
            [SECTION] State
        -----------------------
    ]]

    --[=[
        @class State
        This class wraps a value in getters and setters, its main purpose is to allow primatives to be passed as objects.
        Constructors for this class are available in [Iris]

        ```lua
        local state = Iris.State(0) -- we initialise the state with a value of 0
        
        -- these are equivalent. Ideally you should use `:get()` and ignore `.value`.
        print(state:get())
        print(state.value)

        state:set(state:get() + 1) -- increments the state by getting the current value and adding 1.

        state:onChange(function(newValue)
            print(`The value of the state is now: {newValue}`)
        end)
        ```

        :::caution
        Never call `:set()` on a state when inside the `:onChange()` callback of the same state. This will cause a continous callback.

        Never chain states together so that each state changes the value of another state in a cyclic nature. This will cause a continous callback.
        :::
    ]=]
    local StateClass = {}
    StateClass.__index = StateClass

    --[=[
        @within State
        @method get<T>
        @return T
        
        Returns the states current value.
    ]=]
    function StateClass:get<T>(): T -- you can also simply use .value
        return self.value
    end

    --[=[
        @within State
        @method set<T>
        @param newValue T
        @return T
        
        Allows the caller to assign the state object a new value, and returns the new value.
    ]=]
    function StateClass:set<T>(newValue: T): T
        if newValue == self.value then
            -- no need to update on no change.
            return self.value
        end
        self.value = newValue
        for _, thisWidget: Types.Widget in self.ConnectedWidgets do
            Internal._widgets[thisWidget.type].UpdateState(thisWidget)
        end

        for _, callback in self.ConnectedFunctions do
            callback(newValue)
        end
        return self.value
    end

    --[=[
        @within State
        @method onChange<T>
        @param callback (newValue: T) -> ()
        
        Allows the caller to connect a callback which is called when the states value is changed.

        :::caution
        Calling `:onChange()` every frame will add a new function every frame.
        You must ensure you are only calling `:onChange()` once for each callback for the state's entire lifetime.
        :::
    ]=]
    function StateClass:onChange<T>(callback: (newValue: T) -> ()): () -> ()
        local connectionIndex: number = #self.ConnectedFunctions + 1
        self.ConnectedFunctions[connectionIndex] = callback
        return function()
            self.ConnectedFunctions[connectionIndex] = nil
        end
    end

    Internal.StateClass = StateClass

    --[[
        ---------------------------
            [SECTION] Functions
        ---------------------------
    ]]

    --[=[
        @within Internal
        @function _cycle
        
        Called every frame to handle all of the widget management. Any previous frame data is ammended and everything updates.
    ]=]
    function Internal._cycle()
        --debug.profilebegin("Iris/Cycle")
        if Iris.Disabled then
            return -- Stops all rendering, effectively freezes the current frame with no interaction.
        end

        Internal._rootWidget.lastCycleTick = Internal._cycleTick
        if Internal._rootInstance == nil or Internal._rootInstance.Parent == nil then
            Iris.ForceRefresh()
        end

        for _, widget: Types.Widget in Internal._lastVDOM do
            if widget.lastCycleTick ~= Internal._cycleTick and (widget.lastCycleTick ~= -1) then
                -- a widget which used to be rendered was not called last frame, so we discard it.
                -- if the cycle tick is -1 we have already discarded it.
                Internal._DiscardWidget(widget)
            end
        end

        -- represents all widgets created last frame. We keep the _lastVDOM to reuse widgets from the previous frame
        -- rather than creating a new instance every frame.
        setmetatable(Internal._lastVDOM, { __mode = "kv" })
        Internal._lastVDOM = Internal._VDOM
        Internal._VDOM = Internal._generateEmptyVDOM()

        -- anything that wnats to run before the frame.
        task.spawn(function()
            for _, callback: () -> () in Internal._postCycleCallbacks do
                callback()
            end
        end)

        if Internal._globalRefreshRequested then
            -- rerender every widget
            --debug.profilebegin("Iris Refresh")
            Internal._generateSelectionImageObject()
            Internal._globalRefreshRequested = false
            for _, widget: Types.Widget in Internal._lastVDOM do
                Internal._DiscardWidget(widget)
            end
            Internal._generateRootInstance()
            Internal._lastVDOM = Internal._generateEmptyVDOM()
            --debug.profileend()
        end

        -- update counters
        Internal._cycleTick += 1
        table.clear(Internal._usedIDs)

        -- if Internal.parentInstance:IsA("GuiBase2d") and math.min(Internal.parentInstance.AbsoluteSize.X, Internal.parentInstance.AbsoluteSize.Y) < 100 then
        --     error("Iris Parent Instance is too small")
        -- end
        local compatibleParent: boolean = (Internal.parentInstance:IsA("GuiBase2d") or Internal.parentInstance:IsA("CoreGui") or Internal.parentInstance:IsA("PluginGui") or Internal.parentInstance:IsA("PlayerGui"))
        if compatibleParent == false then
            error("Iris Parent Instance cant contain GUI")
        end

        -- if we are running in Studio, we want full error tracebacks, so we don't have
        -- any pcall to protect from an error.
        if Internal._fullErrorTracebacks then
            for _, callback: () -> () in Internal._connectedFunctions do
                callback()
            end
        else
            --debug.profilebegin("Iris/Generate")

            -- each frame we check on our thread status.
            local coroutineStatus = coroutine.status(Internal._cycleCoroutine)
            if coroutineStatus == "suspended" then
                -- suspended means it yielded, either because it was a complete success
                -- or it caught an error in the code. We run it again for this frame.
                local _, success, result = coroutine.resume(Internal._cycleCoroutine)
                if success == false then
                    -- Connected function code errored
                    error(result, 0)
                end
            elseif coroutineStatus == "running" then
                -- still running (probably because of an asynchronous method inside a connection).
                error("Iris cycleCoroutine took to long to yield. Connected functions should not yield.")
            else
                -- should never reach this (nothing you can do).
                error("unrecoverable state")
            end
            --debug.profileend()
        end

        if Internal._stackIndex ~= 1 then
            -- has to be larger than 1 because of the check that it isnt below 1 in Iris.End
            Internal._stackIndex = 1
            error("Callback has too few calls to Iris.End()", 0)
        end

        --debug.profileend()
    end

    --[=[
        @within Internal
        @ignore
        @function _NoOp

        A dummy function which does nothing. Used as a placeholder for optional methods in a widget class.
        Used in `Internal.WidgetConstructor`
    ]=]
    function Internal._NoOp() end

    --  Widget

    --[=[
        @within Internal
        @function WidgetConstructor
        @param type string -- name used to denote the widget class.
        @param widgetClass Types.WidgetClass -- table of methods for the new widget.

        For each widget, a widget class is created which handles all the operations of a widget. This removes the class nature
        of widgets, and simplifies the available functions which can be applied to any widget. The widgets themselves are
        dumb tables containing all the data but no methods to handle any of the data apart from events.
    ]=]
    function Internal.WidgetConstructor(type: string, widgetClass: Types.WidgetClass)
        local Fields: { [string]: { [string]: { string } } } = {
            All = {
                Required = {
                    "Generate", -- generates the instance.
                    "Discard",
                    "Update",

                    -- not methods !
                    "Args",
                    "Events",
                    "hasChildren",
                    "hasState",
                },
                Optional = {},
            },
            IfState = {
                Required = {
                    "GenerateState",
                    "UpdateState",
                },
                Optional = {},
            },
            IfChildren = {
                Required = {
                    "ChildAdded", -- returns the parent of the child widget.
                },
                Optional = {
                    "ChildDiscarded",
                },
            },
        }

        -- we ensure all essential functions and properties are present, otherwise the code will break later.
        -- some functions will only be needed if the widget has children or has state.
        local thisWidget = {} :: Types.WidgetClass
        for _, field: string in Fields.All.Required do
            assert(widgetClass[field] ~= nil, `field {field} is missing from widget {type}, it is required for all widgets`)
            thisWidget[field] = widgetClass[field]
        end

        for _, field: string in Fields.All.Optional do
            if widgetClass[field] == nil then
                -- assign a dummy function which does nothing.
                thisWidget[field] = Internal._NoOp
            else
                thisWidget[field] = widgetClass[field]
            end
        end

        if widgetClass.hasState then
            for _, field: string in Fields.IfState.Required do
                assert(widgetClass[field] ~= nil, `field {field} is missing from widget {type}, it is required for all widgets with state`)
                thisWidget[field] = widgetClass[field]
            end
            for _, field: string in Fields.IfState.Optional do
                if widgetClass[field] == nil then
                    thisWidget[field] = Internal._NoOp
                else
                    thisWidget[field] = widgetClass[field]
                end
            end
        end

        if widgetClass.hasChildren then
            for _, field: string in Fields.IfChildren.Required do
                assert(widgetClass[field] ~= nil, `field {field} is missing from widget {type}, it is required for all widgets with children`)
                thisWidget[field] = widgetClass[field]
            end
            for _, field: string in Fields.IfChildren.Optional do
                if widgetClass[field] == nil then
                    thisWidget[field] = Internal._NoOp
                else
                    thisWidget[field] = widgetClass[field]
                end
            end
        end

        -- an internal table of all widgets to the widget class.
        Internal._widgets[type] = thisWidget
        -- allowing access to the index for each widget argument.
        Iris.Args[type] = thisWidget.Args

        local ArgNames: { [number]: string } = {}
        for index: string, argument: number in thisWidget.Args do
            ArgNames[argument] = index
        end
        thisWidget.ArgNames = ArgNames

        for index: string, _ in thisWidget.Events do
            if Iris.Events[index] == nil then
                Iris.Events[index] = function()
                    return Internal._EventCall(Internal._lastWidget, index)
                end
            end
        end
    end

    --[=[
        @within Internal
        @function _Insert
        @param widgetType: string -- name of widget class.
        @param arguments { [string]: number } -- arguments of the widget.
        @param states { [string]: States<any> }? -- states of the widget.
        @return Widget -- the widget.

        Every widget is created through _Insert. An ID is generated based on the line of the calling code and is used to
        find the previous frame widget if it exists. If no widget exists, a new one is created.
    ]=]
    function Internal._Insert(widgetType: string, args: Types.WidgetArguments?, states: Types.WidgetStates?): Types.Widget
        local ID: Types.ID = Internal._getID(3)
        --debug.profilebegin(ID)

        -- fetch the widget class which contains all the functions for the widget.
        local thisWidgetClass: Types.WidgetClass = Internal._widgets[widgetType]

        if Internal._VDOM[ID] then
            -- widget already created once this frame, so we can append to it.
            return Internal._ContinueWidget(ID, widgetType)
        end

        local arguments: Types.Arguments = {} :: Types.Arguments
        if args ~= nil then
            if type(args) ~= "table" then
                args = { args }
            end

            -- convert the arguments to a key-value dictionary so arguments can be referred to by their name and not index.
            for index: number, argument: Types.Argument in args do
                arguments[thisWidgetClass.ArgNames[index]] = argument
            end
        end
        -- prevents tampering with the arguments which are used to check for changes.
        table.freeze(arguments)

        local lastWidget: Types.Widget? = Internal._lastVDOM[ID]
        if lastWidget and widgetType == lastWidget.type then
            -- found a matching widget from last frame.
            if Internal._localRefreshActive then
                -- we are redrawing every widget.
                Internal._DiscardWidget(lastWidget)
                lastWidget = nil
            end
        end
        local thisWidget: Types.Widget = if lastWidget == nil then Internal._GenNewWidget(widgetType, arguments, states, ID) else lastWidget

        local parentWidget: Types.ParentWidget = thisWidget.parentWidget

        if thisWidget.type ~= "Window" and thisWidget.type ~= "Tooltip" then
            if thisWidget.ZIndex ~= parentWidget.ZOffset then
                parentWidget.ZUpdate = true
            end

            if parentWidget.ZUpdate then
                thisWidget.ZIndex = parentWidget.ZOffset
                if thisWidget.Instance then
                    thisWidget.Instance.ZIndex = thisWidget.ZIndex
                    thisWidget.Instance.LayoutOrder = thisWidget.ZIndex
                end
            end
        end

        if Internal._deepCompare(thisWidget.providedArguments, arguments) == false then
            -- the widgets arguments have changed, the widget should update to reflect changes.
            -- providedArguments is the frozen table which will not change.
            -- the arguments can be altered internally, which happens for the input widgets.
            thisWidget.arguments = Internal._deepCopy(arguments)
            thisWidget.providedArguments = arguments
            thisWidgetClass.Update(thisWidget)
        end

        thisWidget.lastCycleTick = Internal._cycleTick
        parentWidget.ZOffset += 1

        if thisWidgetClass.hasChildren then
            local thisParent = thisWidget :: Types.ParentWidget
            -- a parent widget, so we increase our depth.
            thisParent.ZOffset = 0
            thisParent.ZUpdate = false
            Internal._stackIndex += 1
            Internal._IDStack[Internal._stackIndex] = thisWidget.ID
        end

        Internal._VDOM[ID] = thisWidget
        Internal._lastWidget = thisWidget

        --debug.profileend()

        return thisWidget
    end

    --[=[
        @within Internal
        @function _GenNewWidget
        @param widgetType string
        @param arguments { [string]: any } -- arguments of the widget.
        @param states { [string]: State<any> }? -- states of the widget.
        @param ID ID -- id of the new widget. Determined in `Internal._Insert`
        @return Widget -- the newly created widget.

        All widgets are created as tables with properties. The widget class contains the functions to create the UI instances and
        update the widget or change state.
    ]=]
    function Internal._GenNewWidget(widgetType: string, arguments: Types.Arguments, states: Types.WidgetStates?, ID: Types.ID): Types.Widget
        local parentId: Types.ID = Internal._IDStack[Internal._stackIndex]
        local parentWidget: Types.ParentWidget = Internal._VDOM[parentId]
        local thisWidgetClass: Types.WidgetClass = Internal._widgets[widgetType]

        -- widgets are just tables with properties.
        local thisWidget = {} :: Types.Widget
        setmetatable(thisWidget, thisWidget)

        thisWidget.ID = ID
        thisWidget.type = widgetType
        thisWidget.parentWidget = parentWidget
        thisWidget.trackedEvents = {}
        thisWidget.UID = HttpService:GenerateGUID(false):sub(0, 8)

        -- widgets have lots of space to ensure they are always visible.
        thisWidget.ZIndex = parentWidget.ZOffset

        thisWidget.Instance = thisWidgetClass.Generate(thisWidget)
        -- tooltips set their parent in the generation method, so we need to udpate it here
        parentWidget = thisWidget.parentWidget

        if Internal._config.Parent then
            thisWidget.Instance.Parent = Internal._config.Parent
        else
            thisWidget.Instance.Parent = Internal._widgets[parentWidget.type].ChildAdded(parentWidget, thisWidget)
        end

        -- we can modify the arguments table, but keep a frozen copy to compare for user-end changes.
        thisWidget.providedArguments = arguments
        thisWidget.arguments = Internal._deepCopy(arguments)
        thisWidgetClass.Update(thisWidget)

        local eventMTParent
        if thisWidgetClass.hasState then
            local stateWidget = thisWidget :: Types.StateWidget
            if states then
                for index: string, state: Types.State<any> in states do
                    if not (type(state) == "table" and getmetatable(state :: any) == Internal.StateClass) then
                        -- generate a n [trimmed]  -  Edit
  18:44:45.999  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Format | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    --stylua: ignore
    Iris.WidgetConstructor("Separator", {
        hasState = false,
        hasChildren = false,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Separator)
            local Separator: Frame = Instance.new("Frame")
            Separator.Name = "Iris_Separator"
            Separator.BackgroundColor3 = Iris._config.SeparatorColor
            Separator.BackgroundTransparency = Iris._config.SeparatorTransparency
            Separator.BorderSizePixel = 0
            if thisWidget.parentWidget.type == "SameLine" then
                Separator.Size = UDim2.new(0, 1, 1, 0)
            else
                Separator.Size = UDim2.new(1, 0, 0, 1)
            end
            Separator.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Separator, Enum.FillDirection.Vertical, UDim.new(0, 0))
            -- this is to prevent a bug of AutomaticLayout edge case when its parent has automaticLayout enabled

            return Separator
        end,
        Update = function(_thisWidget: Types.Separator) end,
        Discard = function(thisWidget: Types.Separator)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("Indent", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
        },
        Events = {},
        Generate = function(thisWidget: Types.Indent)
            local Indent: Frame = Instance.new("Frame")
            Indent.Name = "Iris_Indent"
            Indent.BackgroundTransparency = 1
            Indent.BorderSizePixel = 0
            Indent.Size = UDim2.fromScale(1, 0)
            Indent.AutomaticSize = Enum.AutomaticSize.Y
            Indent.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Indent, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
            widgets.UIPadding(Indent, Vector2.zero)

            return Indent
        end,
        Update = function(thisWidget: Types.Indent)
            local Indent = thisWidget.Instance :: Frame

            local indentWidth: number
            if thisWidget.arguments.Width then
                indentWidth = thisWidget.arguments.Width
            else
                indentWidth = Iris._config.IndentSpacing
            end
            Indent.UIPadding.PaddingLeft = UDim.new(0, indentWidth)
        end,
        Discard = function(thisWidget: Types.Indent)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Indent, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("SameLine", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
            ["VerticalAlignment"] = 2,
            ["HorizontalAlignment"] = 3,
        },
        Events = {},
        Generate = function(thisWidget: Types.SameLine)
            local SameLine: Frame = Instance.new("Frame")
            SameLine.Name = "Iris_SameLine"
            SameLine.BackgroundTransparency = 1
            SameLine.BorderSizePixel = 0
            SameLine.Size = UDim2.fromScale(1, 0)
            SameLine.AutomaticSize = Enum.AutomaticSize.Y
            SameLine.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(SameLine, Enum.FillDirection.Horizontal, UDim.new(0, 0))

            return SameLine
        end,
        Update = function(thisWidget: Types.SameLine)
            local Sameline = thisWidget.Instance :: Frame
            local uiListLayout: UIListLayout = Sameline.UIListLayout
            local itemWidth: number
            if thisWidget.arguments.Width then
                itemWidth = thisWidget.arguments.Width
            else
                itemWidth = Iris._config.ItemSpacing.X
            end
            uiListLayout.Padding = UDim.new(0, itemWidth)
            if thisWidget.arguments.VerticalAlignment then
                uiListLayout.VerticalAlignment = thisWidget.arguments.VerticalAlignment
            else
                uiListLayout.VerticalAlignment = Enum.VerticalAlignment.Top
            end
            if thisWidget.arguments.HorizontalAlignment then
                uiListLayout.HorizontalAlignment = thisWidget.arguments.HorizontalAlignment
            else
                uiListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            end
        end,
        Discard = function(thisWidget: Types.SameLine)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.SameLine, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("Group", {
        hasState = false,
        hasChildren = true,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Group)
            local Group: Frame = Instance.new("Frame")
            Group.Name = "Iris_Group"
            Group.AutomaticSize = Enum.AutomaticSize.XY
            Group.Size = UDim2.fromOffset(0, 0)
            Group.BackgroundTransparency = 1
            Group.BorderSizePixel = 0
            Group.LayoutOrder = thisWidget.ZIndex
            Group.ClipsDescendants = false

            widgets.UIListLayout(Group, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.X))

            return Group
        end,
        Update = function(_thisWidget: Types.Group) end,
        Discard = function(thisWidget: Types.Group)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Group, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Format

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Input | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

type InputDataTypes = "Num" | "Vector2" | "Vector3" | "UDim" | "UDim2" | "Color3" | "Color4" | "Rect" | "Enum" | "" | string

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local numberChanged = {
        ["Init"] = function(_thisWidget: Types.Widget) end,
        ["Get"] = function(thisWidget: Types.Input<any>)
            return thisWidget.lastNumberChangedTick == Iris._cycleTick
        end,
    }

    local function getValueByIndex<T>(value: T, index: number, arguments: any): number
        local t: string = typeof(value)
        local v = value :: any
        if t == "number" then
            return v
        elseif t == "Vector2" then
            if index == 1 then
                return v.X
            elseif index == 2 then
                return v.Y
            end
        elseif t == "Vector3" then
            if index == 1 then
                return v.X
            elseif index == 2 then
                return v.Y
            elseif index == 3 then
                return v.Z
            end
        elseif t == "UDim" then
            if index == 1 then
                return v.Scale
            elseif index == 2 then
                return v.Offset
            end
        elseif t == "UDim2" then
            if index == 1 then
                return v.X.Scale
            elseif index == 2 then
                return v.X.Offset
            elseif index == 3 then
                return v.Y.Scale
            elseif index == 4 then
                return v.Y.Offset
            end
        elseif t == "Color3" then
            local color: { number } = arguments.UseHSV and { v:ToHSV() } or { v.R, v.G, v.B }
            if index == 1 then
                return color[1]
            elseif index == 2 then
                return color[2]
            elseif index == 3 then
                return color[3]
            end
        elseif t == "Rect" then
            if index == 1 then
                return v.Min.X
            elseif index == 2 then
                return v.Min.Y
            elseif index == 3 then
                return v.Max.X
            elseif index == 4 then
                return v.Max.Y
            end
        elseif t == "table" then
            return v[index]
        end

        error(`Incorrect datatype or value: {value} {typeof(value)} {index}`)
    end

    local function updateValueByIndex<T>(value: T, index: number, newValue: number, arguments: Types.Arguments): T
        if typeof(value) == "number" then
            return newValue :: any
        elseif typeof(value) == "Vector2" then
            if index == 1 then
                return Vector2.new(newValue, value.Y) :: any
            elseif index == 2 then
                return Vector2.new(value.X, newValue) :: any
            end
        elseif typeof(value) == "Vector3" then
            if index == 1 then
                return Vector3.new(newValue, value.Y, value.Z) :: any
            elseif index == 2 then
                return Vector3.new(value.X, newValue, value.Z) :: any
            elseif index == 3 then
                return Vector3.new(value.X, value.Y, newValue) :: any
            end
        elseif typeof(value) == "UDim" then
            if index == 1 then
                return UDim.new(newValue, value.Offset) :: any
            elseif index == 2 then
                return UDim.new(value.Scale, newValue) :: any
            end
        elseif typeof(value) == "UDim2" then
            if index == 1 then
                return UDim2.new(UDim.new(newValue, value.X.Offset), value.Y) :: any
            elseif index == 2 then
                return UDim2.new(UDim.new(value.X.Scale, newValue), value.Y) :: any
            elseif index == 3 then
                return UDim2.new(value.X, UDim.new(newValue, value.Y.Offset)) :: any
            elseif index == 4 then
                return UDim2.new(value.X, UDim.new(value.Y.Scale, newValue)) :: any
            end
        elseif typeof(value) == "Rect" then
            if index == 1 then
                return Rect.new(Vector2.new(newValue, value.Min.Y), value.Max) :: any
            elseif index == 2 then
                return Rect.new(Vector2.new(value.Min.X, newValue), value.Max) :: any
            elseif index == 3 then
                return Rect.new(value.Min, Vector2.new(newValue, value.Max.Y)) :: any
            elseif index == 4 then
                return Rect.new(value.Min, Vector2.new(value.Max.X, newValue)) :: any
            end
        elseif typeof(value) == "Color3" then
            if arguments.UseHSV then
                local h: number, s: number, v: number = value:ToHSV()
                if index == 1 then
                    return Color3.fromHSV(newValue, s, v) :: any
                elseif index == 2 then
                    return Color3.fromHSV(h, newValue, v) :: any
                elseif index == 3 then
                    return Color3.fromHSV(h, s, newValue) :: any
                end
            end
            if index == 1 then
                return Color3.new(newValue, value.G, value.B) :: any
            elseif index == 2 then
                return Color3.new(value.R, newValue, value.B) :: any
            elseif index == 3 then
                return Color3.new(value.R, value.G, newValue) :: any
            end
        end

        error(`Incorrect datatype or value {value} {typeof(value)} {index}`)
    end

    local defaultIncrements: { [InputDataTypes]: { number } } = {
        Num = { 1 },
        Vector2 = { 1, 1 },
        Vector3 = { 1, 1, 1 },
        UDim = { 0.01, 1 },
        UDim2 = { 0.01, 1, 0.01, 1 },
        Color3 = { 1, 1, 1 },
        Color4 = { 1, 1, 1, 1 },
        Rect = { 1, 1, 1, 1 },
    }

    local defaultMin: { [InputDataTypes]: { number } } = {
        Num = { 0 },
        Vector2 = { 0, 0 },
        Vector3 = { 0, 0, 0 },
        UDim = { 0, 0 },
        UDim2 = { 0, 0, 0, 0 },
        Rect = { 0, 0, 0, 0 },
    }

    local defaultMax: { [InputDataTypes]: { number } } = {
        Num = { 100 },
        Vector2 = { 100, 100 },
        Vector3 = { 100, 100, 100 },
        UDim = { 1, 960 },
        UDim2 = { 1, 960, 1, 960 },
        Rect = { 960, 960, 960, 960 },
    }

    local defaultPrefx: { [InputDataTypes]: { string } } = {
        Num = { "" },
        Vector2 = { "X: ", "Y: " },
        Vector3 = { "X: ", "Y: ", "Z: " },
        UDim = { "", "" },
        UDim2 = { "", "", "", "" },
        Color3_RGB = { "R: ", "G: ", "B: " },
        Color3_HSV = { "H: ", "S: ", "V: " },
        Color4_RGB = { "R: ", "G: ", "B: ", "T: " },
        Color4_HSV = { "H: ", "S: ", "V: ", "T: " },
        Rect = { "X: ", "Y: ", "X: ", "Y: " },
    }

    local defaultSigFigs: { [InputDataTypes]: { number } } = {
        Num = { 0 },
        Vector2 = { 0, 0 },
        Vector3 = { 0, 0, 0 },
        UDim = { 3, 0 },
        UDim2 = { 3, 0, 3, 0 },
        Color3 = { 0, 0, 0 },
        Color4 = { 0, 0, 0, 0 },
        Rect = { 0, 0, 0, 0 },
    }

    --[[
        Input
    ]]
    local generateInputScalar: <T>(dataType: InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
    do
        local function generateButtons(thisWidget: Types.Input<number>, parent: GuiObject, rightPadding: number, textHeight: number)
            rightPadding += 2 * Iris._config.ItemInnerSpacing.X + 2 * textHeight

            local SubButton = widgets.abstractButton.Generate(thisWidget) :: TextButton
            SubButton.Name = "SubButton"
            SubButton.ZIndex = 5
            SubButton.LayoutOrder = 5
            SubButton.TextXAlignment = Enum.TextXAlignment.Center
            SubButton.Text = "-"
            SubButton.Size = UDim2.fromOffset(Iris._config.TextSize + 2 * Iris._config.FramePadding.Y, Iris._config.TextSize)
            SubButton.Parent = parent

            widgets.applyButtonClick(SubButton, function()
                local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
                local changeValue: number = (thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, 1, thisWidget.arguments :: Types.Argument) or 1) * (isCtrlHeld and 100 or 1)
                local newValue: number = thisWidget.state.number.value - changeValue
                if thisWidget.arguments.Min ~= nil then
                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, 1, thisWidget.arguments :: Types.Argument))
                end
                if thisWidget.arguments.Max ~= nil then
                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, 1, thisWidget.arguments :: Types.Argument))
                end
                thisWidget.state.number:set(newValue)
                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
            end)

            local AddButton = widgets.abstractButton.Generate(thisWidget) :: TextButton
            AddButton.Name = "AddButton"
            AddButton.ZIndex = 6
            AddButton.LayoutOrder = 6
            AddButton.TextXAlignment = Enum.TextXAlignment.Center
            AddButton.Text = "+"
            AddButton.Size = UDim2.fromOffset(Iris._config.TextSize + 2 * Iris._config.FramePadding.Y, Iris._config.TextSize)
            AddButton.Parent = parent

            widgets.applyButtonClick(AddButton, function()
                local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
                local changeValue: number = (thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, 1, thisWidget.arguments :: Types.Argument) or 1) * (isCtrlHeld and 100 or 1)
                local newValue: number = thisWidget.state.number.value + changeValue
                if thisWidget.arguments.Min ~= nil then
                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, 1, thisWidget.arguments :: Types.Argument))
                end
                if thisWidget.arguments.Max ~= nil then
                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, 1, thisWidget.arguments :: Types.Argument))
                end
                thisWidget.state.number:set(newValue)
                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
            end)

            return rightPadding
        end

        function generateInputScalar<T>(dataType: InputDataTypes, components: number, defaultValue: any)
            return {
                hasState = true,
                hasChildren = false,
                Args = {
                    ["Text"] = 1,
                    ["Increment"] = 2,
                    ["Min"] = 3,
                    ["Max"] = 4,
                    ["Format"] = 5,
                },
                Events = {
                    ["numberChanged"] = numberChanged,
                    ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                        return thisWidget.Instance
                    end),
                },
                Generate = function(thisWidget: Types.Input<T>)
                    local Input: Frame = Instance.new("Frame")
                    Input.Name = "Iris_Input" .. dataType
                    Input.Size = UDim2.fromScale(1, 0)
                    Input.BackgroundTransparency = 1
                    Input.BorderSizePixel = 0
                    Input.LayoutOrder = thisWidget.ZIndex
                    Input.AutomaticSize = Enum.AutomaticSize.Y
                    local UIListLayout: UIListLayout = widgets.UIListLayout(Input, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
                    UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                    -- we add plus and minus buttons if there is only one box. This can be disabled through the argument.
                    local rightPadding: number = 0
                    local textHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

                    if components == 1 then
                        rightPadding = generateButtons(thisWidget :: any, Input, rightPadding, textHeight)
                    end

                    -- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
                    -- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
                    -- 4 pixels shorter, all for the sake of flush.
                    local componentWidth: UDim = UDim.new(Iris._config.ContentWidth.Scale / components, (Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1)) - rightPadding) / components)
                    local totalWidth: UDim = UDim.new(componentWidth.Scale * (components - 1), (componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)) + rightPadding)
                    local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

                    -- we handle each component individually since they don't need to interact with each other.
                    for index = 1, components do
                        local InputField: TextBox = Instance.new("TextBox")
                        InputField.Name = "InputField" .. tostring(index)
                        InputField.LayoutOrder = index
                        if index == components then
                            InputField.Size = UDim2.new(lastComponentWidth, Iris._config.ContentHeight)
                        else
                            InputField.Size = UDim2.new(componentWidth, Iris._config.ContentHeight)
                        end
                        InputField.AutomaticSize = Enum.AutomaticSize.Y
                        InputField.BackgroundColor3 = Iris._config.FrameBgColor
                        InputField.BackgroundTransparency = Iris._config.FrameBgTransparency
                        InputField.ClearTextOnFocus = false
                        InputField.TextTruncate = Enum.TextTruncate.AtEnd
                        InputField.ClipsDescendants = true

                        widgets.applyFrameStyle(InputField)
                        widgets.applyTextStyle(InputField)
                        widgets.UISizeConstraint(InputField, Vector2.xAxis)

                        InputField.Parent = Input

                        InputField.FocusLost:Connect(function()
                            local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
                            if newValue ~= nil then
                                if thisWidget.arguments.Min ~= nil then
                                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
                                end
                                if thisWidget.arguments.Max ~= nil then
                                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments :: any))
                                end

                                if thisWidget.arguments.Increment then
                                    newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)) * getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                end

                                thisWidget.state.number:set(updateValueByIndex(thisWidget.state.number.value, index, newValue, thisWidget.arguments :: any))
                                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
                            end
                            local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                            if thisWidget.arguments.Prefix then
                                format = thisWidget.arguments.Prefix[index] .. format
                            end
                            InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))

                            thisWidget.state.editingText:set(0)
                        end)

                        InputField.Focused:Connect(function()
                            -- this highlights the entire field
                            InputField.CursorPosition = #InputField.Text + 1
                            InputField.SelectionStart = 1

                            thisWidget.state.editingText:set(index)
                        end)
                    end

                    local TextLabel: TextLabel = Instance.new("TextLabel")
                    TextLabel.Name = "TextLabel"
                    TextLabel.BackgroundTransparency = 1
                    TextLabel.BorderSizePixel = 0
                    TextLabel.LayoutOrder = 7
                    TextLabel.AutomaticSize = Enum.AutomaticSize.XY

                    widgets.applyTextStyle(TextLabel)

                    TextLabel.Parent = Input

                    return Input
                end,
                Update = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Input {dataType}`

                    if components == 1 then
                        Input.SubButton.Visible = not thisWidget.arguments.NoButtons
                        Input.AddButton.Visible = not thisWidget.arguments.NoButtons
                    end

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        -- we calculate the format for the s.f. using the max, min and increment arguments.
                        local format: { string } = {}
                        for index = 1, components do
                            local sigfigs: number = defaultSigFigs[dataType][index]

                            if thisWidget.arguments.Increment then
                                local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Max then
                                local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Min then
                                local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if sigfigs > 0 then
                                -- we know it's a float.
                                format[index] = `%.{sigfigs}f`
                            else
                                format[index] = "%d"
                            end
                        end

                        thisWidget.arguments.Format = format
                        thisWidget.arguments.Prefix = defaultPrefx[dataType]
                    end
                end,
                Discard = function(thisWidget: Types.Input<T>)
                    thisWidget.Instance:Destroy()
                    widgets.discardState(thisWidget)
                end,
                GenerateState = function(thisWidget: Types.Input<T>)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", 0)
                    end
                end,
                UpdateState = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject

                    for index = 1, components do
                        local InputField: TextBox = Input:FindFirstChild("InputField" .. tostring(index))
                        local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                        if thisWidget.arguments.Prefix then
                            format = thisWidget.arguments.Prefix[index] .. format
                        end
                        InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))
                    end
                end,
            }
        end
    end

    --[[
        Drag
    ]]
    local generateDragScalar: <T>(dataType: InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
    local generateColorDragScalar: (dataType: InputDataTypes, ...any) -> Types.WidgetClass
    do
        local PreviouseMouseXPosition: number = 0
        local AnyActiveDrag: boolean = false
        local ActiveDrag: Types.Input<Types.InputDataType>? = nil
        local ActiveIndex: number = 0
        local ActiveDataType: InputDataTypes | "" = ""

        local function updateActiveDrag()
            local currentMouseX: number = widgets.getMouseLocation().X
            local mouseXDelta: number = currentMouseX - PreviouseMouseXPosition
            PreviouseMouseXPosition = currentMouseX
            if AnyActiveDrag == false then
                return
            end
            if ActiveDrag == nil then
                return
            end

            local state: Types.State<Types.InputDataType> = ActiveDrag.state.number
            if ActiveDataType == "Color3" or ActiveDataType == "Color4" then
                local Drag = ActiveDrag :: any
                state = Drag.state.color
                if ActiveIndex == 4 then
                    state = Drag.state.transparency
                end
            end

            local increment: number = ActiveDrag.arguments.Increment and getValueByIndex(ActiveDrag.arguments.Increment, ActiveIndex, ActiveDrag.arguments) or defaultIncrements[ActiveDataType][ActiveIndex]
            increment *= (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightShift)) and 10 or 1
            increment *= (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightAlt)) and 0.1 or 1
            -- we increase the speed for Color3 and Color4 since it's too slow because the increment argument needs to be low.
            increment *= (ActiveDataType == "Color3" or ActiveDataType == "Color4") and 5 or 1

            local value: number = getValueByIndex(state.value, ActiveIndex, ActiveDrag.arguments)
            local newValue: number = value + (mouseXDelta * increment)

            if ActiveDrag.arguments.Min ~= nil then
                newValue = math.max(newValue, getValueByIndex(ActiveDrag.arguments.Min, ActiveIndex, ActiveDrag.arguments))
            end
            if ActiveDrag.arguments.Max ~= nil then
                newValue = math.min(newValue, getValueByIndex(ActiveDrag.arguments.Max, ActiveIndex, ActiveDrag.arguments))
            end

            state:set(updateValueByIndex(state.value, ActiveIndex, newValue, ActiveDrag.arguments :: any))
            ActiveDrag.lastNumberChangedTick = Iris._cycleTick + 1
        end

        local function DragMouseDown(thisWidget: Types.Input<Types.InputDataType>, dataTypes: InputDataTypes, index: number, x: number, y: number)
            local currentTime: number = widgets.getTime()
            local isTimeValid: boolean = currentTime - thisWidget.lastClickedTime < Iris._config.MouseDoubleClickTime
            local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
            if (isTimeValid and (Vector2.new(x, y) - thisWidget.lastClickedPosition).Magnitude < Iris._config.MouseDoubleClickMaxDist) or isCtrlHeld then
                thisWidget.state.editingText:set(index)
            else
                thisWidget.lastClickedTime = currentTime
                thisWidget.lastClickedPosition = Vector2.new(x, y)

                AnyActiveDrag = true
                ActiveDrag = thisWidget
                ActiveIndex = index
                ActiveDataType = dataTypes
                updateActiveDrag()
            end
        end

        widgets.registerEvent("InputChanged", function()
            if not Iris._started then
                return
            end
            updateActiveDrag()
        end)

        widgets.registerEvent("InputEnded", function(inputObject: InputObject)
            if not Iris._started then
                return
            end
            if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and AnyActiveDrag then
                AnyActiveDrag = false
                ActiveDrag = nil
                ActiveIndex = 0
            end
        end)

        function generateDragScalar<T>(dataType: InputDataTypes, components: number, defaultValue: any)
            return {
                hasState = true,
                hasChildren = false,
                Args = {
                    ["Text"] = 1,
                    ["Increment"] = 2,
                    ["Min"] = 3,
                    ["Max"] = 4,
                    ["Format"] = 5,
                },
                Events = {
                    ["numberChanged"] = numberChanged,
                    ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                        return thisWidget.Instance
                    end),
                },
                Generate = function(thisWidget: Types.Input<T>)
                    thisWidget.lastClickedTime = -1
                    thisWidget.lastClickedPosition = Vector2.zero

                    local Drag: Frame = Instance.new("Frame")
                    Drag.Name = "Iris_Drag" .. dataType
                    Drag.Size = UDim2.fromScale(1, 0)
                    Drag.BackgroundTransparency = 1
                    Drag.BorderSizePixel = 0
                    Drag.LayoutOrder = thisWidget.ZIndex
                    Drag.AutomaticSize = Enum.AutomaticSize.Y
                    local UIListLayout: UIListLayout = widgets.UIListLayout(Drag, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
                    UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                    -- we add a color box if it is Color3 or Color4.
                    local rightPadding: number = 0
                    local textHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

                    if dataType == "Color3" or dataType == "Color4" then
                        rightPadding += Iris._config.ItemInnerSpacing.X + textHeight

                        local ColorBox: ImageLabel = Instance.new("ImageLabel")
                        ColorBox.Name = "ColorBox"
                        ColorBox.BorderSizePixel = 0
                        ColorBox.Size = UDim2.fromOffset(textHeight, textHeight)
                        ColorBox.LayoutOrder = 5
                        ColorBox.Image = widgets.ICONS.ALPHA_BACKGROUND_TEXTURE
                        ColorBox.ImageTransparency = 1

                        widgets.applyFrameStyle(ColorBox, true)

                        ColorBox.Parent = Drag
                    end

                    -- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
                    -- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
                    -- 4 pixels shorter, all for the sake of flush.
                    local componentWidth: UDim = UDim.new(Iris._config.ContentWidth.Scale / components, (Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1)) - rightPadding) / components)
                    local totalWidth: UDim = UDim.new(componentWidth.Scale * (components - 1), (componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)) + rightPadding)
                    local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

                    for index = 1, components do
                        local DragField: TextButton = Instance.new("TextButton")
                        DragField.Name = "DragField" .. tostring(index)
                        DragField.LayoutOrder = index
                        if index == components then
                            DragField.Size = UDim2.new(lastComponentWidth, Iris._config.ContentHeight)
                        else
                            DragField.Size = UDim2.new(componentWidth, Iris._config.ContentHeight)
                        end
                        DragField.AutomaticSize = Enum.AutomaticSize.Y
                        DragField.BackgroundColor3 = Iris._config.FrameBgColor
                        DragField.BackgroundTransparency = Iris._config.FrameBgTransparency
                        DragField.AutoButtonColor = false
                        DragField.Text = ""
                        DragField.ClipsDescendants = true

                        widgets.applyFrameStyle(DragField)
                        widgets.applyTextStyle(DragField)
                        widgets.UISizeConstraint(DragField, Vector2.xAxis)

                        DragField.TextXAlignment = Enum.TextXAlignment.Center

                        DragField.Parent = Drag

                        widgets.applyInteractionHighlights("Background", DragField, DragField, {
                            Color = Iris._config.FrameBgColor,
                            Transparency = Iris._config.FrameBgTransparency,
                            HoveredColor = Iris._config.FrameBgHoveredColor,
                            HoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                            ActiveColor = Iris._config.FrameBgActiveColor,
                            ActiveTransparency = Iris._config.FrameBgActiveTransparency,
                        })

                        local InputField: TextBox = Instance.new("TextBox")
                        InputField.Name = "InputField"
                        InputField.Size = UDim2.new(1, 0, 1, 0)
                        InputField.BackgroundTransparency = 1
                        InputField.ClearTextOnFocus = false
                        InputField.TextTruncate = Enum.TextTruncate.AtEnd
                        InputField.ClipsDescendants = true
                        InputField.Visible = false

                        widgets.applyFrameStyle(InputField, true)
                        widgets.applyTextStyle(InputField)

                        InputField.Parent = DragField

                        InputField.FocusLost:Connect(function()
                            local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
                            local state: Types.State<T> = thisWidget.state.number
                            local widget = thisWidget :: any
                            if dataType == "Color4" and index == 4 then
                                state = widget.state.transparency
                            elseif dataType == "Color3" or dataType == "Color4" then
                                state = widget.state.color
                            end
                            if newValue ~= nil then
                                if dataType == "Color3" or dataType == "Color4" and not widget.arguments.UseFloats then
                                    newValue = newValue / 255
                                end
                                if thisWidget.arguments.Min ~= nil then
                                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
                                end
                                if thisWidget.arguments.Max ~= nil then
                                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments))
                                end

                                if thisWidget.arguments.Increment then
                                    newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)) * getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                end

                                state:set(updateValueByIndex(state.value, index, newValue, thisWidget.arguments :: any))
                                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
                            end

                            local value: number = getValueByIndex(state.value, index, thisWidget.arguments)
                            if dataType == "Color3" or dataType == "Color4" and not widget.arguments.UseFloats then
                                value = math.round(value * 255)
                            end

                            local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                            if thisWidget.arguments.Prefix then
                                format = thisWidget.arguments.Prefix[index] .. format
                            end
                            InputField.Text = string.format(format, value)

                            thisWidget.state.editingText:set(0)
                            InputField:ReleaseFocus(true)
                        end)

                        InputField.Focused:Connect(function()
                            -- this highlights the entire field
                            InputField.CursorPosition = #InputField.Text + 1
                            InputField.SelectionStart = 1

                            thisWidget.state.editingText:set(index)
                        end)

                        widgets.applyButtonDown(DragField, function(x: number, y: number)
                            DragMouseDown(thisWidget :: any, dataType, index, x, y)
                        end)
                    end

                    local TextLabel: TextLabel = Instance.new("TextLabel")
                    TextLabel.Name = "TextLabel"
                    TextLabel.BackgroundTransparency = 1
                    TextLabel.BorderSizePixel = 0
                    TextLabel.LayoutOrder = 6
                    TextLabel.AutomaticSize = Enum.AutomaticSize.XY

                    widgets.applyTextStyle(TextLabel)

                    TextLabel.Parent = Drag

                    return Drag
                end,
                Update = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Drag {dataType}`

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        -- we calculate the format for the s.f. using the max, min and increment arguments.
                        local format: { string } = {}
                        for index = 1, components do
                            local sigfigs: number = defaultSigFigs[dataType][index]

                            if thisWidget.arguments.Increment then
                                local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Max then
                                local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Min then
                                local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if sigfigs > 0 then
                                -- we know it's a float.
                                format[index] = `%.{sigfigs}f`
                            else
                                format[index] = "%d"
                            end
                        end

                        thisWidget.arguments.Format = format
                        thisWidget.arguments.Prefix = defaultPrefx[dataType]
                    end
                end,
                Discard = function(thisWidget: Types.Input<T>)
                    thisWidget.Instance:Destroy()
                    widgets.discardState(thisWidget)
                end,
                GenerateState = function(thisWidget: Types.Input<T>)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
                UpdateState = function(thisWidget: Types.Input<T>)
                    local Drag = thisWidget.Instance :: Frame

                    local widget = thisWidget :: any
                    for index = 1, components do
                        local state: Types.State<T> = thisWidget.state.number
                        if dataType == "Color3" or dataType == "Color4" then
                            state = widget.state.color
                            if index == 4 then
                                state = widget.state.transparency
                            end
                        end
                        local DragField = Drag:FindFirstChild("DragField" .. tostring(index)) :: TextButton
                        local InputField: TextBox = DragField.InputField
                        local value: number = getValueByIndex(state.value, index, thisWidget.arguments)
                        if (dataType == "Color3" or dataType == "Color4") and not widget.arguments.UseFloats then
                            value = math.round(value * 255)
                        end

                        local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                        if thisWidget.arguments.Prefix then
                            format = thisWidget.arguments.Prefix[index] .. format
                        end
                        DragField.Text = string.format(format, value)
                        InputField.Text = tostring(value)

                        if thisWidget.state.editingText.value == index then
                            InputField.Visible = true
                            InputField:CaptureFocus()
                            DragField.TextTransparency = 1
                        else
                            InputField.Visible = false
                            DragField.TextTransparency = Iris._config.TextTransparency
                        end
                    end

                    if dataType == "Color3" or dataType == "Color4" then
                        local ColorBox: ImageLabel = Drag.ColorBox

                        ColorBox.BackgroundColor3 = widget.state.color.value

                        if dataType == "Color4" then
                            ColorBox.ImageTransparency = 1 - widget.state.transparency.value
                        end
                    end
                end,
            }
        end

        function generateColorDragScalar(dataType: InputDataTypes, ...: any)
            local defaultValues: { any } = { ... }
            local input: Types.WidgetClass = generateDragScalar(dataType, dataType == "Color4" and 4 or 3, defaultValues[1])

            return widgets.extend(input, {
                Args = {
                    ["Text"] = 1,
                    ["UseFloats"] = 2,
                    ["UseHSV"] = 3,
                    ["Format"] = 4,
                },
                Update = function(thisWidget: Types.InputColor4)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Drag {dataType}`

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        if thisWidget.arguments.UseFloats then
                            thisWidget.arguments.Format = { "%.3f" }
                        else
                            thisWidget.arguments.Format = { "%d" }
                        end

                        thisWidget.arguments.Prefix = defaultPrefx[dataType .. if thisWidget.arguments.UseHSV then "_HSV" else "_RGB"]
                    end

                    thisWidget.arguments.Min = { 0, 0, 0, 0 }
                    thisWidget.arguments.Max = { 1, 1, 1, 1 }
                    thisWidget.arguments.Increment = { 0.001, 0.001, 0.001, 0.001 }

                    -- since the state values have changed display, we call an update. The check is because state is not
                    -- initialised on creation, so it would error otherwise.
                    if thisWidget.state then
                        Iris._widgets[thisWidget.type].UpdateState(thisWidget)
                    end
                end,
                GenerateState = function(thisWidget: Types.InputColor4)
                    if thisWidget.state.color == nil then
                        thisWidget.state.color = Iris._widgetState(thisWidget, "color", defaultValues[1])
                    end
                    if dataType == "Color4" then
                        if thisWidget.state.transparency == nil then
                            thisWidget.state.transparency = Iris._widgetState(thisWidget, "transparency", defaultValues[2])
                        end
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
            })
        end
    end

    --[[
        Slider
    ]]
    local generateSliderScalar: <T>(dataType: InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
    local generateEnumSliderScalar: (enum: Enum, item: EnumItem) -> Types.WidgetClass
    do
        local AnyActiveSlider: boolean = false
        local ActiveSlider: Types.Input<Types.InputDataType>? = nil
        local ActiveIndex: number = 0
        local ActiveDataType: InputDataTypes | "" = ""

        local function updateActiveSlider()
            if AnyActiveSlider == false then
                return
            end
            if ActiveSlider == nil then
                return
            end

            local Slider = ActiveSlider.Instance :: Frame
            local SliderField = Slider:FindFirstChild("SliderField" .. tostring(ActiveIndex)) :: TextButton
            local GrabBar: Frame = SliderField.GrabBar

            local increment: number = ActiveSlider.arguments.Increment and getValueByIndex(ActiveSlider.arguments.Increment, ActiveIndex, ActiveSlider.arguments) or defaultIncrements[ActiveDataType][ActiveIndex]
            local min: number = ActiveSlider.arguments.Min and getValueByIndex(ActiveSlider.arguments.Min, ActiveIndex, ActiveSlider.arguments) or defaultMin[ActiveDataType][ActiveIndex]
            local max: number = ActiveSlider.arguments.Max and getValueByIndex(ActiveSlider.arguments.Max, ActiveIndex, ActiveSlider.arguments) or defaultMax[ActiveDataType][ActiveIndex]

            local GrabWidth: number = GrabBar.AbsoluteSize.X
            local Offset: number = widgets.getMouseLocation().X - (SliderField.AbsolutePosition.X - widgets.GuiOffset.X + GrabWidth / 2)
            local Ratio: number = Offset / (SliderField.AbsoluteSize.X - GrabWidth)
            local Positions: number = math.floor((max - min) / increment)
            local newValue: number = math.clamp(math.round(Ratio * Positions) * increment + min, min, max)

            ActiveSlider.state.number:set(updateValueByIndex(ActiveSlider.state.number.value, ActiveIndex, newValue, ActiveSlider.arguments :: any))
            ActiveSlider.lastNumberChangedTick = Iris._cycleTick + 1
        end

        local function SliderMouseDown(thisWidget: Types.Input<Types.InputDataType>, dataType: InputDataTypes, index: number)
            local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
            if isCtrlHeld then
                thisWidget.state.editingText:set(index)
            else
                AnyActiveSlider = true
                ActiveSlider = thisWidget
                ActiveIndex = index
                ActiveDataType = dataType
                updateActiveSlider()
            end
        end

        widgets.registerEvent("InputChanged", function()
            if not Iris._started then
                return
            end
            updateActiveSlider()
        end)

        widgets.registerEvent("InputEnded", function(inputObject: InputObject)
            if not Iris._started then
                return
            end
            if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and AnyActiveSlider then
                AnyActiveSlider = false
                ActiveSlider = nil
                ActiveIndex = 0
                ActiveDataType = ""
            end
        end)

        function generateSliderScalar<T>(dataType: InputDataTypes, components: number, defaultValue: any)
            return {
                hasState = true,
                hasChildren = false,
                Args = {
                    ["Text"] = 1,
                    ["Increment"] = 2,
                    ["Min"] = 3,
                    ["Max"] = 4,
                    ["Format"] = 5,
                },
                Events = {
                    ["numberChanged"] = numberChanged,
                    ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                        return thisWidget.Instance
                    end),
                },
                Generate = function(thisWidget: Types.Input<T>)
                    local Slider: Frame = Instance.new("Frame")
                    Slider.Name = "Iris_Slider" .. dataType
                    Slider.Size = UDim2.fromScale(1, 0)
                    Slider.BackgroundTransparency = 1
                    Slider.BorderSizePixel = 0
                    Slider.LayoutOrder = thisWidget.ZIndex
                    Slider.AutomaticSize = Enum.AutomaticSize.Y
                    local UIListLayout: UIListLayout = widgets.UIListLayout(Slider, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
                    UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                    -- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
                    -- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
                    -- 4 pixels shorter, all for the sake of flush.
                    local componentWidth: UDim = UDim.new(Iris._config.ContentWidth.Scale / components, (Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1))) / components)
                    local totalWidth: UDim = UDim.new(componentWidth.Scale * (components - 1), (componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)))
                    local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

                    for index = 1, components do
                        local SliderField: TextButton = Instance.new("TextButton")
                        SliderField.Name = "SliderField" .. tostring(index)
                        SliderField.LayoutOrder = index
                        if index == components then
                            SliderField.Size = UDim2.new(lastComponentWidth, Iris._config.ContentHeight)
                        else
                            SliderField.Size = UDim2.new(componentWidth, Iris._config.ContentHeight)
                        end
                        SliderField.AutomaticSize = Enum.AutomaticSize.Y
                        SliderField.BackgroundColor3 = Iris._config.FrameBgColor
                        SliderField.BackgroundTransparency = Iris._config.FrameBgTransparency
                        SliderField.AutoButtonColor = false
                        SliderField.Text = ""
                        SliderField.ClipsDescendants = true

                        widgets.applyFrameStyle(SliderField)
                        widgets.applyTextStyle(SliderField)
                        widgets.UISizeConstraint(SliderField, Vector2.xAxis)

                        SliderField.Parent = Slider

                        local OverlayText = Instance.new("TextLabel")
                        OverlayText.Name = "OverlayText"
                        OverlayText.Size = UDim2.fromScale(1, 1)
                        OverlayText.BackgroundTransparency = 1
                        OverlayText.BorderSizePixel = 0
                        OverlayText.ZIndex = 10
                        OverlayText.ClipsDescendants = true

                        widgets.applyTextStyle(OverlayText)

                        OverlayText.TextXAlignment = Enum.TextXAlignment.Center

                        OverlayText.Parent = SliderField

                        widgets.applyInteractionHighlights("Background", SliderField, SliderField, {
                            Color = Iris._config.FrameBgColor,
                            Transparency = Iris._config.FrameBgTransparency,
                            HoveredColor = Iris._config.FrameBgHoveredColor,
                            HoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                            ActiveColor = Iris._config.FrameBgActiveColor,
                            ActiveTransparency = Iris._config.FrameBgActiveTransparency,
                        })

                        local InputField: TextBox = Instance.new("TextBox")
                        InputField.Name = "InputField"
                        InputField.Size = UDim2.new(1, 0, 1, 0)
                        InputField.BackgroundTransparency = 1
                        InputField.ClearTextOnFocus = false
                        InputField.TextTruncate = Enum.TextTruncate.AtEnd
                        InputField.ClipsDescendants = true
                        InputField.Visible = false

                        widgets.applyFrameStyle(InputField, true)
                        widgets.applyTextStyle(InputField)

                        InputField.Parent = SliderField

                        InputField.FocusLost:Connect(function()
                            local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
                            if newValue ~= nil then
                                if thisWidget.arguments.Min ~= nil then
                                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
                                end
                                if thisWidget.arguments.Max ~= nil then
                                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments))
                                end

                                if thisWidget.arguments.Increment then
                                    newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)) * getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                end

                                thisWidget.state.number:set(updateValueByIndex(thisWidget.state.number.value, index, newValue, thisWidget.arguments :: any))
                                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
                            end

                            local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                            if thisWidget.arguments.Prefix then
                                format = thisWidget.arguments.Prefix[index] .. format
                            end

                            InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))

                            thisWidget.state.editingText:set(0)
                            InputField:ReleaseFocus(true)
                        end)

                        InputField.Focused:Connect(function()
                            -- this highlights the entire field
                            InputField.CursorPosition = #InputField.Text + 1
                            InputField.SelectionStart = 1

                            thisWidget.state.editingText:set(index)
                        end)

                        widgets.applyButtonDown(SliderField, function()
                            SliderMouseDown(thisWidget :: any, dataType, index)
                        end)

                        local GrabBar: Frame = Instance.new("Frame")
                        GrabBar.Name = "GrabBar"
                        GrabBar.ZIndex = 5
                        GrabBar.AnchorPoint = Vector2.new(0.5, 0.5)
                        GrabBar.Position = UDim2.new(0, 0, 0.5, 0)
                        GrabBar.BorderSizePixel = 0
                        GrabBar.BackgroundColor3 = Iris._config.SliderGrabColor
                        GrabBar.Transparency = Iris._config.SliderGrabTransparency
                        if Iris._config.GrabRounding > 0 then
                            widgets.UICorner(GrabBar, Iris._config.GrabRounding)
                        end

                        widgets.UISizeConstraint(GrabBar, Vector2.new(Iris._config.GrabMinSize, 0))

                        GrabBar.Parent = SliderField
                    end

                    local TextLabel: TextLabel = Instance.new("TextLabel")
                    TextLabel.Name = "TextLabel"
                    TextLabel.BackgroundTransparency = 1
                    TextLabel.BorderSizePixel = 0
                    TextLabel.LayoutOrder = 5
                    TextLabel.AutomaticSize = Enum.AutomaticSize.XY

                    widgets.applyTextStyle(TextLabel)

                    TextLabel.Parent = Slider

                    return Slider
                end,
                Update = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Slider {dataType}`

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        -- we calculate the format for the s.f. using the max, min and increment arguments.
                        local format: { string } = {}
                        for index = 1, components do
                            local sigfigs: number = defaultSigFigs[dataType][index]

                            if thisWidget.arguments.Increment then
                                local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Max then
                                local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Min then
                                local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if sigfigs > 0 then
                                -- we know it's a float.
                                format[index] = `%.{sigfigs}f`
                            else
                                format[index] = "%d"
                            end
                        end

                        thisWidget.arguments.Format = format
                        thisWidget.arguments.Prefix = defaultPrefx[dataType]
                    end

                    for index = 1, components do
                        local SliderField = Input:FindFirstChild("SliderField" .. tostring(index)) :: TextButton
                        local GrabBar: Frame = SliderField.GrabBar

                        local increment: number = thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments) or defaultIncrements[dataType][index]
                        local min: number = thisWidget.arguments.Min and getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments) or defaultMin[dataType][index]
                        local max: number = thisWidget.arguments.Max and getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments) or defaultMax[dataType][index]

                        local grabScaleSize: number = 1 / math.floor((1 + max - min) / increment)

                        GrabBar.Size = UDim2.new(grabScaleSize, 0, 1, 0)
                    end

                    local callbackIndex: number = #Iris._postCycleCallbacks + 1
                    local desiredCycleTick: number = Iris._cycleTick + 1
                    Iris._postCycleCallbacks[callbackIndex] = function()
                        if Iris._cycleTick >= desiredCycleTick then
                            if thisWidget.lastCycleTick ~= -1 then
                                Iris._widgets[`Slider{dataType}`].UpdateState(thisWidget)
                            end
                            Iris._postCycleCallbacks[callbackIndex] = nil
                        end
                    end
                end,
                Discard = function(thisWidget: Types.Input<T>)
                    thisWidget.Instance:Destroy()
                    widgets.discardState(thisWidget)
                end,
                GenerateState = function(thisWidget: Types.Input<T>)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
                UpdateState = function(thisWidget: Types.Input<T>)
                    local Slider = thisWidget.Instance :: Frame

                    for index = 1, components do
                        local SliderField = Slider:FindFirstChild("SliderField" .. tostring(index)) :: TextButton
                        local InputField: TextBox = SliderField.InputField
                        local OverlayText: TextLabel = SliderField.OverlayText
                        local GrabBar: Frame = SliderField.GrabBar

                        local value: number = getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments)
                        local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                        if thisWidget.arguments.Prefix then
                            format = thisWidget.arguments.Prefix[index] .. format
                        end

                        OverlayText.Text = string.format(format, value)
                        InputField.Text = tostring(value)

                        local increment: number = thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments) or defaultIncrements[dataType][index]
                        local min: number = thisWidget.arguments.Min and getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments) or defaultMin[dataType][index]
                        local max: number = thisWidget.arguments.Max and getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments) or defaultMax[dataType][index]

                        local SliderWidth: number = SliderField.AbsoluteSize.X
                        local PaddedWidth: number = SliderWidth - GrabBar.AbsoluteSize.X
                        local Ratio: number = (value - min) / (max - min)
                        local Positions: number = math.floor((max - min) / increment)
                        local ClampedRatio: number = math.clamp(math.floor((Ratio * Positions)) / Positions, 0, 1)
                        local PaddedRatio: number = ((PaddedWidth / SliderWidth) * ClampedRatio) + ((1 - (PaddedWidth / SliderWidth)) / 2)

                        GrabBar.Position = UDim2.new(PaddedRatio, 0, 0.5, 0)

                        if thisWidget.state.editingText.value == index then
                            InputField.Visible = true
                            OverlayText.Visible = false
                            GrabBar.Visible = false
                            InputField:CaptureFocus()
                        else
                            InputField.Visible = false
                            OverlayText.Visible = true
                            GrabBar.Visible = true
                        end
                    end
                end,
            }
        end

        function generateEnumSliderScalar(enum: Enum, item: EnumItem)
            local input: Types.WidgetClass = generateSliderScalar("Enum", 1, item.Value)
            local valueToName = { string }

            for _, enumItem: EnumItem in enum:GetEnumItems() do
                valueToName[enumItem.Value] = enumItem.Name
            end

            return widgets.extend(input, {
                Args = {
                    ["Text"] = 1,
                },
                Update = function(thisWidget: Types.InputEnum)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or "Input Enum"

                    thisWidget.arguments.Increment = 1
                    thisWidget.arguments.Min = 0
                    thisWidget.arguments.Max = #enum:GetEnumItems() - 1

                    local SliderField = Input:FindFirstChild("SliderField1") :: TextButton
                    local GrabBar: Frame = SliderField.GrabBar

                    local grabScaleSize: number = 1 / math.floor(#enum:GetEnumItems())

                    GrabBar.Size = UDim2.new(grabScaleSize, 0, 1, 0)
                end,
                GenerateState = function(thisWidget: Types.InputEnum)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", item.Value)
                    end
                    if thisWidget.state.enumItem == nil then
                        thisWidget.state.enumItem = Iris._widgetState(thisWidget, "enumItem", item)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
            })
        end
    end

    do
        local inputNum: Types.WidgetClass = generateInputScalar("Num", 1, 0)
        inputNum.Args["NoButtons"] = 6
        Iris.WidgetConstructor("InputNum", inputNum)
    end
    Iris.WidgetConstructor("InputVector2", generateInputScalar("Vector2", 2, Vector2.zero))
    Iris.WidgetConstructor("InputVector3", generateInputScalar("Vector3", 3, Vector3.zero))
    Iris.WidgetConstructor("InputUDim", generateInputScalar("UDim", 2, UDim.new()))
    Iris.WidgetConstructor("InputUDim2", generateInputScalar("UDim2", 4, UDim2.new()))
    Iris.WidgetConstructor("InputRect", generateInputScalar("Rect", 4, Rect.new(0, 0, 0, 0)))

    Iris.WidgetConstructor("DragNum", generateDragScalar("Num", 1, 0))
    Iris.WidgetConstructor("DragVector2", generateDragScalar("Vector2", 2, Vector2.zero))
    Iris.WidgetConstructor("DragVector3", generateDragScalar("Vector3", 3, Vector3.zero))
    Iris.WidgetConstructor("DragUDim", generateDragScalar("UDim", 2, UDim.new()))
    Iris.WidgetConstructor("DragUDim2", generateDragScalar("UDim2", 4, UDim2.new()))
    Iris.WidgetConstructor("DragRect", generateDragScalar("Rect", 4, Rect.new(0, 0, 0, 0)))

    Iris.WidgetConstructor("InputColor3", generateColorDragScalar("Color3", Color3.fromRGB(0, 0, 0)))
    Iris.WidgetConstructor("InputColor4", generateColorDragScalar("Color4", Color3.fromRGB(0, 0, 0), 0))

    Iris.WidgetConstructor("SliderNum", generateSliderScalar("Num", 1, 0))
    Iris.WidgetConstructor("SliderVector2", generateSliderScalar("Vector2", 2, Vector2.zero))
    Iris.WidgetConstructor("SliderVector3", generateSliderScalar("Vector3", 3, Vector3.zero))
    Iris.WidgetConstructor("SliderUDim", generateSliderScalar("UDim", 2, UDim.new()))
    Iris.WidgetConstructor("SliderUDim2", generateSliderScalar("UDim2", 4, UDim2.new()))
    Iris.WidgetConstructor("SliderRect", generateSliderScalar("Rect", 4, Rect.new(0, 0, 0, 0)))
    -- Iris.WidgetConstructor("SliderEnum", generateSliderScalar("Enum", 4, 0))

    -- stylua: ignore
    Iris.WidgetConstructor("InputText", {
        hasState = true,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
            ["TextHint"] = 2,
            ["ReadOnly"] = 3,
            ["MultiLine"] = 4,
        },
        Events = {
            ["textChanged"] = {
                ["Init"] = function(thisWidget: Types.InputText)
                    thisWidget.lastTextChangedTick = 0
                end,
                ["Get"] = function(thisWidget: Types.InputText)
                    return thisWidget.lastTextChangedTick == Iris._cycleTick
                end,
            },
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.InputText)
            local InputText: Frame = Instance.new("Frame")
            InputText.Name = "Iris_InputText"
            InputText.AutomaticSize = Enum.AutomaticSize.Y
            InputText.Size = UDim2.fromScale(1, 0)
            InputText.BackgroundTransparency = 1
            InputText.BorderSizePixel = 0
            InputText.ZIndex = thisWidget.ZIndex
            InputText.LayoutOrder = thisWidget.ZIndex
            local UIListLayout: UIListLayout = widgets.UIListLayout(InputText, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
            UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

            local InputField: TextBox = Instance.new("TextBox")
            InputField.Name = "InputField"
            InputField.Size = UDim2.new(Iris._config.ContentWidth, Iris._config.ContentHeight)
            InputField.AutomaticSize = Enum.AutomaticSize.Y
            InputField.BackgroundColor3 = Iris._config.FrameBgColor
            InputField.BackgroundTransparency = Iris._config.FrameBgTransparency
            InputField.Text = ""
            InputField.TextYAlignment = Enum.TextYAlignment.Top
            InputField.PlaceholderColor3 = Iris._config.TextDisabledColor
            InputField.ClearTextOnFocus = false
            InputField.ClipsDescendants = true

            widgets.applyFrameStyle(InputField)
            widgets.applyTextStyle(InputField)
            widgets.UISizeConstraint(InputField, Vector2.xAxis) -- prevents sizes beaking when getting too small.
            -- InputField.UIPadding.PaddingLeft = UDim.new(0, Iris._config.ItemInnerSpacing.X)
            -- InputField.UIPadding.PaddingRight = UDim.new(0, 0)
            InputField.Parent = InputText

            InputField.FocusLost:Connect(function()
                thisWidget.state.text:set(InputField.Text)
                thisWidget.lastTextChangedTick = Iris._cycleTick + 1
            end)

            local frameHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            TextLabel.Size = UDim2.fromOffset(0, frameHeight)
            TextLabel.AutomaticSize = Enum.AutomaticSize.X
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0
            TextLabel.LayoutOrder = 1

            widgets.applyTextStyle(TextLabel)

            TextLabel.Parent = InputText

            return InputText
        end,
        Update = function(thisWidget: Types.InputText)
            local InputText = thisWidget.Instance :: Frame
            local TextLabel: TextLabel = InputText.TextLabel
            local InputField: TextBox = InputText.InputField

            TextLabel.Text = thisWidget.arguments.Text or "Input Text"
            InputField.PlaceholderText = thisWidget.arguments.TextHint or ""
            InputField.TextEditable = not thisWidget.arguments.ReadOnly
            InputField.MultiLine = thisWidget.arguments.MultiLine or false
        end,
        Discard = function(thisWidget: Types.InputText)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
        GenerateState = function(thisWidget: Types.InputText)
            if thisWidget.state.text == nil then
                thisWidget.state.text = Iris._widgetState(thisWidget, "text", "")
            end
        end,
        UpdateState = function(thisWidget: Types.InputText)
            local InputText = thisWidget.Instance :: Frame
            local InputField: TextBox = InputText.InputField

            InputField.Text = thisWidget.state.text.value
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Input

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Menu | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local AnyMenuOpen: boolean = false
    local ActiveMenu: Types.Menu? = nil
    local MenuStack: { Types.Menu } = {}

    local function EmptyMenuStack(menuIndex: number?)
        for index = #MenuStack, menuIndex and menuIndex + 1 or 1, -1 do
            local widget: Types.Menu = MenuStack[index]
            widget.state.isOpened:set(false)

            widget.Instance.BackgroundColor3 = Iris._config.HeaderColor
            widget.Instance.BackgroundTransparency = 1

            table.remove(MenuStack, index)
        end

        if #MenuStack == 0 then
            AnyMenuOpen = false
            ActiveMenu = nil
        end
    end

    local function UpdateChildContainerTransform(thisWidget: Types.Menu)
        local submenu: boolean = thisWidget.parentWidget.type == "Menu"

        local Menu = thisWidget.Instance :: Frame
        local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame
        ChildContainer.Size = UDim2.fromOffset(Menu.AbsoluteSize.X, 0)
        if ChildContainer.Parent == nil then
            return
        end

        local menuPosition: Vector2 = Menu.AbsolutePosition - widgets.GuiOffset
        local menuSize: Vector2 = Menu.AbsoluteSize
        local containerSize: Vector2 = ChildContainer.AbsoluteSize
        local borderSize: number = Iris._config.PopupBorderSize
        local screenSize: Vector2 = ChildContainer.Parent.AbsoluteSize

        local x: number = menuPosition.X
        local y: number
        local anchor: Vector2 = Vector2.zero

        if submenu then
            if menuPosition.X + containerSize.X > screenSize.X then
                anchor = Vector2.xAxis
            else
                x = menuPosition.X + menuSize.X
            end
        end

        if menuPosition.Y + containerSize.Y > screenSize.Y then
            -- too low.
            y = menuPosition.Y - borderSize + (submenu and menuSize.Y or 0)
            anchor += Vector2.yAxis
        else
            y = menuPosition.Y + borderSize + (submenu and 0 or menuSize.Y)
        end

        ChildContainer.Position = UDim2.fromOffset(x, y)
        ChildContainer.AnchorPoint = anchor
    end

    widgets.registerEvent("InputBegan", function(inputObject: InputObject)
        if not Iris._started then
            return
        end
        if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and inputObject.UserInputType ~= Enum.UserInputType.MouseButton2 then
            return
        end
        if AnyMenuOpen == false then
            return
        end
        if ActiveMenu == nil then
            return
        end

        -- this only checks if we clicked outside all the menus. If we clicked in any menu, then the hover function handles this.
        local isInMenu: boolean = false
        local MouseLocation: Vector2 = widgets.getMouseLocation()
        for _, menu: Types.Menu in MenuStack do
            for _, container: GuiObject in { menu.ChildContainer, menu.Instance } do
                local rectMin: Vector2 = container.AbsolutePosition - widgets.GuiOffset
                local rectMax: Vector2 = rectMin + container.AbsoluteSize
                if widgets.isPosInsideRect(MouseLocation, rectMin, rectMax) then
                    isInMenu = true
                    break
                end
            end
            if isInMenu then
                break
            end
        end

        if not isInMenu then
            EmptyMenuStack()
        end
    end)

    --stylua: ignore
    Iris.WidgetConstructor("MenuBar", {
        hasState = false,
        hasChildren = true,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.MenuBar)
            local MenuBar: Frame = Instance.new("Frame")
            MenuBar.Name = "MenuBar"
            MenuBar.Size = UDim2.fromScale(1, 0)
            MenuBar.AutomaticSize = Enum.AutomaticSize.Y
            MenuBar.BackgroundColor3 = Iris._config.MenubarBgColor
            MenuBar.BackgroundTransparency = Iris._config.MenubarBgTransparency
            MenuBar.BorderSizePixel = 0
            MenuBar.LayoutOrder = thisWidget.ZIndex
            MenuBar.ClipsDescendants = true

            widgets.UIPadding(MenuBar, Vector2.new(Iris._config.WindowPadding.X, 1))
            widgets.UIListLayout(MenuBar, Enum.FillDirection.Horizontal, UDim.new()).VerticalAlignment = Enum.VerticalAlignment.Center
            widgets.applyFrameStyle(MenuBar, true, true)

            return MenuBar
        end,
        Update = function()
            
        end,
        ChildAdded = function(thisWidget: Types.MenuBar, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
        Discard = function(thisWidget: Types.MenuBar)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("Menu", {
        hasState = true,
        hasChildren = true,
        Args = {
            ["Text"] = 1,
        },
        Events = {
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["opened"] = {
                ["Init"] = function(_thisWidget: Types.Menu) end,
                ["Get"] = function(thisWidget: Types.Menu)
                    return thisWidget.lastOpenedTick == Iris._cycleTick
                end,
            },
            ["closed"] = {
                ["Init"] = function(_thisWidget: Types.Menu) end,
                ["Get"] = function(thisWidget: Types.Menu)
                    return thisWidget.lastClosedTick == Iris._cycleTick
                end,
            },
        },
        Generate = function(thisWidget: Types.Menu)
            local Menu: TextButton
            thisWidget.ButtonColors = {
                Color = Iris._config.HeaderColor,
                Transparency = 1,
                HoveredColor = Iris._config.HeaderHoveredColor,
                HoveredTransparency = Iris._config.HeaderHoveredTransparency,
                ActiveColor = Iris._config.HeaderHoveredColor,
                ActiveTransparency = Iris._config.HeaderHoveredTransparency,
            }
            if thisWidget.parentWidget.type == "Menu" then
                -- this Menu is a sub-Menu
                Menu = Instance.new("TextButton")
                Menu.Name = "Menu"
                Menu.BackgroundColor3 = Iris._config.HeaderColor
                Menu.BackgroundTransparency = 1
                Menu.BorderSizePixel = 0
                Menu.Size = UDim2.fromScale(1, 0)
                Menu.Text = ""
                Menu.AutomaticSize = Enum.AutomaticSize.Y
                Menu.LayoutOrder = thisWidget.ZIndex
                Menu.AutoButtonColor = false

                local UIPadding = widgets.UIPadding(Menu, Iris._config.FramePadding)
                UIPadding.PaddingTop = UIPadding.PaddingTop - UDim.new(0, 1)
                widgets.UIListLayout(Menu, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X)).VerticalAlignment = Enum.VerticalAlignment.Center

                local TextLabel: TextLabel = Instance.new("TextLabel")
                TextLabel.Name = "TextLabel"
                TextLabel.BackgroundTransparency = 1
                TextLabel.BorderSizePixel = 0
                TextLabel.AutomaticSize = Enum.AutomaticSize.XY

                widgets.applyTextStyle(TextLabel)

                TextLabel.Parent = Menu

                local frameSize: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y
                local padding: number = math.round(0.2 * frameSize)
                local iconSize: number = frameSize - 2 * padding

                local Icon: ImageLabel = Instance.new("ImageLabel")
                Icon.Name = "Icon"
                Icon.Size = UDim2.fromOffset(iconSize, iconSize)
                Icon.BackgroundTransparency = 1
                Icon.BorderSizePixel = 0
                Icon.ImageColor3 = Iris._config.TextColor
                Icon.ImageTransparency = Iris._config.TextTransparency
                Icon.Image = widgets.ICONS.RIGHT_POINTING_TRIANGLE
                Icon.LayoutOrder = 1

                Icon.Parent = Menu
            else
                Menu = Instance.new("TextButton")
                Menu.Name = "Menu"
                Menu.AutomaticSize = Enum.AutomaticSize.XY
                Menu.Size = UDim2.fromScale(0, 0)
                Menu.BackgroundColor3 = Iris._config.HeaderColor
                Menu.BackgroundTransparency = 1
                Menu.BorderSizePixel = 0
                Menu.Text = ""
                Menu.LayoutOrder = thisWidget.ZIndex
                Menu.AutoButtonColor = false
                Menu.ClipsDescendants = true

                widgets.applyTextStyle(Menu)
                widgets.UIPadding(Menu, Vector2.new(Iris._config.ItemSpacing.X, Iris._config.FramePadding.Y))
            end
            widgets.applyInteractionHighlights("Background", Menu, Menu, thisWidget.ButtonColors)

            widgets.applyButtonClick(Menu, function()
                local openMenu: boolean = if #MenuStack <= 1 then not thisWidget.state.isOpened.value else true
                thisWidget.state.isOpened:set(openMenu)

                AnyMenuOpen = openMenu
                ActiveMenu = openMenu and thisWidget or nil
                -- the hovering should handle all of the menus after the first one.
                if #MenuStack <= 1 then
                    if openMenu then
                        table.insert(MenuStack, thisWidget)
                    else
                        table.remove(MenuStack)
                    end
                end
            end)

            widgets.applyMouseEnter(Menu, function()
                if AnyMenuOpen and ActiveMenu and ActiveMenu ~= thisWidget then
                    local parentMenu = thisWidget.parentWidget :: Types.Menu
                    local parentIndex: number? = table.find(MenuStack, parentMenu)

                    EmptyMenuStack(parentIndex)
                    thisWidget.state.isOpened:set(true)
                    ActiveMenu = thisWidget
                    AnyMenuOpen = true
                    table.insert(MenuStack, thisWidget)
                end
            end)

            local ChildContainer: ScrollingFrame = Instance.new("ScrollingFrame")
            ChildContainer.Name = "MenuContainer"
            ChildContainer.BackgroundColor3 = Iris._config.PopupBgColor
            ChildContainer.BackgroundTransparency = Iris._config.PopupBgTransparency
            ChildContainer.BorderSizePixel = 0
            ChildContainer.Size = UDim2.fromOffset(0, 0)
            ChildContainer.AutomaticSize = Enum.AutomaticSize.XY

            ChildContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
            ChildContainer.ScrollBarImageTransparency = Iris._config.ScrollbarGrabTransparency
            ChildContainer.ScrollBarImageColor3 = Iris._config.ScrollbarGrabColor
            ChildContainer.ScrollBarThickness = Iris._config.ScrollbarSize
            ChildContainer.CanvasSize = UDim2.fromScale(0, 0)
            ChildContainer.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar

            ChildContainer.ZIndex = 6
            ChildContainer.LayoutOrder = 6
            ChildContainer.ClipsDescendants = true

            -- Unfortunatley, ScrollingFrame does not work with UICorner
            -- if Iris._config.PopupRounding > 0 then
            --     widgets.UICorner(ChildContainer, Iris._config.PopupRounding)
            -- end

            widgets.UIStroke(ChildContainer, Iris._config.WindowBorderSize, Iris._config.BorderColor, Iris._config.BorderTransparency)
            widgets.UIPadding(ChildContainer, Vector2.new(2, Iris._config.WindowPadding.Y - Iris._config.ItemSpacing.Y))
            
            local ChildContainerUIListLayout: UIListLayout = widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, 1))
            ChildContainerUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top

            local RootPopupScreenGui = Iris._rootInstance and Iris._rootInstance:FindFirstChild("PopupScreenGui") :: GuiObject
            ChildContainer.Parent = RootPopupScreenGui
            
            
            thisWidget.ChildContainer = ChildContainer
            return Menu
        end,
        Update = function(thisWidget: Types.Menu)
            local Menu = thisWidget.Instance :: TextButton
            local TextLabel: TextLabel
            if thisWidget.parentWidget.type == "Menu" then
                TextLabel = Menu.TextLabel
            else
                TextLabel = Menu
            end
            TextLabel.Text = thisWidget.arguments.Text or "Menu"
        end,
        ChildAdded = function(thisWidget: Types.Menu, _thisChild: Types.Widget)
            UpdateChildContainerTransform(thisWidget)
            return thisWidget.ChildContainer
        end,
        ChildDiscarded = function(thisWidget: Types.Menu, _thisChild: Types.Widget)
            UpdateChildContainerTransform(thisWidget)
        end,
        GenerateState = function(thisWidget: Types.Menu)
            if thisWidget.state.isOpened == nil then
                thisWidget.state.isOpened = Iris._widgetState(thisWidget, "isOpened", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Menu)
            local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame

            if thisWidget.state.isOpened.value then
                thisWidget.lastOpenedTick = Iris._cycleTick + 1
                thisWidget.ButtonColors.Transparency = Iris._config.HeaderTransparency
                ChildContainer.Visible = true

                UpdateChildContainerTransform(thisWidget)
            else
                thisWidget.lastClosedTick = Iris._cycleTick + 1
                thisWidget.ButtonColors.Transparency = 1
                ChildContainer.Visible = false
            end
        end,
        Discard = function(thisWidget: Types.Menu)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("MenuItem", {
        hasState = false,
        hasChildren = false,
        Args = {
            Text = 1,
            KeyCode = 2,
            ModifierKey = 3,
        },
        Events = {
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.MenuItem)
            local MenuItem: TextButton = Instance.new("TextButton")
            MenuItem.Name = "MenuItem"
            MenuItem.BackgroundTransparency = 1
            MenuItem.BorderSizePixel = 0
            MenuItem.Size = UDim2.fromScale(1, 0)
            MenuItem.Text = ""
            MenuItem.AutomaticSize = Enum.AutomaticSize.Y
            MenuItem.LayoutOrder = thisWidget.ZIndex
            MenuItem.AutoButtonColor = false

            local UIPadding = widgets.UIPadding(MenuItem, Iris._config.FramePadding)
            UIPadding.PaddingTop = UIPadding.PaddingTop - UDim.new(0, 1)
            widgets.UIListLayout(MenuItem, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))

            widgets.applyInteractionHighlights("Background", MenuItem, MenuItem, {
                Color = Iris._config.HeaderColor,
                Transparency = 1,
                HoveredColor = Iris._config.HeaderHoveredColor,
                HoveredTransparency = Iris._config.HeaderHoveredTransparency,
                ActiveColor = Iris._config.HeaderHoveredColor,
                ActiveTransparency = Iris._config.HeaderHoveredTransparency,
            })

            widgets.applyButtonClick(MenuItem, function()
                EmptyMenuStack()
            end)

            widgets.applyMouseEnter(MenuItem, function()
                local parentMenu = thisWidget.parentWidget :: Types.Menu
                if AnyMenuOpen and ActiveMenu and ActiveMenu ~= parentMenu then
                    local parentIndex: number? = table.find(MenuStack, parentMenu)

                    EmptyMenuStack(parentIndex)
                    ActiveMenu = parentMenu
                    AnyMenuOpen = true
                end
            end)

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0
            TextLabel.AutomaticSize = Enum.AutomaticSize.XY

            widgets.applyTextStyle(TextLabel)

            TextLabel.Parent = MenuItem

            local Shortcut: TextLabel = Instance.new("TextLabel")
            Shortcut.Name = "Shortcut"
            Shortcut.BackgroundTransparency = 1
            Shortcut.BorderSizePixel = 0
            Shortcut.LayoutOrder = 1
            Shortcut.AutomaticSize = Enum.AutomaticSize.XY

            widgets.applyTextStyle(Shortcut)

            Shortcut.Text = ""
            Shortcut.TextColor3 = Iris._config.TextDisabledColor
            Shortcut.TextTransparency = Iris._config.TextDisabledTransparency

            Shortcut.Parent = MenuItem

            return MenuItem
        end,
        Update = function(thisWidget: Types.MenuItem)
            local MenuItem = thisWidget.Instance :: TextButton
            local TextLabel: TextLabel = MenuItem.TextLabel
            local Shortcut: TextLabel = MenuItem.Shortcut

            TextLabel.Text = thisWidget.arguments.Text
            if thisWidget.arguments.KeyCode then
				if thisWidget.arguments.ModifierKey then
					Shortcut.Text = thisWidget.arguments.ModifierKey.Name .. " + " .. thisWidget.arguments.KeyCode.Name
				else
					Shortcut.Text = thisWidget.arguments.KeyCode.Name
				end
            end
        end,
        Discard = function(thisWidget: Types.MenuItem)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("MenuToggle", {
        hasState = true,
        hasChildren = false,
        Args = {
            Text = 1,
            KeyCode = 2,
            ModifierKey = 3,
        },
        Events = {
            ["checked"] = {
                ["Init"] = function(_thisWidget: Types.MenuToggle) end,
                ["Get"] = function(thisWidget: Types.MenuToggle): boolean
                    return thisWidget.lastCheckedTick == Iris._cycleTick
                end,
            },
            ["unchecked"] = {
                ["Init"] = function(_thisWidget: Types.MenuToggle) end,
                ["Get"] = function(thisWidget: Types.MenuToggle): boolean
                    return thisWidget.lastUncheckedTick == Iris._cycleTick
                end,
            },
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.MenuToggle)
            local MenuItem: TextButton = Instance.new("TextButton")
            MenuItem.Name = "MenuItem"
            MenuItem.BackgroundTransparency = 1
            MenuItem.BorderSizePixel = 0
            MenuItem.Size = UDim2.fromScale(1, 0)
            MenuItem.Text = ""
            MenuItem.AutomaticSize = Enum.AutomaticSize.Y
            MenuItem.LayoutOrder = thisWidget.ZIndex
            MenuItem.AutoButtonColor = false

            local UIPadding = widgets.UIPadding(MenuItem, Iris._config.FramePadding)
            UIPadding.PaddingTop = UIPadding.PaddingTop - UDim.new(0, 1)
            widgets.UIListLayout(MenuItem, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X)).VerticalAlignment = Enum.VerticalAlignment.Center

            widgets.applyInteractionHighlights("Background", MenuItem, MenuItem, {
                Color = Iris._config.HeaderColor,
                Transparency = 1,
                HoveredColor = Iris._config.HeaderHoveredColor,
                HoveredTransparency = Iris._config [trimmed]  -  Edit
  18:44:46.369  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Image | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local abstractImage = {
        hasState = false,
        hasChildren = false,
        Args = {
            ["Image"] = 1,
            ["Size"] = 2,
            ["Rect"] = 3,
            ["ScaleType"] = 4,
            ["ResampleMode"] = 5,
            ["TileSize"] = 6,
            ["SliceCenter"] = 7,
            ["SliceScale"] = 8,
        },
        Discard = function(thisWidget: Types.Image)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass

	--stylua: ignore
	Iris.WidgetConstructor("Image", widgets.extend(abstractImage, {
            Events = {
                ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                    return thisWidget.Instance
                end),
            },
            Generate = function(thisWidget: Types.Image)
                local Image: ImageLabel = Instance.new("ImageLabel")
                Image.Name = "Iris_Image"
                Image.BackgroundTransparency = 1
                Image.BorderSizePixel = 0
                Image.ImageColor3 = Iris._config.ImageColor
                Image.ImageTransparency = Iris._config.ImageTransparency
                Image.LayoutOrder = thisWidget.ZIndex

                widgets.applyFrameStyle(Image, true)

                return Image
            end,
            Update = function(thisWidget: Types.Image)
                local Image = thisWidget.Instance :: ImageLabel
    
                Image.Image = thisWidget.arguments.Image or widgets.ICONS.UNKNOWN_TEXTURE
                Image.Size = thisWidget.arguments.Size
                if thisWidget.arguments.ScaleType then
                    Image.ScaleType = thisWidget.arguments.ScaleType
                    if thisWidget.arguments.ScaleType == Enum.ScaleType.Tile and thisWidget.arguments.TileSize then
                        Image.TileSize = thisWidget.arguments.TileSize
                    elseif thisWidget.arguments.ScaleType == Enum.ScaleType.Slice then
                        if thisWidget.arguments.SliceCenter then
                            Image.SliceCenter = thisWidget.arguments.SliceCenter
                        end
                        if thisWidget.arguments.SliceScale then
                            Image.SliceScale = thisWidget.arguments.SliceScale
                        end
                    end
                end
    
                if thisWidget.arguments.Rect then
                    Image.ImageRectOffset = thisWidget.arguments.Rect.Min
                    Image.ImageRectSize = Vector2.new(thisWidget.arguments.Rect.Width, thisWidget.arguments.Rect.Height)
                end
    
                if thisWidget.arguments.ResampleMode then
                    Image.ResampleMode = thisWidget.arguments.ResampleMode
                end
            end,
		} :: Types.WidgetClass)
	)

    --stylua: ignore
    Iris.WidgetConstructor("ImageButton", widgets.extend(abstractImage, {
            Events = {
                ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                    return thisWidget.Instance
                end),
                ["rightClicked"] = widgets.EVENTS.rightClick(function(thisWidget: Types.Widget)
                    return thisWidget.Instance
                end),
                ["doubleClicked"] = widgets.EVENTS.doubleClick(function(thisWidget: Types.Widget)
                    return thisWidget.Instance
                end),
                ["ctrlClicked"] = widgets.EVENTS.ctrlClick(function(thisWidget: Types.Widget)
                    return thisWidget.Instance
                end),
                ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                    return thisWidget.Instance
                end),
            },
            Generate = function(thisWidget: Types.ImageButton)
                local Button: ImageButton = Instance.new("ImageButton")
                Button.Name = "Iris_ImageButton"
                Button.AutomaticSize = Enum.AutomaticSize.XY
                Button.BackgroundColor3 = Iris._config.FrameBgColor
                Button.BackgroundTransparency = Iris._config.FrameBgTransparency
                Button.BorderSizePixel = 0
                Button.Image = ""
                Button.ImageTransparency = 1
                Button.LayoutOrder = thisWidget.ZIndex
                Button.AutoButtonColor = false
                
                widgets.applyFrameStyle(Button, true)
                widgets.UIPadding(Button, Vector2.new(Iris._config.ImageBorderSize, Iris._config.ImageBorderSize))
                
                local Image: ImageLabel = Instance.new("ImageLabel")
                Image.Name = "ImageLabel"
                Image.BackgroundTransparency = 1
                Image.BorderSizePixel = 0
                Image.ImageColor3 = Iris._config.ImageColor
                Image.ImageTransparency = Iris._config.ImageTransparency
                Image.Parent = Button

                widgets.applyInteractionHighlights("Background", Button, Button, {
                    Color = Iris._config.FrameBgColor,
                    Transparency = Iris._config.FrameBgTransparency,
                    HoveredColor = Iris._config.FrameBgHoveredColor,
                    HoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                    ActiveColor = Iris._config.FrameBgActiveColor,
                    ActiveTransparency = Iris._config.FrameBgActiveTransparency,
                })

                return Button
            end,
            Update = function(thisWidget: Types.ImageButton)
                local Button = thisWidget.Instance :: TextButton
                local Image: ImageLabel = Button.ImageLabel
    
                Image.Image = thisWidget.arguments.Image or widgets.ICONS.UNKNOWN_TEXTURE
                Image.Size = thisWidget.arguments.Size
                if thisWidget.arguments.ScaleType then
                    Image.ScaleType = thisWidget.arguments.ScaleType
                    if thisWidget.arguments.ScaleType == Enum.ScaleType.Tile and thisWidget.arguments.TileSize then
                        Image.TileSize = thisWidget.arguments.TileSize
                    elseif thisWidget.arguments.ScaleType == Enum.ScaleType.Slice then
                        if thisWidget.arguments.SliceCenter then
                            Image.SliceCenter = thisWidget.arguments.SliceCenter
                        end
                        if thisWidget.arguments.SliceScale then
                            Image.SliceScale = thisWidget.arguments.SliceScale
                        end
                    end
                end
    
                if thisWidget.arguments.Rect then
                    Image.ImageRectOffset = thisWidget.arguments.Rect.Min
                    Image.ImageRectSize = Vector2.new(thisWidget.arguments.Rect.Width, thisWidget.arguments.Rect.Height)
                end
    
                if thisWidget.arguments.ResampleMode then
                    Image.ResampleMode = thisWidget.arguments.ResampleMode
                end
            end,
        } :: Types.WidgetClass)
    )
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Image

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.WidgetTypes | Enabled: N/A
--------------------------------------------------------------------
--[=[
    @within Iris
    @type ID string
]=]
export type ID = string

--[=[
    @within State
    @type State<T> { ID: ID, value: T, get: (self) -> T, set: (self, newValue: T) -> T, onChange: (self, callback: (newValue: T) -> ()) -> (), ConnectedWidgets: { [ID]: Widget }, ConnectedFunctions: { (newValue: T) -> () } }
]=]
export type State<T> = {
    ID: ID,
    value: T,
    ConnectedWidgets: { [ID]: Widget },
    ConnectedFunctions: { (newValue: T) -> () },

    get: (self: State<T>) -> T,
    set: (self: State<T>, newValue: T) -> (),
    onChange: (self: State<T>, funcToConnect: (newValue: T) -> ()) -> () -> (),
}

--[=[
    @within Iris
    @type Widget { ID: ID, type: string, lastCycleTick: number, parentWidget: Widget, Instance: GuiObject, ZIndex: number, arguments: { [string]: any }}
]=]
export type Widget = {
    ID: ID,
    type: string,
    lastCycleTick: number,
    trackedEvents: {},
    parentWidget: ParentWidget,

    arguments: {},
    providedArguments: {},

    Instance: GuiObject,
    ZIndex: number,
}

export type ParentWidget = Widget & {
    ChildContainer: GuiObject,
    ZOffset: number,
    ZUpdate: boolean,
}

export type StateWidget = Widget & {
    state: {
        [string]: State<any>,
    },
}

-- Events

export type Hovered = {
    isHoveredEvent: boolean,
    hovered: () -> boolean,
}

export type Clicked = {
    lastClickedTick: number,
    clicked: () -> boolean,
}

export type RightClicked = {
    lastRightClickedTick: number,
    rightClicked: () -> boolean,
}

export type DoubleClicked = {
    lastClickedTime: number,
    lastClickedPosition: Vector2,
    lastDoubleClickedTick: number,
    doubleClicked: () -> boolean,
}

export type CtrlClicked = {
    lastCtrlClickedTick: number,
    ctrlClicked: () -> boolean,
}

export type Active = {
    active: () -> boolean,
}

export type Checked = {
    lastCheckedTick: number,
    checked: () -> boolean,
}

export type Unchecked = {
    lastUncheckedTick: number,
    unchecked: () -> boolean,
}

export type Opened = {
    lastOpenedTick: number,
    opened: () -> boolean,
}

export type Closed = {
    lastClosedTick: number,
    closed: () -> boolean,
}

export type Collapsed = {
    lastCollapsedTick: number,
    collapsed: () -> boolean,
}

export type Uncollapsed = {
    lastUncollapsedTick: number,
    uncollapsed: () -> boolean,
}

export type Selected = {
    lastSelectedTick: number,
    selected: () -> boolean,
}

export type Unselected = {
    lastUnselectedTick: number,
    unselected: () -> boolean,
}

export type Changed = {
    lastChangedTick: number,
    changed: () -> boolean,
}

export type NumberChanged = {
    lastNumberChangedTick: number,
    numberChanged: () -> boolean,
}

export type TextChanged = {
    lastTextChangedTick: number,
    textChanged: () -> boolean,
}

-- Widgets

-- Window

export type Root = ParentWidget

export type Window = ParentWidget & {
    usesScreenGuis: boolean,

    arguments: {
        Title: string?,
        NoTitleBar: boolean?,
        NoBackground: boolean?,
        NoCollapse: boolean?,
        NoClose: boolean?,
        NoMove: boolean?,
        NoScrollbar: boolean?,
        NoResize: boolean?,
        NoNav: boolean?,
        NoMenu: boolean?,
    },

    state: {
        size: State<Vector2>,
        position: State<Vector2>,
        isUncollapsed: State<boolean>,
        isOpened: State<boolean>,
        scrollDistance: State<number>,
    },
} & Opened & Closed & Collapsed & Uncollapsed & Hovered

export type Tooltip = Widget & {
    arguments: {
        Text: string,
    },
}

-- Menu

export type MenuBar = ParentWidget

export type Menu = ParentWidget & {
    ButtonColors: { [string]: Color3 | number },

    arguments: {
        Text: string?,
    },

    state: {
        isOpened: State<boolean>,
    },
} & Clicked & Opened & Closed & Hovered

export type MenuItem = Widget & {
    arguments: {
        Text: string,
        KeyCode: Enum.KeyCode?,
        ModifierKey: Enum.ModifierKey?,
    },
} & Clicked & Hovered

export type MenuToggle = Widget & {
    arguments: {
        Text: string,
        KeyCode: Enum.KeyCode?,
        ModifierKey: Enum.ModifierKey?,
    },

    state: {
        isChecked: State<boolean>,
    },
} & Checked & Unchecked & Hovered

-- Format

export type Separator = Widget

export type Indent = ParentWidget & {
    arguments: {
        Width: number?,
    },
}

export type SameLine = ParentWidget & {
    arguments: {
        Width: number?,
        VerticalAlignment: Enum.VerticalAlignment?,
        HorizontalAlignment: Enum.HorizontalAlignment?,
    },
}

export type Group = ParentWidget

-- Text

export type Text = Widget & {
    arguments: {
        Text: string,
        Wrapped: boolean?,
        Color: Color3?,
        RichText: boolean?,
    },
} & Hovered

export type SeparatorText = Widget & {
    arguments: {
        Text: string,
    },
} & Hovered

-- Basic

export type Button = Widget & {
    arguments: {
        Text: string?,
        Size: UDim2?,
    },
} & Clicked & RightClicked & DoubleClicked & CtrlClicked & Hovered

export type Checkbox = Widget & {
    arguments: {
        Text: string?,
    },

    state: {
        isChecked: State<boolean>,
    },
} & Unchecked & Checked & Hovered

export type RadioButton = Widget & {
    arguments: {
        Text: string?,
        Index: any,
    },

    state: {
        index: State<any>,
    },

    active: () -> boolean,
} & Selected & Unselected & Active & Hovered

-- Image

export type Image = Widget & {
    arguments: {
        Image: string,
        Size: UDim2,
        Rect: Rect?,
        ScaleType: Enum.ScaleType?,
        TileSize: UDim2?,
        SliceCenter: Rect?,
        SliceScale: number?,
        ResampleMode: Enum.ResamplerMode?,
    },
} & Hovered

export type ImageButton = Image & Clicked & RightClicked & DoubleClicked & CtrlClicked

-- Tree

export type Tree = CollapsingHeader & {
    arguments: {
        SpanAvailWidth: boolean?,
        NoIndent: boolean?,
    },
}

export type CollapsingHeader = ParentWidget & {
    arguments: {
        Text: string?,
    },

    state: {
        isUncollapsed: State<boolean>,
    },
} & Collapsed & Uncollapsed & Hovered

-- Input
export type Input<T> = Widget & {
    lastClickedTime: number,
    lastClickedPosition: Vector2,

    arguments: {
        Text: string?,
        Increment: T,
        Min: T,
        Max: T,
        Format: { string },
        Prefix: { string },
        NoButtons: boolean?,
    },

    state: {
        number: State<T>,
        editingText: State<number>,
    },
} & NumberChanged & Hovered

export type InputColor3 = Input<{ number }> & {
    arguments: {
        UseFloats: boolean?,
        UseHSV: boolean?,
    },

    state: {
        color: State<Color3>,
        editingText: State<boolean>,
    },
} & NumberChanged & Hovered

export type InputColor4 = InputColor3 & {
    state: {
        transparency: State<number>,
    },
}

export type InputEnum = Input<number> & {
    state: {
        enumItem: State<EnumItem>,
    },
}

export type InputText = Widget & {
    arguments: {
        Text: string?,
        TextHint: string?,
        ReadOnly: boolean?,
        MultiLine: boolean?,
    },

    state: {
        text: State<string>,
    },
} & TextChanged & Hovered

-- Combo

export type Selectable = Widget & {
    ButtonColors: { [string]: Color3 | number },

    arguments: {
        Text: string?,
        Index: any?,
        NoClick: boolean?,
    },

    state: {
        index: State<any>,
    },
} & Selected & Unselected & Clicked & RightClicked & DoubleClicked & CtrlClicked & Hovered

export type Combo = ParentWidget & {
    ComboChildrenHeight: number,

    arguments: {
        Text: string?,
        NoButton: boolean?,
        NoPreview: boolean?,
    },

    state: {
        index: State<any>,
        isOpened: State<boolean>,
    },
} & Opened & Closed & Clicked & Hovered

-- Plot

export type ProgressBar = Widget & {
    arguments: {
        Text: string?,
        Format: string?,
    },

    state: {
        progress: State<number>,
    },
} & Changed & Hovered

export type Table = ParentWidget & {
    RowColumnIndex: number,
    InitialNumColumns: number,
    ColumnInstances: { Frame },
    CellInstances: { Frame },

    arguments: {
        NumColumns: number,
        RowBg: boolean?,
        BordersOuter: boolean?,
        BordersInner: boolean?,
    },
} & Hovered

return {}

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.WidgetTypes

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.PubTypes | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

export type ID = Types.ID
export type State<T> = Types.State<T>

export type Widget = Types.Widget
export type Root = Types.Root
export type Window = Types.Window
export type Tooltip = Types.Tooltip
export type MenuBar = Types.MenuBar
export type Menu = Types.Menu
export type MenuItem = Types.MenuItem
export type MenuToggle = Types.MenuToggle
export type Separator = Types.Separator
export type Indent = Types.Indent
export type SameLine = Types.SameLine
export type Group = Types.Group
export type Text = Types.Text
export type SeparatorText = Types.SeparatorText
export type Button = Types.Button
export type Checkbox = Types.Checkbox
export type RadioButton = Types.RadioButton
export type Image = Types.Image
export type ImageButton = Types.ImageButton
export type Tree = Types.Tree
export type CollapsingHeader = Types.CollapsingHeader
export type Input<T> = Types.Input<T>
export type InputColor3 = Types.InputColor3
export type InputColor4 = Types.InputColor4
export type InputEnum = Types.InputEnum
export type InputText = Types.InputText
export type Selectable = Types.Selectable
export type Combo = Types.Combo
export type ProgressBar = Types.ProgressBar
export type Table = Types.Table

export type Iris = Types.Iris

return {}

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.PubTypes

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.CaffanSDK | 2025 | Enabled: N/A
--------------------------------------------------------------------
local Debugger = {}

local Iris = require(script.Parent)

local inventoryState = Iris.State({})

function Debugger.UpdateInventory(newData)
	inventoryState:set(newData or {})
end

function Debugger.Render()
	Iris.Window({"Overseer Debugger"})

	Iris.Tree({"Live Inventory"})
	local inv = inventoryState.value
	if type(inv) == "table" then
		for category, items in pairs(inv) do
			Iris.Tree({tostring(category)})
			if type(items) == "table" then
				for name, value in pairs(items) do
					Iris.Text({string.format("%s: %s", tostring(name), tostring(value))})
				end
			else
				Iris.Text({tostring(items)})
			end
			Iris.End()
		end
	else
		Iris.Text({"No Data Received"})
	end
	Iris.End()

	Iris.End()
end

return Debugger
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.CaffanSDK | 2025

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.CaffanSDK_Noclip | Enabled: N/A
--------------------------------------------------------------------
-- NoclipController.lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")

local noclipEnabled = false
local noclipConnection = nil
local damageBackup = nil

-- Load animation ONCE
local noclipAnim = Instance.new("Animation")
noclipAnim.AnimationId = "rbxassetid://117137114595019"
local track = humanoid:LoadAnimation(noclipAnim)
track.Priority = Enum.AnimationPriority.Action4
track.Looped = true  -- VERY IMPORTANT

local function setInvincible(state)
	if state then
		damageBackup = humanoid.HealthChanged:Connect(function()
			humanoid.Health = humanoid.MaxHealth
		end)
	else
		if damageBackup then damageBackup:Disconnect() end
		damageBackup = nil
	end
end


local function setCollision(noclipActive)
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			if noclipActive then
				part.CanCollide = false
			else
				if part.Name == "HumanoidRootPart" or part.Name == "Head" then
					part.CanCollide = true
				else
					part.CanCollide = false
				end
			end
		end
	end
end

local function enableNoclip()
	if noclipEnabled then return end
	noclipEnabled = true

	setCollision(true)
	setInvincible(true)

	-- PLAY ANIMATION ONLY ONCE
	if not track.IsPlaying then
		track:Play()
	end

	noclipConnection = RunService.Stepped:Connect(function()
		if noclipEnabled then
			setCollision(true)
		end
	end)
end

local function disableNoclip()
	if not noclipEnabled then return end
	noclipEnabled = false

	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end

	setCollision(false)
	setInvincible(false)

	if track.IsPlaying then
		track:Stop()
	end
end

local function toggleNoclip()
	if noclipEnabled then
		disableNoclip()
	else
		enableNoclip()
	end
end

-- Hotkey: N
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.N then
		toggleNoclip()
	end
end)

return {
	Toggle = toggleNoclip,
	Enabled = function() return noclipEnabled end,
}

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.CaffanSDK_Noclip

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.NoclipController | Enabled: N/A
--------------------------------------------------------------------
-- NoclipController.lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")

local noclipEnabled = false
local noclipConnection = nil
local damageConn = nil

-- Load animation ONCE
local anim = Instance.new("Animation")
anim.AnimationId = "rbxassetid://117137114595019"
local track = humanoid:LoadAnimation(anim)
track.Looped = true
track.Priority = Enum.AnimationPriority.Action4

local function setCollision(state)
	for _, part in char:GetDescendants() do
		if part:IsA("BasePart") then
			part.CanCollide = not state
		end
	end
end

local function setInvincible(state)
	if state then
		damageConn = humanoid.HealthChanged:Connect(function()
			humanoid.Health = humanoid.MaxHealth
		end)
	else
		if damageConn then damageConn:Disconnect() end
		damageConn = nil
	end
end

local function enable()
	if noclipEnabled then return end
	noclipEnabled = true

	setCollision(true)
	setInvincible(true)
	if not track.IsPlaying then track:Play() end

	noclipConnection = RunService.Stepped:Connect(function()
		setCollision(true)
	end)
end

local function disable()
	if not noclipEnabled then return end
	noclipEnabled = false

	if noclipConnection then noclipConnection:Disconnect() end
	noclipConnection = nil

	setCollision(false)
	setInvincible(false)
	if track.IsPlaying then track:Stop() end
end

local function toggle()
	if noclipEnabled then disable() else enable() end
end

return {
	Enabled = function() return noclipEnabled end,
	Toggle = toggle,
	Set = function(b) if b then enable() else disable() end end,
}

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.NoclipController

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.FootstepModule | Enabled: N/A
--------------------------------------------------------------------
-- Please confirm the author of this script was by "uglyburger0"
-- Any scripts under this module are viruses.

-- Types
export type SoundTable = {string}
export type SoundIds = {[string]: SoundTable}

-- Main Module
local main = {}

main.SoundIds = {
	["Bass"] = {
		"rbxassetid://9126748907",
		"rbxassetid://9126748813",
		"rbxassetid://9126748580",
		"rbxassetid://9126748691",
		"rbxassetid://9126748431",
		"rbxassetid://9126748324",
		"rbxassetid://9126748239",
		"rbxassetid://9126748185",
		"rbxassetid://9126748045",
		"rbxassetid://9126747958"
	},
	
	["Carpet"] = {
		"rbxassetid://9126748130",
		"rbxassetid://9126747861",
		"rbxassetid://9126747720",
		"rbxassetid://9126747529",
		"rbxassetid://9126747412",
		"rbxassetid://9126747283",
		"rbxassetid://9126746732",
		"rbxassetid://9126746837",
		"rbxassetid://9126747132",
		"rbxassetid://9126746984",
		"rbxassetid://9126746598",
		"rbxassetid://9126746481",
		"rbxassetid://9126746371",
		"rbxassetid://9126746291"
	},
	
	["Concrete"] = {
		"rbxassetid://9126746167",
		"rbxassetid://9126746098",
		"rbxassetid://9126745995",
		"rbxassetid://9126745877",
		"rbxassetid://9126745774",
		"rbxassetid://9126745574",
		"rbxassetid://9126745336",
		"rbxassetid://9126745241",
		"rbxassetid://9126745445",
		"rbxassetid://9126745052",
		"rbxassetid://9126745141",
		"rbxassetid://9126745676",
		"rbxassetid://9126744969",
		"rbxassetid://9126744894",
		"rbxassetid://9126744639",
		"rbxassetid://9126744789",
		"rbxassetid://9126744481"
	},
	
	["Dirt"] = {
		"rbxassetid://9126744390",
		"rbxassetid://9126744718",
		"rbxassetid://9126744263",
		"rbxassetid://9126744157",
		"rbxassetid://9126744066",
		"rbxassetid://9126744009",
		"rbxassetid://9126743796",
		"rbxassetid://9126743938",
		"rbxassetid://9126743711",
		"rbxassetid://9126743879",
		"rbxassetid://9126743613",
		"rbxassetid://9126743481",
		"rbxassetid://9126743338",
		"rbxassetid://9126743086"
	},
	
	["Glass"] = {
		"rbxassetid://9126742971",
		"rbxassetid://9126742461",
		"rbxassetid://9126742875",
		"rbxassetid://9126742786",
		"rbxassetid://9126743193",
		"rbxassetid://9126742680",
		"rbxassetid://9126742582",
		"rbxassetid://9126742510"
	},
	
	["Grass"] = {
		"rbxassetid://9126742396",
		"rbxassetid://9126741427",
		"rbxassetid://9126742333",
		"rbxassetid://9126742215",
		"rbxassetid://9126742271",
		"rbxassetid://9126742031",
		"rbxassetid://9126741934",
		"rbxassetid://9126742105",
		"rbxassetid://9126741826",
		"rbxassetid://9126741594",
		"rbxassetid://9126741512",
		"rbxassetid://9126741741",
		"rbxassetid://9126741674"
	},
	
	["Gravel"] = {
		"rbxassetid://9126741273",
		"rbxassetid://9126740393",
		"rbxassetid://9126741200",
		"rbxassetid://9126741051",
		"rbxassetid://9126741128",
		"rbxassetid://9126740951",
		"rbxassetid://9126740802",
		"rbxassetid://9126740724",
		"rbxassetid://9126740524",
		"rbxassetid://9126740623"
	},
	
	["Ladder"] = {
		"rbxassetid://9126740217",
		"rbxassetid://9126739039",
		"rbxassetid://9126740133",
		"rbxassetid://9126739947",
		"rbxassetid://9126740044",
		"rbxassetid://9126740305",
		"rbxassetid://9126739834",
		"rbxassetid://9126739622",
		"rbxassetid://9126739505",
		"rbxassetid://9126739406",
		"rbxassetid://9126739332",
		"rbxassetid://9126739229"
	},
	
	["Metal_Auto"] = {
		"rbxassetid://9126739090",
		"rbxassetid://9126738967",
		"rbxassetid://9126738896",
		"rbxassetid://9126738732",
		"rbxassetid://9126738543",
		"rbxassetid://9126738634"
	},
	
	["Metal_Chainlink"] = {
		"rbxassetid://9126738423",
		"rbxassetid://9126737791",
		"rbxassetid://9126738338",
		"rbxassetid://9126738197",
		"rbxassetid://9126738113",
		"rbxassetid://9126738032",
		"rbxassetid://9126737943",
		"rbxassetid://9126737853"
	},
	
	["Metal_Grate"] = {
		"rbxassetid://9126737728",
		"rbxassetid://9126736554",
		"rbxassetid://9126737597",
		"rbxassetid://9126737668",
		"rbxassetid://9126737506",
		"rbxassetid://9126737412",
		"rbxassetid://9126737315",
		"rbxassetid://9126737212",
		"rbxassetid://9126736947",
		"rbxassetid://9126737081",
		"rbxassetid://9126736863",
		"rbxassetid://9126736806",
		"rbxassetid://9126736642",
		"rbxassetid://9126736721"
	},
	
	["Metal_Solid"] = {
		"rbxassetid://9126736470",
		"rbxassetid://9126734921",
		"rbxassetid://9126736274",
		"rbxassetid://9126736354",
		"rbxassetid://9126736186",
		"rbxassetid://9126736049",
		"rbxassetid://9126735913",
		"rbxassetid://9126735734",
		"rbxassetid://9126735546",
		"rbxassetid://9126735474",
		"rbxassetid://9126735265",
		"rbxassetid://9126735374",
		"rbxassetid://9126735161",
		"rbxassetid://9126735028",
		"rbxassetid://9126735089",
		"rbxassetid://9126734972"
	},
	
	["Mud"] = {
		"rbxassetid://9126734842",
		"rbxassetid://9126734314",
		"rbxassetid://9126734778",
		"rbxassetid://9126734710",
		"rbxassetid://9126734613",
		"rbxassetid://9126734499",
		"rbxassetid://9126734365",
		"rbxassetid://9126734432",
		"rbxassetid://9126734244"
	},
	
	["Rubber"] = {
		"rbxassetid://9126734172",
		"rbxassetid://9126733896",
		"rbxassetid://9126734560",
		"rbxassetid://9126734010",
		"rbxassetid://9126733324",
		"rbxassetid://9126733766",
		"rbxassetid://9126733614",
		"rbxassetid://9126733493"
	},
	
	["Sand"] = {
		"rbxassetid://9126733118",
		"rbxassetid://9126733408",
		"rbxassetid://9126733225",
		"rbxassetid://9126732675",
		"rbxassetid://9126732571",
		"rbxassetid://9126732962",
		"rbxassetid://9126732962",
		"rbxassetid://9126732457",
		"rbxassetid://9126732862",
		"rbxassetid://9126732776",
		"rbxassetid://9126732334",
		"rbxassetid://9126732253"
	},
	
	-- Added 9/04/2022
	["Slosh"] = {
		"rbxassetid://10822813850",
		"rbxassetid://10822813728",
		"rbxassetid://10822813637",
		"rbxassetid://10822813572",
		"rbxassetid://10822813486",
		"rbxassetid://10822813412"
	},
	
	["Snow"] = {
		"rbxassetid://9126732128",
		"rbxassetid://9126731099",
		"rbxassetid://9126732016",
		"rbxassetid://9126731951",
		"rbxassetid://9126731877",
		"rbxassetid://9126731632",
		"rbxassetid://9126731493",
		"rbxassetid://9126731343",
		"rbxassetid://9126731790",
		"rbxassetid://9126731243",
		"rbxassetid://9126731169",
		"rbxassetid://9126730861"
	},
	
	["Tile"] = {
		"rbxassetid://9126730713",
		"rbxassetid://9126730782",
		"rbxassetid://9126731037",
		"rbxassetid://9126730980",
		"rbxassetid://9126730651",
		"rbxassetid://9126730563",
		"rbxassetid://9126730279",
		"rbxassetid://9126730403",
		"rbxassetid://9126730056",
		"rbxassetid://9126730172",
		"rbxassetid://9126729836",
		"rbxassetid://9126730472",
		"rbxassetid://9126729938",
		"rbxassetid://9126729706"
	},
	
	["Wood"] = {
		"rbxassetid://9126931624",
		"rbxassetid://9126931515",
		"rbxassetid://9126931417",
		"rbxassetid://9126931322",
		"rbxassetid://9126931699",
		"rbxassetid://9126931235",
		"rbxassetid://9126931169",
		"rbxassetid://9126931026",
		"rbxassetid://9126930953",
		"rbxassetid://9126930885",
		"rbxassetid://9126930789",
		"rbxassetid://9126930647",
		"rbxassetid://9126930516",
		"rbxassetid://9126930598",
		"rbxassetid://9126930718"
	}
}

main.MaterialMap = {
	[Enum.Material.Slate] = 		main.SoundIds.Concrete,
	[Enum.Material.Concrete] = 		main.SoundIds.Concrete,
	[Enum.Material.Brick] = 		main.SoundIds.Concrete,
	[Enum.Material.Cobblestone] = 	main.SoundIds.Concrete,
	[Enum.Material.Sandstone] =		main.SoundIds.Concrete,
	[Enum.Material.Rock] = 			main.SoundIds.Concrete,
	[Enum.Material.Basalt] = 		main.SoundIds.Concrete,
	[Enum.Material.CrackedLava] = 	main.SoundIds.Concrete,
	[Enum.Material.Asphalt] = 		main.SoundIds.Concrete,
	[Enum.Material.Limestone] = 	main.SoundIds.Concrete,
	[Enum.Material.Pavement] = 		main.SoundIds.Concrete,

	[Enum.Material.Plastic] = 		main.SoundIds.Tile,
	[Enum.Material.Marble] = 		main.SoundIds.Tile,
	[Enum.Material.Neon] = 			main.SoundIds.Tile,
	[Enum.Material.Granite] = 		main.SoundIds.Tile,
	
	[Enum.Material.Wood] = 			main.SoundIds.Wood,
	[Enum.Material.WoodPlanks] = 	main.SoundIds.Wood,
	
	[Enum.Material.Water] = 		main.SoundIds.Slosh,
	
	[Enum.Material.CorrodedMetal] = main.SoundIds.Metal_Solid,
	[Enum.Material.DiamondPlate] = 	main.SoundIds.Metal_Solid,
	[Enum.Material.Metal] = 		main.SoundIds.Metal_Solid,
	
	[Enum.Material.Foil] = 			main.SoundIds.Metal_Grate,
	
	[Enum.Material.Ground] = 		main.SoundIds.Dirt,
	
	[Enum.Material.Grass] = 		main.SoundIds.Grass,
	[Enum.Material.LeafyGrass] = 	main.SoundIds.Grass,
	
	[Enum.Material.Fabric] = 		main.SoundIds.Carpet,
	
	[Enum.Material.Pebble] = 		main.SoundIds.Gravel,
	
	[Enum.Material.Snow] = 			main.SoundIds.Snow,
	
	[Enum.Material.Sand] = 			main.SoundIds.Sand,
	[Enum.Material.Salt] = 			main.SoundIds.Sand,

	[Enum.Material.Ice] = 			main.SoundIds.Glass,
	[Enum.Material.Glacier] = 		main.SoundIds.Glass,
	[Enum.Material.Glass] = 		main.SoundIds.Glass,
	
	[Enum.Material.SmoothPlastic] = main.SoundIds.Rubber,
	[Enum.Material.ForceField] = 	main.SoundIds.Rubber,
	
	[Enum.Material.Mud] = 			main.SoundIds.Mud
}

-- This function produces a folder under a specified parent.
-- "soundProperties" is a table determining what the default properties of these audios will be.
function main:CreateSoundGroup(parent:Instance?, name:string?, soundProperties:{string:any}?, isFolder:boolean?) : SoundGroup|Folder
	if not parent then warn("Parent not specified, Footstep folder parented to workspace") end
	isFolder = isFolder or false
	soundProperties = soundProperties or {}
	parent = parent or workspace
	-- Create folder
	local SoundGroup = nil
	if not isFolder then
		SoundGroup = Instance.new("SoundGroup"); SoundGroup.Volume = 1; SoundGroup.Name = name or "Footsteps"
	else
		SoundGroup = Instance.new("Folder"); SoundGroup.Name = name or "Footsteps"
	end
	local index = 0
	for soundMaterial,soundList in pairs(main.SoundIds) do
		index = 0
		local sectionGroup = nil
		if not isFolder then
			sectionGroup = Instance.new("SoundGroup"); sectionGroup.Volume = 1; sectionGroup.Name = soundMaterial
		else
			sectionGroup = Instance.new("Folder"); sectionGroup.Name = soundMaterial
		end
		for _,soundId in pairs(soundList) do
			index += 1 -- Increment index
			local soundEffect = Instance.new("Sound")
			soundEffect.Name = string.format("%s_%02i",soundMaterial:lower(),index)
			-- Set optional sound group
			if not isFolder then
				soundEffect.SoundGroup = sectionGroup
			end
			for property,value in pairs(soundProperties) do
				soundEffect[property] = value
			end
			soundEffect.SoundId = soundId
			soundEffect.Parent = sectionGroup
		end
		sectionGroup.Parent = SoundGroup
	end
	
	SoundGroup.Parent = parent
	return SoundGroup
end

-- This function returns a table from the MaterialMap given the material.
function main:GetTableFromMaterial(EnumItem : Enum.Material|string) : { [string]: {string}}
	if typeof(EnumItem) == "string" then -- CONVERSION
		EnumItem = Enum.Material[EnumItem]
	end
	return main.MaterialMap[EnumItem]
end

-- This function is a primitive "pick randomly from table" function.
function main:GetRandomSound(SoundTable:{string}) : string
	return SoundTable[math.random(#SoundTable)]
end

return main
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.FootstepModule

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponFunctions | Enabled: N/A
--------------------------------------------------------------------
--- @ WeaponFunctionsModule
local WeaponFunctions = {}

--- @ WeaponFunctionsModule > Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

--- @ WeaponFunctionsModule > Runtime State
local currentWeapon = nil
local equipped = false
local aiming = false
local shooting = false
local reloading = false
local shoulderSwapped = false



----------------------------------------------------------------
-- HELPERS
----------------------------------------------------------------
local function play(anim)
	if anim then anim:Play() end
end

local function stop(anim)
	if anim then anim:Stop() end
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > Bind Animations
----------------------------------------------------------------
local function bindAnimations(weaponData)
	local animator = humanoid:FindFirstChildOfClass("Animator")
	local animLookup = {}

	local idSet = shoulderSwapped
		and weaponData.AnimationIds.Left
		or weaponData.AnimationIds.Default

	if not idSet then
		warn("Missing animation set for weapon")
		return {}
	end

	for name, id in pairs(idSet) do
		local anim = Instance.new("Animation")
		anim.AnimationId = id
		animLookup[name] = animator:LoadAnimation(anim)
	end

	return animLookup
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > SpawnWeapon (FROM SERVER)
----------------------------------------------------------------
-- Called from your server when a weapon is assigned
-- Example server call:
-- RemoteEvent:FireClient(player, "SpawnWeapon", name, data)

function WeaponFunctions.InitializeWeapon(weaponName, weaponData)
	local weaponModel = character:WaitForChild(weaponName)

	return {
		Model = weaponModel,
		Data = weaponData,
		Animations = bindAnimations(weaponData),
		Ammo = weaponData.MagSize or 0
	}
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > Equip / Unequip
----------------------------------------------------------------
function WeaponFunctions.Equip(weaponObj)
	if equipped or not weaponObj then return end

	currentWeapon = weaponObj
	equipped = true

	play(weaponObj.Animations.Equip)
end


function WeaponFunctions.Unequip()
	if not equipped then return end

	if currentWeapon and currentWeapon.Animations then
		for _, anim in pairs(currentWeapon.Animations) do
			stop(anim)
		end
	end

	equipped = false
	aiming = false
	shooting = false
	reloading = false
	currentWeapon = nil
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > Shoulder Swap
----------------------------------------------------------------
function WeaponFunctions.SwitchShoulder()
	if not currentWeapon then return end

	shoulderSwapped = not shoulderSwapped

	-- Stop old animations
	for _, track in pairs(currentWeapon.Animations) do
		track:Stop()
	end

	-- Bind new anims
	currentWeapon.Animations = bindAnimations(currentWeapon.Data)

	if aiming then
		play(currentWeapon.Animations.Aim)
	end

	if equipped then
		play(currentWeapon.Animations.Equip)
	end
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > Aim System
----------------------------------------------------------------
function WeaponFunctions.StartAim()
	if not equipped or not currentWeapon or reloading then return end
	aiming = true
	play(currentWeapon.Animations.Aim)
end

function WeaponFunctions.StopAim()
	if not aiming or not currentWeapon then return end
	aiming = false
	stop(currentWeapon.Animations.Aim)
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > Shooting
----------------------------------------------------------------
function WeaponFunctions.Shoot()
	if not currentWeapon or shooting or reloading then return end
	if currentWeapon.Ammo <= 0 then return end

	shooting = true
	currentWeapon.Ammo -= 1

	play(currentWeapon.Animations.Shoot)

	task.delay(currentWeapon.Data.FireRate or 0.15, function()
		shooting = false
	end)
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > Reloading
----------------------------------------------------------------
function WeaponFunctions.Reload()
	if not currentWeapon or reloading then return end
	if currentWeapon.Ammo >= currentWeapon.Data.MagSize then return end

	reloading = true
	play(currentWeapon.Animations.Reload)

	local duration = currentWeapon.Animations.Reload.Length
	task.delay(duration, function()
		currentWeapon.Ammo = currentWeapon.Data.MagSize
		reloading = false
	end)
end



----------------------------------------------------------------
--- @ WeaponFunctionsModule > RenderStep (Optional Aim Adjustments)
----------------------------------------------------------------
RunService.RenderStepped:Connect(function()
	if aiming and currentWeapon then
		-- camera offset, FOV, sway, etc.
	end
end)


return WeaponFunctions

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponFunctions

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.AssaultRifle | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "AssaultRifle"
module.WeaponType = "PurchasableFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Left Arm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 30,        -- Clip capacity (Factions MP)
	StartingAmmo = 60,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.11,    -- Time in seconds between shots
	FireMode = "Auto",   -- "Semi", "Burst", "Auto"
	-- Base damage applied to humanoid health
	Damage = {
		Body = 34,
		Head = 68,
	},
	ReloadTime = 2.4,   -- Duration in seconds for the reload action
	Accuracy = 0.8,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 3.0,
		Horizontal = 1.2,
	},
	Spread = {
		Min = 1,              -- Base spread angle/radius when aiming still
		Max = 7.5,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 1.2,  -- Amount the spread expands with each shot
		DecaySpeed = 4.0,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = 35,
		FireRate = module.Base.FireRate * 0.90, -- 10% faster
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.88,
	},

	["Upgrade2"] = {
		MagSize = 40,
		FireRate = module.Base.FireRate * 0.82, -- 18% faster
		Accuracy = module.Base.Accuracy + 0.10,
		ReloadTime = module.Base.ReloadTime * 0.80,
	}
}


-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://134980275983817", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://110596953973961", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://120131805341379", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://139833795330626", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://114856127484189", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://138782049171297", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://89858576934108", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Crouch = {
		Equip = { Id = "rbxassetid://134606980711746", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://77832019960026", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://125458553529407", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://72834849394610", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://110355161342512", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://108719039152127", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://128839839765543", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Prone = {
		Equip = { Id = "rbxassetid://92140909429396", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://117637871741969", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://108263009869788", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://111841868854161", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://111339754020694", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.AssaultRifle

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Mini-14 | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "Mini-14"
module.WeaponType = "LargeFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Left Arm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 8,        -- Clip capacity (Factions MP)
	StartingAmmo = 7,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.17,    -- Time in seconds between shots
	FireMode = "Semi",   -- "Semi", "Burst", "Auto"
	-- Base damage applied to humanoid health
	Damage = {
		Body = 34,
		Head = 68,
	},
	ReloadTime = 1.6,   -- Duration in seconds for the reload action
	Accuracy = 0.8,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.5,
		Horizontal = 1.0,
	},
	Spread = {
		Min = 0.5,              -- Base spread angle/radius when aiming still
		Max = 6.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 1.5,  -- Amount the spread expands with each shot
		DecaySpeed = 3.0,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://134980275983817", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://110596953973961", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://120131805341379", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://139833795330626", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://114856127484189", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://138782049171297", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://89858576934108", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Crouch = {
		Equip = { Id = "rbxassetid://134606980711746", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://77832019960026", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://125458553529407", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://72834849394610", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://110355161342512", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://108719039152127", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://128839839765543", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Prone = {
		Equip = { Id = "rbxassetid://92140909429396", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://117637871741969", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://108263009869788", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://111841868854161", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://111339754020694", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Mini-14
  -  Edit
  18:44:46.660  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Beretta | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "Beretta"
module.WeaponType = "SmallFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Right Arm"
module.FireMode = "Semi"   -- "Semi", "Burst", "Auto"

-- Base stats (un-upgraded)
module.Base = {
	MagSize = 8,        -- Clip capacity (Factions MP)
	StartingAmmo = 7,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.17,    -- Time in seconds between shots
	-- Base damage applied to humanoid health
	Damage = {
		Body = 34,
		Head = 68,
	},
	ReloadTime = 1.6,   -- Duration in seconds for the reload action
	Accuracy = 0.8,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.5,
		Horizontal = 1.0,
	},
	Spread = {
		Min = 0.5,              -- Base spread angle/radius when aiming still
		Max = 6.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 1.5,  -- Amount the spread expands with each shot
		DecaySpeed = 3.0,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://88408632559415", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://110596953973961", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://96166468142225", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://76042316323172", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://79017794074571", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://130657637234666", Priority = Enum.AnimationPriority.Action3 },
	},

	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Beretta

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Vepr | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "Vepr"
module.WeaponType = "LargeFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Left Arm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 8,        -- Clip capacity (Factions MP)
	StartingAmmo = 7,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.17,    -- Time in seconds between shots
	FireMode = "Semi",   -- "Semi", "Burst", "Auto"
	-- Base damage applied to humanoid health
	Damage = {
		Body = 34,
		Head = 68,
	},
	ReloadTime = 1.6,   -- Duration in seconds for the reload action
	Accuracy = 0.8,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.5,
		Horizontal = 1.0,
	},
	Spread = {
		Min = 0.5,              -- Base spread angle/radius when aiming still
		Max = 6.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 1.5,  -- Amount the spread expands with each shot
		DecaySpeed = 3.0,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://134980275983817", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://110596953973961", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://120131805341379", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://139833795330626", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://114856127484189", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://138782049171297", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://89858576934108", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Crouch = {
		Equip = { Id = "rbxassetid://134606980711746", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://77832019960026", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://125458553529407", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://72834849394610", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://110355161342512", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://108719039152127", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://128839839765543", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Prone = {
		Equip = { Id = "rbxassetid://92140909429396", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://117637871741969", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://108263009869788", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://111841868854161", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://111339754020694", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Vepr

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
-- ^ change to strict to crash studio c:

--[[
	Written by Eti the Spirit (18406183)
	
		The latest patch notes can be located here (and do note, the version at the top of this script might be outdated. I have a thing for forgetting to change it):
		>	https://etithespirit.github.io/FastCastAPIDocs/changelog
		
		*** If anything is broken, please don't hesitate to message me! ***
		
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		
		YOU SHOULD ONLY CREATE ONE CASTER PER GUN.
		YOU SHOULD >>>NEVER<<< CREATE A NEW CASTER EVERY TIME THE GUN NEEDS TO BE FIRED.
		
		A caster (created with FastCast.new()) represents a "gun".
		When you consider a gun, you think of stats like accuracy, bullet speed, etc. This is the info a caster stores. 
	
	--
	
	This is a library used to create hitscan-based guns that simulate projectile physics.
	
	This means:
		- You don't have to worry about bullet lag / jittering
		- You don't have to worry about keeping bullets at a low speed due to physics being finnicky between clients
		- You don't have to worry about misfires in bullet's Touched event (e.g. where it may going so fast that it doesn't register)
		
	Hitscan-based guns are commonly seen in the form of laser beams, among other things. Hitscan simply raycasts out to a target
	and says whether it hit or not.
	
	Unfortunately, while reliable in terms of saying if something got hit or not, this method alone cannot be used if you wish
	to implement bullet travel time into a weapon. As a result of that, I made this library - an excellent remedy to this dilemma.
	
	FastCast is intended to be require()'d once in a script, as you can create as many casters as you need with FastCast.new()
	This is generally handy since you can store settings and information in these casters, and even send them out to other scripts via events
	for use.
	
	Remember -- A "Caster" represents an entire gun (or whatever is launching your projectiles), *NOT* the individual bullets.
	Make the caster once, then use the caster to fire your bullets. Do not make a caster for each bullet.
--]]

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local FastCast = {}
FastCast.DebugLogging = false
FastCast.VisualizeCasts = false
FastCast.__index = FastCast
FastCast.__type = "FastCast" -- For compatibility with TypeMarshaller

-- Extra stuff
FastCast.HighFidelityBehavior = {
	Default = 1,
	Always = 3
}

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local ActiveCastStatic = require(script.ActiveCast)
local Signal = require(script.Signal)
local table = require(script.Table)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This Caster has been disposed. It can no longer be used."

-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

-----------------------------------------------------------
----------------------- STATIC CODE -----------------------
-----------------------------------------------------------

-- Tell the ActiveCast factory module what FastCast actually *is*.
ActiveCastStatic.SetStaticFastCastReference(FastCast)

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Constructor.
function FastCast.new()
	return setmetatable({
		LengthChanged = Signal.new("LengthChanged"),
		RayHit = Signal.new("RayHit"),
		RayPierced = Signal.new("RayPierced"),
		CastTerminating = Signal.new("CastTerminating"),
		WorldRoot = workspace
	}, FastCast)
end

-- Create a new ray info object.
-- This is just a utility alias with some extra type checking.
function FastCast.newBehavior(): FastCastBehavior
	-- raycastParams, maxDistance, acceleration, canPierceFunction, cosmeticBulletTemplate, cosmeticBulletContainer, autoIgnoreBulletContainer
	return {
		RaycastParams = nil,
		Acceleration = Vector3.new(),
		MaxDistance = 1000,
		CanPierceFunction = nil,
		HighFidelityBehavior = FastCast.HighFidelityBehavior.Default,
		HighFidelitySegmentSize = 0.5,
		CosmeticBulletTemplate = nil,
		CosmeticBulletProvider = nil,
		CosmeticBulletContainer = nil,
		AutoIgnoreContainer = true
	}
end

local DEFAULT_DATA_PACKET = FastCast.newBehavior()
function FastCast:Fire(origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior?): ActiveCast
	if castDataPacket == nil then castDataPacket = DEFAULT_DATA_PACKET end
	
	local cast = ActiveCastStatic.new(self, origin, direction, velocity, castDataPacket)
	cast.RayInfo.WorldRoot = self.WorldRoot
	return cast
end

-- Export
return FastCast
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.Table | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
-- shut up jesser

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local RobloxTable = table
local Table = {}

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- Only works on ordinal. yada yada.
Table.insertAndGetIndexOf = function (tbl, value)
	tbl[#tbl + 1] = value
	return #tbl
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

return setmetatable({}, {
	__index = function(tbl, index)
		if Table[index] ~= nil then
			return Table[index]
		else
			return RobloxTable[index]
		end
	end;

	__newindex = function(tbl, index, value)
		error("Add new table entries by editing the Module itself.")
	end;
})
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.Table

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.ActiveCast | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
-- ^ change to strict to crash studio c:
-- ActiveCast class type.
-- The ActiveCast type represents a currently running cast.


-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.Parent.TypeDefinitions)

type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

local typeof = require(script.Parent.TypeMarshaller)

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local ActiveCastStatic = {}
ActiveCastStatic.__index = ActiveCastStatic
ActiveCastStatic.__type = "ActiveCast" -- For compatibility with TypeMarshaller

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local RunService = game:GetService("RunService")
local table = require(script.Parent.Table)
local FastCast = nil -- Static reference to the FastCast static module.

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts in debug mode.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This ActiveCast has been terminated. It can no longer be used."

-- If pierce callback has to run more than this many times, it will register a hit and stop calculating pierces.
-- This only applies for repeated piercings, e.g. the amount of parts that fit within the space of a single cast segment (NOT the whole bullet's trajectory over its entire lifetime)
local MAX_PIERCE_TEST_COUNT = 100

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

-- Looks for a folder within workspace.Terrain that contains elements to visualize casts.
local function GetFastCastVisualizationContainer(): Instance
	local fcVisualizationObjects = workspace.Terrain:FindFirstChild(FC_VIS_OBJ_NAME)
	if fcVisualizationObjects ~= nil then
		return fcVisualizationObjects
	end
	
	fcVisualizationObjects = Instance.new("Folder")
	fcVisualizationObjects.Name = FC_VIS_OBJ_NAME
	fcVisualizationObjects.Archivable = false -- TODO: Keep this as-is? You can't copy/paste it if this is false. I have it false so that it doesn't linger in studio if you save with the debug data in there.
	fcVisualizationObjects.Parent = workspace.Terrain
	return fcVisualizationObjects
end

-----------------------------------------------------------
------------------------ DEBUGGING ------------------------
-----------------------------------------------------------

-- Print that runs only if debug mode is active.
local function PrintDebug(message: string)
	if FastCast.DebugLogging == true then
		print(message)
	end
end

-- Visualizes a ray. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeSegment(castStartCFrame: CFrame, castLength: number): ConeHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("ConeHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = castStartCFrame
	adornment.Height = castLength
	adornment.Color3 = Color3.new()
	adornment.Radius = 0.25
	adornment.Transparency = 0.5
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-- Visualizes an impact. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeHit(atCF: CFrame, wasPierce: boolean): SphereHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("SphereHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = atCF
	adornment.Radius = 0.4
	adornment.Transparency = 0.25
	adornment.Color3 = (wasPierce == false) and Color3.new(0.2, 1, 0.5) or Color3.new(1, 0.2, 0.2)
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-----------------------------------------------------------
------------------------ CORE CODE ------------------------
-----------------------------------------------------------

-- Thanks to zoebasil for supplying the velocity and position functions below. (I've modified these functions)
-- I was having a huge issue trying to get it to work and I had overcomplicated a bunch of stuff.
-- GetPositionAtTime is used in physically simulated rays (Where Caster.HasPhysics == true or the specific Fire has a specified acceleration).
-- This returns the location that the bullet will be at when you specify the amount of time the bullet has existed, the original location of the bullet, and the velocity it was launched with.
local function GetPositionAtTime(time: number, origin: Vector3, initialVelocity: Vector3, acceleration: Vector3): Vector3
	local force = Vector3.new((acceleration.X * time^2) / 2,(acceleration.Y * time^2) / 2, (acceleration.Z * time^2) / 2)
	return origin + (initialVelocity * time) + force
end

-- A variant of the function above that returns the velocity at a given point in time.
local function GetVelocityAtTime(time: number, initialVelocity: Vector3, acceleration: Vector3): Vector3
	return initialVelocity + acceleration * time
end

local function GetTrajectoryInfo(cast: ActiveCast, index: number): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local trajectories = cast.StateInfo.Trajectories
	local trajectory = trajectories[index]
	local duration = trajectory.EndTime - trajectory.StartTime
	
	local origin = trajectory.Origin
	local vel = trajectory.InitialVelocity
	local accel = trajectory.Acceleration
	
	return {GetPositionAtTime(duration, origin, vel, accel), GetVelocityAtTime(duration, vel, accel)}
end

local function GetLatestTrajectoryEndInfo(cast: ActiveCast): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	return GetTrajectoryInfo(cast, #cast.StateInfo.Trajectories)
end

local function CloneCastParams(params: RaycastParams): RaycastParams
	local clone = RaycastParams.new()
	clone.CollisionGroup = params.CollisionGroup
	clone.FilterType = params.FilterType
	clone.FilterDescendantsInstances = params.FilterDescendantsInstances
	clone.IgnoreWater = params.IgnoreWater
	return clone
end

local function SendRayHit(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendRayPierced(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendLengthChanged(cast: ActiveCast, lastPoint: Vector3, rayDir: Vector3, rayDisplacement: number, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
	cast.Caster.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
end

-- Simulate a raycast by one tick.
local function SimulateCast(cast: ActiveCast, delta: number, expectingShortCall: boolean)
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	PrintDebug("Casting for frame.")
	local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
	
	local origin = latestTrajectory.Origin
	local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	local initialVelocity = latestTrajectory.InitialVelocity
	local acceleration = latestTrajectory.Acceleration
	
	local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
	local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	cast.StateInfo.TotalRuntime += delta
	
	-- Recalculate this.
	totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	local currentTarget = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local segmentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
	local totalDisplacement = currentTarget - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.
	
	local rayDir = totalDisplacement.Unit * segmentVelocity.Magnitude * delta
	local targetWorldRoot = cast.RayInfo.WorldRoot
	local resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)
	
	local point = currentTarget
	local part: Instance? = nil
	local material = Enum.Material.Air
	local normal = Vector3.new()
	
	if (resultOfCast ~= nil) then
		point = resultOfCast.Position
		part = resultOfCast.Instance
		material = resultOfCast.Material
		normal = resultOfCast.Normal
	end
	
	local rayDisplacement = (point - lastPoint).Magnitude
	-- For clarity -- totalDisplacement is how far the ray would have traveled if it hit nothing,
	-- and rayDisplacement is how far the ray really traveled (which will be identical to totalDisplacement if it did indeed hit nothing)
	
	SendLengthChanged(cast, lastPoint, rayDir.Unit, rayDisplacement, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
	cast.StateInfo.DistanceCovered += rayDisplacement
	
	local rayVisualization: ConeHandleAdornment? = nil
	if (delta > 0) then
		rayVisualization = DbgVisualizeSegment(CFrame.new(lastPoint, lastPoint + rayDir), rayDisplacement)
	end
	
	
	-- HIT DETECTED. Handle all that garbage, and also handle behaviors 1 and 2 (default behavior, go high res when hit) if applicable.
	-- CAST BEHAVIOR 2 IS HANDLED IN THE CODE THAT CALLS THIS FUNCTION.
	
	if part and part ~= cast.RayInfo.CosmeticBulletObject then
		local start = tick()
		PrintDebug("Hit something, testing now.")
		
		-- SANITY CHECK: Don't allow the user to yield or run otherwise extensive code that takes longer than one frame/heartbeat to execute.
		if (cast.RayInfo.CanPierceCallback ~= nil) then
			if expectingShortCall == false then
				if (cast.StateInfo.IsActivelySimulatingPierce) then
					cast:Terminate()
					error("ERROR: The latest call to CanPierceCallback took too long to complete! This cast is going to suffer desyncs which WILL cause unexpected behavior and errors. Please fix your performance problems, or remove statements that yield (e.g. wait() calls)")
					-- Use error. This should absolutely abort the cast.
				end
			end
			-- expectingShortCall is used to determine if we are doing a forced resolution increase, in which case this will be called several times in a single frame, which throws this error.
			cast.StateInfo.IsActivelySimulatingPierce = true
		end
		------------------------------
		
		if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
			PrintDebug("Piercing function is nil or it returned FALSE to not pierce this hit.")
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if (cast.StateInfo.HighFidelityBehavior == 2 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize ~= 0) then
				cast.StateInfo.CancelHighResCast = false -- Reset this here.
				
				if cast.StateInfo.IsActivelyResimulating then
					cast:Terminate()
					error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
				end
				

				cast.StateInfo.IsActivelyResimulating = true
				
				-- This is a physics based cast and it needs to be recalculated.
				PrintDebug("Hit was registered, but recalculation is on for physics based casts. Recalculating to verify a real hit...")
				
				-- Split this ray segment into smaller segments of a given size.
				-- In 99% of cases, it won't divide evently (e.g. I have a distance of 1.25 and I want to divide into 0.1 -- that won't work)
				-- To fix this, the segments need to be stretched slightly to fill the space (rather than having a single shorter segment at the end)
				
				local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
				local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
				local realSegmentLength = rayDisplacement / numSegmentsReal -- this spits out 0.51, which isn't exact to the defined 0.5, but it's close
				
				-- Now the real hard part is converting this to time.
				local timeIncrement = delta / numSegmentsReal
				for segmentIndex = 1, numSegmentsReal do
					if cast.StateInfo.CancelHighResCast then
						cast.StateInfo.CancelHighResCast = false
						break
					end
					
					local subPosition = GetPositionAtTime(lastDelta + (timeIncrement * segmentIndex), origin, initialVelocity, acceleration)
					local subVelocity = GetVelocityAtTime(lastDelta + (timeIncrement * segmentIndex), initialVelocity, acceleration) 
					local subRayDir = subVelocity * delta
					local subResult = targetWorldRoot:Raycast(subPosition, subRayDir, cast.RayInfo.Parameters)
					
					local subDisplacement = (subPosition - (subPosition + subVelocity)).Magnitude
					
					if (subResult ~= nil) then
						local subDisplacement = (subPosition - subResult.Position).Magnitude
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
						if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
							-- Still hit even at high res
							cast.StateInfo.IsActivelyResimulating = false
							
							SendRayHit(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject)
							cast:Terminate()
							local vis = DbgVisualizeHit(CFrame.new(point), false)
							if (vis ~= nil) then vis.Color3 = Color3.new(0.0588235, 0.87451, 1) end
							return
						else
							-- Recalculating hit something pierceable instead.
							SendRayPierced(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) -- This may result in CancelHighResCast being set to true.
							local vis = DbgVisualizeHit(CFrame.new(point), true)
							if (vis ~= nil) then vis.Color3 = Color3.new(1, 0.113725, 0.588235) end
							if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.305882, 0.243137, 0.329412) end
						end
					else
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
					end
				end
				
				-- If the script makes it here, then it wasn't a real hit (higher resolution revealed that the low-res hit was faulty)
				-- Just let it keep going.
				cast.StateInfo.IsActivelyResimulating = false
			elseif (cast.StateInfo.HighFidelityBehavior ~= 1 and cast.StateInfo.HighFidelityBehavior ~= 3) then
				cast:Terminate()
				error("Invalid value " .. (cast.StateInfo.HighFidelityBehavior) .. " for HighFidelityBehavior.")
			else
				-- This is not a physics cast, or recalculation is off.
				PrintDebug("Hit was successful. Terminating.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(point), false)
				return
			end
		else
			PrintDebug("Piercing function returned TRUE to pierce this part.")
			if rayVisualization ~= nil then
				rayVisualization.Color3 = Color3.new(0.4, 0.05, 0.05) -- Turn it red to signify that the cast was scrapped.
			end
			DbgVisualizeHit(CFrame.new(point), true)
			
			local params = cast.RayInfo.Parameters
			local alteredParts = {}
			local currentPierceTestCount = 0
			local originalFilter = params.FilterDescendantsInstances
			local brokeFromSolidObject = false
			while true do
				-- So now what I need to do is redo this entire cast, just with the new filter list
								
				-- Catch case: Is it terrain?
				if resultOfCast.Instance:IsA("Terrain") then
					if material == Enum.Material.Water then
						-- Special case: Pierced on water?
						cast:Terminate()
						error("Do not add Water as a piercable material. If you need to pierce water, set cast.RayInfo.Parameters.IgnoreWater = true instead", 0)
					end
					warn("WARNING: The pierce callback for this cast returned TRUE on Terrain! This can cause severely adverse effects.")
				end
				
				if params.FilterType == Enum.RaycastFilterType.Blacklist then
					-- blacklist
					-- DO NOT DIRECTLY TABLE.INSERT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.insert(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				else
					-- whitelist
					-- method implemeneted by custom table system
					-- DO NOT DIRECTLY TABLE.REMOVEOBJECT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.removeObject(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				end
				
				SendRayPierced(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				
				-- List has been updated, so let's cast again.
				resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, params)
				
				-- No hit? No simulation. Break.
				if resultOfCast == nil then
					break
				end
				
				if currentPierceTestCount >= MAX_PIERCE_TEST_COUNT then
					warn("WARNING: Exceeded maximum pierce test budget for a single ray segment (attempted to test the same segment " .. MAX_PIERCE_TEST_COUNT .. " times!)")
					break
				end
				currentPierceTestCount = currentPierceTestCount + 1;
				
				if cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false then
					brokeFromSolidObject = true
					break
				end
			end
			
			-- Restore the filter to its default state.
			cast.RayInfo.Parameters.FilterDescendantsInstances = originalFilter
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if brokeFromSolidObject then
				-- We actually hit something while testing.
				PrintDebug("Broke because the ray hit something solid (" .. tostring(resultOfCast.Instance) .. ") while testing for a pierce. Terminating the cast.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(resultOfCast.Position), false)
				return
			end
			
			-- And exit the function here too.
		end
	end
	
	if (cast.StateInfo.DistanceCovered >= cast.RayInfo.MaxDistance) then
		-- SendRayHit(cast, nil, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
		cast:Terminate()
		DbgVisualizeHit(CFrame.new(currentTarget), false)
	end
end

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Ctor
function ActiveCastStatic.new(caster: Caster, origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior): ActiveCast
	if typeof(velocity) == "number" then
		velocity = direction.Unit * velocity
	end	
	
	if (castDataPacket.HighFidelitySegmentSize <= 0) then
		error("Cannot set FastCastBehavior.HighFidelitySegmentSize <= 0!", 0)
	end
	
	-- Basic setup
	local cast = {
		Caster = caster,
		
		-- Data that keeps track of what's going on as well as edits we might make during runtime.
		StateInfo = {
			UpdateConnection = nil,
			Paused = false,
			TotalRuntime = 0,
			DistanceCovered = 0,
			HighFidelitySegmentSize = castDataPacket.HighFidelitySegmentSize,
			HighFidelityBehavior = castDataPacket.HighFidelityBehavior,
			IsActivelySimulatingPierce = false,
			IsActivelyResimulating = false,
			CancelHighResCast = false,
			Trajectories = {
				{
					StartTime = 0,
					EndTime = -1,
					Origin = origin,
					InitialVelocity = velocity,
					Acceleration = castDataPacket.Acceleration
				}
			}
		},
		
		-- Information pertaining to actual raycasting.
		RayInfo = {
			Parameters = castDataPacket.RaycastParams,
			WorldRoot = workspace,
			MaxDistance = castDataPacket.MaxDistance or 1000,
			CosmeticBulletObject = castDataPacket.CosmeticBulletTemplate, -- This is intended. We clone it a smidge of the way down.
			CanPierceCallback = castDataPacket.CanPierceFunction
		},
		
		UserData = {}
	}
	
	if cast.StateInfo.HighFidelityBehavior == 2 then
		cast.StateInfo.HighFidelityBehavior = 3
	end
	
	
	if cast.RayInfo.Parameters ~= nil then
		cast.RayInfo.Parameters = CloneCastParams(cast.RayInfo.Parameters)
	else
		cast.RayInfo.Parameters = RaycastParams.new()
	end

	local usingProvider = false
	if castDataPacket.CosmeticBulletProvider == nil then
		-- The provider is nil. Use a cosmetic object clone.
		if cast.RayInfo.CosmeticBulletObject ~= nil then
			cast.RayInfo.CosmeticBulletObject = cast.RayInfo.CosmeticBulletObject:Clone()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			cast.RayInfo.CosmeticBulletObject.Parent = castDataPacket.CosmeticBulletContainer
		end
	else
		-- The provider is not nil.
		-- Is it what we want?
		if typeof(castDataPacket.CosmeticBulletProvider) == "PartCache" then
			-- this modded version of typeof is implemented up top.
			-- Aside from that, yes, it's a part cache. Good to go!
			
			if cast.RayInfo.CosmeticBulletObject ~= nil then
				-- They also set the template. Not good. Warn + clear this up.
				warn("Do not define FastCastBehavior.CosmeticBulletTemplate and FastCastBehavior.CosmeticBulletProvider at the same time! The provider will be used, and CosmeticBulletTemplate will be set to nil.")
				cast.RayInfo.CosmeticBulletObject = nil
				castDataPacket.CosmeticBulletTemplate = nil
			end

			cast.RayInfo.CosmeticBulletObject = castDataPacket.CosmeticBulletProvider:GetPart()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			usingProvider = true
		else
			warn("FastCastBehavior.CosmeticBulletProvider was not an instance of the PartCache module (an external/separate model)! Are you inputting an instance created via PartCache.new? If so, are you on the latest version of PartCache? Setting FastCastBehavior.CosmeticBulletProvider to nil.")
			castDataPacket.CosmeticBulletProvider = nil
		end
	end

	local targetContainer: Instance;
	if usingProvider then
		targetContainer = castDataPacket.CosmeticBulletProvider.CurrentCacheParent
	else
		targetContainer = castDataPacket.CosmeticBulletContainer
	end
	
	if castDataPacket.AutoIgnoreContainer == true and targetContainer ~= nil then
		local ignoreList = cast.RayInfo.Parameters.FilterDescendantsInstances
		if table.find(ignoreList, targetContainer) == nil then
			table.insert(ignoreList, targetContainer)
			cast.RayInfo.Parameters.FilterDescendantsInstances = ignoreList
		end
	end
	
	local event
	if RunService:IsClient() then
		event = RunService.RenderStepped
	else
		event = RunService.Heartbeat
	end
	
	setmetatable(cast, ActiveCastStatic)
	
	cast.StateInfo.UpdateConnection = event:Connect(function (delta)
		if cast.StateInfo.Paused then return end
		
		PrintDebug("Casting for frame.")
		local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
		if (cast.StateInfo.HighFidelityBehavior == 3 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize > 0) then
			
			local timeAtStart = tick()
			
			if cast.StateInfo.IsActivelyResimulating then
				cast:Terminate()
				error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
			end
			
			cast.StateInfo.IsActivelyResimulating = true
			
			-- Actually want to calculate this early to find displacement
			local origin = latestTrajectory.Origin
			local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			local initialVelocity = latestTrajectory.InitialVelocity
			local acceleration = latestTrajectory.Acceleration
			
			local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
			local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			
			cast.StateInfo.TotalRuntime += delta
			
			-- Recalculate this.
			totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			
			local currentPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local currentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
			local totalDisplacement = currentPoint - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.
			
			local rayDir = totalDisplacement.Unit * currentVelocity.Magnitude * delta
			local targetWorldRoot = cast.RayInfo.WorldRoot
			local resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)
			
			local point = currentPoint
			
			if (resultOfCast ~= nil) then
				point = resultOfCast.Position
			end
			
			local rayDisplacement = (point - lastPoint).Magnitude
			
			-- Now undo this. The line below in the for loop will add this time back gradually.
			cast.StateInfo.TotalRuntime -= delta
			
			-- And now that we have displacement, we can calculate segment size.
			local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
			local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
			if (numSegmentsReal == 0) then
				numSegmentsReal = 1
			end
			
			local timeIncrement = delta / numSegmentsReal
			
			for segmentIndex = 1, numSegmentsReal do
				if getmetatable(cast) == nil then return end -- Could have been disposed.
				if cast.StateInfo.CancelHighResCast then
					cast.StateInfo.CancelHighResCast = false
					break
				end
				PrintDebug("[" .. segmentIndex .. "] Subcast of time increment " .. timeIncrement)
				SimulateCast(cast, timeIncrement, true)
			end
			
			if getmetatable(cast) == nil then return end -- Could have been disposed.
			cast.StateInfo.IsActivelyResimulating = false
			
			if (tick() - timeAtStart) > 0.016 * 5 then
				warn("Extreme cast lag encountered! Consider increasing HighFidelitySegmentSize.")
			end
			
		else
			SimulateCast(cast, delta, false)
		end
	end)
	
	return cast
end

function ActiveCastStatic.SetStaticFastCastReference(ref)
	FastCast = ref
end

---- GETTERS AND SETTERS ----

local function ModifyTransformation(cast: ActiveCast, velocity: Vector3?, acceleration: Vector3?, position: Vector3?)
	local trajectories = cast.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	
	-- NEW BEHAVIOR: Don't create a new trajectory if we haven't even used the current one.
	if lastTrajectory.StartTime == cast.StateInfo.TotalRuntime then
		-- This trajectory is fresh out of the box. Let's just change it since it hasn't actually affected the cast yet, so changes won't have adverse effects.
		if (velocity == nil) then
			velocity = lastTrajectory.InitialVelocity
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = lastTrajectory.Origin
		end	
		
		lastTrajectory.Origin = position
		lastTrajectory.InitialVelocity = velocity
		lastTrajectory.Acceleration = acceleration
	else
		-- The latest trajectory is done. Set its end time and get its location. 
		lastTrajectory.EndTime = cast.StateInfo.TotalRuntime
		
		local point, velAtPoint = unpack(GetLatestTrajectoryEndInfo(cast))
		
		if (velocity == nil) then
			velocity = velAtPoint
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = point
		end	
		table.insert(cast.StateInfo.Trajectories, {
			StartTime = cast.StateInfo.TotalRuntime,
			EndTime = -1,
			Origin = position,
			InitialVelocity = velocity,
			Acceleration = acceleration
		})
		cast.StateInfo.CancelHighResCast = true
	end
end

function ActiveCastStatic:SetVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, velocity, nil, nil)
end

function ActiveCastStatic:SetAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, acceleration, nil)
end

function ActiveCastStatic:SetPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, nil, position)
end

function ActiveCastStatic:GetVelocity(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetVelocityAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

function ActiveCastStatic:GetAcceleration(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return currentTrajectory.Acceleration
end

function ActiveCastStatic:GetPosition(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetPositionAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.Origin, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

---- ARITHMETIC ----

function ActiveCastStatic:AddVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetVelocity(self:GetVelocity() + velocity)
end

function ActiveCastStatic:AddAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetAcceleration(self:GetAcceleration() + acceleration)
end

function ActiveCastStatic:AddPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetPosition(self:GetPosition() + position)
end

---- STATE MODIFICATION ----

function ActiveCastStatic:Pause()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Pause", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = true
end

function ActiveCastStatic:Resume()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Resume", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = false
end

function ActiveCastStatic:Terminate()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Terminate", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	
	-- First: Set EndTime on the latest trajectory since it is now done simulating.
	local trajectories = self.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	lastTrajectory.EndTime = self.StateInfo.TotalRuntime
	
	-- Disconnect the update connection.
	self.StateInfo.UpdateConnection:Disconnect()
	
	-- Now fire CastTerminating
	self.Caster.CastTerminating:FireSync(self)
	
	-- And now set the update connection object to nil.
	self.StateInfo.UpdateConnection = nil
	
	-- And nuke everything in the table + clear the metatable.
	self.Caster = nil
	self.StateInfo = nil
	self.RayInfo = nil
	self.UserData = nil
	setmetatable(self, nil)
end

return ActiveCastStatic
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.ActiveCast

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.Signal | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
-- ^ change to strict to crash studio c:

-- A new implementation of RBXScriptSignal that uses proper Lua OOP.
-- This was explicitly made to transport other OOP objects.
-- I would be using BindableEvents, but they don't like cyclic tables (part of OOP objects with __index)

-- Inject types
local TypeDefs = require(script.Parent.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

local TestService = game:GetService("TestService")
local table = require(script.Parent.Table)

local SignalStatic = {}
SignalStatic.__index = SignalStatic
SignalStatic.__type = "Signal" -- For compatibility with TypeMarshaller
local ConnectionStatic = {}
ConnectionStatic.__index = ConnectionStatic
ConnectionStatic.__type = "SignalConnection" -- For compatibility with TypeMarshaller

export type Signal = {
	Name: string,
	Connections: {[number]: Connection},
	YieldingThreads: {[number]: BindableEvent}
}

export type Connection = {
	Signal: Signal?,
	Delegate: any,
	Index: number	
}

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

function SignalStatic.new(signalName: string): Signal
	local signalObj: Signal = {
		Name = signalName,
		Connections = {},
		YieldingThreads = {}
	}
	return setmetatable(signalObj, SignalStatic)
end

local function NewConnection(sig: Signal, func: any): Connection 
	local connectionObj: Connection = {
		Signal = sig,
		Delegate = func,
		Index = -1
	}
	return setmetatable(connectionObj, ConnectionStatic)
end

local function ThreadAndReportError(delegate: any, args: GenericTable, handlerName: string)
	local thread = coroutine.create(function ()
		delegate(unpack(args))
	end)
	local success, msg = coroutine.resume(thread)
	if not success then 
		-- For the love of god roblox PLEASE add the ability to customize message type in output statements.
		-- This "testservice" garbage at the start of my message is annoying as all hell.
		TestService:Error(string.format("Exception thrown in your %s event handler: %s", handlerName, msg))
		TestService:Checkpoint(debug.traceback(thread))
	end
end

function SignalStatic:Connect(func)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Connect", "Signal.new()"))
	local connection = NewConnection(self, func)
	connection.Index = #self.Connections + 1
	table.insert(self.Connections, connection.Index, connection)
	return connection
end

function SignalStatic:Fire(...)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Fire", "Signal.new()"))
	local args = table.pack(...)
	local allCons = self.Connections
	local yieldingThreads = self.YieldingThreads
	for index = 1, #allCons do
		local connection = allCons[index]
		if connection.Delegate ~= nil then
			-- Catch case for disposed signals.
			ThreadAndReportError(connection.Delegate, args, connection.Signal.Name)
		end
	end
	for index = 1, #yieldingThreads do
		local thread = yieldingThreads[index]
		if thread ~= nil then
			coroutine.resume(thread, ...)
		end
	end
end

function SignalStatic:FireSync(...)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("FireSync", "Signal.new()"))
	local args = table.pack(...)
	local allCons = self.Connections
	local yieldingThreads = self.YieldingThreads
	for index = 1, #allCons do
		local connection = allCons[index]
		if connection.Delegate ~= nil then
			-- Catch case for disposed signals.
			connection.Delegate(unpack(args))
		end
	end
	for index = 1, #yieldingThreads do
		local thread = yieldingThreads[index]
		if thread ~= nil then
			coroutine.resume(thread, ...)
		end
	end
end

function SignalStatic:Wait()
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Wait", "Signal.new()"))
	local args = {}
	local thread = coroutine.running()
	table.insert(self.YieldingThreads, thread)
	args = { coroutine.yield() }
	table.removeObject(self.YieldingThreads, thread)
	return unpack(args)
end

function SignalStatic:Dispose()
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Dispose", "Signal.new()"))
	local allCons = self.Connections
	for index = 1, #allCons do
		allCons[index]:Disconnect()
	end
	self.Connections = {}
	setmetatable(self, nil)
end

function ConnectionStatic:Disconnect()
	assert(getmetatable(self) == ConnectionStatic, ERR_NOT_INSTANCE:format("Disconnect", "private function NewConnection()"))
	table.remove(self.Signal.Connections, self.Index)
	self.SignalStatic = nil
	self.Delegate = nil
	self.YieldingThreads = {}
	self.Index = -1
	setmetatable(self, nil)
end

return SignalStatic
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.Signal

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.TypeDefinitions | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
-- ^ change to strict to crash studio c:

-- Defines all FC types.
-- Any script that requires this will have these types defined.

--[[
local TypeDefs = require(script.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast
--]]

-- Represents the function to determine piercing.
export type CanPierceFunction = (ActiveCast, RaycastResult, Vector3) -> boolean

-- Represents any table.
export type GenericTable = {[any]: any}

-- Represents a Caster :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caster/
export type Caster = {
	WorldRoot: WorldRoot,
	LengthChanged: RBXScriptSignal,
	RayHit: RBXScriptSignal,
	RayPierced: RBXScriptSignal,
	CastTerminating: RBXScriptSignal,
	Fire: (Vector3, Vector3, Vector3 | number, FastCastBehavior) -> ()
}

-- Represents a FastCastBehavior :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/fcbehavior/
export type FastCastBehavior = {
	RaycastParams: RaycastParams?,
	MaxDistance: number,
	Acceleration: Vector3,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	CosmeticBulletTemplate: Instance?,
	CosmeticBulletProvider: any, -- Intended to be a PartCache. Dictated via TypeMarshaller.
	CosmeticBulletContainer: Instance?,
	AutoIgnoreContainer: boolean,
	CanPierceFunction: CanPierceFunction
}

-- Represents a CastTrajectory :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/casttrajectory/
export type CastTrajectory = {
	StartTime: number,
	EndTime: number,
	Origin: Vector3,
	InitialVelocity: Vector3,
	Acceleration: Vector3
}

-- Represents a CastStateInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caststateinfo/
export type CastStateInfo = {
	UpdateConnection: RBXScriptSignal,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	Paused: boolean,
	TotalRuntime: number,
	DistanceCovered: number,
	IsActivelySimulatingPierce: boolean,
	IsActivelyResimulating: boolean,
	CancelHighResCast: boolean,
	Trajectories: {[number]: CastTrajectory}
}

-- Represents a CastRayInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/castrayinfo/
export type CastRayInfo = {
	Parameters: RaycastParams,
	WorldRoot: WorldRoot,
	MaxDistance: number,
	CosmeticBulletObject: Instance?,
	CanPierceCallback: CanPierceFunction
}

-- Represents an ActiveCast :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/activecast/
export type ActiveCast = {
	Caster: Caster,
	StateInfo: CastStateInfo,
	RayInfo: CastRayInfo,
	UserData: {[any]: any}
}

return {}
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.TypeDefinitions

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.TypeMarshaller | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
-- ^ change to strict to crash studio c:

local oldtypeof = typeof
local function typeof(objIn: any): string
	local objType = oldtypeof(objIn)
	if objType ~= "table" then return objType end

	-- Could be a custom type if it's a table.
	local meta = getmetatable(objIn)
	if oldtypeof(meta) ~= "table" then return objType end

	-- Has a metatable that's an exposed table.
	local customType: string? = meta["__type"] -- I want to mandate that this is a string.
	if customType == nil then return objType end

	-- Has a type field
	return customType
end

return typeof
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.FastCastRedux.TypeMarshaller

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.ServerScriptService.lootboxtest | Enabled: true
--------------------------------------------------------------------
local replicated = game:GetService("ReplicatedStorage")
local LootModule = require(replicated.Peak.Modules.Loot:WaitForChild("LootModule"))
local interactEvent = replicated.Peak.Remotes.InteractEvent


local INTERACT_DISTANCE = 10



local function spawnLoot(itemName, lootBox)
	-- Validate lootBox
	if not lootBox or not lootBox:IsA("BasePart") then
		warn("Invalid loot box passed to spawnLoot!")
		return
	end

	-- Get all "Attachment" objects in the loot box
	local attachments = {}
	for _, child in ipairs(lootBox:GetChildren()) do
		if child:IsA("Attachment") and child.Name == "Attachment" then
			table.insert(attachments, child)
		end
	end

	if #attachments == 0 then
		warn("No attachments found in loot box: " .. lootBox.Name)
		return
	end

	-- Choose a random attachment
	local chosenAttachment = attachments[math.random(1, #attachments)]
	local spawnPosition = chosenAttachment.WorldPosition

	-- Create a loot part at the chosen position
	local lootPart = Instance.new("Part")
	lootPart.Name = itemName
	lootPart.Size = Vector3.new(1, 1, 1)
	lootPart.Position = spawnPosition
	lootPart.Anchored = true
	lootPart.Parent = workspace

	-- Optionally add customization (e.g., decal, model, etc.)
end



interactEvent.OnServerEvent:Connect(function(player, lootBox)
	-- Validate the player's character and position
	local character = player.Character
	local root = character and character:FindFirstChild("HumanoidRootPart")
	if not root then return end
	if not lootBox or not lootBox:IsA("BasePart") then return end

	if (root.Position - lootBox.Position).Magnitude > INTERACT_DISTANCE then
		player:Kick("Attempted to interact too far from a loot box!")
		return
	end

	-- Generate loot using the LootModule
	local loot = {}
	local lootCount = math.random(2, 4) -- Example: randomize the number of loot items
	for i = 1, lootCount do
		local item = LootModule:RollLoot("Common") -- Use a loot pool
		if item then
			table.insert(loot, item)
		end
	end

	-- Send validated loot data back to the client
	interactEvent:FireClient(player, loot, lootBox)
end)
--// END OF SCRIPT: game.ServerScriptService.lootboxtest

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.ServerScriptService.Server | weapon | Enabled: true
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Peak = ReplicatedStorage:WaitForChild("Peak")
local Remotes = Peak:WaitForChild("Remotes")
local Modules = Peak:WaitForChild("Modules")
local Assets = Peak:WaitForChild("Assets")

local WeaponRemotes = Remotes:WaitForChild("WeaponSys")
local CoreRemote = WeaponRemotes:WaitForChild("Core")

local WeaponModulesRoot = Modules:WaitForChild("WeaponSys")
local WeaponDataFolder = WeaponModulesRoot:WaitForChild("WeaponData")
local WeaponModelFolder = Assets:WaitForChild("WeaponModels")

local ServerWeaponState = {} 
-- When a player joins, their entry becomes:
-- ServerWeaponState[player] = {
--     Primary = { Model = ..., Ammo = ..., etc },
--     Secondary = { Model = ..., Ammo = ..., etc }
-- }

local BackpackC0 = CFrame.new(0.7, -1.2, -0.6) * CFrame.Angles(math.rad(90), 0, 0)
local TorsoHolsterC0 = CFrame.new(1, -0.7, 0.65) * CFrame.fromEulerAnglesXYZ(math.rad(-45), math.rad(90), 0)
local HandC0 = CFrame.new() 
local SidearmHolsterC0 = CFrame.new(1, -0.7, 0.65) * CFrame.fromOrientation(
	math.rad(-45),
	math.rad(90),
	0
)


local function GetProfileForPlayer(player)
	return _G.Profiles and _G.Profiles[player]
end

local function LoadWeaponModule(weaponName)
	local mod = WeaponDataFolder:FindFirstChild(weaponName)
	if mod then return require(mod) end
	return nil
end

local function GetSlotForWeapon(player, weaponData)
	local t = weaponData.WeaponType

	if t == "Secondary" or t == "SmallFirearm" then
		return "Secondary"
	elseif t == "Primary" or t == "LargeFirearm" then
		return "Primary"
	end

	-- fallback default
	return "Primary"
end

local function WaitForBackpack(player)
	local char = player.Character
	if not char then return nil end

	-- Wait indefinitely until backpack is actually inserted
	local backpack = char:FindFirstChild("Backpack")
	while not backpack do
		task.wait(0.05)
		backpack = char:FindFirstChild("Backpack")
	end

	local testBP = backpack:FindFirstChild("TestBP")
	while not testBP do
		task.wait(0.05)
		testBP = backpack:FindFirstChild("TestBP")
	end

	local lp = testBP:FindFirstChild("Backpack_LP")
	while not lp do
		task.wait(0.05)
		lp = testBP:FindFirstChild("Backpack_LP")
	end

	return lp
end


local function GetOrSpawnWeapon(player, weaponName, weaponData)
	if not player or not weaponName or not weaponData then
		warn("[GetOrSpawnWeapon] Missing args")
		return nil, nil, nil
	end

	local char = player.Character
	if not char or not char.Parent then
		return nil, nil, nil
	end

	-- RESET STATE IF CHARACTER CHANGED
	ServerWeaponState[player] = ServerWeaponState[player] or {}
	local slot = GetSlotForWeapon(player, weaponData) or "Primary"
	local state = ServerWeaponState[player][slot]

	if state and state.Character ~= char then
		ServerWeaponState[player][slot] = nil
		state = nil
	end

	-- CREATE STATE IF NONE
	if not state then
		state = {
			Character = char,
			WeaponName = weaponName,
			Data = weaponData,
			Ammo = (weaponData.Base and weaponData.Base.StartingAmmo) or 0,
			Equipped = false,
		}
		ServerWeaponState[player][slot] = state
	end

	-- FIND TEMPLATE
	local template = WeaponModelFolder:FindFirstChild(weaponName)
	if not template then
		warn("[GetOrSpawnWeapon] Missing model:", weaponName)
		return nil, nil, nil
	end

	-- SPAWN MODEL IF NEEDED
	if not state.Model or not state.Model.Parent then
		state.Model = template:Clone()
		state.Model.Name = weaponName
		state.Model.Parent = char
	end

	local model = state.Model
	local handle = model:FindFirstChild("Handle") or model:WaitForChild("Handle", 2)
	if not handle then
		warn("[GetOrSpawnWeapon] Handle missing:", weaponName)
		model:Destroy()
		return nil, nil, nil
	end

	-- ALWAYS RE-FIND ATTACH PART
	local attachName = weaponData.AttachmentPart or "Right Arm"
	local attachPart = char:FindFirstChild(attachName)

	if not attachPart then
		attachPart = char:FindFirstChild("Right Arm") or char:FindFirstChild("Torso")
	end

	state.AttachmentPart = attachPart

	-- ALWAYS RE-FIND HOLSTER PART
	if slot == "Primary" then
		state.HolsterPart = WaitForBackpack(player)
	else
		state.HolsterPart = char:FindFirstChild("Torso")
	end

	if not state.Equipped then
		if slot == "Primary" then
			state.HolsterPart = WaitForBackpack(player)

			if state.Weld then state.Weld:Destroy() end

			local weld = Instance.new("Motor6D")
			weld.Name = "WeaponWeld"
			weld.Part0 = state.HolsterPart
			weld.Part1 = handle
			weld.C0 = BackpackC0
			weld.C1 = CFrame.new()
			weld.Parent = handle
			state.Weld = weld
		else
			local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")

			if state.Weld then state.Weld:Destroy() end

			local weld = Instance.new("Motor6D")
			weld.Name = "WeaponWeld"
			weld.Part0 = torso
			weld.Part1 = handle
			weld.C0 = SidearmHolsterC0
			weld.C1 = CFrame.new()
			weld.Parent = handle
			state.Weld = weld
		end
	end
	-- IMPORTANT:
	-- DO NOT CREATE ANY WELD HERE.
	-- Leave welding 100% to AttachToHand / AttachToHolster.

	return model, attachPart, slot
end



local function AttachToHand(player, slot)
	local state = ServerWeaponState[player] and ServerWeaponState[player][slot]
	if not state or not state.Model then return end

	local handle = state.Model:FindFirstChild("Handle")
	if not handle then return end

	local char = player.Character
	local armName = state.Data.AttachmentPart or "Right Arm"
	local newArm = char:FindFirstChild(armName)

	-- fallback if missing
	if not newArm then
		newArm = char:FindFirstChild("Left Arm")
	end

	state.AttachmentPart = newArm
	state.Equipped = true

	if state.Weld then state.Weld:Destroy() end

	local weld = Instance.new("Motor6D")
	weld.Name = "WeaponWeld"
	weld.Part0 = state.AttachmentPart
	weld.Part1 = handle
	weld.C0 = HandC0
	weld.C1 = CFrame.new()
	weld.Parent = handle
	state.Weld = weld

	CoreRemote:FireClient(player, "Equipped", {
		Slot = slot,
		WeaponName = state.WeaponName,
		Ammo = state.Ammo,
		Data = state.Data,
		AttachmentPart = state.Data.AttachmentPart,
	})
end

local function AttachToHolster(player, slot)
	local state = ServerWeaponState[player] and ServerWeaponState[player][slot]
	if not state or not state.Model then return end

	local handle = state.Model:FindFirstChild("Handle")
	if not handle then return end

	state.Equipped = false

	-- Secondary = torso holster
	if slot == "Secondary" then
		local torso = player.Character:FindFirstChild("UpperTorso") or player.Character:FindFirstChild("Torso")
		if not torso then return end

		if state.Weld then state.Weld:Destroy() end

		local weld = Instance.new("Motor6D")
		weld.Name = "WeaponWeld"
		weld.Part0 = torso
		weld.Part1 = handle
		weld.C0 = SidearmHolsterC0
		weld.C1 = CFrame.new()
		weld.Parent = handle
		state.Weld = weld

	else
		-- Primary = backpack logic (ALWAYS RE-FETCH BACKPACK_LP)
		local char = player.Character
		local backpack = char:FindFirstChild("Backpack")

		if backpack then
			local testBP = backpack:FindFirstChild("TestBP")
			local lp = testBP and testBP:FindFirstChild("Backpack_LP")
			if lp then
				state.HolsterPart = lp
			else
				-- If not found, force WaitForBackpack (guaranteed)
				state.HolsterPart = WaitForBackpack(player)
			end
		else
			state.HolsterPart = WaitForBackpack(player)
		end

		if state.Weld then state.Weld:Destroy() end

		local weld = Instance.new("Motor6D")
		weld.Name = "WeaponWeld"
		weld.Part0 = state.HolsterPart
		weld.Part1 = handle
		weld.C0 = BackpackC0
		weld.C1 = CFrame.new()
		weld.Parent = handle
		state.Weld = weld
	end

	CoreRemote:FireClient(player, "Holstered", { Slot = slot })
end

local ALLOWED_LIMBS = {
	Head = true,
	Torso = true,
	["Left Arm"] = true,
	["Right Arm"] = true,
	["Left Leg"] = true,
	["Right Leg"] = true,
}

local function ProcessHit(player, targetPos, state)
	local char = player.Character
	if not char or not char:FindFirstChild("Head") then return end

	local origin = char.Head.Position
	local direction = (targetPos - origin)
	local dist = direction.Magnitude
	direction = direction.Unit

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {player.Character, state.Model}
	params.FilterType = Enum.RaycastFilterType.Exclude

	local result = workspace:Raycast(origin, direction * dist, params)
	if not result then return end

	local part = result.Instance
	if not ALLOWED_LIMBS[part.Name] then
		return -- ignore everything except the allowed limbs
	end

	local model = part:FindFirstAncestorOfClass("Model")
	if not model then return end

	local hum = model:FindFirstChild("Humanoid")
	if not hum or hum.Health <= 0 then return end

	-- Damage calculation
	local damage = state.Data.Base.Damage.Body
	if part.Name == "Head" then
		damage = state.Data.Base.Damage.Head
	end

	hum:TakeDamage(damage)

	
	CoreRemote:FireClient(player, "HitMarker", {
		HitPart = part.Name,
		Damage = damage,
		Target = model.Name,
	})
end
CoreRemote.OnServerEvent:Connect(function(player, action, payload)
	local profile = GetProfileForPlayer(player)
	if not profile then return end

	if action == "Equip" then
		local weaponName = payload.WeaponName
		local mod = LoadWeaponModule(weaponName)
		if mod then
			local _, _, slot = GetOrSpawnWeapon(player, weaponName, mod)
			AttachToHand(player, slot)
		end

	elseif action == "Unequip" then
		local slot = payload and payload.Slot
		if not slot then
			warn("[Unequip] Missing slot!")
			return
		end

		local playerState = ServerWeaponState[player]
		if not playerState then return end

		local state = playerState[slot]
		if not state then
			warn("[Unequip] No state for slot:", slot)
			return
		end

		state.Equipped = false

		-- DO NOT holster yet â€” wait for FinishUnequip animation from client
		CoreRemote:FireClient(player, "Unequipped", {
			Slot = slot
		})
	elseif action == "FinishUnequip" then
		local slot = payload and payload.Slot
		if not slot then
			warn("[FinishUnequip] Missing payload.Slot from client!")
			return
		end

		-- Validate slot
		if slot ~= "Primary" and slot ~= "Secondary" then
			warn("[FinishUnequip] Invalid slot from client:", slot)
			return
		end

		local playerState = ServerWeaponState[player]
		if not playerState then
			warn("[FinishUnequip] No weapon state for", player.Name)
			return
		end

		local state = playerState[slot]
		if not state then
			warn("[FinishUnequip] No state found for slot:", slot)
			return
		end

		-- Set equipped false CORRECTLY
		state.Equipped = false

		-- Move weapon into holster
		AttachToHolster(player, slot)

		-- Stop leftover animations
		local char = player.Character
		local hum = char and char:FindFirstChild("Humanoid")

		if hum then
			for _, t in ipairs(hum:GetPlayingAnimationTracks()) do
				if
					t.Priority == Enum.AnimationPriority.Action or
					t.Priority == Enum.AnimationPriority.Action2 or
					t.Priority == Enum.AnimationPriority.Action3 or
					t.Priority == Enum.AnimationPriority.Action4
				then
					t:Stop(0.1)
				end
			end
		end

	elseif action == "Shoot" then
		local slot = payload.Slot
		if not slot then return end
		local playerState = ServerWeaponState[player]
		if not playerState then return end

		local state = playerState[slot]
		if not state or not state.Model or not state.Equipped then return end

		if state.Ammo and state.Ammo > 0 then
			local clientTargetPos = payload.TargetPosition
			if not clientTargetPos then return end

			local char = player.Character
			local head = char and char:FindFirstChild("Head")
			if not head then return end

			local maxDist = state.Data.Base.MaxDistance or 2000
			local origin = head.Position
			local dist = (clientTargetPos - origin).Magnitude

			if dist > maxDist + 20 then
				return 
			end

			local raycastParams = RaycastParams.new()
			raycastParams.FilterDescendantsInstances = {char, state.Model}
			raycastParams.FilterType = Enum.RaycastFilterType.Exclude

			local direction = (clientTargetPos - origin).Unit * dist
			local hitResult = workspace:Raycast(origin, direction, raycastParams)

			if hitResult and (hitResult.Position - clientTargetPos).Magnitude > 5 then
				return
			end

			state.Ammo -= 1

			ProcessHit(player, clientTargetPos, state)

			local weaponModel = state.Model
			local handle = weaponModel:FindFirstChild("Handle")
			local muzzle = handle and handle:FindFirstChild("MuzzleFX")
			local originPos = muzzle and muzzle.WorldPosition or head.Position

			CoreRemote:FireAllClients("Shot", {
				Player = player,
				WeaponName = state.WeaponName,
				Ammo = state.Ammo,
				Payload = payload,
				Origin = originPos     
			})
		else
			CoreRemote:FireClient(player, "DryFire", {})
		end

	elseif action == "Reload" then
		local slot = payload.Slot
		if not slot then return end

		local playerState = ServerWeaponState[player]
		local state = playerState and playerState[slot]
		if not state then return end

		state.Ammo = state.Data.Base.MagSize

		CoreRemote:FireAllClients("Reloaded", {
			Player = player,
			WeaponName = state.WeaponName,
			Ammo = state.Ammo,
			Slot = slot
		})


	elseif action == "ShoulderSwap" then
		CoreRemote:FireClient(player, "ShoulderSwap")
	end
end)

Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(char)

		-- wait for profile
		local profile
		for i = 1, 10 do
			profile = GetProfileForPlayer(player)
			if profile then break end
			task.wait(0.2)
		end
		if not profile then
			warn("[PlayerAdded] profile missing for", player.Name)
			return
		end

		-- wait backpack
		local ok = pcall(function()
			return WaitForBackpack(player)
		end)
		if not ok then
			warn("[PlayerAdded] WaitForBackpack failed for", player.Name)
		end

		local inv = profile.Data
			and profile.Data.Inventory
			and profile.Data.Inventory.Weapons

		if not inv then
			warn("[PlayerAdded] no inventory weapons for", player.Name)
			return
		end

		ServerWeaponState[player] = {
			Primary = nil,
			Secondary = nil,
		}

		----------------------------------------------------------
		-- FUNCTION TO SPAWN ANY WEAPON + SEND HOLSTER TO CLIENT
		----------------------------------------------------------
		local function SpawnWeapon(weaponName)
			local mod = LoadWeaponModule(weaponName)
			if not mod then
				warn("[PlayerAdded] weapon module missing:", weaponName, "for", player.Name)
				return
			end

			local model, attach, slot = GetOrSpawnWeapon(player, weaponName, mod)
			if not model then return end

			AttachToHolster(player, slot)

			local playerState = ServerWeaponState[player]
			local state = playerState and playerState[slot]

			if state then
				CoreRemote:FireClient(player, "Holstered", {
					Slot = slot,
					WeaponName = state.WeaponName,
					Ammo = state.Ammo,
					Data = state.Data,               -- FULL module, not Base
					AttachmentPart = state.Data.AttachmentPart,
				})
			end
		end

		----------------------------------------------------------
		-- SPAWN PRIMARY
		----------------------------------------------------------
		if inv.Primary then
			SpawnWeapon(inv.Primary)
		end

		----------------------------------------------------------
		-- SPAWN SECONDARY
		----------------------------------------------------------
		if inv.Secondary then
			SpawnWeapon(inv.Secondary)
		end

	end)
end)



Players.PlayerRemoving:Connect(function(player)
	local state = ServerWeaponState[player]
	if state then
		if state.Primary and state.Primary.Model then
			state.Primary.Model:Destroy()
		end
		if state.Secondary and state.Secondary.Model then
			state.Secondary.Model:Destroy()
		end
	end
	ServerWeaponState[player] = nil
end)
--// END OF SCRIPT: game.ServerScriptService.Server | weapon
  -  Edit
  18:44:47.001  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.ServerScriptService.Flashlight | Enabled: true
--------------------------------------------------------------------
local PhysicsService = game:GetService("PhysicsService")
local Players = game:GetService("Players")

local FLASHLIGHT_GROUP = "Flashlight"
local CHARACTER_GROUP = "Character"

-- Create a collision group if it doesnâ€™t exist
local function ensureGroupExists(name)
	for _, group in PhysicsService:GetRegisteredCollisionGroups() do
		if group.name == name then
			return
		end
	end
	PhysicsService:RegisterCollisionGroup(name)
end

-- Ensure groups exist
ensureGroupExists(FLASHLIGHT_GROUP)
ensureGroupExists(CHARACTER_GROUP)

-- Set rules:
-- Flashlight should NEVER collide with character parts
PhysicsService:CollisionGroupSetCollidable(FLASHLIGHT_GROUP, CHARACTER_GROUP, false)
PhysicsService:CollisionGroupSetCollidable(CHARACTER_GROUP, FLASHLIGHT_GROUP, false)

-- Flashlight SHOULD collide with the world
PhysicsService:CollisionGroupSetCollidable(FLASHLIGHT_GROUP, "Default", true)


Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)

		-- Put all character BaseParts into "Character" group
		for _, d in ipairs(character:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CollisionGroup = CHARACTER_GROUP
			end
		end

		-- Clone flashlight core
		local coreClone = script:WaitForChild("FLCore"):Clone()
		coreClone.Parent = character
		coreClone.Enabled = true

		-- Put all flashlight BaseParts into "Flashlight" group
		for _, d in ipairs(coreClone:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CollisionGroup = FLASHLIGHT_GROUP
			end
		end
	end)
end)

--// END OF SCRIPT: game.ServerScriptService.Flashlight

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.ServerScriptService.Flashlight.FLCore | Enabled: false
--------------------------------------------------------------------
local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")

local FlashlightModule = require(script:WaitForChild("FlashlightModule"))

local UIS = game:GetService("UserInputService")
local CAS = game.ContextActionService

local On = false
local db = false

local function Emission()
	if db then return end
	db = true

	if Humanoid.Health > 0 then
		On = not On

		if On then
			FlashlightModule.CreateFlashlight(Character)
			CAS:SetTitle("Flashlight", "Off")
		else
			FlashlightModule.RemoveFlashlight(Character)
			CAS:SetTitle("Flashlight", "On")
		end
	end

	task.wait(0.25)
	db = false
end

Humanoid.Died:Connect(function()
	if On then
		FlashlightModule.RemoveFlashlight(Character)
	end
end)

CAS:BindAction("Flashlight", Emission, true, Enum.KeyCode.F)
CAS:SetPosition("Flashlight", UDim2.new(0.2, 105, 0.2, 0))
CAS:SetTitle("Flashlight", "Off")

--// END OF SCRIPT: game.ServerScriptService.Flashlight.FLCore

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ServerScriptService.Flashlight.FLCore.FlashlightModule | Enabled: N/A
--------------------------------------------------------------------
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")

local FlashlightModule = {
	Lerp = false,
	LerpSpeed = 0.6,
	TweenSpeed = 0.11,

	LightPart = nil,
	UpdateConnection = nil,
	FromAttach = nil,
	
	OnSound = "rbxassetid://89707816463137",
	OffSound = "rbxassetid://78509455631020",
	

	_onSoundObj = nil,
	_offSoundObj = nil,
}

local function GetSound(parent, soundId)
	local s = Instance.new("Sound")
	s.SoundId = soundId
	s.Volume = 1
	s.RollOffMaxDistance = 45
	s.Parent = parent

	-- Preload so Play() never fails
	ContentProvider:PreloadAsync({s})

	return s
end

-------------------------------------------------------
-- GET FLASHLIGHT ATTACHMENT
-------------------------------------------------------
local function GetFlashlightAttachment(character)
	local backpackModel = character:FindFirstChild("Backpack")
	if not backpackModel then return end

	local testBP = backpackModel:FindFirstChild("TestBP")
	if not testBP then return end

	local bpLP = testBP:FindFirstChild("Backpack_LP")
	if not bpLP then return end

	local flashlight = bpLP:FindFirstChild("Flashlight")
	if not flashlight then return end

	local fromAttach = flashlight:FindFirstChild("From")
	if not fromAttach or not fromAttach:IsA("Attachment") then return end

	return fromAttach, flashlight
end

-------------------------------------------------------
-- CREATE FLASHLIGHT (Only runs once)
-------------------------------------------------------
FlashlightModule.CreateFlashlight = function(character)
	
	if FlashlightModule.LightPart then
		FlashlightModule.LightPart.Light.Enabled = true
		FlashlightModule.LightPart.Ring.Transparency = 0.747

		if FlashlightModule._onSoundObj then
			FlashlightModule._onSoundObj:Play()
		end
		return
	end

	local fromAttach, flashlightPart = GetFlashlightAttachment(character)
	if not fromAttach then
		return warn("FlashlightModule: Could not locate flashlight attachment.")
	end
	FlashlightModule.FromAttach = fromAttach

	local LightPart = script:WaitForChild("LightPart"):Clone()
	FlashlightModule.LightPart = LightPart

	local Ring = LightPart.Ring
	local Light = LightPart.Light

	LightPart.Parent = Camera
	LightPart.CFrame = fromAttach.WorldCFrame

	Light.Enabled = true
	Ring.Transparency = 0.747

	-- Create ON sound once & preload
	if not FlashlightModule._onSoundObj then
		FlashlightModule._onSoundObj = GetSound(flashlightPart, FlashlightModule.OnSound)
	end
	FlashlightModule._onSoundObj:Play()

	-- Update loop
	if FlashlightModule.UpdateConnection then
		FlashlightModule.UpdateConnection:Disconnect()
	end

	FlashlightModule.UpdateConnection = RunService.RenderStepped:Connect(function(dt)
		if not FlashlightModule.LightPart or not FlashlightModule.FromAttach then return end

		local light = FlashlightModule.LightPart
		local attach = FlashlightModule.FromAttach

		-- POSITION ALWAYS EXACT (no delay)
		local origin = attach.WorldPosition

		-- Desired facing direction (toward mouse/camera)
		local desiredCF = CFrame.lookAt(origin, origin + Camera.CFrame.LookVector)

		-- Extract rotation only
		local currentCF = light.CFrame
		local currentRot = currentCF - currentCF.Position
		local desiredRot = desiredCF - desiredCF.Position

		-- Smooth rotation only (LERP)
		local alpha = 1 - math.exp(-20 * dt) -- super smooth
		local smoothedRot = currentRot:Lerp(desiredRot, alpha)

		-- Apply back to the correct position
		light.CFrame = smoothedRot + origin
	end)


end

-------------------------------------------------------
-- TURN FLASHLIGHT OFF (no destruction)
-------------------------------------------------------
FlashlightModule.RemoveFlashlight = function(character)
	if not FlashlightModule.LightPart then return end

	FlashlightModule.LightPart.Light.Enabled = false
	FlashlightModule.LightPart.Ring.Transparency = 1

	if not FlashlightModule._offSoundObj then
		FlashlightModule._offSoundObj = GetSound(character, FlashlightModule.OffSound)
	end

	FlashlightModule._offSoundObj:Play()
end


return FlashlightModule

--// END OF SCRIPT: game.ServerScriptService.Flashlight.FLCore.FlashlightModule

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.ServerScriptService.Overseer.Clients.Data | Enabled: true
--------------------------------------------------------------------
--- @ CORE DATA 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Peak = ReplicatedStorage:WaitForChild("Peak")
local Remotes = Peak:WaitForChild("Remotes")
local Modules = Peak:WaitForChild("Modules")
local ClientModules = Modules:WaitForChild("Client")
local Helpers = ClientModules:WaitForChild("Helpers")
local AssetsFolder = Peak:WaitForChild("Assets")

local Clothing = AssetsFolder:WaitForChild("Clothing")
local PlayerClothing = Clothing:WaitForChild("Player")
local Backpacks = PlayerClothing:WaitForChild("Backpacks")

local DataEvent = Remotes:WaitForChild("DataEvent")
local DebugEvent = Remotes:WaitForChild("DebugInventory")

local DataUtils = require(Modules:WaitForChild("DataHelper"))
local PlayerDataModule = require(Modules:WaitForChild("PlayerData"))
local CosmeticLoader = require(Helpers:WaitForChild("ClothingLoading"))

local ProfileService = require(game.ServerScriptService.Overseer.Modules:WaitForChild("ProfileService"))
local PlayerStore = ProfileService.GetProfileStore("PlayerData18", PlayerDataModule.DefaultPlayerData)

local Profiles = {}
_G.Profiles = Profiles
local SAVEONLEAVE = true

local function WaitForCharacter(player)
	if player.Character and player.Character.Parent then
		return player.Character
	end
	local char = player.CharacterAdded:Wait()
	return char
end

local function LoadProfile(player)
	local key = "Player_" .. player.UserId
	local profile
	local tries = 0

	repeat
		tries += 1
		profile = PlayerStore:LoadProfileAsync(key)

		if not profile then
			warn("[ProfileService] FAILED load for", player.Name, " try:", tries)
			task.wait(0.5)
		end

		if tries >= 10 and not profile then
			player:Kick("Data failed to load after multiple attempts")
			return nil
		end
	until profile

	---------------------------------------------------
	-- VALID PROFILE RECEIVED
	---------------------------------------------------
	profile:AddUserId(player.UserId)
	profile:Reconcile()

	if not profile.Data then
		warn("[PROFILE ERROR] Missing .Data for", player.Name)
		profile.Data = PlayerDataModule.DefaultPlayerData
	end

	profile:ListenToRelease(function()
		pcall(function()
			player:Kick("Your data was released â€” please rejoin.")
		end)
	end)

	Profiles[player] = profile
	return profile
end

local function LoadPlayerCosmetics(player, profile)
	local char = player.Character or player.CharacterAdded:Wait()

	char:WaitForChild("Humanoid")
	char:WaitForChild("Torso", 1)

	task.wait(0.25) -- ensure replication
	CosmeticLoader.LoadCosmetics(player, profile.Data)
end

Players.PlayerAdded:Connect(function(player)
	print(">> Loading Profile for", player.Name)

	local profile = LoadProfile(player)
	if not profile then
		return
	end

	-- Send inventory to client for debug panel
	task.defer(function()
		DebugEvent:FireClient(player, profile.Data.Inventory)
	end)

	-- Load cosmetics after character spawns
	player.CharacterAdded:Connect(function(newChar)
		newChar.Parent = workspace.Game.Characters
		task.defer(function()
			if Profiles[player] then
				LoadPlayerCosmetics(player, profile)
			end
		end)
	end)

	-- If character spawned too early
	if player.Character then
		task.defer(function()
			if Profiles[player] then
				LoadPlayerCosmetics(player, profile)
			end
		end)
	end

	print("[ProfileService] Finished loading data for", player.Name)
end)


Players.PlayerRemoving:Connect(function(player)
	local profile = Profiles[player]
	if profile then
		if SAVEONLEAVE then
			profile:Release()
		else
			warn("[DATA] SAVE DISABLED â€” Not saving for", player.Name)
		end
		Profiles[player] = nil
	end
end)


-- Remote event handling
DataEvent.OnServerEvent:Connect(function(player, action, path, value)
	local profile = Profiles[player]
	if not profile or not profile.Data then
		warn("[DataEvent] NO profile for", player.Name)
		return
	end

	if action == "Add" then
		DataUtils.Add(profile, path, value)
	elseif action == "Remove" then
		DataUtils.Remove(profile, path, value)
	else
		warn("[DataEvent] Unknown action", action)
	end

	task.defer(function()
		DebugEvent:FireClient(player, profile.Data.Inventory)
	end)
end)
--// END OF SCRIPT: game.ServerScriptService.Overseer.Clients.Data

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.ServerScriptService.Overseer.Server.Players.Framework | Enabled: true
--------------------------------------------------------------------
local Replicated = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")

	local existingAnimator = humanoid:FindFirstChildOfClass("Animator")
	if existingAnimator then
		existingAnimator:Destroy()
	end

	local animator = Instance.new("Animator")
	animator.Name = "Animator"
	animator.Parent = humanoid

	local defaultAnimate = character:WaitForChild("Animate")
	if defaultAnimate then
		defaultAnimate:Destroy()
	end
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterAdded)
	if player.Character then
		onCharacterAdded(player.Character)
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)

for _, player in ipairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
--// END OF SCRIPT: game.ServerScriptService.Overseer.Server.Players.Framework

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ServerScriptService.Overseer.Modules.ProfileService | Enabled: N/A
--------------------------------------------------------------------
-- local Madwork = _G.Madwork
--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
		
	Members:
	
		ProfileService.ServiceLocked         [bool]
		
		ProfileService.IssueSignal           [ScriptSignal] (error_message, profile_store_name, profile_key)
		ProfileService.CorruptionSignal      [ScriptSignal] (profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state)
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]
			profile_store_index   [string] -- DataStore name
			OR
			profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables
				{
					Name = "StoreName", -- [string] -- DataStore name
					-- Optional arguments:
					Scope = "StoreScope", -- [string] -- DataStore scope
				}
			profile_template      [table] -- Profiles will default to given table (hard-copy) when no data was saved previously

		ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)
			-- Returns true if ProfileService is connected to live Roblox DataStores
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile] or nil -- not_released_handler(place_id, game_job_id)
			profile_key            [string] -- DataStore key
			not_released_handler   nil or []: -- Defaults to "ForceLoad"
				[string] "ForceLoad" -- Force loads profile on first call
				OR
				[string] "Steal" -- Steals the profile ignoring it's session lock
				OR
				[function] (place_id, game_job_id) --> [string] "Repeat", "Cancel", "ForceLoad" or "Steal"
					place_id      [number] or nil
					game_job_id   [string] or nil

				-- not_released_handler [function] will be triggered in cases where the profile is not released by a session. This
				--	function may yield for as long as desirable and must return one of three string values:

						["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
						["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
						["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
							and release the profile for another session that has loaded the profile
						["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
							a session lock for this session.

		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates] or nil
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
			profile_key      [string] -- DataStore key
			update_handler   [function] (global_updates [GlobalUpdates])
			
		ProfileStore:ViewProfileAsync(profile_key, version) --> [Profile] or nil
			-- Reads profile without requesting a session lock; Data will not be saved and profile doesn't need to be released
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --> [ProfileVersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool]
			-- Completely wipes out profile data from the DataStore / mock DataStore with no way to recover it.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)

	Methods [ProfileVersionQuery]:

		ProfileVersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile has the same rules as profile returned by :ViewProfileAsync()
		
	Members [Profile]:
	
		Profile.Data              [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData          [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)

		Profile.MetaTagsUpdated   [ScriptSignal] (meta_tags_latest) -- Fires after every auto-save, after
			--	Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved;
			--  .MetaTagsUpdated will fire regardless of whether .MetaTagsLatest changed after update;
			--	.MetaTagsUpdated may fire after the Profile is released - changes to Profile.Data are not saved
			--	after release.

		Profile.RobloxMetaData    [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds           [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo           [DataStoreKeyInfo]
		Profile.KeyInfoUpdated    [ScriptSignal] (key_info [DataStoreKeyInfo])
		
		Profile.GlobalUpdates     [GlobalUpdates]
		
	Methods [Profile]:
	
		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to
			
		Profile:GetMetaTag(tag_name) --> value [any]
			tag_name   [string]
		
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
		
		Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
			-- WARNING: Profiles can be released externally if another session force-loads
			--	this profile - use :ListenToRelease() to handle player leaving cleanup.
			
		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)

		Profile:ListenToHopReady(listener) --> [ScriptConnection] () -- Passed listener will be executed after the releasing UpdateAsync call finishes;
			--	Wrap universe teleport requests with this method AFTER releasing the profile to improve session lock sharing between universe places;
			--  :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a release happens
			--	next to an auto-update in regular usage scenarios.

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)
			user_id   [number]

		Profile:Identify() --> [string] -- Returns a string containing DataStore name, scope and key; Used for debug;
			-- Example return: "[Store:"GameData";Scope:"Live";Key:"Player_2312310"]"
		
		Profile:SetMetaTag(tag_name, value) -- Equivalent of Profile.MetaData.MetaTags[tag_name] = value
			tag_name   [string]
			value      [any]
		
		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)

		-- VIEW-MODE ONLY:

		Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

		Profile:OverwriteAsync() -- (Yields) Saves the profile payload to the DataStore and removes the session lock
		
	Methods [GlobalUpdates]:
	
	-- ALWAYS PUBLIC:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data [table]}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data [table]}, ...}
		
	-- ONLY WHEN FROM "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:LockActiveUpdate(update_id)  -- WARNING: will error after profile expires
		GlobalUpdates:ClearLockedUpdate(update_id) -- WARNING: will error after profile expires
		
	-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
			update_data   [table]
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
			update_data   [table]
		GlobalUpdates:ClearActiveUpdate(update_id)
		
--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	RobloxWriteCooldown = 7, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 8, -- Steps taken before ForceLoad request steals the active session for a profile
	AssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead
		-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.
	
	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds
	
	MetaTagsUpdatedValues = { -- Technical stuff - do not alter
		ProfileCreateTime = true,
		SessionLoadCount = true,
		ActiveSession = true,
		ForceLoadSession = true,
		LastUpdate = true,
	},
	
}

local Madwork -- Standalone Madwork reference for portable version of ProfileService
do

	local MadworkScriptSignal = {}

	local FreeRunnerThread = nil
	
	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		FreeRunnerThread = acquired_runner_thread
	end
	
	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end
	
	-- ScriptConnection object:

	local ScriptConnection = {
		--[[
			_listener = listener,
			_script_signal = script_signal,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,
			
			_next = next_script_connection,
			_is_connected = is_connected,
		--]]
	}
	ScriptConnection.__index = ScriptConnection

	function ScriptConnection:Disconnect()

		if self._is_connected == false then
			return
		end

		self._is_connected = false
		self._script_signal._listener_count -= 1

		if self._script_signal._head == self then
			self._script_signal._head = self._next
		else
			local prev = self._script_signal._head
			while prev ~= nil and prev._next ~= self do
				prev = prev._next
			end
			if prev ~= nil then
				prev._next = self._next
			end
		end

		if self._disconnect_listener ~= nil then
			if not FreeRunnerThread then
				FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
			end
			task.spawn(FreeRunnerThread, self._disconnect_listener, self._disconnect_param)
			self._disconnect_listener = nil
		end

	end
	
	-- ScriptSignal object:

	local ScriptSignal = {
		--[[
			_head = nil,
			_listener_count = 0,
		--]]
	}
	ScriptSignal.__index = ScriptSignal

	function ScriptSignal:Connect(listener, disconnect_listener, disconnect_param) --> [ScriptConnection]

		local script_connection = {
			_listener = listener,
			_script_signal = self,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,

			_next = self._head,
			_is_connected = true,
		}
		setmetatable(script_connection, ScriptConnection)

		self._head = script_connection
		self._listener_count += 1

		return script_connection

	end

	function ScriptSignal:GetListenerCount() --> [number]
		return self._listener_count
	end

	function ScriptSignal:Fire(...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item._listener, ...)
			end
			item = item._next
		end
	end

	function ScriptSignal:FireUntil(continue_callback, ...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				item._listener(...)
				if continue_callback() ~= true then
					return
				end
			end
			item = item._next
		end
	end

	function MadworkScriptSignal.NewScriptSignal() --> [ScriptSignal]
		return {
			_head = nil,
			_listener_count = 0,
			Connect = ScriptSignal.Connect,
			GetListenerCount = ScriptSignal.GetListenerCount,
			Fire = ScriptSignal.Fire,
			FireUntil = ScriptSignal.FireUntil,
		}
	end

	-- Madwork framework namespace:
	
	Madwork = {
		NewScriptSignal = MadworkScriptSignal.NewScriptSignal,
		ConnectToOnClose = function(task, run_in_studio_mode)
			if game:GetService("RunService"):IsStudio() == false or run_in_studio_mode == true then
				game:BindToClose(task)
			end
		end,
	}

end

----- Service Table -----

local ProfileService = {

	ServiceLocked = false, -- Set to true once the server is shutting down

	IssueSignal = Madwork.NewScriptSignal(), -- (error_message, profile_store_name, profile_key) -- Fired when a DataStore API call throws an error
	CorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
	-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value

	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true
	-- (You may alert players with this, or set up analytics)

	ServiceIssueCount = 0,

	_active_profile_stores = {}, -- {profile_store, ...}

	_auto_save_list = {}, -- {profile, ...} -- loaded profile table which will be circularly auto-saved

	_issue_queue = {}, -- [table] {issue_time, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / os.clock() = critical state start

	-- Debug:
	_mock_data_store = {},
	_user_mock_data_store = {},

	_use_mock_data_store = false,

}

--[[
	Saved profile structure:
	
	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
			LastUpdate = 0, -- os.time()
		},
		RobloxMetaData = {},
		UserIds = {},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
	
	OR
	
	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local IsLiveCheckActive = false

local UseMockDataStore = false
local MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled

local UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock
local UseMockTag = {}

local CustomWriteQueue = {
	--[[
		[store] = {
			[key] = {
				LastWrite = os.clock(),
				Queue = {callback, ...},
				CleanupJob = nil,
			},
			...
		},
		...
	--]]
}

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

----- Private functions -----

local function IdentifyProfile(store_name, store_scope, key)
	return string.format(
		"[Store:\"%s\";%sKey:\"%s\"]",
		store_name,
		store_scope ~= nil and string.format("Scope:\"%s\";", store_scope) or "",
		key
	)
end

local function CustomWriteQueueCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		CustomWriteQueue[store][key] = nil
		if next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueMarkForCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		if CustomWriteQueue[store][key] ~= nil then

			local queue_data = CustomWriteQueue[store][key]
			local queue = queue_data.Queue

			if queue_data.CleanupJob == nil then

				queue_data.CleanupJob = RunService.Heartbeat:Connect(function()
					if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
						queue_data.CleanupJob:Disconnect()
						CustomWriteQueueCleanup(store, key)
					end
				end)

			end

		elseif next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueAsync(callback, store, key) --> ... -- Passed return from callback

	if CustomWriteQueue[store] == nil then
		CustomWriteQueue[store] = {}
	end
	if CustomWriteQueue[store][key] == nil then
		CustomWriteQueue[store][key] = {LastWrite = 0, Queue = {}, CleanupJob = nil}
	end

	local queue_data = CustomWriteQueue[store][key]
	local queue = queue_data.Queue

	-- Cleanup job:

	if queue_data.CleanupJob ~= nil then
		queue_data.CleanupJob:Disconnect()
		queue_data.CleanupJob = nil
	end

	-- Queue logic:

	if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
		queue_data.LastWrite = os.clock()
		return callback()
	else
		table.insert(queue, callback)
		while true do
			if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and queue[1] == callback then
				table.remove(queue, 1)
				queue_data.LastWrite = os.clock()
				return callback()
			end
			task.wait()
		end
	end

end

local function IsCustomWriteQueueEmptyFor(store, key) --> is_empty [bool]
	local lookup = CustomWriteQueue[store]
	if lookup ~= nil then
		lookup = lookup[key]
		return lookup == nil or #lookup.Queue == 0
	end
	return true
end

local function WaitForLiveAccessCheck() -- This function was created to prevent the ProfileService module yielding execution when required
	while IsLiveCheckActive == true do
		task.wait()
	end
end

local function WaitForPendingProfileStore(profile_store)
	while profile_store._is_pending == true do
		task.wait()
	end
end

local function RegisterIssue(error_message, store_name, store_scope, profile_key) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error " .. IdentifyProfile(store_name, store_scope, profile_key) .. " - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterCorruption(store_name, store_scope, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Resolved profile corruption " .. IdentifyProfile(store_name, store_scope, profile_key))
	ProfileService.CorruptionSignal:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = transform
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data),
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock, is_get_call, version) --> loaded_data, key_info
	local loaded_data, key_info
	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local data_corrupted = false
			local global_updates_data = {0, {}}

			if latest_data == nil then
				missing_profile = true
			elseif type(latest_data) ~= "table" then
				missing_profile = true
				data_corrupted = true
			end

			if type(latest_data) == "table" then
				-- Case #1: Profile was loaded
				if type(latest_data.Data) == "table"
					and type(latest_data.MetaData) == "table"
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					if update_settings.ExistingProfileHandle ~= nil then
						update_settings.ExistingProfileHandle(latest_data)
					end
					-- Case #2: Profile was not loaded but GlobalUpdate data exists
				elseif latest_data.Data == nil
					and latest_data.MetaData == nil
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates or global_updates_data
					missing_profile = true
				else
					missing_profile = true
					data_corrupted = true
				end
			end

			-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates_data,
				}
				if update_settings.MissingProfileHandle ~= nil then
					update_settings.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if update_settings.EditProfile ~= nil then
				update_settings.EditProfile(latest_data)
			end

			-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
			if data_corrupted == true then
				latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end
		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
			loaded_data, key_info = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		elseif UseMockDataStore == true then -- Used when API access is disabled
			loaded_data, key_info = MockUpdateAsync(MockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		else
			loaded_data, key_info = CustomWriteQueueAsync(
				function() -- Callback
					if is_get_call == true then
						local get_data, get_key_info
						if version ~= nil then
							local success, error_message = pcall(function()
								get_data, get_key_info = profile_store._global_data_store:GetVersionAsync(profile_key, version)
							end)
							if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
								warn("[ProfileService]: Passed version argument is not valid; Traceback:\n" .. debug.traceback())
							end
						else
							get_data, get_key_info = profile_store._global_data_store:GetAsync(profile_key)
						end
						get_data = transform_function(get_data)
						return get_data, get_key_info
					else
						return profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
					end
				end,
				profile_store._profile_store_lookup, -- Store
				profile_key -- Key
			)
		end
	end)
	if success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true and is_get_call ~= true then
			RegisterCorruption(
				profile_store._profile_store_name,
				profile_store._profile_store_scope,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		RegisterIssue(
			(error_message ~= nil) and error_message or "Undefined error",
			profile_store._profile_store_name,
			profile_store._profile_store_scope,
			profile_key
		)
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index = table.find(AutoSaveList, profile)
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
	loaded_profiles[profile._profile_key] = nil
	if next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	local place_id
	local game_job_id
	local active_session = profile.MetaData.ActiveSession
	if active_session ~= nil then
		place_id = active_session[1]
		game_job_id = active_session[2]
	end
	profile._release_listeners:Fire(place_id, game_job_id)
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					global_updates_object._new_active_update_listeners:Fire(new_global_update[1], new_global_update[4])
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:

					global_updates_object._new_locked_update_listeners:FireUntil(
						function()
							-- Check if listener marked the update to be cleared:
							-- Normally there should be only one listener per profile for new locked global updates, but
							-- in case several listeners are connected we will not trigger more listeners after one listener
							-- marks the locked global update to be cleared.
							return table.find(pending_update_clear, new_global_update[1]) == nil
						end,
						new_global_update[1], new_global_update[4]
					)

				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session, is_overwriting)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(
			profile._profile_store._profile_store_name,
			profile._profile_store._profile_store_scope,
			profile._profile_key
		)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! Profile: " .. profile:Identify())
	end
	if release_from_session == true and is_overwriting ~= true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local last_session_load_count = profile.MetaData.SessionLoadCount
	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again
	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	while repeat_save_flag == true do
		if release_from_session ~= true then
			repeat_save_flag = false
		end
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			profile._profile_store,
			profile._profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local session_owns_profile = false
					local force_load_pending = false

					if is_overwriting ~= true then
						-- 1) Check if this session still owns the profile: --
						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
						end
						if type(force_load_session) == "table" then
							force_load_pending = not IsThisSession(force_load_session)
						end
					else
						session_owns_profile = true
					end

					if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile

						if is_overwriting ~= true then
							-- 2) Manage global updates: --
							local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							local latest_global_updates_list = latest_global_updates_data[2]

							local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
							local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
							local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
							-- Active update locking:
							for i = 1, #latest_global_updates_list do
								for _, lock_id in ipairs(pending_update_lock) do
									if latest_global_updates_list[i][1] == lock_id then
										latest_global_updates_list[i][3] = true
										break
									end
								end
							end
							-- Locked update clearing:
							for _, clear_id in ipairs(pending_update_clear) do
								for i = 1, #latest_global_updates_list do
									if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then
										table.remove(latest_global_updates_list, i)
										break
									end
								end
							end
						end

						-- 3) Save profile data: --
						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then
							latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
							latest_data.MetaData.LastUpdate = os.time()
							if release_from_session == true or force_load_pending == true then
								latest_data.MetaData.ActiveSession = nil
							end
						else
							latest_data.MetaData = profile.MetaData
							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil
							latest_data.GlobalUpdates = profile.GlobalUpdates._updates_latest
						end

					end
				end,
			},
			profile._is_user_mock
		)
		if loaded_data ~= nil and key_info ~= nil then
			if is_overwriting == true then
				break
			end
			repeat_save_flag = false
			-- 4) Set latest data in profile: --
			-- Updating DataStoreKeyInfo:
			profile.KeyInfo = key_info
			-- Setting global updates:
			local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
			local old_global_updates_data = global_updates_object._updates_latest
			local new_global_updates_data = loaded_data.GlobalUpdates
			global_updates_object._updates_latest = new_global_updates_data
			-- Setting MetaData:
			local session_meta_data = profile.MetaData
			local latest_meta_data = loaded_data.MetaData
			for key in pairs(SETTINGS.MetaTagsUpdatedValues) do
				session_meta_data[key] = latest_meta_data[key]
			end
			session_meta_data.MetaTagsLatest = latest_meta_data.MetaTags
			-- 5) Check if session still owns the profile: --
			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false
			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
			end
			local is_active = profile:IsActive()
			if session_owns_profile == true then
				-- 6) Check for new global updates: --
				if is_active == true then -- Profile could've been released before the saving thread finished
					CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
				end
			else
				-- Session no longer owns the profile:
				-- 7) Release profile if it hasn't been released yet: --
				if is_active == true then
					ReleaseProfileInternally(profile)
				end
				-- Cleanup reference in custom write queue:
				CustomWriteQueueMarkForCleanup(profile._profile_store._profile_store_lookup, profile._profile_key)
				-- Hop ready listeners:
				if profile._hop_ready == false then
					profile._hop_ready = true
					profile._hop_ready_listeners:Fire()
				end
			end
			-- Signaling MetaTagsUpdated listeners after a possible external profile release was handled:
			profile.MetaTagsUpdated:Fire(profile.MetaData.MetaTagsLatest)
			-- Signaling KeyInfoUpdated listeners:
			profile.KeyInfoUpdated:Fire(key_info)
		elseif repeat_save_flag == true then
			task.wait() -- Prevent infinite loop in case DataStore API does not yield
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
		
		_new_active_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		_new_locked_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		
		_profile = Profile / nil, -- [Profile / nil]
		
		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_active_update_listeners:Connect(listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_locked_update_listeners:Connect(listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]
		
		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]
		
		_release_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready = false,
		
		_view_mode = true / nil, -- [bool] or nil
		
		_load_timestamp = os.clock(),
		
		_is_user_mock = false, -- ProfileStore.Mock
		_mock_key_info = {},
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	local loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles
	return loaded_profiles[self._profile_key] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self._profile_store._profile_template)
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self:IsActive() == false then
		-- Call release listener immediately if profile is expired
		local place_id
		local game_job_id
		local active_session = self.MetaData.ActiveSession
		if active_session ~= nil then
			place_id = active_session[1]
			game_job_id = active_session[2]
		end
		listener(place_id, game_job_id)
		return {Disconnect = function() end}
	else
		return self._release_listeners:Connect(listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode - Should you be calling :OverwriteAsync() instead?")
	end
	if self:IsActive() == false then
		warn("[ProfileService]: Attempted saving an inactive profile "
			.. self:Identify() .. "; Traceback:\n" .. debug.traceback())
		return
	end
	-- Reject save request if a save is already pending in the queue - this will prevent the user from
	--	unecessary API request spam which we could not meaningfully execute anyways!
	if IsCustomWriteQueueEmptyFor(self._profile_store._profile_store_lookup, self._profile_key) == true then
		-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
		RemoveProfileFromAutoSave(self)
		AddProfileToAutoSave(self)
		-- Call save function in a new thread:
		task.spawn(SaveProfileAsync, self)
	end
end

function Profile:Release()
	if self._view_mode == true then
		return
	end
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true) -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:ListenToHopReady(listener) --> [ScriptConnection] ()
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToHopReady()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self._hop_ready == true then
		task.spawn(listener)
		return {Disconnect = function() end}
	else
		return self._hop_ready_listeners:Connect(listener)
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :AddUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end

	if user_id < 0 and self._is_user_mock ~= true and UseMockDataStore ~= true then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end
	
end

function Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :RemoveUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end
	
	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:Identify() --> [string]
	return IdentifyProfile(
		self._profile_store._profile_store_name,
		self._profile_store._profile_store_scope,
		self._profile_key
	)
end

function Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

	if self._view_mode ~= true then
		error("[ProfileService]: :ClearGlobalUpdates() can only be used in view mode")
	end

	local global_updates_object = {
		_updates_latest = {0, {}},
		_profile = self,
	}
	setmetatable(global_updates_object, GlobalUpdates)

	self.GlobalUpdates = global_updates_object

end

function Profile:OverwriteAsync() -- Saves the profile to the DataStore and removes the session lock

	if self._view_mode ~= true then
		error("[ProfileService]: :OverwriteAsync() can only be used in view mode")
	end

	SaveProfileAsync(self, nil, true)

end

-- ProfileVersionQuery object:

local ProfileVersionQuery = {
	--[[
		_profile_store = profile_store,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = pages, -- [DataStoreVersionPages]
		_query_index = index, -- [number]
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	--]]
}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery:_MoveQueue()
	while #self._query_queue > 0 do
		local queue_entry = table.remove(self._query_queue, 1)
		task.spawn(queue_entry)
		if self._is_query_yielded == true then
			break
		end
	end
end

function ProfileVersionQuery:NextAsync(_is_stacking) --> [Profile] or nil

	if self._profile_store == nil then
		return nil
	end

	local profile
	local is_finished = false

	local function query_job()

		if self._query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self._query_pages == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)
			
			local list_success, error_message = pcall(function()
				self._query_pages = self._profile_store._global_data_store:ListVersionsAsync(
					self._profile_key,
					self._sort_direction,
					self._min_date,
					self._max_date
				)
				self._query_index = 0
			end)

			if list_success == false or self._query_pages == nil then
				warn("[ProfileService]: Version query fail - " .. tostring(error_message))
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		local current_page = self._query_pages:GetCurrentPage()
		local next_item = current_page[self._query_index + 1]

		-- No more entries:
		
		if self._query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)

			local success = pcall(function()
				self._query_pages:AdvanceToNextPageAsync()
				self._query_index = 0
			end)

			if success == false or #self._query_pages:GetCurrentPage() == 0 then
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		-- Next page item:

		self._query_index += 1
		profile = self._profile_store:ViewProfileAsync(self._profile_key, next_item.Version)
		is_finished = true

	end

	if self._is_query_yielded == false then
		query_job()
	else
		if _is_stacking == true then
			table.insert(self._query_queue, 1, query_job)
		else
			table.insert(self._query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

-- ProfileStore object:

local ProfileStore = {
	--[[
		Mock = {},
	
		_profile_store_name = "", -- [string] -- DataStore name
		_profile_store_scope = nil, -- [string] or [nil] -- DataStore scope
		_profile_store_lookup = "", -- [string] -- _profile_store_name .. "\0" .. (_profile_store_scope or "")
		
		_profile_template = {}, -- [table]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
		
		_loaded_profiles = {[profile_key] = Profile, ...},
		_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
		
		_mock_loaded_profiles = {[profile_key] = Profile, ...},
		_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)

	not_released_handler = not_released_handler or "ForceLoad"

	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" and not_released_handler ~= "Steal" then
		error("[ProfileService]: Invalid not_released_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	local is_user_mock = _use_mock == UseMockTag

	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_lookup == self._profile_store_lookup then
			local loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
			if loaded_profiles[profile_key] ~= nil then
				error("[ProfileService]: Profile " .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) .. " is already loaded in this session")
				-- Are you using Profile:Release() properly?
			end
		end
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = not_released_handler == "ForceLoad"
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	local aggressive_steal = not_released_handler == "Steal" -- Developer invoked steal
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs
		local loaded_data, key_info
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = table.pack(StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									local last_update = latest_data.MetaData.LastUpdate
									if last_update ~= nil then
										if os.time() - last_update > SETTINGS.AssumeDeadSessionLock then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
											return
										end
									end
									if steal_session == true or aggressive_steal == true then
										local force_load_uninterrupted = false
										if force_load_session ~= nil then
											force_load_uninterrupted = IsThisSession(force_load_session)
										end
										if force_load_uninterrupted == true or aggressive_steal == true then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
										end
									elseif request_force_load == true then
										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
						}
					end,
					EditProfile = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							if active_session ~= nil and IsThisSession(active_session) == true then
								latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
								latest_data.MetaData.LastUpdate = os.time()
							end
						end
					end,
				},
				is_user_mock
			))
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},

						_new_active_update_listeners = Madwork.NewScriptSignal(),
						_new_locked_update_listeners = Madwork.NewScriptSignal(),

						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						MetaTagsUpdated = Madwork.NewScriptSignal(),

						RobloxMetaData = loaded_data.RobloxMetaData or {},
						UserIds = loaded_data.UserIds or {},
						KeyInfo = key_info,
						KeyInfoUpdated = Madwork.NewScriptSignal(),

						GlobalUpdates = global_updates_object,

						_profile_store = self,
						_profile_key = profile_key,

						_release_listeners = Madwork.NewScriptSignal(),
						_hop_ready_listeners = Madwork.NewScriptSignal(),
						_hop_ready = false,

						_load_timestamp = os.clock(),

						_is_user_mock = is_user_mock,
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					if is_user_mock == true then
						self._mock_loaded_profiles[profile_key] = profile
					else
						self._loaded_profiles[profile_key] = profile
					end
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if ProfileService.ServiceLocked == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							task.wait() -- Overload prevention
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					elseif aggressive_steal == true then
						task.wait() -- Overload prevention
					else
						local handler_result = not_released_handler(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							task.wait() -- Overload prevention
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							task.wait() -- Overload prevention
						elseif handler_result == "Steal" then
							aggressive_steal = true
							task.wait() -- Overload prevention
						else
							error(
								"[ProfileService]: Invalid return from not_released_handler (\"" .. tostring(handler_result) .. "\")(" .. type(handler_result) .. ");" ..
									"\n" .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) ..
									" Traceback:\n" .. debug.traceback()
							)
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely the ProfileService.ServiceLocked flag was raised
			end
		else
			task.wait() -- Overload prevention
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			},
			_use_mock == UseMockTag
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end

function ProfileStore:ViewProfileAsync(profile_key, version, _use_mock) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	if version ~= nil and (_use_mock == UseMockTag or UseMockDataStore == true) then
		return nil -- No version support in mock mode
	end

	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)
					latest_data.Data = DeepCopyTable(self._profile_template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {},
					}
				end,
				EditProfile = nil,
			},
			_use_mock == UseMockTag,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handle load_data:
		if loaded_data ~= nil then
			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates, -- {0, {}}
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				MetaTagsUpdated = Madwork.NewScriptSignal(),

				RobloxMetaData = loaded_data.RobloxMetaData or {},
				UserIds = loaded_data.UserIds or {},
				KeyInfo = key_info,
				KeyInfoUpdated = Madwork.NewScriptSignal(),

				GlobalUpdates = global_updates_object,

				_profile_store = self,
				_profile_key = profile_key,

				_view_mode = true,

				_load_timestamp = os.clock(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- If loop breaks return nothing
end

function ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date, _use_mock) --> [ProfileVersionQuery]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return setmetatable({}, ProfileVersionQuery) -- Silently fail :Next() requests
	end

	WaitForPendingProfileStore(self)

	if _use_mock == UseMockTag or UseMockDataStore == true then
		error("[ProfileService]: :ProfileVersionQuery() is not supported in mock mode")
	end

	-- Type check:
	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error("[ProfileService]: Invalid sort_direction (" .. tostring(sort_direction) .. ")")
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error("[ProfileService]: Invalid min_date (" .. tostring(min_date) .. ")")
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error("[ProfileService]: Invalid max_date (" .. tostring(max_date) .. ")")
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	local profile_version_query = {
		_profile_store = self,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = nil,
		_query_index = 0,
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	}
	setmetatable(profile_version_query, ProfileVersionQuery)

	return profile_version_query

end

function ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return false
	end

	WaitForPendingProfileStore(self)

	local wipe_status = false

	if _use_mock == UseMockTag then -- Used when the profile is accessed through ProfileStore.Mock
		local mock_data_store = UserMockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	elseif UseMockDataStore == true then -- Used when API access is disabled
		local mock_data_store = MockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	else
		wipe_status = pcall(function()
			self._global_data_store:RemoveAsync(profile_key)
		end)
	end

	CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)

	return wipe_status
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]

	local profile_store_name
	local profile_store_scope = nil

	-- Parsing profile_store_index:
	if type(profile_store_index) == "string" then
		-- profile_store_index as string:
		profile_store_name = profile_store_index
	elseif type(profile_store_index) == "table" then
		-- profile_store_index as table:
		profile_store_name = profile_store_index.Name
		profile_store_scope = profile_store_index.Scope
	else
		error("[ProfileService]: Invalid or missing profile_store_index")
	end

	-- Type checking:
	if profile_store_name == nil or type(profile_store_name) ~= "string" then
		error("[ProfileService]: Missing or invalid \"Name\" parameter")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: ProfileStore name cannot be an empty string")
	end

	if profile_store_scope ~= nil and (type(profile_store_scope) ~= "string" or string.len(profile_store_scope) == 0) then
		error("[ProfileService]: Invalid \"Scope\" parameter")
	end

	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end

	local profile_store
	profile_store = {
		Mock = {
			LoadProfileAsync = function(_, profile_key, not_released_handler)
				return profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)
			end,
			GlobalUpdateProfileAsync = function(_, profile_key, update_handler)
				return profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)
			end,
			ViewProfileAsync = function(_, profile_key, version)
				return profile_store:ViewProfileAsync(profile_key, version, UseMockTag)
			end,
			FindProfileVersionAsync = function(_, profile_key, sort_direction, min_date, max_date)
				return profile_store:FindProfileVersionAsync(profile_key, sort_direction, min_date, max_date, UseMockTag)
			end,
			WipeProfileAsync = function(_, profile_key)
				return profile_store:WipeProfileAsync(profile_key, UseMockTag)
			end
		},

		_profile_store_name = profile_store_name,
		_profile_store_scope = profile_store_scope,
		_profile_store_lookup = profile_store_name .. "\0" .. (profile_store_scope or ""),

		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
		_mock_loaded_profiles = {},
		_mock_profile_load_jobs = {},
		_is_pending = false,
	}
	setmetatable(profile_store, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if IsLiveCheckActive == true then
		profile_store._is_pending = true
		task.spawn(function()
			WaitForLiveAccessCheck()
			if UseMockDataStore == false then
				profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
			end
			profile_store._is_pending = false
		end)
	else
		if UseMockDataStore == false then
			profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
		end
	end

	return profile_store
end

function ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)

	WaitForLiveAccessCheck()

	return UseMockDataStore == false

end

----- Initialize -----

if IsStudio == true then
	IsLiveCheckActive = true
	task.spawn(function()
		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)
		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil
		if no_internet_access == true then
			warn("[ProfileService]: No internet access - check your network connection")
		end
		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			UseMockDataStore = true
			ProfileService._use_mock_data_store = true
			print("[ProfileService]: Roblox API services unavailable - data will not be saved")
		else
			print("[ProfileService]: Roblox API services available - data will be saved")
		end
		IsLiveCheckActive = false
	end)
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile._load_timestamp < SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = os.clock()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
task.spawn(function()
	WaitForLiveAccessCheck()
	Madwork.ConnectToOnClose(
		function()
			ProfileService.ServiceLocked = true
			-- 1) Release all active profiles: --
			-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
			local on_close_save_job_count = 0
			local active_profiles = {}
			for index, profile in ipairs(AutoSaveList) do
				active_profiles[index] = profile
			end
			-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
			for _, profile in ipairs(active_profiles) do
				if profile:IsActive() == true then
					on_close_save_job_count = on_close_save_job_count + 1
					task.spawn(function() -- Save profile on new thread
						SaveProfileAsync(profile, true)
						on_close_save_job_count = on_close_save_job_count - 1
					end)
				end
			end
			-- 2) Yield until all active profile jobs are finished: --
			while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
				task.wait()
			end
			return -- We're done!
		end,
		UseMockDataStore == false -- Always run this OnClose task if using Roblox API services
	)
end)

return ProfileService
--// END OF SCRIPT: game.ServerScriptService.Overseer.Modules.ProfileService

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.ServerScriptService.Overseer.Systems.LeanReplicator | Enabled: true
--------------------------------------------------------------------
--- @ Core System
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage.Peak.Remotes
local ReplicateLean = Remotes.ReplicateLean

--- @ Core System > Logic
ReplicateLean.OnServerEvent:Connect(function(player, bp, br, hp, hr)
	ReplicateLean:FireAllClients(player, bp, br, hp, hr)
end)
--// END OF SCRIPT: game.ServerScriptService.Overseer.Systems.LeanReplicator

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ServerScriptService.Stories.exampleStory.story | Enabled: N/A
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Types = require(ReplicatedStorage.Iris.PubTypes)

return function(parent: GuiObject)
    local Iris: Types.Iris = require(ReplicatedStorage.Iris)
    local Input = require(script.Parent.UserInputService)

    Input.SinkFrame.Parent = parent

    Iris.Internal._utility.UserInputService = Input
    Iris.UpdateGlobalConfig({
        UseScreenGUIs = false,
    })
    Iris.Internal._utility.GuiOffset = Input.SinkFrame.AbsolutePosition
    Iris.Internal._utility.MouseOffset = Input.SinkFrame.AbsolutePosition
    Input.SinkFrame:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
        Iris.Internal._utility.GuiOffset = Input.SinkFrame.AbsolutePosition
        Iris.Internal._utility.MouseOffset = Input.SinkFrame.AbsolutePosition
    end)

    Iris.Init(parent)

    -- Actual Iris code here:
    Iris:Connect(Iris.ShowDemoWindow)

    return function()
        Iris.Shutdown()

        for _, connection in Input._connections do
            connection:Disconnect()
        end

        Input.SinkFrame:Destroy()
    end
end

--// END OF SCRIPT: game.ServerScriptService.Stories.exampleStory.story

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [ModuleScript] Path: game.ServerScriptService.Stories.UserInputService | Enabled: N/A
--------------------------------------------------------------------
local Signal = require(script.Signal)

local UserInputService: UserInputService = game:GetService("UserInputService")

local Input = {}

Input.X = 0
Input.Y = 0
Input.KeyDown = {}
Input._connections = {}

-- This frame will act as our UserInputService detector. Most events should go through it.
-- it's not perfect, but there's not a better alternative (I think)
local SinkFrame: Frame = Instance.new("Frame")
SinkFrame.Name = "SinkFrame"
SinkFrame.AnchorPoint = Vector2.new(0.5, 0.5)
S [trimmed]  -  Edit
  18:44:47.386  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [Script] Path: game.StarterGui.random plugin | Enabled: false
--------------------------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local enabled = true

if plugin then
	local toolbar = plugin:CreateToolbar("UISelect")
	local Button = toolbar:CreateButton("UI Select", "Allows you to select user interface without having to be on the ui layer.", "rbxassetid://7143000156");
	Button:SetActive(enabled)

	Button.Click:Connect(function()
		enabled = not enabled
		Button:SetActive(enabled)
	end)
end


UserInputService.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 and enabled then	
		local position = UserInputService:GetMouseLocation()
		local guis = game.StarterGui:GetGuiObjectsAtPosition(position.X,position.Y)

		guis = (game.Selection:Get()[1] ~= guis[1] and guis[1]) and game.Selection:Set({guis[1]})
	end
end)
--// END OF SCRIPT: game.StarterGui.random plugin

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterGui.ScreenGui.TextLabel.InventoryDebug | Enabled: true
--------------------------------------------------------------------

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DebugEvent = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes"):WaitForChild("DebugInventory")

local label = script.Parent
if not label or not label:IsA("TextLabel") then
	warn("InventoryDebug: script parent is not a TextLabel")
	return
end

local function formatInventory(inv)
	if type(inv) ~= "table" then
		return "---- DEBUG INVENTORY ----\n(no inventory data received)"
	end

	local lines = {}
	table.insert(lines, "---- DEBUG INVENTORY ----")

	for category, items in pairs(inv) do
		table.insert(lines, "")
		table.insert(lines, "[" .. tostring(category) .. "]")

	
		if type(items) == "table" then
			for item, value in pairs(items) do
				table.insert(lines, string.format("  %s = %s", tostring(item), tostring(value)))
			end
		else
			table.insert(lines, "  " .. tostring(items))
		end
	end

	return table.concat(lines, "\n")
end

DebugEvent.OnClientEvent:Connect(function(inv)
	local ok, text = pcall(formatInventory, inv)
	if ok then
		label.Text = text
	else
		label.Text = "Error formatting inventory: " .. tostring(text)
	end
end)

label.Text = "---- DEBUG INVENTORY ----\n(waiting for server...)"

--// END OF SCRIPT: game.StarterGui.ScreenGui.TextLabel.InventoryDebug

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterGui.Level.LocalScript | Enabled: false
--------------------------------------------------------------------
local ROGUEBANNER = script.Parent:WaitForChild("LevelBanner")
local tweenserv = game:GetService("TweenService")
local inputserv = game:GetService("UserInputService")
local Sounds = script.Parent.Parent:WaitForChild("uisounds")
local SFX = script.Parent.Parent:WaitForChild("SFX")

local soundeffecttable = Sounds:WaitForChild("Effects"):GetChildren()

--tweens
local quickspeed = TweenInfo.new(0.2)
local normalspeed = TweenInfo.new(1)
local slowspeed = TweenInfo.new(1.5)


local tweenredbar = tweenserv:Create(ROGUEBANNER.REDBAR ,normalspeed, {Size = UDim2.new(2, 0,1, 0)})
local redbartransparency = tweenserv:Create(ROGUEBANNER.REDBAR ,quickspeed, {BackgroundTransparency = 1})

local tweenredbarback = tweenserv:Create(ROGUEBANNER.REDBAR ,quickspeed, {Size = UDim2.new(0, 0,1, 0)})
local tweenROGUEBANNER = tweenserv:Create(ROGUEBANNER ,quickspeed, {Size = UDim2.new(0.01, 0,0.101, 0)})
local tweenROGUEBANNERNORMALSIZE = tweenserv:Create(ROGUEBANNER ,quickspeed, {Size = UDim2.new(0.233, 0,0.101, 0)})

local tweentextROGUEIN = tweenserv:Create(ROGUEBANNER.Rogue ,quickspeed, {TextTransparency = 0})
local tweentextROGUEOUT = tweenserv:Create(ROGUEBANNER.Rogue ,quickspeed, {TextTransparency = 1})
local tweentextGONEIN = tweenserv:Create(ROGUEBANNER.Gone ,quickspeed, {TextTransparency = 0})
local tweentextGONEOUT = tweenserv:Create(ROGUEBANNER.Gone ,quickspeed, {TextTransparency = 1})

local function LEVELUP()
	ROGUEBANNER.REDBAR.BackgroundTransparency = 0.75
	ROGUEBANNER.Visible = true

	tweenROGUEBANNERNORMALSIZE:Play()
	tweenROGUEBANNERNORMALSIZE.Completed:Wait()
	tweentextROGUEIN:Play()
	tweentextGONEIN:Play()

	tweenredbar:Play()
	tweenredbar.Completed:Wait()
	wait(2)
	redbartransparency:Play()
	redbartransparency.Completed:Wait()
	tweenredbarback:Play()
	tweentextROGUEOUT:Play()
	tweentextGONEOUT:Play()
	tweentextGONEOUT.Completed:Wait()
	tweenROGUEBANNER:Play()
	tweenROGUEBANNER.Completed:Wait()
	ROGUEBANNER.Visible = false
	ROGUEBANNER.REDBAR.BackgroundTransparency = 0
end

local PlayerData = game.Players.LocalPlayer:WaitForChild("playerData")
local PlayerStats = PlayerData:WaitForChild("PlayerStats")

local Level = PlayerStats:WaitForChild("LEVEL")

local function playRandomSound()
	local randomIndex = math.random(1, #soundeffecttable)
	local sound = soundeffecttable[randomIndex]
	if sound:IsA("Sound") then
		sound:Play()
	end
end


		Level.Changed:Connect(function()
			Sounds:WaitForChild("Effects"):WaitForChild("1"):Play()
			LEVELUP()	
			

		end)


--// END OF SCRIPT: game.StarterGui.Level.LocalScript

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterGui.LIVES.H.topLeft.Team2Lives.updateLives | Enabled: false
--------------------------------------------------------------------
repeat
	wait()
until game:GetService("ReplicatedStorage"):WaitForChild("WhatTeam").Value ~= nil

local textto = nil
if game:GetService("ReplicatedStorage"):WaitForChild("WhatTeam").Value == "Team2" then
	textto = game:GetService("ReplicatedStorage"):WaitForChild("GAME"):WaitForChild("SupplyRaid"):WaitForChild("LivesTeam2")
else
	textto = game:GetService("ReplicatedStorage"):WaitForChild("GAME"):WaitForChild("SupplyRaid"):WaitForChild("LivesTeam1")
end

textto.Changed:Connect(function()
	script.Parent.Text = tostring(textto.Value)
end)

--// END OF SCRIPT: game.StarterGui.LIVES.H.topLeft.Team2Lives.updateLives

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterGui.LIVES.H.topLeft.Team1Lives.ui | Enabled: false
--------------------------------------------------------------------
repeat
	wait()
	print("Waiting for WhatTeam to be non-nil")
until game:GetService("ReplicatedStorage"):WaitForChild("WhatTeam").Value ~= nil

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local WhatTeam = ReplicatedStorage:WaitForChild("WhatTeam")
local remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("assignTeam")

local function getLivesForTeam(team)
	local supplyRaid = ReplicatedStorage:WaitForChild("GAME"):WaitForChild("SupplyRaid")
	local livesName = "Lives" .. tostring(team)
	local lives = supplyRaid:FindFirstChild(livesName)
	if not lives then
		warn("Lives for team " .. tostring(team) .. " not found. Using default lives value.")
		lives = Instance.new("IntValue")
		lives.Value = 0
		lives.Name = livesName
	end
	return lives
end

local function updateTeamUI(team, player)
	local playerGui = player:FindFirstChild("PlayerGui")
	if not playerGui then
		warn("PlayerGui not found for player: " .. player.Name)
		return
	end

	local livesFrame = playerGui:FindFirstChild("LIVES")
	if not livesFrame then
		warn("LIVES frame not found in PlayerGui for player: " .. player.Name)
		return
	end

	local teamgui = livesFrame.H.topLeft:FindFirstChild("TEAM1")
	local teams = ReplicatedStorage:WaitForChild("GAME"):WaitForChild("Teams"):FindFirstChild(tostring(team))

	local oppTeam = team == "Team1" and "Team2" or "Team1"
	local teamguiopp = livesFrame.H.topLeft:FindFirstChild("TEAM2")
	local teamsopp = ReplicatedStorage:WaitForChild("GAME"):WaitForChild("Teams"):FindFirstChild(tostring(oppTeam))

	-- Debugging information
	print("Updating UI for team:", team)
	print("TEAM1 GUI:", teamgui)
	print("TEAM2 GUI:", teamguiopp)

	if teamgui and teams then
		print("TEAM1 GUI found, updating templates.")
		-- Clear existing templates
		for _, v in pairs(teamgui:GetChildren()) do
			if v.Name:find("Template") then
				v:Destroy()
			end
		end
		-- Create new templates
		local template = teamgui:FindFirstChild("TEMPLATE")
		if template then
			for _, v in pairs(teams:GetChildren()) do
				local newTemplate = template:Clone()
				newTemplate.Visible = true
				newTemplate.Parent = teamgui
				newTemplate.Name = v.Name .. "Template"

				-- Debug: Print the new template name
				print("Created template for:", v.Name)

				local boolv = Instance.new("BoolValue")
				boolv.Name = "CanDestroy"
				boolv.Parent = newTemplate

				local character = workspace:FindFirstChild("Characters"):FindFirstChild(v.Name)
				if character then
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.Health <= 0 then
						newTemplate:FindFirstChild("X").Visible = true
						newTemplate.ImageTransparency = 0.5
					end
				end
			end
		else
			warn("TEMPLATE not found in TEAM1 GUI.")
		end
	else
		warn("TEAM1 GUI or teams not found for team:", team)
	end

	if teamguiopp and teamsopp then
		print("TEAM2 GUI found, updating templates.")
		-- Clear existing templates
		for _, v in pairs(teamguiopp:GetChildren()) do
			if v.Name:find("Template") then
				v:Destroy()
			end
		end
		-- Create new templates
		local template = teamguiopp:FindFirstChild("TEMPLATE")
		if template then
			for _, v in pairs(teamsopp:GetChildren()) do
				local newTemplate = template:Clone()
				newTemplate.Visible = true
				newTemplate.Parent = teamguiopp
				newTemplate.Name = v.Name .. "Template"

				-- Debug: Print the new template name for opponent
				print("Created template for opponent:", v.Name)

				local boolv = Instance.new("BoolValue")
				boolv.Name = "CanDestroy"
				boolv.Parent = newTemplate

				local character = workspace:FindFirstChild("Characters"):FindFirstChild(v.Name)
				if character then
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.Health <= 0 then
						newTemplate:FindFirstChild("X").Visible = true
						newTemplate.ImageTransparency = 0.5
					end
				end
			end
		else
			warn("TEMPLATE not found in TEAM2 GUI.")
		end
	else
		warn("TEAM2 GUI or teams not found for opponent team:", oppTeam)
	end

	local textto = getLivesForTeam(team)
	textto.Changed:Connect(function()
		script.Parent.Text = tostring(textto.Value)
	end)
end

remote.OnClientEvent:Connect(function(team)
	print("Received team assignment:", team)
	WhatTeam.Value = team
	local player = game.Players.LocalPlayer
	updateTeamUI(team, player)
end)

-- Initial setup
local player = game.Players.LocalPlayer
updateTeamUI(WhatTeam.Value, player)

-- Listen for team changes
WhatTeam.Changed:Connect(function()
	print("WhatTeam value changed to:", WhatTeam.Value)
	updateTeamUI(WhatTeam.Value, player)
end)

--// END OF SCRIPT: game.StarterGui.LIVES.H.topLeft.Team1Lives.ui

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterGui.LIVES.H.Countdown.LocalScript | Enabled: false
--------------------------------------------------------------------
local theval = game:GetService("ReplicatedStorage"):WaitForChild("GAME"):WaitForChild("gametime")


theval.Changed:Connect(function()
	if theval then
		script.Parent.Visible = true
		
		local Time = theval.Value
		local min, sec = tostring(math.floor(Time/60)), tostring(Time%60)
		if #sec == 1 then
			sec = sec.."0"
		end
		local FixedTime = tostring(min)..":"..tostring(sec)
		
		script.Parent.Text = FixedTime
	end
end)


--// END OF SCRIPT: game.StarterGui.LIVES.H.Countdown.LocalScript

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterPlayer.StarterCharacterScripts.DataBridgeExample | Enabled: false
--------------------------------------------------------------------
local DataEvent = game.ReplicatedStorage.DataEvent

-- Example:
DataEvent:FireServer("Add", "Inventory.Resources.Alcohol", 1)
DataEvent:FireServer("Add", "Inventory.Consumables.Medkits", 1)
DataEvent:FireServer("Remove", "Inventory.Ammo.Primary", 5)


-- add items from cmd to test
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Resources.Alcohol", 3)

game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Resources.Blades", 5)
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Consumables.Molotovs", 1)
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Ammo.Primary", 20)
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Weapons.Primary", "Vepr")
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Remove", "Inventory.Resources.Rags", 2)

--// END OF SCRIPT: game.StarterPlayer.StarterCharacterScripts.DataBridgeExample

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterPlayer.StarterCharacterScripts.Framework | Enabled: true
--------------------------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Tweenservice = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local Debris = game:GetService("Debris")
local ContentProvider = game:GetService("ContentProvider")

local LeanController = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].LeanController)
local FootPlanting = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].FootPlanting)
local CameraController = require(ReplicatedStorage.Peak.Modules.Camera.CameraController)
local AnimationData = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].Animations.Animations)
local AnimationList = AnimationData.GetList()

local CameraFX = require(ReplicatedStorage.Peak.Modules.Camera.CameraFX)
local FootstepModule = require(ReplicatedStorage.Peak.Modules.Librarys.FootstepModule)
local RootMotion = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].RootMotionModule)
local DebugDraw = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].RootMotionModule.DebugDraw)

local WeaponRemotes = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes"):WaitForChild("WeaponSys")
local SetWeaponLock = WeaponRemotes:WaitForChild("SetWeaponLock")

local Config = {
	Movement = {
		WalkSpeed = 8, 
		SprintSpeed = 17, 
		Acceleration = 8, 
		CrouchDeceleration = 5, 
		RotationSpeed = 12, 
		AimRotationSpeed = 35, 
	},

	FootPlanting = {
		IdleInfluence = 100, 
		WalkInfluence = 50, 
		Smoothness = 5, 
	},

	Audio = {
		StepBaseSpeed = 0.55, 
	},

	Visuals = {
		AnimFadeTime = 0.2, 
		MaxTiltAngle = 20, 
	},

	Vaulting = {
		MaxDist = 3.5, 
		MinHeight = 1.5, 
		MaxHeight = 4.5, 
		DepthCheck = 1.0, 
		SafetyClearance = 1.0, 
		MinLandingSpace = 0.5, 
		MaxTraversal = 8.0, 
		DebugMode = false, 
	}
}


local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local head = character:WaitForChild("Head") 

local torso = character:WaitForChild("Torso")
local neck = torso:WaitForChild("Neck")
local rightShoulder = torso:WaitForChild("Right Shoulder")
local leftShoulder = torso:WaitForChild("Left Shoulder")

local originNeckC0 = neck.C0
local originRightC0 = rightShoulder.C0
local originLeftC0 = leftShoulder.C0

local currentArmPitch = 0

local Playergui = player:WaitForChild("PlayerGui")
local REARMED = nil
local BackpackFrame = nil

local currentFootInfluence = Config.FootPlanting.IdleInfluence
local animationTracks = {}
local currentAnimSpeed = 0
local lastStepTime = 0

local State = "Standing"
local States = {"Standing", "Crouching", "Proning", "Backpack", "Down", "Dead"}
local backpackOpen = false
local Canmove = true
local transitionActive = false
local transitionEndTime = 0
local vaultDebounce = false


local function LoadPlayerAnimations(humanoid, animationList)
	local animator = humanoid:WaitForChild("Animator")

	local tracks = {}
	local preload = {}

	for name, data in pairs(animationList) do
		if data.Id then
			local anim = Instance.new("Animation")
			anim.AnimationId = data.Id

			local track = animator:LoadAnimation(anim)
			if track then
				track.Priority = data.Priority or Enum.AnimationPriority.Core
				tracks[name] = track
				table.insert(preload, anim)
			end
		end
	end

	task.spawn(function()
		pcall(function()
			ContentProvider:PreloadAsync(preload)
		end)
	end)

	return tracks
end

local function playTransition(track, duration)
	if not track then return end

	transitionActive = true
	transitionEndTime = tick() + (type(duration) == "number" and duration or 0.4)

	if track.Priority == nil then track.Priority = Enum.AnimationPriority.Action end
	track.Priority = Enum.AnimationPriority.Action
	track.Looped = false

	track:Play(0.1)
end

local function SetState(newState)
	if State == newState then return end
	State = newState

	if animationTracks.StandToCrouch then animationTracks.StandToCrouch:Stop() end
	if animationTracks.CrouchToProne then animationTracks.CrouchToProne:Stop() end

	if newState == "Standing" then
		Tweenservice:Create(humanoid, TweenInfo.new(0.25), {HipHeight = 0}):Play()
		character:SetAttribute("Stance", "Default")

		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop(0.2) end
		if animationTracks.CrouchWalk then animationTracks.CrouchWalk:Stop(0.2) end
		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop(0.2) end
		if animationTracks.ProneWalk then animationTracks.ProneWalk:Stop(0.2) end

	elseif newState == "Crouching" then
		if State == "Standing" and animationTracks.StandToCrouch then
			playTransition(animationTracks.StandToCrouch, 0.35)
		end
		character:SetAttribute("Stance", "Crouch")
		Tweenservice:Create(humanoid, TweenInfo.new(0.25), {HipHeight = -0.65}):Play()

		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop(0.2) end
		if animationTracks.ProneWalk then animationTracks.ProneWalk:Stop(0.2) end
		if animationTracks.Idle then animationTracks.Idle:Stop(0.2) end
		if animationTracks.Walk then animationTracks.Walk:Stop(0.2) end
		if animationTracks.Run then animationTracks.Run:Stop(0.2) end

	elseif newState == "Proning" then
		if State == "Crouching" and animationTracks.CrouchToProne then
			playTransition(animationTracks.CrouchToProne, 0.35)
		end
		character:SetAttribute("Stance", "Prone")
		Tweenservice:Create(humanoid, TweenInfo.new(0.25), {HipHeight = -1.35}):Play()

		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop(0.2) end
		if animationTracks.CrouchWalk then animationTracks.CrouchWalk:Stop(0.2) end
		if animationTracks.Idle then animationTracks.Idle:Stop(0.2) end
		if animationTracks.Walk then animationTracks.Walk:Stop(0.2) end
		if animationTracks.Run then animationTracks.Run:Stop(0.2) end
	end
end

local function lerp(a, b, t)
	return a + (b - a) * t
end

local function getInputVector()
	local x = 0
	local z = 0

	if UserInputService:IsKeyDown(Enum.KeyCode.W) then z -= 1 end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) then z += 1 end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) then x -= 1 end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) then x += 1 end

	local input = Vector3.new(x, 0, z)
	if input.Magnitude > 0 then
		input = input.Unit
	end

	return input
end

local function getFloorY()
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}
	local ray = workspace:Raycast(rootPart.Position, Vector3.new(0, -5, 0), rayParams)
	return ray and ray.Position.Y or (rootPart.Position.Y - 3)
end

local function getObjectDepth(hitInstance, ledgePos, lookVector)
	local maxScanDist = Config.Vaulting.MaxTraversal
	local stepSize = 0.25
	local maxGapTolerance = 1.0

	local targetWhitelist = {hitInstance}
	local model = hitInstance:FindFirstAncestorOfClass("Model")

	if model and not model:IsA("Workspace") then
		targetWhitelist = {model}
	end

	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Include
	rayParams.FilterDescendantsInstances = targetWhitelist

	local currentDist = 0
	local lastValidHitDist = 0
	local gapDistance = 0

	while currentDist < maxScanDist do
		currentDist += stepSize
		local checkPos = ledgePos + (lookVector * currentDist) + Vector3.new(0, 1, 0)
		local ray = workspace:Raycast(checkPos, Vector3.new(0, -3, 0), rayParams)

		if ray then
			gapDistance = 0
			lastValidHitDist = currentDist
			if Config.Vaulting.DebugMode then
				DebugDraw.Sphere(ray.Position, 0.1, Color3.new(0, 1, 0), 2)
			end
		else
			gapDistance += stepSize
			if Config.Vaulting.DebugMode then
				DebugDraw.Sphere(checkPos - Vector3.new(0, 1, 0), 0.1, Color3.new(1, 0.5, 0), 2)
			end

			if gapDistance > maxGapTolerance then
				if Config.Vaulting.DebugMode then
					DebugDraw.Sphere(checkPos, 0.3, Color3.new(1, 0, 0), 4)
				end
				return lastValidHitDist
			end
		end
	end

	return nil
end

local function getLandingSpace(ledgePos, objectDepth, lookVector, requestedOffset)
	local rayStart = ledgePos + (lookVector * objectDepth) + Vector3.new(0, 2, 0) 
	local checkDist = requestedOffset + 0.5
	local rayDir = lookVector * checkDist

	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}

	local ray = workspace:Raycast(rayStart, rayDir, rayParams)

	if ray then
		local availableSpace = (ray.Position - rayStart).Magnitude
		return math.max(0, availableSpace - 0.5) 
	end

	return requestedOffset
end

local function checkPathObstruction(startPos, direction, distance, targetInstance)
	local model = targetInstance:FindFirstAncestorOfClass("Model")
	local ignoreList = {character, targetInstance}

	if model and not model:IsA("Workspace") then
		table.insert(ignoreList, model)
	end

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = ignoreList
	params.FilterType = Enum.RaycastFilterType.Exclude

	local size = Vector3.new(1.5, 3.5, 1.5)
	local cframe = CFrame.lookAt(startPos, startPos + direction)

	local result = workspace:Blockcast(cframe, size, direction * distance, params)

	if result then
		return true
	end
	return false
end

local function getLedgeInfo(wallHitPosition, wallNormal)
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}

	local rayStart = wallHitPosition + Vector3.new(0, Config.Vaulting.MaxHeight, 0) - (wallNormal * Config.Vaulting.DepthCheck)
	local rayDir = Vector3.new(0, -(Config.Vaulting.MaxHeight + 2), 0) 

	local ledgeRay = workspace:Raycast(rayStart, rayDir, rayParams)

	if ledgeRay then
		local floorY = getFloorY()
		local objectHeight = ledgeRay.Position.Y - floorY

		if objectHeight > Config.Vaulting.MinHeight and objectHeight < Config.Vaulting.MaxHeight then
			return ledgeRay.Position
		end
	end
	return nil
end

local function attemptVault()
	if vaultDebounce or not Canmove then return end
	if State ~= "Standing" then return end

	local rayOrigin = rootPart.Position - Vector3.new(0, 1, 0)
	local rayDirection = rootPart.CFrame.LookVector * Config.Vaulting.MaxDist
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}

	local wallHit = workspace:Raycast(rayOrigin, rayDirection, rayParams)

	if wallHit then

		local target = wallHit.Instance
		local hasTag = CollectionService:HasTag(target, "VaultableLow")

		if not hasTag then
			local model = target:FindFirstAncestorOfClass("Model")
			if model and CollectionService:HasTag(model, "VaultableLow") then
				hasTag = true
			end
		end

		if not hasTag then return end

		local ledgePos = getLedgeInfo(wallHit.Position, wallHit.Normal)

		if ledgePos then
			vaultDebounce = true
			Canmove = false
			SetWeaponLock:Fire(true)

			local vaultData = AnimationData.GetData("Vault")
			local vaultTrack = animationTracks["Vault"]

			if not vaultTrack then
				vaultDebounce = false
				Canmove = true
				SetWeaponLock:Fire(false)
				return
			end

			local objectDepth = getObjectDepth(wallHit.Instance, ledgePos, rootPart.CFrame.LookVector)

			if not objectDepth then
				vaultDebounce = false
				Canmove = true
				SetWeaponLock:Fire(false)
				return
			end

			local forwardOffset = vaultData.ForwardOffset or 3.5
			local baseDistance = vaultData.BaseDistance or 6

			local distToWall = (Vector3.new(wallHit.Position.X, 0, wallHit.Position.Z) - Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z)).Magnitude

			local calculatedOffset = (objectDepth < 2.0) and 1.5 or forwardOffset

			local safeLandingOffset = getLandingSpace(ledgePos, objectDepth, rootPart.CFrame.LookVector, calculatedOffset)

			if safeLandingOffset < Config.Vaulting.MinLandingSpace then
				if objectDepth > 2.0 then
					safeLandingOffset = -Config.Vaulting.SafetyClearance
				else
					vaultDebounce = false
					Canmove = true
					SetWeaponLock:Fire(false)
					return
				end
			end

			local totalTravel = distToWall + objectDepth + Config.Vaulting.SafetyClearance + safeLandingOffset

			local isBlocked = checkPathObstruction(rootPart.Position, rootPart.CFrame.LookVector, totalTravel, wallHit.Instance)
			if isBlocked then
				vaultDebounce = false
				Canmove = true
				SetWeaponLock:Fire(false)
				return
			end

			local scale = math.clamp(totalTravel / baseDistance, 0.5, 3.0)

			local lookPos = Vector3.new(wallHit.Position.X, rootPart.Position.Y, wallHit.Position.Z)
			rootPart.CFrame = CFrame.lookAt(rootPart.Position, lookPos)

			RootMotion:StartCorrection({
				["Track"] = vaultTrack,
				["AlignHRPCFrame"] = false, 
				["MaintainVelocity"] = true,
				["IgnoreCollision"] = true,
				["TranslationScale"] = scale
			})

			task.wait(vaultTrack.Length)
			vaultDebounce = false
			Canmove = true
			SetWeaponLock:Fire(false)
		end
	end
end

local function BackpackOpen()
	if not BackpackFrame then return end

	Canmove = false
	BackpackFrame.Visible = true

	if State == "Crouching" then
		animationTracks.BpCrouchingOff:Play(0.15)
	elseif State == "Proning" then
		local track = animationTracks.BpProneOff or animationTracks.BpCrouchingOff
		if track then track:Play(0.15) end
	else 
		animationTracks.BpStandingOff:Play(0.15)
	end

	if State == "Proning" then
		if animationTracks.BpProneIdle then
			animationTracks.BpProneIdle:Play(0.2)
		end
	else
		animationTracks.BpIdle:Play(1.45)
	end

	if State == "Proning" then
		Tweenservice:Create(humanoid, TweenInfo.new(1), {HipHeight = -0.9}):Play()
	else
		Tweenservice:Create(humanoid, TweenInfo.new(1), {HipHeight = -0.5}):Play()
	end
end

local function BackpackClose()
	if not BackpackFrame then return end
	BackpackFrame.Visible = false

	if State == "Crouching" then
		animationTracks.BpCrouchingOn:Play(0.15)
	elseif State == "Proning" then
		local track = animationTracks.BpProneOn or animationTracks.BpCrouchingOn
		if track then track:Play(0.15) end
	else 
		animationTracks.BpStandingOn:Play(0.15)
	end

	animationTracks.BpStandingOff:Stop(1)
	animationTracks.BpIdle:Stop(0.15)
	if animationTracks.BpProneIdle then
		animationTracks.BpProneIdle:Stop(0.15)
	end

	local targetHip
	if State == "Crouching" then
		targetHip = -0.65
	elseif State == "Proning" then
		targetHip = -1.35
	else 
		targetHip = 0
	end

	Tweenservice:Create(humanoid, TweenInfo.new(1.15), {HipHeight = targetHip}):Play()
	task.wait(1.15)
	Canmove = true
end

local function checkAndPlay(trackToPlay, tracksToStop)
	if trackToPlay and not trackToPlay.IsPlaying then
		trackToPlay:Play(0.2)
	end
	for _, track in ipairs(tracksToStop) do
		if track and track.IsPlaying then
			track:Stop(0.2)
		end
	end
end

local function isMovingBackwards()
	if not rootPart then return false end

	local move = humanoid.MoveDirection
	if move.Magnitude < 0.1 then 
		return false 
	end

	local forward = rootPart.CFrame.LookVector
	return forward:Dot(move) < -0.3 -- negative = walking backwards
end

local function playAnimDirectional(track, stopList, backwards)
	if not track then return end

	-- Stop others
	if stopList then
		for _, other in ipairs(stopList) do
			if other then other:Stop(0.15) end
		end
	end

	-- Play forward/backwards
	if backwards then
		if not track.IsPlaying then
			track.TimePosition = track.Length -- start at end for smooth reverse
			track:Play(0.15)
		end
		track:AdjustSpeed(-1)
	else
		if not track.IsPlaying then
			track:Play(0.15)
		end
		track:AdjustSpeed(1)
	end
end

local function updateSimpleAnimations(dt)
	if transitionActive then
		if tick() >= transitionEndTime then
			transitionActive = false
		else
			return
		end
	end

	local velocity = rootPart.AssemblyLinearVelocity * Vector3.new(1,0,1)
	local speed = velocity.Magnitude
	local isSprinting = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
		and (not character:GetAttribute("IsAiming"))

	local backwards = isMovingBackwards()

	-----------------------------------------------------
	-- STATE: STANDING
	-----------------------------------------------------
	if State == "Standing" then
		if speed > 0.5 then
			if isSprinting and not backwards then
				playAnimDirectional(animationTracks.Run, {animationTracks.Walk, animationTracks.Idle}, false)
			else
				playAnimDirectional(animationTracks.Walk, {animationTracks.Run, animationTracks.Idle}, backwards)
			end
		else
			playAnimDirectional(animationTracks.Idle, {animationTracks.Walk, animationTracks.Run}, false)
		end

		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop() end
		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop() end

		-----------------------------------------------------
		-- STATE: CROUCHING
		-----------------------------------------------------
	elseif State == "Crouching" then
		if speed > 0.5 then
			playAnimDirectional(animationTracks.CrouchWalk, {animationTracks.CrouchIdle}, backwards)
		else
			playAnimDirectional(animationTracks.CrouchIdle, {animationTracks.CrouchWalk}, false)
		end

		if animationTracks.Idle then animationTracks.Idle:Stop() end
		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop() end

		-----------------------------------------------------
		-- STATE: PRONING
		-----------------------------------------------------
	elseif State == "Proning" then
		if speed > 0.5 then
			playAnimDirectional(animationTracks.ProneWalk, {animationTracks.ProneIdle}, backwards)
		else
			playAnimDirectional(animationTracks.ProneIdle, {animationTracks.ProneWalk}, false)
		end

		if animationTracks.Idle then animationTracks.Idle:Stop() end
		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop() end
	end
end


local function onRenderStep(deltaTime)
	if not character or not character.Parent or humanoid.Health <= 0 then return end

	local safeDt = math.min(deltaTime, 0.05) 

	if not Canmove then
		humanoid.WalkSpeed = 0
		humanoid:Move(Vector3.zero, false)
		return
	end

	local inputVector = getInputVector()

	local isAiming = character:GetAttribute("IsAiming")
	local isSprinting = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and not isAiming 

	if isAiming then
		CameraController:SetAnchor(rootPart, 10)
	else
		CameraController:SetAnchor(head, 10)
	end

	local targetSpeed = isSprinting and Config.Movement.SprintSpeed or Config.Movement.WalkSpeed

	if State == "Standing" then
		targetSpeed = isSprinting and Config.Movement.SprintSpeed or Config.Movement.WalkSpeed
	elseif State == "Crouching" then
		targetSpeed = Config.Movement.WalkSpeed * 0.55
	elseif State == "Proning" then
		targetSpeed = Config.Movement.WalkSpeed * 0.25
	end

	if inputVector.Magnitude > 0 then
		local _, yaw = camera.CFrame:ToEulerAnglesYXZ()
		local moveDirection = CFrame.Angles(0, yaw, 0) * inputVector

		local accel = Config.Movement.Acceleration

		if State == "Crouching" and humanoid.WalkSpeed > targetSpeed then
			accel = Config.Movement.CrouchDeceleration
		end

		humanoid.WalkSpeed = lerp(humanoid.WalkSpeed, targetSpeed, 1 - math.exp(-safeDt * accel))
		humanoid:Move(moveDirection, false)
	else
		humanoid.WalkSpeed = lerp(humanoid.WalkSpeed, 0, 1 - math.exp(-safeDt * Config.Movement.Acceleration))
		humanoid:Move(Vector3.zero, false)
	end

	if isAiming or (not isSprinting) then
		humanoid.AutoRotate = false
		local _, cameraYaw = camera.CFrame:ToEulerAnglesYXZ()
		local targetRotation = CFrame.Angles(0, cameraYaw, 0)

		local currentCFrame = rootPart.CFrame
		local targetCFrame = CFrame.new(currentCFrame.Position) * targetRotation

		local rotSpeed = isAiming and Config.Movement.AimRotationSpeed or Config.Movement.RotationSpeed
		rootPart.CFrame = currentCFrame:Lerp(targetCFrame, safeDt * rotSpeed)
	else
		humanoid.AutoRotate = true
	end

	local cameraPitch = math.asin(camera.CFrame.LookVector.Y)
	local targetPitch = isAiming and cameraPitch or 0

	local limit = math.rad(Config.Visuals.MaxTiltAngle)
	targetPitch = math.clamp(targetPitch, -limit, limit)

	currentArmPitch = targetPitch

	local aimPosPart = nil
	if isAiming then
		for _, child in ipairs(character:GetChildren()) do
			if child:IsA("Model") and child:FindFirstChild("AimPos") then
				aimPosPart = child.AimPos
				break
			end
		end
	end

	local targetNeckC0
	if aimPosPart then
		local headPos = (torso.CFrame * originNeckC0).Position
		local targetPos = aimPosPart.Position

		local lookDir = (targetPos - headPos).Unit
		local localDir = torso.CFrame:VectorToObjectSpace(lookDir)

		local yaw = math.atan2(-localDir.X, -localDir.Z)
		local pitch = math.asin(localDir.Y)

		local damp = 0.5

		targetNeckC0 = originNeckC0 * CFrame.Angles(pitch * damp, yaw * damp, 0)
	else
		targetNeckC0 = originNeckC0 * CFrame.Angles(currentArmPitch * 0.5, 0, 0)
	end

	rightShoulder.C0 = originRightC0 * CFrame.Angles(0, 0, currentArmPitch)
	leftShoulder.C0 = originLeftC0 * CFrame.Angles(0, 0, -currentArmPitch)
	neck.C0 = neck.C0:Lerp(targetNeckC0, safeDt * 10)

	local flatVel = rootPart.AssemblyLinearVelocity * Vector3.new(1, 0, 1)
	local currentSpeed = flatVel.Magnitude

	if currentSpeed > 0.5 and humanoid.FloorMaterial ~= Enum.Material.Air then
		local stepRate = math.clamp(Config.Audio.StepBaseSpeed / (currentSpeed / Config.Movement.WalkSpeed), 0.25, 1)

		if time() - lastStepTime > stepRate then
			lastStepTime = time()

			local params = RaycastParams.new()
			params.FilterDescendantsInstances = {character}
			params.FilterType = Enum.RaycastFilterType.Exclude
			local result = workspace:Raycast(rootPart.Position, Vector3.new(0, -4, 0), params)

			if result and result.Material then
				local soundTable = FootstepModule:GetTableFromMaterial(result.Material)
				if soundTable then
					local soundId = FootstepModule:GetRandomSound(soundTable)
					local sound = Instance.new("Sound")
					sound.SoundId = soundId
					sound.Volume = 0.35
					sound.Parent = rootPart
					sound:Play()
					Debris:AddItem(sound, 1.5)
				end
			end
		end
	end

	local targetInfluence = (inputVector.Magnitude > 0) and Config.FootPlanting.WalkInfluence or Config.FootPlanting.IdleInfluence
	currentFootInfluence = lerp(currentFootInfluence, targetInfluence, safeDt * Config.FootPlanting.Smoothness)
	FootPlanting.SetInfluence(currentFootInfluence)

	updateSimpleAnimations(safeDt)
end

local function Initialize()
	if not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local animator = humanoid:WaitForChild("Animator")

	if character:FindFirstChild("Animate") then
		character.Animate:Destroy()
	end

	REARMED = Playergui:WaitForChild("REARMED HUD")
	if REARMED then
		local h = REARMED:WaitForChild("H")
		if h then
			BackpackFrame = h:WaitForChild("Backpack")
		end
	end

	LeanController.Start()
	CameraController:Init(player)
	CameraFX.Start()
	FootPlanting.Start()
	FootstepModule:CreateSoundGroup(game:GetService("SoundService"), "FootstepsPreload", {Volume = 0.5}, true)

	local AnimationList = AnimationData.GetList()
	animationTracks = LoadPlayerAnimations(humanoid, AnimationList)

	local requiredAnims = {
		"Idle","Walk","Run",
		"CrouchIdle","CrouchWalk",
		"ProneIdle","ProneWalk",
		"StandToCrouch","CrouchToProne",
		"BpIdle",
		"BpStandingOn","BpStandingOff",
		"BpCrouchingOn","BpCrouchingOff",
		"BpProneOn","BpProneOff",
		"Vault",
	}

	local function createTrackIfMissing(name)
		if animationTracks[name] then return end

		local animId = AnimationData.GetId(name)
		if not animId then
			return
		end

		local anim = Instance.new("Animation")
		anim.AnimationId = animId

		local track = animator:LoadAnimation(anim)
		animationTracks[name] = track
	end

	for _, name in ipairs(requiredAnims) do
		createTrackIfMissing(name)
	end

	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode ~= Enum.KeyCode.B then return end

		if vaultDebounce then return end

		backpackOpen = not backpackOpen

		if backpackOpen then
			CameraController:TweenOffset(
				Vector3.new(4, 0.5, 7),
				TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			)
			BackpackOpen()
		else
			CameraController:TweenOffset(
				Vector3.new(2, 0.5, 7),
				TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			)
			BackpackClose()
		end
	end)

	UserInputService.InputBegan:Connect(function(input, processed)
		if processed then return end

		if backpackOpen or not Canmove then return end

		if input.KeyCode == Enum.KeyCode.Space then
			attemptVault()
		end

		if input.KeyCode == Enum.KeyCode.LeftControl then
			if State == "Standing" then
				SetState("Crouching")
			elseif State == "Crouching" then
				SetState("Standing")
			elseif State == "Proning" then
				SetState("Crouching")
			end
		end

		if input.KeyCode == Enum.KeyCode.Z then
			if State == "Crouching" then
				SetState("Proning")
			elseif State == "Proning" then
				SetState("Crouching")
			end
		end

	end)

	RunService.RenderStepped:Connect(onRenderStep)

	humanoid.Died:Connect(function()
		LeanController.Stop()
		FootPlanting.Stop()

		for _, track in pairs(animationTracks) do
			track:Stop(0.2)
		end
	end)
end

Initialize()
--// END OF SCRIPT: game.StarterPlayer.StarterCharacterScripts.Framework

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterPlayer.StarterCharacterScripts.lootboxtest | Enabled: true
--------------------------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")



local player = Players.LocalPlayer
local interactEvent = ReplicatedStorage:WaitForChild("Peak").Remotes.InteractEvent
local proximityDistance = 10
local resetTime = 30 -- Time (in seconds) for the loot box to reset

-- Ensure the character and animation system exist
local function getCharacter()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:FindFirstChild("Humanoid")
	local animator = humanoid and humanoid:FindFirstChild("Animator")
	return character, humanoid, animator
end

-- Preload animation
local lootBoxAnim = ReplicatedStorage:WaitForChild("Peak").Modules.Loot.LootBox
local character, humanoid, animator = getCharacter()
local lootAnimTrack = animator:LoadAnimation(lootBoxAnim)

-- Function to find nearby loot boxes
local function getNearestLootBox()
	local character = player.Character
	local root = character and character:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	local nearestBox = nil
	local shortestDistance = math.huge

	for _, lootBox in ipairs(workspace.Game.Interactables.SupplyBox:GetChildren()) do
		if lootBox:IsA("Part") then
			-- Check if loot box is already looted
			local lootedCheck = lootBox:FindFirstChild("LootedCheck")
			if lootedCheck and lootedCheck.Value == true then
				continue -- Skip this loot box if it's already looted
			end

			local distance = (root.Position - lootBox.Position).Magnitude
			if distance <= proximityDistance and distance < shortestDistance then
				nearestBox = lootBox
				shortestDistance = distance
			end
		end
	end

	return nearestBox
end




-- Spawn loot on the client
local function spawnLoot(lootData, lootBox)
	-- Get all attachments in the loot box
	local attachments = {}
	for _, child in ipairs(lootBox:GetChildren()) do
		if child:IsA("Attachment") and child.Name == "Attachment" then
			table.insert(attachments, child)
		end
	end

	if #attachments == 0 then
		warn("No attachments found in loot box: " .. lootBox.Name)
		return
	end

	-- Prevent the loot box from being reused immediately
	if lootBox:FindFirstChild("LootedCheck") then
		if lootBox.LootedCheck.Value then
			return
		end
	else
		local Looted = Instance.new("BoolValue")
		Looted.Parent = lootBox
		Looted.Name = "LootedCheck"
		Looted.Value = false -- Start as unlooted
	end

	local LootboxModel = lootBox.SupplyBox
	local lootboxhumanoid = LootboxModel.Humanoid
	local lootboxanimator = lootboxhumanoid.Animator

	local boxidle = LootboxModel.Idle
	local boxOpen = LootboxModel.Open
	local boxClose = LootboxModel.Close
	local boxLoopOpen = LootboxModel.OpenIdle

	local boxtrack1 = lootboxanimator:LoadAnimation(boxidle)
	local boxtrack2 = lootboxanimator:LoadAnimation(boxOpen)
	local boxtrack3 = lootboxanimator:LoadAnimation(boxClose)
	local boxtrack4 = lootboxanimator:LoadAnimation(boxLoopOpen)

	
	
	-- Mark as looted
	lootBox.LootedCheck.Value = true
	boxtrack2:Play()
boxtrack4:Play(1)

	-- Spawn loot one by one
	for index, item in ipairs(lootData) do
		task.delay(index * 0.5, function() -- Delays each item by 0.5 seconds
			local chosenAttachment = attachments[math.random(1, #attachments)]
			local spawnPosition = chosenAttachment.WorldPosition

			-- Create loot part
			local lootPart = Instance.new("Part")
			lootPart.Name = item
			lootPart.Size = Vector3.new(1, 1, 1)
			lootPart.Position = lootBox.Position -- Start from the loot box
			lootPart.Anchored = true
			lootPart.BrickColor = BrickColor.White()
			--lootPart.Material = Enum.Material.Neon
			lootPart.Parent = lootBox:WaitForChild("DroppedLoot")


			-- Define arc motion
			local midPoint = lootBox.Position + Vector3.new(0, 2, 0) -- Adjust height if needed

			-- Tween to create arc effect
			local tweenInfo1 = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local tweenInfo2 = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

			local tween1 = TweenService:Create(lootPart, tweenInfo1, { Position = midPoint })
			local tween2 = TweenService:Create(lootPart, tweenInfo2, { Position = spawnPosition })

			-- Play tweens sequentially
			tween1:Play()
			tween1.Completed:Connect(function()
				tween2:Play()
			end)
		end)
	end

	-- Start the reset timer
	task.delay(resetTime, function()
		if lootBox:FindFirstChild("LootedCheck") then
			lootBox.LootedCheck.Value = false
			
			boxtrack2:Stop()
			boxtrack4:Stop()
		boxtrack3:Play()

			print(lootBox.Name .. " has been reset and is ready to be looted again!")
		end
	end)
end


-- Detect E key press and send interaction request to the server
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.E then
		local nearestLootBox = getNearestLootBox()
		if nearestLootBox then
			local lootedCheck = nearestLootBox:FindFirstChild("LootedCheck")
			if lootedCheck and lootedCheck.Value == true then
				warn("Loot box is already looted!") -- Debugging message
				return -- Stop interaction if the loot box is already looted
			end

			local character = player.Character
			local root = character and character:FindFirstChild("HumanoidRootPart")
			local charwalkspeed = character.Humanoid.WalkSpeed

			if root and humanoid and animator then
				-- Freeze movement
				humanoid.WalkSpeed = 0

				-- Create BodyGyro to rotate character towards loot box
				local bodyGyro = Instance.new("BodyGyro")
				bodyGyro.Parent = root
				bodyGyro.MaxTorque = Vector3.new(0, 400000, 0) -- Allow rotation on Y-axis
				bodyGyro.P = 10000 -- Responsiveness
				bodyGyro.CFrame = CFrame.lookAt(root.Position, Vector3.new(nearestLootBox.Position.X, root.Position.Y, nearestLootBox.Position.Z))

				-- Play animation
				lootAnimTrack:Play(0.5)

				-- Remove BodyGyro & restore movement after animation finishes
				task.delay(lootAnimTrack.Length, function()
					if bodyGyro then
						bodyGyro:Destroy()
					end
					if humanoid then
						humanoid.WalkSpeed = charwalkspeed
					end
				end)
			end

			interactEvent:FireServer(nearestLootBox)
		end
	end
end)

-- Receive loot data from the server and spawn loot
interactEvent.OnClientEvent:Connect(function(lootData, lootBox)
	spawnLoot(lootData, lootBox)
end)

--// END OF SCRIPT: game.StarterPlayer.StarterCharacterScripts.lootboxtest

--------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterPlayer.StarterPlayerScripts.CaffanSDK | 2025 | Enabled: true
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DebugEvent = ReplicatedStorage.Peak.Remotes.DebugInventory

local Iris = require(ReplicatedStorage.Peak.Modules.Librarys.Iris).Init()
local InventoryDebug = require(ReplicatedStorage.Peak.Modules.Librarys.Iris["CaffanSDK | 2025"])
local SmartBone = require(ReplicatedStorage.Peak.Modules.Client.SmartBone)

SmartBone.Start()

Iris:Connect(function()
	InventoryDebug.Render()
end)

DebugEvent.OnClientEvent:Connect(function(inv)
	InventoryDebug.UpdateInventory(inv)
end)
--// END OF SCRIPT: game.StarterPlayer.StarterPlayerScripts.CaffanSDK | 2025
  -  Edit
  18:44:47.697  --------------------------------------------------------------------
--// [METADATA - NOT PART OF SCRIPT] [LocalScript] Path: game.StarterPlayer.StarterPlayerScripts.Client | weapon | Enabled: true
--------------------------------------------------------------------
--**************************************************************
-- @ WeaponSystem | Client Script
--**************************************************************

--- @ WeaponClient
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local ContentProvider = game:GetService("ContentProvider")

--- @ WeaponClient > Player / Character
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local animator = humanoid:WaitForChild("Animator")

--- @ WeaponClient > Dependencies
local success, CameraController = pcall(function()
	return require(ReplicatedStorage.Peak.Modules.Camera.CameraController)
end)

if not success then
	warn("WeaponClient: Could not load CameraController.")
	CameraController = nil
end

local CrosshairHandler = require(ReplicatedStorage.Peak.Modules.Client.CrosshairHandler)
local HitmarkerHandler = require(ReplicatedStorage.Peak.Modules.Client.HitmarkerHandler)

--- @ WeaponClient > Remotes
local WeaponSysFolder = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes"):WaitForChild("WeaponSys")
local WeaponRemote = WeaponSysFolder:WaitForChild("Core")
local SetWeaponLock = WeaponSysFolder:WaitForChild("SetWeaponLock")
local DebugInventory = ReplicatedStorage.Peak.Remotes:WaitForChild("DebugInventory")

local Sounds = ReplicatedStorage.Peak:WaitForChild("Sounds")
local Hud = player.PlayerGui:WaitForChild("REARMED HUD"):WaitForChild("H")
local HealthBG = Hud:WaitForChild("HudBG")
local AmmoList = Hud:WaitForChild("AmmoList")
local AmmoTemplates = AmmoList:WaitForChild("Templates")
local PistolBullet = AmmoTemplates:WaitForChild("Pistol")
local RifleBullet = AmmoTemplates:WaitForChild("Rifle")
local ShotgunBullet = AmmoTemplates:WaitForChild("Shotgun")

local AmmoCount = Hud:WaitForChild("AmmoCount")
local WeaponIcons = Hud:WaitForChild("WeaponIcons")
local Point = Hud:WaitForChild("Point")
local Melee = Hud:WaitForChild("Melee")
local Shiv = Hud:WaitForChild("Shiv")
local Wrench = Hud:WaitForChild("Wrench")


local BulletIconsByType = {
	SmallFirearm = PistolBullet,
	LargeFirearm = RifleBullet,
	ShotgunFirearm = ShotgunBullet,
}


--- @ WeaponClient > Configuration
local CameraConfig = {
	FOV = {
		Default = 60,
		Aim = 40,
		Sprint = 67,
	},
	Offsets = {
		Default = Vector3.new(2, 0.5, 7),
		Aim = Vector3.new(2, 1.4, 4.5),
		Sprint = Vector3.new(2, 0.5, 8),
	},
	Settings = {
		DebugTracers = false,
	}
}

--- @ WeaponClient > Variables
local LocalInventory = {}
local currentWeapon = nil
local currentAmmo = 0
local weaponStats = nil 
local weaponActive = false 
local currentSpread = 0
local currentSlot = nil
local Firemode = nil

local isAiming = false
local isFiring = false
local isSprinting = false
local shoulderSwapped = false
local isBusy = false
local isLocked = false
local triggerDown = false
local firing = false
local fireConnection
local fireHeld = false
local burstActive = false

local loadedAnims = {}     
local currentIdle = nil
local currentEquipTrack = nil
local currentUnequipTrack = nil

CrosshairHandler.Init(player)
local HitmarkerUI = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
local cross = HitmarkerHandler.new(HitmarkerUI)

if cross and type(cross.FollowMouse) == "function" then
	cross:FollowMouse(true)
end

local function GetCurrentStance()
	local stance = character:GetAttribute("Stance")

	if stance == "Crouch" then
		return "Crouch"
	elseif stance == "Prone" then
		return "Prone"
	else
		return "Default"
	end
end

--- @ WeaponClient > VFX
local function DrawDebugRay(origin, endPos, color)
	local distance = (endPos - origin).Magnitude
	local p = Instance.new("Part")
	p.Name = "DebugTrace"
	p.Anchored = true
	p.CanCollide = false
	p.CanQuery = false
	p.CastShadow = false
	p.Material = Enum.Material.Neon
	p.Color = color or Color3.new(1, 0, 0)
	p.Size = Vector3.new(0.05, 0.05, distance)
	p.CFrame = CFrame.lookAt(origin, endPos) * CFrame.new(0, 0, -distance/2)
	p.Parent = workspace.Terrain
	Debris:AddItem(p, 0.05)
end

local function DrawTracer(origin, endPos, muzzleFX)
	local attachment0 = Instance.new("Attachment")
	attachment0.CFrame = CFrame.new(origin)
	attachment0.Parent = workspace.Terrain

	local attachment1 = Instance.new("Attachment")
	attachment1.CFrame = CFrame.new(endPos)
	attachment1.Parent = workspace.Terrain

	local beamsData = {}
	local maxLifetime = 0.25 

	if muzzleFX then
		for _, child in ipairs(muzzleFX:GetChildren()) do
			if child:IsA("Beam") then
				local lifetime = child:GetAttribute("Lifetime")
				local duration = (lifetime and typeof(lifetime) == "number") and lifetime or 0.25

				if duration > maxLifetime then
					maxLifetime = duration
				end

				table.insert(beamsData, {Beam = child:Clone(), Time = duration})
			end
		end
	end

	if #beamsData == 0 then
		local beam = Instance.new("Beam")
		beam.Transparency = NumberSequence.new(0.3)
		beam.Width0 = 0.1
		beam.Width1 = 0.1
		beam.FaceCamera = true
		beam.Color = ColorSequence.new(Color3.new(1, 1, 1))
		beam.LightEmission = 1
		beam.LightInfluence = 0
		table.insert(beamsData, {Beam = beam, Time = 0.25})
	end

	for _, data in ipairs(beamsData) do
		local beam = data.Beam
		local time = data.Time

		beam.Attachment0 = attachment0
		beam.Attachment1 = attachment1
		beam.Parent = workspace.Terrain

		local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(beam, tweenInfo, {Width0 = 0, Width1 = 0})
		tween:Play()

		Debris:AddItem(beam, time + 0.05)
	end

	Debris:AddItem(attachment0, maxLifetime + 0.05)
	Debris:AddItem(attachment1, maxLifetime + 0.05)
end

local function PlayMuzzleFX(char, weaponName)
	if not char then return end
	local model = char:FindFirstChild(weaponName)
	if not model then return end

	local handle = model:FindFirstChild("Handle")
	if not handle then return end

	local muzzleFX = handle:FindFirstChild("MuzzleFX")
	if not muzzleFX then return end

	local fireSound = muzzleFX:FindFirstChild("FireSound")
	if fireSound then
		fireSound:Play()
	end

	for _, child in ipairs(muzzleFX:GetChildren()) do
		if child:IsA("ParticleEmitter") then
			local count = child:GetAttribute("EmitCount") or 1
			child:Emit(count)
		end
	end

	local light = muzzleFX:FindFirstChildWhichIsA("Light")
	if light then
		light.Enabled = true
		task.delay(0.05, function()
			if light then light.Enabled = false end
		end)
	end
end

local function PlayDryFire(char, weaponName)
	if not char then return end
	local model = char:FindFirstChild(weaponName)
	if not model then return end

	local handle = model:FindFirstChild("Handle")
	if not handle then return end

	local muzzleFX = handle:FindFirstChild("MuzzleFX")
	if not muzzleFX then return end

	local emptySound = muzzleFX:FindFirstChild("Empty")
	if emptySound then
		emptySound:Play()
	end
end



--- @ WeaponClient > Helper Functions
function RequestEquipWeapon(weaponName, slot)
	WeaponRemote:FireServer("Equip", {
		WeaponName = weaponName,
		Slot = slot
	})
end

local function UpdateAmmoUI(weaponName, ammo, magSize)
	-- Clear old bullets
	for _, child in ipairs(AmmoList:GetChildren()) do
		if child:IsA("ImageLabel") then
			child:Destroy()
		end
	end

	-- Fetch weapon data
	local weaponModuleScript = ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData:FindFirstChild(weaponName)
	if not weaponModuleScript then return end

	local weaponData = require(weaponModuleScript)
	local weaponType = weaponData.WeaponType

	local template = BulletIconsByType[weaponType]
	if not template then return end

	ammo = math.clamp(ammo, 0, magSize)
	-- Build bullets
	for i = 1, magSize do
		local bullet = template:Clone()
		bullet.LayoutOrder = i
		bullet.Visible = true
		bullet.Parent = AmmoList

		-- Show empty bullets
		if i > ammo then
			bullet.ImageColor3 = Color3.fromRGB(45, 45, 45) -- dark/empty
		else
			bullet.ImageColor3 = Color3.fromRGB(255, 255, 255) -- full
		end
	end

	-- Update numeric counter
	AmmoCount:WaitForChild("Reserve").Text = magSize
	AmmoCount:WaitForChild("Mag").Text = ammo
end

local function UpdateWeaponIcons(weaponName)
	for _, icon in ipairs(WeaponIcons:GetChildren()) do
		if icon:IsA("ImageLabel") then
			icon.Visible = (icon.Name == weaponName)
		end
	end
end

local function LoadWeaponAnimations(weaponName)
	for key, track in pairs(loadedAnims) do
		if typeof(track) == "Instance" and track:IsA("AnimationTrack") then
			track:Stop()
		end
	end
	loadedAnims = {}

	local weaponModuleScript = ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData:FindFirstChild(weaponName)
	if not weaponModuleScript then
		warn("Weapon data not found for:", weaponName)
		return
	end

	local weaponModule = require(weaponModuleScript)

	local stance = GetCurrentStance()

	local animSet = weaponModule.AnimationIds[stance]

	if shoulderSwapped and weaponModule.AnimationIds.Left then
		animSet = weaponModule.AnimationIds.Left
	end

	if not animSet then return end

	local assetsToLoad = {}
	local animMap = {}

	local function stageAnim(key, entry)
		if not entry or not entry.Id then return end
		local anim = Instance.new("Animation")
		anim.AnimationId = entry.Id
		table.insert(assetsToLoad, anim)
		animMap[key] = {Anim = anim, Priority = entry.Priority}
	end

	stageAnim("Equip", animSet.Equip)
	stageAnim("UnEquip", animSet.UnEquip)
	stageAnim("Shoot", animSet.Shoot)
	stageAnim("Aim", animSet.Aim)
	stageAnim("Reload", animSet.Reload)
	stageAnim("Idle", animSet.Idle)
	stageAnim("Sprint", animSet.Sprint)

	ContentProvider:PreloadAsync(assetsToLoad)

	for key, info in pairs(animMap) do
		local track = animator:LoadAnimation(info.Anim)
		if info.Priority then track.Priority = info.Priority end

		if key == "Equip" then
			currentEquipTrack = track
		elseif key == "UnEquip" then
			currentUnequipTrack = track
		elseif key == "Idle" then
			currentIdle = track
			loadedAnims.Idle = track
		else
			loadedAnims[key] = track
		end
	end
end

local function IsSidearm()
	if not weaponStats then return false end
	return weaponStats.WeaponClass == "Sidearm"  -- you choose the tag name
end

--- @ WeaponClient > Actions
local function StartSprint()
	if not weaponActive then return end
	if isSprinting then return end
	if isAiming then return end
	if isLocked then return end
	if isBusy then return end
	if not loadedAnims.Sprint then return end

	isSprinting = true

	-- STOP AIM
	if loadedAnims.Aim then
		loadedAnims.Aim:Stop(0.15)
	end

	--  SIDEARM: Stop idle while sprinting
	if IsSidearm() and currentIdle then
		currentIdle:Stop(0.25)
	end

	-- PLAY SPRINT ANIM
	loadedAnims.Sprint:Play(0.35)

	-- CAMERA STUFF
	if CameraController then
		CameraController:TweenOffset(CameraConfig.Offsets.Sprint, TweenInfo.new(0.35))
		CameraController:TweenFOV(CameraConfig.FOV.Sprint, TweenInfo.new(0.35))
	end
end

local function StopSprint()
	if not isSprinting then return end
	isSprinting = false

	if loadedAnims.Sprint then
		loadedAnims.Sprint:Stop(0.35)
	end

	--  SIDEARM: Bring idle back smoothly once sprint ends
	if IsSidearm() and currentIdle and weaponActive and not isAiming then
		currentIdle:Play(0.25)
		currentIdle.Looped = true
	end

	if CameraController then
		CameraController:TweenOffset(CameraConfig.Offsets.Default, TweenInfo.new(0.35))
		CameraController:TweenFOV(CameraConfig.FOV.Default, TweenInfo.new(0.35))
	end
end
local function SetAim(state)
	if not weaponActive then return end
	if isBusy and state == true then return end 
	if isAiming == state then return end

	if state and isLocked then return end

	if state then StopSprint() end
	isAiming = state

	if character then
		character:SetAttribute("IsAiming", state)
	end

	CrosshairHandler.SetVisible(state)

	if state then
		if loadedAnims.Aim then loadedAnims.Aim:Play(0.2) end

		if CameraController then
			CameraController:TweenOffset(CameraConfig.Offsets.Aim, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
			CameraController:TweenFOV(CameraConfig.FOV.Aim, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
		end
	else
		if loadedAnims.Aim then loadedAnims.Aim:Stop(0.2) end
		if currentIdle and weaponActive and not isSprinting then
			currentIdle:Play(0.2)
		end

		if CameraController then
			CameraController:TweenOffset(CameraConfig.Offsets.Default, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
			CameraController:TweenFOV(CameraConfig.FOV.Default, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
		end
	end
end


local _unequipInProgress = false

local function UnequipWeapon()
	-- Prevent re-entry
	if _unequipInProgress then return end
	_unequipInProgress = true

	isBusy = true

	-- Cache BEFORE anything mutates these
	local weaponName = currentWeapon
	local slot = currentSlot
	local cachedSlot = slot or "Primary" -- safety default

	if currentIdle then currentIdle:Stop(0.1) end

	for _, track in pairs(loadedAnims) do
		if track and track.IsPlaying then
			track:Stop(0.1)
		end
	end

	-- sendFinish is safe-once (local guard)
	local sentFinish = false
	local function sendFinish(cf)
		if sentFinish then return end
		sentFinish = true

		-- double-safe default
		local finalSlot = cachedSlot or "Primary"

		WeaponRemote:FireServer("FinishUnequip", {
			WeaponName = weaponName or "Unknown",
			Slot = finalSlot,
			FinalCFrame = cf
		})
	end

	if currentUnequipTrack then
		currentUnequipTrack.Looped = false
		currentUnequipTrack:Play()

		currentUnequipTrack.Stopped:Once(function()
			local finalCF = CFrame.new()

			if character and weaponName then
				local weaponModel = character:FindFirstChild(weaponName)
				if weaponModel then
					local handle = weaponModel:FindFirstChild("Handle")
					if handle then
						finalCF = handle.CFrame
					end
				end
			end

			sendFinish(finalCF)
		end)
	else
		-- immediate
		sendFinish(CFrame.new())
		weaponActive = false
		-- clear slot so input checks won't think we still hold a slot
		currentSlot = nil
	end

	-- Cleanup AFTER caching everything
	SetAim(false)
	triggerDown = false
	if character then character:SetAttribute("IsAiming", false) end
	StopSprint()

	if CameraController then
		CameraController:TweenOffset(CameraConfig.Offsets.Default, TweenInfo.new(0.4))
		CameraController:TweenFOV(CameraConfig.FOV.Default, TweenInfo.new(0.4))
	end

	-- wipe local references now

	print("[WeaponClient] Unequipped safely")

	-- allow another unequip after a short delay
	task.delay(5, function()
		if _unequipInProgress then
			-- timeout fallback: fully clear client state
			_unequipInProgress = false
			isBusy = false
			currentWeapon = nil
			currentSlot = nil
			weaponActive = false
			CleanupClientWeapon()
			warn("[WeaponClient] Unequip timed out â€” forcing client cleanup")
		end
	end)
end



local function SetWeapon(weaponName, ammo, baseStats, fireMode)
	isBusy = true
	SetAim(false)
	triggerDown = false

	if currentIdle then currentIdle:Stop() end

	currentWeapon = weaponName
	currentAmmo = ammo

	local incoming = baseStats or {}
	local base = (type(incoming) == "table" and incoming.Base and type(incoming.Base) == "table")
		and incoming.Base or incoming


	weaponStats = base or {}
	weaponStats.FireMode = fireMode or incoming.FireMode or weaponStats.FireMode or "Semi"

	UpdateWeaponIcons(weaponName)
	UpdateAmmoUI(currentWeapon, currentAmmo, weaponStats.MagSize)

	if weaponStats and weaponStats.Spread then
		currentSpread = weaponStats.Spread.Min
	end

	if fireMode ~= nil then
		weaponStats.FireMode = fireMode
	end

	LoadWeaponAnimations(weaponName)

	if currentWeapon ~= weaponName then return end

	CrosshairHandler.SetStyle("Circle")
	print("[SetWeapon] weaponStats.FireMode =", weaponStats.FireMode)

	if weaponStats and weaponStats.FireRate then
		print("[SetWeapon] FireRate:", weaponStats.FireRate)
	end

	local equipTime = 0
	if currentEquipTrack then 
		currentEquipTrack:Play() 
		if currentEquipTrack.Length > 0 then
			equipTime = currentEquipTrack.Length
		end
	end

	task.delay(equipTime, function()
		if currentWeapon == weaponName then
			isBusy = false

			if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
				SetAim(true)
			end
		end
	end)

	local thisWeapon = weaponName

	task.delay(0.25, function()
		if weaponActive and currentWeapon == thisWeapon and currentIdle and not isSprinting then
			currentIdle:Play()
			currentIdle.Looped = true
		end
	end)

	print("[WeaponClient] Equipped", weaponName)
end

local function FireWeapon()
	local weaponModel = character:FindFirstChild(currentWeapon)
	if not weaponModel then return end
	local handle = weaponModel:FindFirstChild("Handle")
	if not handle then return end

	local camera = workspace.CurrentCamera
	local mouseLocation = UserInputService:GetMouseLocation()
	local screenRay = camera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y)

	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character, weaponModel, camera}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	local maxDist = weaponStats and weaponStats.MaxDistance or 2000

	local spreadOffset = Vector3.new(
		math.random() - 0.5, 
		math.random() - 0.5, 
		math.random() - 0.5
	).Unit * (currentSpread / 100)

	local rayDirection = (screenRay.Direction + spreadOffset).Unit

	local targetPos
	local cameraHit = workspace:Raycast(screenRay.Origin, rayDirection * maxDist, raycastParams)
	if cameraHit then
		targetPos = cameraHit.Position
	else
		targetPos = screenRay.Origin + rayDirection * maxDist
	end

	local muzzlePos = handle.Position
	local muzzleFX = handle:FindFirstChild("MuzzleFX")
	if muzzleFX then
		muzzlePos = muzzleFX.WorldPosition
	end

	local gunRayDir = (targetPos - muzzlePos).Unit
	local muzzleClearance = weaponStats and weaponStats.MuzzleLength or 4

	if currentAmmo <= 0 then 
		PlayDryFire(character, currentWeapon)
		isFiring = true
		task.delay(0.2, function() isFiring = false end)
		return 
	end

	isFiring = true 

	if weaponStats and weaponStats.Spread then
		currentSpread = math.min(currentSpread + weaponStats.Spread.IncreasePerShot, weaponStats.Spread.Max)
	end

	if loadedAnims.Shoot then 
		loadedAnims.Shoot.Looped = false 
		loadedAnims.Shoot:Play() 
	end

	PlayMuzzleFX(character, currentWeapon)

	DrawTracer(muzzlePos, targetPos, muzzleFX)

	if CameraConfig.Settings.DebugTracers then
		DrawDebugRay(muzzlePos, targetPos, Color3.new(1, 0, 0))
	end

	if CameraController and weaponStats and weaponStats.Recoil then
		local vRecoil = weaponStats.Recoil.Vertical or 1
		local hRecoil = weaponStats.Recoil.Horizontal or 0.5

		local kickX = math.random(-hRecoil*10, hRecoil*10) / 100
		local kickY = math.random(vRecoil*50, vRecoil*100) / 100

		CameraController:AddRecoil(kickX, kickY)
	end

	WeaponRemote:FireServer("Shoot", {
		TargetPosition = targetPos,
		Slot = currentSlot
	})
	currentAmmo -= 1
	UpdateAmmoUI(currentWeapon, currentAmmo, weaponStats.MagSize)

	local cooldown = weaponStats.FireRate or 0.15
	task.delay(cooldown, function()
		isFiring = false
	end)
end

local autoLoop = nil

local function IsTriggerHeld()
	return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
end

local function StartAutoFire()
	print("StartAutoFire CALLED") 
	if autoLoop then
		print("Auto loop already active")
		return
	end
	print("Creating auto loop...")
	autoLoop = RunService.Heartbeat:Connect(function()
		print("Auto loop tick")
		if not IsTriggerHeld() then return end

		if not weaponActive or not currentWeapon then return end
		if not isAiming then return end
		if isBusy or isLocked then return end

		if not weaponStats or weaponStats.FireMode ~= "Auto" then return end
		if currentAmmo <= 0 then return end

		if isFiring then
			return
		end
		print("Auto Loop Active", isAiming, isFiring)
		FireWeapon()
	end)
end

local function StopAutoFire()
	if autoLoop then
		autoLoop:Disconnect()
		autoLoop = nil
	end
end


local function ReloadWeapon()
	if not weaponActive or not currentWeapon then return end
	if isBusy then return end
	if isLocked then return end
	if currentAmmo >= weaponStats.MagSize then return end

	isBusy = true
	triggerDown = false
	StopSprint()

	if loadedAnims.Reload then
		loadedAnims.Reload:Play()

		task.delay(loadedAnims.Reload.Length, function()
			if weaponActive and currentWeapon then
				WeaponRemote:FireServer("Reload", {
					Slot = currentSlot
				})
				isBusy = false
				currentAmmo = weaponStats.MagSize
				UpdateAmmoUI(currentWeapon, currentAmmo, currentAmmo)

			end
		end)
	else
		WeaponRemote:FireServer("Reload")
		currentAmmo = weaponStats.MagSize
		UpdateAmmoUI(currentWeapon, currentAmmo, currentAmmo)
		isBusy = false
	end
end



SetWeaponLock.Event:Connect(function(locked)
	isLocked = locked
	if isLocked then
		SetAim(false)
		StopSprint()
		triggerDown = false
	end
end)

--- @ WeaponClient > Networking
DebugInventory.OnClientEvent:Connect(function(invData)
	LocalInventory = invData or {}
end)

--- @ WeaponClient > Input Handling
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then

		triggerDown = true

		if not weaponActive or not isAiming or isBusy or isLocked or not currentWeapon then
			return
		end

		local fireMode = (weaponStats and weaponStats.FireMode) or "Semi"
		print("[InputBegan] fireMode ->", fireMode, "weaponStats exists?", weaponStats ~= nil)

		if fireMode == "Semi" then
			if not isFiring then
				FireWeapon()
			end
			return
		end

		if fireMode == "Burst" then
			if not isFiring then
				task.spawn(function()
					for i = 1, weaponStats.BurstCount or 3 do
						if not triggerDown then break end
						if isFiring then break end
						if isBusy or isLocked then break end
						if currentAmmo <= 0 then break end

						FireWeapon()
						task.wait(weaponStats.BurstDelay or 0.06)
					end
				end)
			end
			return
		end

		if fireMode == "Auto" then
			StartAutoFire()
			return
		end
	end

	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		if weaponActive and not isBusy then
			SetAim(true)
		end
	end

	if input.KeyCode == Enum.KeyCode.R then
		if weaponActive then
			ReloadWeapon()
		end
	end

	if input.KeyCode == Enum.KeyCode.One then
		if isBusy or isLocked then return end

		-- inventory ready?
		if not LocalInventory or not LocalInventory.Weapons then
			warn("Inventory not ready yet")
			return
		end

		local weapon = LocalInventory.Weapons.Primary
		if not weapon then return end

		--------------------------------------------------------------------
		-- CASE 1: Already holding PRIMARY â†’ UNEQUIP
		--------------------------------------------------------------------
		if weaponActive and currentSlot == "Primary" then
			UnequipWeapon("Primary")
			return
		end

		--------------------------------------------------------------------
		-- CASE 2: Holding another slot â†’ UNEQUIP FIRST, then EQUIP PRIMARY
		--------------------------------------------------------------------
		if weaponActive and currentSlot ~= "Primary" then
			local oldSlot = currentSlot

			UnequipWeapon(oldSlot)

			return
		end

		--------------------------------------------------------------------
		-- CASE 3: No weapon out â†’ EQUIP PRIMARY
		--------------------------------------------------------------------
		if not weaponActive then
			RequestEquipWeapon(weapon, "Primary")
			return
		end
	end

	if input.KeyCode == Enum.KeyCode.Two then
		if isBusy or isLocked then return end
		local weapon = LocalInventory.Weapons and LocalInventory.Weapons.Secondary
		if not weapon then return end

		if weaponActive and currentSlot == "Secondary" then
			UnequipWeapon()
		else
			if weaponActive then 
				UnequipWeapon()
				task.wait(0.5)
			end
			RequestEquipWeapon(weapon, "Secondary")
		end
	end

	if input.KeyCode == Enum.KeyCode.Q then
		if weaponActive and CameraController and not isLocked and not isBusy then
			CameraController:SwapShoulder()
		end
	end

	if input.KeyCode == Enum.KeyCode.LeftShift then
		if weaponActive and not isBusy then
			StartSprint()
		end
	end
end)

UserInputService.InputEnded:Connect(function(input, gp)
	if gp then return end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		triggerDown = false
		StopAutoFire()
	end

	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		SetAim(false)
	end

	if input.KeyCode == Enum.KeyCode.LeftShift then
		StopSprint()
	end
end)

local WhizFolder = Sounds:WaitForChild("Whiz")

local WHIZ_MAX_DIST = 5        -- Bullet passed VERY close to head
local WHIZ_MED_DIST = 12       -- Medium-close
local WHIZ_LIGHT_DIST = 20     -- Barely passed
local DISTANT_SHOT_MIN = 150    -- Muzzle far away â†’ distant shot plays

-- Returns closest distance between player head and bullet line segment
local function DistanceFromLine(point, a, b)
	local ab = b - a
	local t = ((point - a):Dot(ab)) / (ab:Dot(ab))
	t = math.clamp(t, 0, 1)
	local closest = a + ab * t
	return (point - closest).Magnitude
end

local function PlayRandom(folder)
	local list = folder:GetChildren()
	if #list == 0 then return end
	local chosen = list[math.random(1, #list)]
	if chosen:IsA("Sound") then
		chosen:Play()
	end
end

local function PlayDistantAtMuzzle(muzzle, folder)
	if not (muzzle and folder) then return end

	local sounds = folder:GetChildren()
	if #sounds == 0 then return end

	local chosen = sounds[math.random(1, #sounds)]
	if not chosen:IsA("Sound") then return end

	-- Clone & parent to muzzle
	local clone = chosen:Clone()
	clone.Parent = muzzle
	clone.PlayOnRemove = false

	-- Autodestroy when done
	clone.Ended:Connect(function()
		clone:Destroy()
	end)

	clone:Play()
end

function CleanupClientWeapon()
	-- stop animations
	for _, t in ipairs(loadedAnims) do
		t:Stop(0)
	end

	if currentIdle then
		currentIdle:Stop(0)
	end
end
--- @ WeaponClient > Remote Responses
WeaponRemote.OnClientEvent:Connect(function(action, data)
	if action == "Equipped" then
		weaponActive = true
		currentSlot = data.Slot
		SetWeapon(data.WeaponName, data.Ammo, data.Data, data.FireMode)

	elseif action == "Unequipped" or action == "Holstered" then
		-- Server signals the weapon is no longer equipped / moved to holster.
		-- Treat this as the server-side confirmation for the unequip flow.
		weaponActive = false
		isBusy = false
		-- clear client-side weapon references now
		currentWeapon = nil
		currentSlot = nil
		currentIdle = nil
		_unequipInProgress = false

		-- Full cleanup: stop animations, clear aiming/sprinting and UI
		isAiming = false
		isSprinting = false
		triggerDown = false

		if CleanupClientWeapon then
			CleanupClientWeapon()
		else
			for _, track in pairs(loadedAnims) do
				if track and track.IsPlaying then
					track:Stop(0)
				end
			end
			if currentEquipTrack then currentEquipTrack:Stop(0) end
			if currentUnequipTrack then currentUnequipTrack:Stop(0) end
		end

		print("[WeaponClient] Server confirmed holster/unequip -> client cleaned up")

	elseif action == "UnequipConfirmed" then
		-- back-compat if you ever emit explicit confirm name
		weaponActive = false
		currentWeapon = nil
		currentSlot = nil
		currentIdle = nil
		isBusy = false
		_unequipInProgress = false
		if CleanupClientWeapon then CleanupClientWeapon() end

		print("[WeaponClient] UnequipConfirmed received -> cleared state")

	elseif action == "Shot" then
		if data.Player == player then
			currentAmmo = data.Ammo
		else
			-- OTHER PLAYER FIRED
			if data.Player.Character then
				PlayMuzzleFX(data.Player.Character, data.WeaponName)

				if data.Payload and data.Payload.TargetPosition then
					local otherModel = data.Player.Character:FindFirstChild(data.WeaponName)
					if otherModel then
						local otherHandle = otherModel:FindFirstChild("Handle")
						if otherHandle then
							local otherMuzzle = otherHandle:FindFirstChild("MuzzleFX")
							local origin = otherMuzzle and otherMuzzle.WorldPosition or otherHandle.Position

							local camPos = workspace.CurrentCamera.CFrame.Position
							local muzzleDist = (camPos - origin).Magnitude

							if muzzleDist >= DISTANT_SHOT_MIN then
								PlayDistantAtMuzzle(otherMuzzle or otherHandle, WhizFolder.Distant)
							end

							local target = data.Payload.TargetPosition



							if CameraConfig.Settings.DebugTracers then
								DrawDebugRay(origin, target, Color3.new(1, 0.6, 0))
							else
								DrawTracer(origin, target, otherMuzzle)
							end


							-- Only crack for bullets NOT fired by us
							local head = character:FindFirstChild("Head")
							if head then
								local headPos = head.Position

								local dist = DistanceFromLine(headPos, origin, target)
								local muzzleDist = (origin - headPos).Magnitude

								if dist <= WHIZ_MAX_DIST then
									PlayRandom(WhizFolder.Heavy)
								elseif dist <= WHIZ_MED_DIST then
									PlayRandom(WhizFolder.Medium)
								elseif dist <= WHIZ_LIGHT_DIST then
									PlayRandom(WhizFolder.Light)
								end
							end
						end
					end
				end
			end
		end

	elseif action == "Reloaded" then
		if data.Player == player then
			currentAmmo = data.Ammo
		end

	elseif action == "ForceStopAllWeaponAnimations" or action == "Holstered" then
		isBusy = false 

		for _, track in pairs(loadedAnims) do
			if track and typeof(track) == "Instance" then track:Stop(0) end
		end
		if currentEquipTrack then currentEquipTrack:Stop(0) end
		if currentUnequipTrack then currentUnequipTrack:Stop(0) end

		if animator then
			for _, t in ipairs(animator:GetPlayingAnimationTracks()) do
				if t.Priority == Enum.AnimationPriority.Action or t.Priority == Enum.AnimationPriority.Action2 or t.Priority == Enum.AnimationPriority.Action3 or t.Priority == Enum.AnimationPriority.Action4 then
					t:Stop(0)
				end
			end
		end

		currentIdle = nil
		isAiming = false
		isSprinting = false
		triggerDown = false
	elseif action == "HitMarker" then
		local isHeadshot = (data.HitPart == "Head")

		-- Play SOUNDS (optional)
		if isHeadshot then
			Sounds.hitmarker.headmarker:Play()
		else
			Sounds.hitmarker.newkillmarker:Play()
		end
		-- Trigger UI hitmarker
		if cross then
			cross:HitMarker(isHeadshot)
		end
	end
end)

--- @ WeaponClient > Render Loop
local lastMoveDir = Vector3.zero

RunService.RenderStepped:Connect(function(dt)
	if not weaponActive then
		if isSprinting then StopSprint() end
		lastMoveDir = humanoid.MoveDirection
		return
	end

	if weaponActive then
		UserInputService.MouseIconEnabled = false

		if weaponStats and weaponStats.Spread then
			local spreadData = weaponStats.Spread
			local minSpread = spreadData.Min
			local decay = spreadData.DecaySpeed * dt

			if currentSpread > minSpread then
				currentSpread = math.max(minSpread, currentSpread - decay)
			end

			CrosshairHandler.SetSpread(currentSpread * 20)
		end
	end

	local moveDir = humanoid.MoveDirection
	local shiftHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

	if moveDir.Magnitude > 0 then
		if shiftHeld and not isSprinting and not isAiming and not isBusy then
			StartSprint()
		end
	else
		if isSprinting then
			StopSprint()
		end
	end

	if isSprinting and not shiftHeld then
		StopSprint()
	end

	lastMoveDir = moveDir
end)
--[[
character:GetAttributeChangedSignal("Stance"):Connect(function()
	if not weaponActive or not currentWeapon then return end

	for _, track in pairs(loadedAnims) do
		if track and track.IsPlaying then
			track:Stop(0.2)
		end
	end

	LoadWeaponAnimations(currentWeapon)

	task.delay(0.05, function()
		if not weaponActive or not currentWeapon then return end

		if currentIdle then
			currentIdle:Play(0.2)
		end
		if isAiming and loadedAnims.Aim then
			loadedAnims.Aim:Play(0.2)
		end
	end)
end)
--]]

player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	animator = humanoid:WaitForChild("Animator")

	print("[WeaponClient] Character respawn detected â†’ rebuilding animation state")

	-- Clear old animations
	loadedAnims = {}
	currentIdle = nil
	currentEquipTrack = nil
	currentUnequipTrack = nil
	weaponActive = false
	currentWeapon = nil
	weaponStats = nil
	isBusy = false
	isLocked = false
	isFiring = false
	triggerDown = false
	isAiming = false

	-- Reload animations if weapon was active before death
	if currentWeapon then
		print("[WeaponClient] Reloading animations for", currentWeapon)
		LoadWeaponAnimations(currentWeapon)

		-- Restore idle animation
		task.delay(0.3, function()
			if weaponActive and currentIdle then
				currentIdle:Play()
				currentIdle.Looped = true
			end
		end)
	end
end)
--// END OF SCRIPT: game.StarterPlayer.StarterPlayerScripts.Client | weapon
  -  Edit
  18:44:47.927  

====================================================================  -  Edit
  18:44:47.927  ====================================================================  -  Edit
  18:44:47.927  ==                                                                ==  -  Edit
  18:44:47.927  ==                  END OF SCRIPT EXPORT PROCESS                  ==  -  Edit
  18:44:47.927  ==            (Exported a total of 161 scripts)             ==  -  Edit
  18:44:47.928  ==                                                                ==  -  Edit
  18:44:47.928  ====================================================================  -  Edit
  18:44:47.928  ====================================================================
  -  Edit
