  14:14:59.557  Printing now...  -  Edit
  14:14:59.557  --- START OF FILE game.txt ---
  -  Edit
  14:14:59.557   â–¶ ==================================================================== (x2)  -  Edit
  14:14:59.557  ==                                                                ==  -  Edit
  14:14:59.557  ==                 START OF SCRIPT EXPORT PROCESS                 ==  -  Edit
  14:14:59.557  ==                                                                ==  -  Edit
  14:14:59.557  ====================================================================  -  Edit
  14:14:59.557  ====================================================================
  -  Edit
  14:14:59.559  --------------------------------------------------------------------
--// [Script] Path: game.Workspace.Launch Pad Test.Script | Enabled: true
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")

local Peak = ReplicatedStorage:WaitForChild("Peak")
local Remotes = Peak:WaitForChild("Remotes")
local WeaponRemotes = Remotes:WaitForChild("WeaponSys")
local ObjectHitEvent = WeaponRemotes:WaitForChild("ObjectHit")

local pad = script.Parent
local soundActive = pad:WaitForChild("Activation")
local soundDeactive = pad:WaitForChild("Deactivate")

local isActive = false
local launchPower = 250 
local hitDebounce = {}

pad.Color = Color3.fromRGB(255, 0, 0)

local function ActivatePad()
	if isActive then return end
	isActive = true

	pad.Color = Color3.fromRGB(0, 255, 0)
	soundActive:Play()

	task.wait(5)

	soundDeactive:Play()
	pad.Color = Color3.fromRGB(255, 0, 0)
	isActive = false
	hitDebounce = {}
end

pad.Touched:Connect(function(hit)
	if not isActive then return end

	local char = hit.Parent
	local hrp = char:FindFirstChild("HumanoidRootPart")

	if hrp and not hitDebounce[char] then
		hitDebounce[char] = true

		hrp.CFrame = hrp.CFrame + Vector3.new(0, 0.2, 0)

		hrp.AssemblyLinearVelocity = pad.CFrame.UpVector * launchPower

		task.delay(1, function()
			hitDebounce[char] = nil
		end)
	end
end)

local connection = ObjectHitEvent.Event:Connect(function(player, hitPart, hitPosition, weaponData, shotDirection)
	if hitPart == pad then
		ActivatePad()
	end
end)

pad.Destroying:Connect(function()
	if connection then connection:Disconnect() end
end)
--// END OF SCRIPT: game.Workspace.Launch Pad Test.Script

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterPlayer.StarterCharacterScripts.DataBridgeExample | Enabled: false
--------------------------------------------------------------------
local DataEvent = game.ReplicatedStorage.DataEvent

-- Example:
DataEvent:FireServer("Add", "Inventory.Resources.Alcohol", 1)
DataEvent:FireServer("Add", "Inventory.Consumables.Medkits", 1)
DataEvent:FireServer("Remove", "Inventory.Ammo.Primary", 5)


-- add items from cmd to test
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Resources.Alcohol", 3)

game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Resources.Blades", 5)
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Consumables.Molotovs", 1)
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Ammo.Primary", 20)
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Add", "Inventory.Weapons.Primary", "Vepr")
game.ReplicatedStorage.Peak.Remotes.DataEvent:FireServer("Remove", "Inventory.Resources.Rags", 2)

--// END OF SCRIPT: game.StarterPlayer.StarterCharacterScripts.DataBridgeExample

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterPlayer.StarterCharacterScripts.Framework | Enabled: true
--------------------------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Tweenservice = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local Debris = game:GetService("Debris")
local ContentProvider = game:GetService("ContentProvider")

local LeanController = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].LeanController)
local FootPlanting = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].FootPlanting)
local CameraController = require(ReplicatedStorage.Peak.Modules.Camera.CameraController)
local AnimationData = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].Animations.Animations)
local AnimationList = AnimationData.GetList()

local CameraFX = require(ReplicatedStorage.Peak.Modules.Camera.CameraFX)
local FootstepModule = require(ReplicatedStorage.Peak.Modules.Librarys.FootstepModule)
local RootMotion = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].RootMotionModule)
local DebugDraw = require(ReplicatedStorage.Peak.Modules["Character Manipulation"].RootMotionModule.DebugDraw)

local WeaponRemotes = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes"):WaitForChild("WeaponSys")
local SetWeaponLock = WeaponRemotes:WaitForChild("SetWeaponLock")


local Config = {
	Movement = {
		WalkSpeed = 8, 
		SprintSpeed = 17, 
		Acceleration = 8, 
		CrouchDeceleration = 5, 
		RotationSpeed = 12, 
		AimRotationSpeed = 35, 
	},

	FootPlanting = {
		IdleInfluence = 100, 
		WalkInfluence = 50, 
		Smoothness = 5, 
	},

	Audio = {
		StepBaseSpeed = 0.55, 
	},

	Visuals = {
		AnimFadeTime = 0.2, 
		MaxTiltAngle = 20, 

		CameraNoise = {
			Idle   = {Intensity = Vector3.new(0.3, 0.4, 0.5), Speed = 0.2, Smoothness = 6},
			Walk   = {Intensity = Vector3.new(0.5, 0.5, 0.5), Speed = 1.5, Smoothness = 5},
			Sprint = {Intensity = Vector3.new(0.6, 0.5, 0.6), Speed = 2.5, Smoothness = 5},
			Aim    = {Intensity = Vector3.zero,               Speed = 1.0, Smoothness = 8},
		},
	},

	Vaulting = {
		MaxDist = 3.5, 
		MinHeight = 1.5, 
		MaxHeight = 4.5, 
		DepthCheck = 1.0, 
		SafetyClearance = 1.0, 
		MinLandingSpace = 0.5, 
		MaxTraversal = 8.0, 
		DebugMode = false, 
	},

	Diving = {
		Force = 70,
		UpForce = 22,
		RecoveryTime = 1.2,
		LandImpulseDown = 2.5,
		LandImpulseDir = 3.5,
	}
}


local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local head = character:WaitForChild("Head") 

local torso = character:WaitForChild("Torso")
local neck = torso:WaitForChild("Neck")
local rightShoulder = torso:WaitForChild("Right Shoulder")
local leftShoulder = torso:WaitForChild("Left Shoulder")

local originNeckC0 = neck.C0
local originRightC0 = rightShoulder.C0
local originLeftC0 = leftShoulder.C0

local currentArmPitch = 0

local Playergui = player:WaitForChild("PlayerGui")
local REARMED = nil
local BackpackFrame = nil

local currentFootInfluence = Config.FootPlanting.IdleInfluence
local animationTracks = {}
local currentAnimSpeed = 0
local lastStepTime = 0

local State = "Standing"
local States = {"Standing", "Crouching", "Proning", "Backpack", "Down", "Dead", "Diving"}
local backpackOpen = false
local Canmove = true
local transitionActive = false
local transitionEndTime = 0
local vaultDebounce = false
local diveStartTime = 0
local diveCooldown = false

local Voicelines = ReplicatedStorage.Peak.Assets:WaitForChild("Voices")

local Voice = "Merc2"

if player.Name == "kaiizyr" then
	Voice = "Merc1"
else
	Voice = "Merc2"
end


local function PlayVoiceline(killer, category)
	local pack = Voicelines:FindFirstChild(Voice)
	if not pack then return end

	local folder = pack:FindFirstChild(category)
	if not folder then return end

	local sounds = folder:GetChildren()
	if #sounds < 1 then return end

	local sound = sounds[math.random(1, #sounds)]:Clone()

	local char = killer.Character
	if not char then return end

	local head = char:FindFirstChild("Head")
	if not head then return end

	sound.Parent = head
	sound:Play()

	game.Debris:AddItem(sound, sound.TimeLength + 10)
end

local function LoadPlayerAnimations(humanoid, animationList)
	local animator = humanoid:WaitForChild("Animator")

	local tracks = {}
	local preload = {}

	for name, data in pairs(animationList) do
		if data.Id then
			local anim = Instance.new("Animation")
			anim.AnimationId = data.Id

			local track = animator:LoadAnimation(anim)
			if track then
				track.Priority = data.Priority or Enum.AnimationPriority.Core
				tracks[name] = track
				table.insert(preload, anim)
			end
		end
	end

	task.spawn(function()
		pcall(function()
			ContentProvider:PreloadAsync(preload)
		end)
	end)

	return tracks
end

local function playTransition(track, duration)
	if not track then return end

	transitionActive = true
	transitionEndTime = tick() + (type(duration) == "number" and duration or 0.4)

	if track.Priority == nil then track.Priority = Enum.AnimationPriority.Action end
	track.Priority = Enum.AnimationPriority.Action
	track.Looped = false

	track:Play(0.1)
end

local function SetState(newState)
	if State == newState then return end
	if diveCooldown and newState ~= "Proning" then return end

	State = newState

	if animationTracks.StandToCrouch then animationTracks.StandToCrouch:Stop() end
	if animationTracks.CrouchToProne then animationTracks.CrouchToProne:Stop() end

	if newState == "Standing" then
		Tweenservice:Create(humanoid, TweenInfo.new(0.25), {HipHeight = 0}):Play()
		character:SetAttribute("Stance", "Default")

		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop(0.2) end
		if animationTracks.CrouchWalk then animationTracks.CrouchWalk:Stop(0.2) end
		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop(0.2) end
		if animationTracks.ProneWalk then animationTracks.ProneWalk:Stop(0.2) end

	elseif newState == "Crouching" then
		if State == "Standing" and animationTracks.StandToCrouch then
			playTransition(animationTracks.StandToCrouch, 0.35)
		end
		character:SetAttribute("Stance", "Crouch")
		Tweenservice:Create(humanoid, TweenInfo.new(0.25), {HipHeight = -0.65}):Play()

		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop(0.2) end
		if animationTracks.ProneWalk then animationTracks.ProneWalk:Stop(0.2) end
		if animationTracks.Idle then animationTracks.Idle:Stop(0.2) end
		if animationTracks.Walk then animationTracks.Walk:Stop(0.2) end
		if animationTracks.Run then animationTracks.Run:Stop(0.2) end

	elseif newState == "Proning" then
		if State == "Crouching" and animationTracks.CrouchToProne then
			playTransition(animationTracks.CrouchToProne, 0.35)
		end
		character:SetAttribute("Stance", "Prone")
		Tweenservice:Create(humanoid, TweenInfo.new(0.25), {HipHeight = -1.35}):Play()

		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop(0.2) end
		if animationTracks.CrouchWalk then animationTracks.CrouchWalk:Stop(0.2) end
		if animationTracks.Idle then animationTracks.Idle:Stop(0.2) end
		if animationTracks.Walk then animationTracks.Walk:Stop(0.2) end
		if animationTracks.Run then animationTracks.Run:Stop(0.2) end
	end
end

local function IsWeaponEquipped()
	return character:FindFirstChildWhichIsA("Tool") ~= nil
end

local function checkDiveObstruction()
	local rayOrigin = rootPart.Position
	local rayDirection = rootPart.CFrame.LookVector * 5
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}
	rayParams.FilterType = Enum.RaycastFilterType.Exclude

	while true do
		local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
		if not result then return false end

		local hit = result.Instance
		if hit.CanCollide == false or hit.Transparency == 1 then
			local newFilter = rayParams.FilterDescendantsInstances
			table.insert(newFilter, hit)
			rayParams.FilterDescendantsInstances = newFilter
		else
			return true
		end
	end
end

local function PerformDive()
	if State == "Diving" or not Canmove or diveCooldown then return end
	if checkDiveObstruction() then return end

	State = "Diving"
	Canmove = false
	diveCooldown = true
	diveStartTime = tick()

	SetWeaponLock:Fire(true)

	if animationTracks.Run then animationTracks.Run:Stop(0) end
	if animationTracks.Walk then animationTracks.Walk:Stop(0) end
	if animationTracks.Idle then animationTracks.Idle:Stop(0) end

	character:SetAttribute("Stance", "Prone")

	if not IsWeaponEquipped() then
		if animationTracks.ProneIdle then
			animationTracks.ProneIdle:Play(0)
		end
	end

	Tweenservice:Create(humanoid, TweenInfo.new(0.05), {HipHeight = -1.35}):Play()

	local moveDir = rootPart.CFrame.LookVector
	rootPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
	rootPart.AssemblyLinearVelocity = (moveDir * Config.Diving.Force) + Vector3.new(0, Config.Diving.UpForce, 0)

	task.delay(2.0, function()
		if State == "Diving" then
			Canmove = true
			SetState("Proning")
			task.wait(Config.Diving.RecoveryTime)
			diveCooldown = false
			SetWeaponLock:Fire(false)
		end
	end)
end

local function lerp(a, b, t)
	return a + (b - a) * t
end

local function getInputVector()
	local x = 0
	local z = 0

	if UserInputService:IsKeyDown(Enum.KeyCode.W) then z -= 1 end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) then z += 1 end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) then x -= 1 end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) then x += 1 end

	local input = Vector3.new(x, 0, z)
	if input.Magnitude > 0 then
		input = input.Unit
	end

	return input
end

local function getFloorY()
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}
	local ray = workspace:Raycast(rootPart.Position, Vector3.new(0, -5, 0), rayParams)
	return ray and ray.Position.Y or (rootPart.Position.Y - 3)
end

local function getObjectDepth(hitInstance, ledgePos, lookVector)
	local maxScanDist = Config.Vaulting.MaxTraversal
	local stepSize = 0.25
	local maxGapTolerance = 1.0

	local targetWhitelist = {hitInstance}
	local model = hitInstance:FindFirstAncestorOfClass("Model")

	if model and not model:IsA("Workspace") then
		targetWhitelist = {model}
	end

	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Include
	rayParams.FilterDescendantsInstances = targetWhitelist

	local currentDist = 0
	local lastValidHitDist = 0
	local gapDistance = 0

	while currentDist < maxScanDist do
		currentDist += stepSize
		local checkPos = ledgePos + (lookVector * currentDist) + Vector3.new(0, 1, 0)
		local ray = workspace:Raycast(checkPos, Vector3.new(0, -3, 0), rayParams)

		if ray then
			gapDistance = 0
			lastValidHitDist = currentDist
			if Config.Vaulting.DebugMode then
				DebugDraw.Sphere(ray.Position, 0.1, Color3.new(0, 1, 0), 2)
			end
		else
			gapDistance += stepSize
			if Config.Vaulting.DebugMode then
				DebugDraw.Sphere(checkPos - Vector3.new(0, 1, 0), 0.1, Color3.new(1, 0.5, 0), 2)
			end

			if gapDistance > maxGapTolerance then
				if Config.Vaulting.DebugMode then
					DebugDraw.Sphere(checkPos, 0.3, Color3.new(1, 0, 0), 4)
				end
				return lastValidHitDist
			end
		end
	end

	return nil
end

local function getLandingSpace(ledgePos, objectDepth, lookVector, requestedOffset)
	local rayStart = ledgePos + (lookVector * objectDepth) + Vector3.new(0, 2, 0) 
	local checkDist = requestedOffset + 0.5
	local rayDir = lookVector * checkDist

	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}

	local ray = workspace:Raycast(rayStart, rayDir, rayParams)

	if ray then
		local availableSpace = (ray.Position - rayStart).Magnitude
		return math.max(0, availableSpace - 0.5) 
	end

	return requestedOffset
end

local function checkPathObstruction(startPos, direction, distance, targetInstance)
	local model = targetInstance:FindFirstAncestorOfClass("Model")
	local ignoreList = {character, targetInstance}

	if model and not model:IsA("Workspace") then
		table.insert(ignoreList, model)
	end

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = ignoreList
	params.FilterType = Enum.RaycastFilterType.Exclude

	local size = Vector3.new(1.5, 3.5, 1.5)
	local cframe = CFrame.lookAt(startPos, startPos + direction)

	local result = workspace:Blockcast(cframe, size, direction * distance, params)

	if result then
		return true
	end
	return false
end

local function getLedgeInfo(wallHitPosition, wallNormal)
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}

	local rayStart = wallHitPosition + Vector3.new(0, Config.Vaulting.MaxHeight, 0) - (wallNormal * Config.Vaulting.DepthCheck)
	local rayDir = Vector3.new(0, -(Config.Vaulting.MaxHeight + 2), 0) 

	local ledgeRay = workspace:Raycast(rayStart, rayDir, rayParams)

	if ledgeRay then
		local floorY = getFloorY()
		local objectHeight = ledgeRay.Position.Y - floorY

		if objectHeight > Config.Vaulting.MinHeight and objectHeight < Config.Vaulting.MaxHeight then
			return ledgeRay.Position
		end
	end
	return nil
end

local function attemptVault()
	if vaultDebounce or not Canmove then return end
	if State ~= "Standing" then return end

	local rayOrigin = rootPart.Position - Vector3.new(0, 1, 0)
	local rayDirection = rootPart.CFrame.LookVector * Config.Vaulting.MaxDist
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {character}

	local wallHit = workspace:Raycast(rayOrigin, rayDirection, rayParams)

	if wallHit then

		local target = wallHit.Instance
		local hasTag = CollectionService:HasTag(target, "VaultableLow")

		if not hasTag then
			local model = target:FindFirstAncestorOfClass("Model")
			if model and CollectionService:HasTag(model, "VaultableLow") then
				hasTag = true
			end
		end

		if not hasTag then return end

		local ledgePos = getLedgeInfo(wallHit.Position, wallHit.Normal)

		if ledgePos then
			vaultDebounce = true
			Canmove = false
			SetWeaponLock:Fire(true)

			local vaultData = AnimationData.GetData("Vault")
			local vaultTrack = animationTracks["Vault"]

			if not vaultTrack then
				vaultDebounce = false
				Canmove = true
				SetWeaponLock:Fire(false)
				return
			end

			local objectDepth = getObjectDepth(wallHit.Instance, ledgePos, rootPart.CFrame.LookVector)

			if not objectDepth then
				vaultDebounce = false
				Canmove = true
				SetWeaponLock:Fire(false)
				return
			end

			local forwardOffset = vaultData.ForwardOffset or 3.5
			local baseDistance = vaultData.BaseDistance or 6

			local distToWall = (Vector3.new(wallHit.Position.X, 0, wallHit.Position.Z) - Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z)).Magnitude

			local calculatedOffset = (objectDepth < 2.0) and 1.5 or forwardOffset

			local safeLandingOffset = getLandingSpace(ledgePos, objectDepth, rootPart.CFrame.LookVector, calculatedOffset)

			if safeLandingOffset < Config.Vaulting.MinLandingSpace then
				if objectDepth > 2.0 then
					safeLandingOffset = -Config.Vaulting.SafetyClearance
				else
					vaultDebounce = false
					Canmove = true
					SetWeaponLock:Fire(false)
					return
				end
			end

			local totalTravel = distToWall + objectDepth + Config.Vaulting.SafetyClearance + safeLandingOffset

			local isBlocked = checkPathObstruction(rootPart.Position, rootPart.CFrame.LookVector, totalTravel, wallHit.Instance)
			if isBlocked then
				vaultDebounce = false
				Canmove = true
				SetWeaponLock:Fire(false)
				return
			end

			local scale = math.clamp(totalTravel / baseDistance, 0.5, 3.0)

			local lookPos = Vector3.new(wallHit.Position.X, rootPart.Position.Y, wallHit.Position.Z)
			rootPart.CFrame = CFrame.lookAt(rootPart.Position, lookPos)

			RootMotion:StartCorrection({
				["Track"] = vaultTrack,
				["AlignHRPCFrame"] = false, 
				["MaintainVelocity"] = true,
				["IgnoreCollision"] = true,
				["TranslationScale"] = scale
			})

			task.wait(vaultTrack.Length)
			vaultDebounce = false
			Canmove = true
			SetWeaponLock:Fire(false)
		end
	end
end

local function BackpackOpen()
	if not BackpackFrame then return end
	PlayVoiceline(player, "BackpackOpen")
	Canmove = false
	BackpackFrame.Visible = true
	BackpackFrame.Parent.HudBG.Visible = false
	BackpackFrame.Parent.Wrench.Visible = false
	BackpackFrame.Parent.Shiv.Visible = false
	BackpackFrame.Parent.WeaponIcons.Visible = false
	BackpackFrame.Parent.AmmoList.Visible = false
	BackpackFrame.Parent.AmmoCount.Visible = false


	if State == "Crouching" then
		animationTracks.BpCrouchingOff:Play(0.15)
	elseif State == "Proning" then
		local track = animationTracks.BpProneOff or animationTracks.BpCrouchingOff
		if track then track:Play(0.15) end
	else 
		animationTracks.BpStandingOff:Play(0.15)
	end

	if State == "Proning" then
		if animationTracks.BpProneIdle then
			animationTracks.BpProneIdle:Play(0.2)
		end
	else
		animationTracks.BpIdle:Play(1.45)
	end

	if State == "Proning" then
		Tweenservice:Create(humanoid, TweenInfo.new(1), {HipHeight = -0.9}):Play()
	else
		Tweenservice:Create(humanoid, TweenInfo.new(1), {HipHeight = -0.5}):Play()
	end
end

local function BackpackClose()
	if not BackpackFrame then return end
	BackpackFrame.Visible = false
	BackpackFrame.Parent.HudBG.Visible = true
	BackpackFrame.Parent.Wrench.Visible = true
	BackpackFrame.Parent.Shiv.Visible = true
	BackpackFrame.Parent.WeaponIcons.Visible = true
	BackpackFrame.Parent.AmmoList.Visible = true
	BackpackFrame.Parent.AmmoCount.Visible = true

	PlayVoiceline(player, "BackpackClose")

	if State == "Crouching" then
		animationTracks.BpCrouchingOn:Play(0.15)
	elseif State == "Proning" then
		local track = animationTracks.BpProneOn or animationTracks.BpCrouchingOn
		if track then track:Play(0.15) end
	else 
		animationTracks.BpStandingOn:Play(0.15)
	end

	animationTracks.BpStandingOff:Stop(1)
	animationTracks.BpIdle:Stop(0.15)
	if animationTracks.BpProneIdle then
		animationTracks.BpProneIdle:Stop(0.15)
	end

	local targetHip
	if State == "Crouching" then
		targetHip = -0.65
	elseif State == "Proning" then
		targetHip = -1.35
	else 
		targetHip = 0
	end

	Tweenservice:Create(humanoid, TweenInfo.new(1.15), {HipHeight = targetHip}):Play()
	task.wait(1.15)
	Canmove = true
end

local function checkAndPlay(trackToPlay, tracksToStop)
	if trackToPlay and not trackToPlay.IsPlaying then
		trackToPlay:Play(0.2)
	end
	for _, track in ipairs(tracksToStop) do
		if track and track.IsPlaying then
			track:Stop(0.2)
		end
	end
end

local function isMovingBackwards()
	if not rootPart then return false end

	local move = humanoid.MoveDirection
	if move.Magnitude < 0.1 then 
		return false 
	end

	local forward = rootPart.CFrame.LookVector
	return forward:Dot(move) < -0.3 -- negative = walking backwards
end

local function playAnimDirectional(track, stopList, backwards)
	if not track then return end

	-- Stop others
	if stopList then
		for _, other in ipairs(stopList) do
			if other then other:Stop(0.15) end
		end
	end

	-- Play forward/backwards
	if backwards then
		if not track.IsPlaying then
			track.TimePosition = track.Length -- start at end for smooth reverse
			track:Play(0.15)
		end
		track:AdjustSpeed(-1)
	else
		if not track.IsPlaying then
			track:Play(0.15)
		end
		track:AdjustSpeed(1)
	end
end

local function updateSimpleAnimations(dt)
	if transitionActive then
		if tick() >= transitionEndTime then
			transitionActive = false
		else
			return
		end
	end

	local velocity = rootPart.AssemblyLinearVelocity * Vector3.new(1,0,1)
	local speed = velocity.Magnitude
	local isSprinting = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
		and (not character:GetAttribute("IsAiming"))

	local backwards = isMovingBackwards()

	-----------------------------------------------------
	-- STATE: STANDING
	-----------------------------------------------------
	if State == "Standing" then
		if speed > 0.5 then
			if isSprinting and not backwards then
				playAnimDirectional(animationTracks.Run, {animationTracks.Walk, animationTracks.Idle}, false)
			else
				playAnimDirectional(animationTracks.Walk, {animationTracks.Run, animationTracks.Idle}, backwards)
			end
		else
			playAnimDirectional(animationTracks.Idle, {animationTracks.Walk, animationTracks.Run}, false)
		end

		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop() end
		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop() end

		-----------------------------------------------------
		-- STATE: CROUCHING
		-----------------------------------------------------
	elseif State == "Crouching" then
		if speed > 0.5 then
			playAnimDirectional(animationTracks.CrouchWalk, {animationTracks.CrouchIdle}, backwards)
		else
			playAnimDirectional(animationTracks.CrouchIdle, {animationTracks.CrouchWalk}, false)
		end

		if animationTracks.Idle then animationTracks.Idle:Stop() end
		if animationTracks.ProneIdle then animationTracks.ProneIdle:Stop() end

		-----------------------------------------------------
		-- STATE: PRONING
		-----------------------------------------------------
	elseif State == "Proning" then
		if speed > 0.5 then
			playAnimDirectional(animationTracks.ProneWalk, {animationTracks.ProneIdle}, backwards)
		else
			playAnimDirectional(animationTracks.ProneIdle, {animationTracks.ProneWalk}, false)
		end

		if animationTracks.Idle then animationTracks.Idle:Stop() end
		if animationTracks.CrouchIdle then animationTracks.CrouchIdle:Stop() end
	end
end


local function onRenderStep(deltaTime)
	if not character or not character.Parent or humanoid.Health <= 0 then return end

	local safeDt = math.min(deltaTime, 0.05) 

	if State == "Diving" then
		local elapsed = tick() - diveStartTime

		if elapsed > 0.1 and humanoid.FloorMaterial ~= Enum.Material.Air then

			local vel = rootPart.AssemblyLinearVelocity
			local flatVel = Vector3.new(vel.X, 0, vel.Z)

			local dir = flatVel.Magnitude > 1 and flatVel.Unit or rootPart.CFrame.LookVector

			local side = 1
			local offsetVal = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Offset")
			if offsetVal and offsetVal.Value.X < 0 then
				side = -1
			end

			local impulse = Vector3.new(0, -Config.Diving.LandImpulseDown, 0) + (dir * Config.Diving.LandImpulseDir)

			CameraController:ApplyImpulse(impulse, 20, 5)

			rootPart.AssemblyLinearVelocity = Vector3.zero
			Canmove = true
			SetWeaponLock:Fire(false)
			SetState("Proning")

			task.delay(Config.Diving.RecoveryTime, function()
				diveCooldown = false
			end)
		end

		return 
	end

	if not Canmove then
		humanoid.WalkSpeed = 0
		humanoid:Move(Vector3.zero, false)
		return
	end

	local inputVector = getInputVector()

	local isAiming = character:GetAttribute("IsAiming")
	local isSprinting = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and not isAiming 

	if isAiming then
		CameraController:SetAnchor(rootPart, 10)
	else
		CameraController:SetAnchor(head, 10)
	end

	local targetSpeed = isSprinting and Config.Movement.SprintSpeed or Config.Movement.WalkSpeed

	if State == "Standing" then
		targetSpeed = isSprinting and Config.Movement.SprintSpeed or Config.Movement.WalkSpeed
	elseif State == "Crouching" then
		targetSpeed = Config.Movement.WalkSpeed * 0.55
	elseif State == "Proning" then
		targetSpeed = Config.Movement.WalkSpeed * 0.25
	end

	if inputVector.Magnitude > 0 then
		local _, yaw = camera.CFrame:ToEulerAnglesYXZ()
		local moveDirection = CFrame.Angles(0, yaw, 0) * inputVector

		local accel = Config.Movement.Acceleration

		if State == "Crouching" and humanoid.WalkSpeed > targetSpeed then
			accel = Config.Movement.CrouchDeceleration
		end

		humanoid.WalkSpeed = lerp(humanoid.WalkSpeed, targetSpeed, 1 - math.exp(-safeDt * accel))
		humanoid:Move(moveDirection, false)
	else
		humanoid.WalkSpeed = lerp(humanoid.WalkSpeed, 0, 1 - math.exp(-safeDt * Config.Movement.Acceleration))
		humanoid:Move(Vector3.zero, false)
	end

	if isAiming or (not isSprinting) then
		humanoid.AutoRotate = false
		local _, cameraYaw = camera.CFrame:ToEulerAnglesYXZ()
		local targetRotation = CFrame.Angles(0, cameraYaw, 0)

		local currentCFrame = rootPart.CFrame
		local targetCFrame = CFrame.new(currentCFrame.Position) * targetRotation

		local rotSpeed = isAiming and Config.Movement.AimRotationSpeed or Config.Movement.RotationSpeed
		rootPart.CFrame = currentCFrame:Lerp(targetCFrame, safeDt * rotSpeed)
	else
		humanoid.AutoRotate = true
	end

	local cameraPitch = math.asin(camera.CFrame.LookVector.Y)
	local targetPitch = isAiming and cameraPitch or 0

	local limit = math.rad(Config.Visuals.MaxTiltAngle)
	targetPitch = math.clamp(targetPitch, -limit, limit)

	currentArmPitch = targetPitch

	local aimPosPart = nil
	if isAiming then
		for _, child in ipairs(character:GetChildren()) do
			if child:IsA("Model") and child:FindFirstChild("AimPos") then
				aimPosPart = child.AimPos
				break
			end
		end
	end

	local targetNeckC0
	if aimPosPart then
		local headPos = (torso.CFrame * originNeckC0).Position
		local targetPos = aimPosPart.Position

		local lookDir = (targetPos - headPos).Unit
		local localDir = torso.CFrame:VectorToObjectSpace(lookDir)

		local yaw = math.atan2(-localDir.X, -localDir.Z)
		local pitch = math.asin(localDir.Y)

		local damp = 0.5

		targetNeckC0 = originNeckC0 * CFrame.Angles(pitch * damp, yaw * damp, 0)
	else
		targetNeckC0 = originNeckC0 * CFrame.Angles(currentArmPitch * 0.5, 0, 0)
	end

	rightShoulder.C0 = originRightC0 * CFrame.Angles(0, 0, currentArmPitch)
	leftShoulder.C0 = originLeftC0 * CFrame.Angles(0, 0, -currentArmPitch)
	neck.C0 = neck.C0:Lerp(targetNeckC0, safeDt * 10)

	local flatVel = rootPart.AssemblyLinearVelocity * Vector3.new(1, 0, 1)
	local currentSpeed = flatVel.Magnitude

	if currentSpeed > 0.5 and humanoid.FloorMaterial ~= Enum.Material.Air then
		local stepRate = math.clamp(Config.Audio.StepBaseSpeed / (currentSpeed / Config.Movement.WalkSpeed), 0.25, 1)

		if time() - lastStepTime > stepRate then
			lastStepTime = time()

			local params = RaycastParams.new()
			params.FilterDescendantsInstances = {character}
			params.FilterType = Enum.RaycastFilterType.Exclude
			local result = workspace:Raycast(rootPart.Position, Vector3.new(0, -4, 0), params)

			if result and result.Material then
				local soundTable = FootstepModule:GetTableFromMaterial(result.Material)
				if soundTable then

					local soundInstance = FootstepModule:GetRandomSound(soundTable)
					if soundInstance then
						local sound = Instance.new("Sound")
						sound.SoundId = soundInstance
						sound.Volume = soundInstance.Volume or 0.35
						sound.PlaybackSpeed = soundInstance.PlaybackSpeed or 1
						sound.Parent = rootPart

						sound:Play()
						Debris:AddItem(sound, 1.5)
					end

				end
			end
		end
	end

	local noiseCfg = Config.Visuals.CameraNoise
	if isAiming then
		CameraController:SetPerlin(noiseCfg.Aim.Intensity, noiseCfg.Aim.Speed, noiseCfg.Aim.Smoothness)
	elseif currentSpeed > 1 then
		if isSprinting then
			CameraController:SetPerlin(noiseCfg.Sprint.Intensity, noiseCfg.Sprint.Speed, noiseCfg.Sprint.Smoothness)
		else
			CameraController:SetPerlin(noiseCfg.Walk.Intensity, noiseCfg.Walk.Speed, noiseCfg.Walk.Smoothness)
		end
	else
		CameraController:SetPerlin(noiseCfg.Idle.Intensity, noiseCfg.Idle.Speed, noiseCfg.Idle.Smoothness)
	end

	local targetInfluence = (inputVector.Magnitude > 0) and Config.FootPlanting.WalkInfluence or Config.FootPlanting.IdleInfluence
	currentFootInfluence = lerp(currentFootInfluence, targetInfluence, safeDt * Config.FootPlanting.Smoothness)
	FootPlanting.SetInfluence(currentFootInfluence)

	updateSimpleAnimations(safeDt)
end





local hud = player.PlayerGui:WaitForChild("REARMED HUD"):WaitForChild("H")
local HealthHud = hud:WaitForChild("HudBG")
local RedGlow = HealthHud.LowGlow
local ArmorBar = HealthHud.Armor
local HealthBar = HealthHud.Health
local humanoid = character:WaitForChild("Humanoid")

local healthGradient = HealthBar.UIGradient
local glowGradient   = RedGlow:WaitForChild("UIGradient")

local lowGlowHP     = 40
local glowStartHP   = 35 
local safeHP        = 41

local healthRotationMin = -180
local healthRotationMax = 15

local glowRotAt35 = -112
local glowRotAt0  = 38

local whiteColor = Color3.fromRGB(255,255,255)
local redColor   = Color3.fromRGB(255,60,60)

local tweenInfo = TweenInfo.new(0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
local isRed = false

local pulseSpeed = 1.5
local pulseMin = 0.4
local pulseMax = 1.0
local pulseDir = -1
local pulseValue = pulseMax


local function ResetHUD()
	isRed = false
	pulseDir = -1
	pulseValue = pulseMax

	HealthBar.ImageColor3 = whiteColor
	RedGlow.Visible = false
	RedGlow.ImageTransparency = 1

	healthGradient.Rotation = healthRotationMin
	glowGradient.Rotation = glowRotAt35
end

ResetHUD()

humanoid.HealthChanged:Connect(function(h)
	if h == humanoid.MaxHealth then
		ResetHUD()
	end
end)


local function SetHealthRotation(percent)
	local rot = healthRotationMin + ((1 - percent) * (healthRotationMax - healthRotationMin))
	healthGradient.Rotation = rot
end


local function SetGlowRotation(hp)
	if hp > lowGlowHP then
		return
	end

	if hp >= glowStartHP then
		glowGradient.Rotation = glowRotAt35
		return
	end

	local t = math.clamp((glowStartHP - hp) / glowStartHP, 0, 1)
	local rot = glowRotAt35 + (glowRotAt0 - glowRotAt35) * t
	glowGradient.Rotation = rot
end



RunService.RenderStepped:Connect(function(dt)
	local hp = humanoid.Health
	local maxHP = humanoid.MaxHealth
	local percent = hp / maxHP

	SetHealthRotation(percent)


	if hp <= lowGlowHP and not isRed then
		isRed = true
		Tweenservice:Create(HealthBar, tweenInfo, { ImageColor3 = redColor }):Play()

	elseif hp >= safeHP and isRed then
		isRed = false
		Tweenservice:Create(HealthBar, tweenInfo, { ImageColor3 = whiteColor }):Play()
	end


	if hp <= lowGlowHP then
		RedGlow.Visible = true
		SetGlowRotation(hp)

		pulseValue += pulseDir * dt * pulseSpeed
		if pulseValue <= pulseMin then
			pulseValue = pulseMin
			pulseDir = 1
		elseif pulseValue >= pulseMax then
			pulseValue = pulseMax
			pulseDir = -1
		end
		RedGlow.ImageTransparency = pulseValue

	else
		RedGlow.Visible = false
	end
end)


local function Initialize()
	if not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local animator = humanoid:WaitForChild("Animator")

	if character:FindFirstChild("Animate") then
		character.Animate:Destroy()
	end

	REARMED = Playergui:WaitForChild("REARMED HUD")
	if REARMED then
		local h = REARMED:WaitForChild("H")
		if h then
			BackpackFrame = h:WaitForChild("Backpack")
		end
	end

	LeanController.Start()
	CameraController:Init(player)
	CameraFX.Start()
	FootPlanting.Start()
	FootstepModule:CreateSoundGroup(game:GetService("SoundService"), "FootstepsPreload", {Volume = 0.5}, true)

	local AnimationList = AnimationData.GetList()
	animationTracks = LoadPlayerAnimations(humanoid, AnimationList)

	local requiredAnims = {
		"Idle","Walk","Run",
		"CrouchIdle","CrouchWalk",
		"ProneIdle","ProneWalk",
		"StandToCrouch","CrouchToProne",
		"BpIdle",
		"BpStandingOn","BpStandingOff",
		"BpCrouchingOn","BpCrouchingOff",
		"BpProneOn","BpProneOff",
		"Vault",
		"Dive",
	}

	local function createTrackIfMissing(name)
		if animationTracks[name] then return end

		local animId = AnimationData.GetId(name)
		if not animId then
			return
		end

		local anim = Instance.new("Animation")
		anim.AnimationId = animId

		local track = animator:LoadAnimation(anim)
		animationTracks[name] = track
	end

	for _, name in ipairs(requiredAnims) do
		createTrackIfMissing(name)
	end

	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode ~= Enum.KeyCode.B then return end

		if vaultDebounce then return end

		backpackOpen = not backpackOpen

		if backpackOpen then
			CameraController:TweenOffset(
				Vector3.new(4, 0.5, 7),
				TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			)
			BackpackOpen()
		else
			CameraController:TweenOffset(
				Vector3.new(2, 0.5, 7),
				TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			)
			BackpackClose()
		end
	end)

	UserInputService.InputBegan:Connect(function(input, processed)
		if processed then return end

		if backpackOpen or not Canmove then return end

		if input.KeyCode == Enum.KeyCode.Space then
			attemptVault()
		end

		if input.KeyCode == Enum.KeyCode.LeftControl then
			if State == "Standing" then
				SetState("Crouching")
			elseif State == "Crouching" then
				SetState("Standing")
			elseif State == "Proning" then
				SetState("Crouching")
			end
		end

		if input.KeyCode == Enum.KeyCode.Z then
			local shiftHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
			local horizontalVel = rootPart.AssemblyLinearVelocity * Vector3.new(1, 0, 1)
			local currentSpeed = horizontalVel.Magnitude

			if State == "Standing" and shiftHeld and currentSpeed > 13 then
				PerformDive()
			elseif State == "Crouching" then
				SetState("Proning")
			elseif State == "Proning" then
				SetState("Crouching")
			end
		end

	end)

	RunService.RenderStepped:Connect(onRenderStep)

	humanoid.Died:Connect(function()
		LeanController.Stop()
		FootPlanting.Stop()

		for _, track in pairs(animationTracks) do
			track:Stop(0.2)
		end
	end)
end

Initialize()
--// END OF SCRIPT: game.StarterPlayer.StarterCharacterScripts.Framework

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterPlayer.StarterCharacterScripts.lootboxtest | Enabled: true
--------------------------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")



local player = Players.LocalPlayer
local interactEvent = ReplicatedStorage:WaitForChild("Peak").Remotes.InteractEvent
local proximityDistance = 10
local resetTime = 30 -- Time (in seconds) for the loot box to reset

-- Ensure the character and animation system exist
local function getCharacter()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:FindFirstChild("Humanoid")
	local animator = humanoid and humanoid:FindFirstChild("Animator")
	return character, humanoid, animator
end

-- Preload animation
local lootBoxAnim = ReplicatedStorage:WaitForChild("Peak").Modules.Loot.LootBox
local character, humanoid, animator = getCharacter()
local lootAnimTrack = animator:LoadAnimation(lootBoxAnim)

-- Function to find nearby loot boxes
local function getNearestLootBox()
	local character = player.Character
	local root = character and character:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	local nearestBox = nil
	local shortestDistance = math.huge

	for _, lootBox in ipairs(workspace.Game.Interactables.SupplyBox:GetChildren()) do
		if lootBox:IsA("Part") then
			-- Check if loot box is already looted
			local lootedCheck = lootBox:FindFirstChild("LootedCheck")
			if lootedCheck and lootedCheck.Value == true then
				continue -- Skip this loot box if it's already looted
			end

			local distance = (root.Position - lootBox.Position).Magnitude
			if distance <= proximityDistance and distance < shortestDistance then
				nearestBox = lootBox
				shortestDistance = distance
			end
		end
	end

	return nearestBox
end




-- Spawn loot on the client
local function spawnLoot(lootData, lootBox)
	-- Get all attachments in the loot box
	local attachments = {}
	for _, child in ipairs(lootBox:GetChildren()) do
		if child:IsA("Attachment") and child.Name == "Attachment" then
			table.insert(attachments, child)
		end
	end

	if #attachments == 0 then
		warn("No attachments found in loot box: " .. lootBox.Name)
		return
	end

	-- Prevent the loot box from being reused immediately
	if lootBox:FindFirstChild("LootedCheck") then
		if lootBox.LootedCheck.Value then
			return
		end
	else
		local Looted = Instance.new("BoolValue")
		Looted.Parent = lootBox
		Looted.Name = "LootedCheck"
		Looted.Value = false -- Start as unlooted
	end

	local LootboxModel = lootBox.SupplyBox
	local lootboxhumanoid = LootboxModel.Humanoid
	local lootboxanimator = lootboxhumanoid.Animator

	local boxidle = LootboxModel.Idle
	local boxOpen = LootboxModel.Open
	local boxClose = LootboxModel.Close
	local boxLoopOpen = LootboxModel.OpenIdle

	local boxtrack1 = lootboxanimator:LoadAnimation(boxidle)
	local boxtrack2 = lootboxanimator:LoadAnimation(boxOpen)
	local boxtrack3 = lootboxanimator:LoadAnimation(boxClose)
	local boxtrack4 = lootboxanimator:LoadAnimation(boxLoopOpen)

	
	
	-- Mark as looted
	lootBox.LootedCheck.Value = true
	boxtrack2:Play()
boxtrack4:Play(1)

	-- Spawn loot one by one
	for index, item in ipairs(lootData) do
		task.delay(index * 0.5, function() -- Delays each item by 0.5 seconds
			local chosenAttachment = attachments[math.random(1, #attachments)]
			local spawnPosition = chosenAttachment.WorldPosition

			-- Create loot part
			local lootPart = Instance.new("Part")
			lootPart.Name = item
			lootPart.Size = Vector3.new(1, 1, 1)
			lootPart.Position = lootBox.Position -- Start from the loot box
			lootPart.Anchored = true
			lootPart.BrickColor = BrickColor.White()
			--lootPart.Material = Enum.Material.Neon
			lootPart.Parent = lootBox:WaitForChild("DroppedLoot")


			-- Define arc motion
			local midPoint = lootBox.Position + Vector3.new(0, 2, 0) -- Adjust height if needed

			-- Tween to create arc effect
			local tweenInfo1 = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local tweenInfo2 = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

			local tween1 = TweenService:Create(lootPart, tweenInfo1, { Position = midPoint })
			local tween2 = TweenService:Create(lootPart, tweenInfo2, { Position = spawnPosition })

			-- Play tweens sequentially
			tween1:Play()
			tween1.Completed:Connect(function()
				tween2:Play()
			end)
		end)
	end

	-- Start the reset timer
	task.delay(resetTime, function()
		if lootBox:FindFirstChild("LootedCheck") then
			lootBox.LootedCheck.Value = false
			
			boxtrack2:Stop()
			boxtrack4:Stop()
		boxtrack3:Play()

			print(lootBox.Name .. " has been reset and is ready to be looted again!")
		end
	end)
end


-- Detect E key press and send interaction request to the server
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.E then
		local nearestLootBox = getNearestLootBox()
		if nearestLootBox then
			local lootedCheck = nearestLootBox:FindFirstChild("LootedCheck")
			if lootedCheck and lootedCheck.Value == true then
				warn("Loot box is already looted!") -- Debugging message
				return -- Stop interaction if the loot box is already looted
			end

			local character = player.Character
			local root = character and character:FindFirstChild("HumanoidRootPart")
			local charwalkspeed = character.Humanoid.WalkSpeed

			if root and humanoid and animator then
				-- Freeze movement
				humanoid.WalkSpeed = 0

				-- Create BodyGyro to rotate character towards loot box
				local bodyGyro = Instance.new("BodyGyro")
				bodyGyro.Parent = root
				bodyGyro.MaxTorque = Vector3.new(0, 400000, 0) -- Allow rotation on Y-axis
				bodyGyro.P = 10000 -- Responsiveness
				bodyGyro.CFrame = CFrame.lookAt(root.Position, Vector3.new(nearestLootBox.Position.X, root.Position.Y, nearestLootBox.Position.Z))

				-- Play animation
				lootAnimTrack:Play(0.5)

				-- Remove BodyGyro & restore movement after animation finishes
				task.delay(lootAnimTrack.Length, function()
					if bodyGyro then
						bodyGyro:Destroy()
					end
					if humanoid then
						humanoid.WalkSpeed = charwalkspeed
					end
				end)
			end

			interactEvent:FireServer(nearestLootBox)
		end
	end
end)

-- Receive loot data from the server and spawn loot
interactEvent.OnClientEvent:Connect(function(lootData, lootBox)
	spawnLoot(lootData, lootBox)
end)

--// END OF SCRIPT: game.StarterPlayer.StarterCharacterScripts.lootboxtest

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterPlayer.StarterPlayerScripts.CaffanSDK | 2025 | Enabled: true
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DebugEvent = ReplicatedStorage.Peak.Remotes.DebugInventory

local Iris = require(ReplicatedStorage.Peak.Modules.Librarys.Iris).Init()
local InventoryDebug = require(ReplicatedStorage.Peak.Modules.Librarys.Iris["CaffanSDK | 2025"])
local SmartBone = require(ReplicatedStorage.Peak.Modules.Client.SmartBone)

SmartBone.Start()

Iris:Connect(function()
	--InventoryDebug.Render()
end)

DebugEvent.OnClientEvent:Connect(function(inv)
	InventoryDebug.UpdateInventory(inv)
end)
--// END OF SCRIPT: game.StarterPlayer.StarterPlayerScripts.CaffanSDK | 2025

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterPlayer.StarterPlayerScripts.Client | weapon | Enabled: true
--------------------------------------------------------------------
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local ContentProvider = game:GetService("ContentProvider")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local animator = humanoid:WaitForChild("Animator")

local success, CameraController = pcall(function()
	return require(ReplicatedStorage.Peak.Modules.Camera.CameraController)
end)

if not success then
	warn("WeaponClient: Could not load CameraController.")
	CameraController = nil
end

local CrosshairHandler = require(ReplicatedStorage.Peak.Modules.Client.CrosshairHandler)
local HitmarkerHandler = require(ReplicatedStorage.Peak.Modules.Client.HitmarkerHandler)

local WeaponSysFolder = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes"):WaitForChild("WeaponSys")
local WeaponRemote = WeaponSysFolder:WaitForChild("Core")
local SetWeaponLock = WeaponSysFolder:WaitForChild("SetWeaponLock")
local DebugInventory = ReplicatedStorage.Peak.Remotes:WaitForChild("DebugInventory")
local RequestInventory = ReplicatedStorage.Peak.Remotes:WaitForChild("RequestInventory")

local Sounds = ReplicatedStorage.Peak:WaitForChild("Sounds")
local Hud = player.PlayerGui:WaitForChild("REARMED HUD"):WaitForChild("H")
local HealthBG = Hud:WaitForChild("HudBG")
local AmmoList = Hud:WaitForChild("AmmoList")
local AmmoTemplates = AmmoList:WaitForChild("Templates")
local PistolBullet = AmmoTemplates:WaitForChild("Pistol")
local RifleBullet = AmmoTemplates:WaitForChild("Rifle")
local ShotgunBullet = AmmoTemplates:WaitForChild("Shotgun")

local AmmoCount = Hud:WaitForChild("AmmoCount")
local ReserveLabel = AmmoCount:WaitForChild("Reserve")
local MagLabel = AmmoCount:WaitForChild("Mag")

local WeaponIcons = Hud:WaitForChild("WeaponIcons")
local Point = Hud:WaitForChild("Point")
local Melee = Hud:WaitForChild("Melee")
local Shiv = Hud:WaitForChild("Shiv")
local Wrench = Hud:WaitForChild("Wrench")


local BulletIconsByType = {
	SmallFirearm = PistolBullet,
	LargeFirearm = RifleBullet,
	ShotgunFirearm = ShotgunBullet,
}


local CameraConfig = {
	FOV = {
		Default = 60,
		Aim = 40,
		Sprint = 67,
	},
	Offsets = {
		Default = Vector3.new(2, 0.5, 7),
		Aim = Vector3.new(2, 1.4, 4.5),
		Sprint = Vector3.new(2, 0.5, 8),
	},
	Settings = {
		DebugTracers = false,
	}
}

local LocalInventory = nil 
local PendingEquipSlot = nil 

local currentWeapon = nil
local currentAmmo = 0
local weaponStats = nil 
local weaponActive = false 
local currentSpread = 0
local currentSlot = nil
local Firemode = nil

local isAiming = false
local isFiring = false
local isSprinting = false
local shoulderSwapped = false
local isBusy = false
local isLocked = false
local triggerDown = false
local firing = false
local fireConnection
local fireHeld = false
local burstActive = false

local loadedAnims = {}     
local currentIdle = nil
local currentEquipTrack = nil
local currentUnequipTrack = nil

local ALLOWED_LIMBS = {
	["Head"] = true,
	["Torso"] = true,
	["Left Arm"] = true,
	["Right Arm"] = true,
	["Left Leg"] = true,
	["Right Leg"] = true,
}

local function OptimizeHitboxes(char)
	if not char then return end
	local function ProcessPart(part)
		if part:IsA("BasePart") then
			if not ALLOWED_LIMBS[part.Name] then
				part.CanQuery = false
			else
				part.CanQuery = true
			end
			if part.Name == "HumanoidRootPart" then
				part.CanQuery = false
			end
		end
	end

	for _, desc in pairs(char:GetDescendants()) do
		ProcessPart(desc)
	end
	char.DescendantAdded:Connect(ProcessPart)
end

local function OnCharAdded(newChar)
	OptimizeHitboxes(newChar)
end

workspace.ChildAdded:Connect(function(child)
	if child:IsA("Model") and child:FindFirstChild("Humanoid") then
		OptimizeHitboxes(child)
	end
end)

for _, child in ipairs(workspace:GetChildren()) do
	if child:IsA("Model") and child:FindFirstChild("Humanoid") then
		OptimizeHitboxes(child)
	end
end

CrosshairHandler.Init(player)
local HitmarkerUI = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
local cross = HitmarkerHandler.new(HitmarkerUI)

if cross and type(cross.FollowMouse) == "function" then
	cross:FollowMouse(true)
end

local function GetCurrentStance()
	local stance = character:GetAttribute("Stance")

	if stance == "Crouch" then
		return "Crouch"
	elseif stance == "Prone" then
		return "Prone"
	else
		return "Default"
	end
end

local function DrawDebugRay(origin, endPos, color)
	local distance = (endPos - origin).Magnitude
	local p = Instance.new("Part")
	p.Name = "DebugTrace"
	p.Anchored = true
	p.CanCollide = false
	p.CanQuery = false
	p.CastShadow = false
	p.Material = Enum.Material.Neon
	p.Color = color or Color3.new(1, 0, 0)
	p.Size = Vector3.new(0.05, 0.05, distance)
	p.CFrame = CFrame.lookAt(origin, endPos) * CFrame.new(0, 0, -distance/2)
	p.Parent = workspace.Terrain
	Debris:AddItem(p, 0.05)
end

local function DrawTracer(origin, endPos, muzzleFX)
	local attachment0 = Instance.new("Attachment")
	attachment0.CFrame = CFrame.new(origin)
	attachment0.Parent = workspace.Terrain

	local attachment1 = Instance.new("Attachment")
	attachment1.CFrame = CFrame.new(endPos)
	attachment1.Parent = workspace.Terrain

	local beamsData = {}
	local maxLifetime = 0.25 

	if muzzleFX then
		for _, child in ipairs(muzzleFX:GetChildren()) do
			if child:IsA("Beam") then
				local lifetime = child:GetAttribute("Lifetime")
				local duration = (lifetime and typeof(lifetime) == "number") and lifetime or 0.25

				if duration > maxLifetime then
					maxLifetime = duration
				end

				table.insert(beamsData, {Beam = child:Clone(), Time = duration})
			end
		end
	end

	if #beamsData == 0 then
		local beam = Instance.new("Beam")
		beam.Transparency = NumberSequence.new(0.3)
		beam.Width0 = 0.1
		beam.Width1 = 0.1
		beam.FaceCamera = true
		beam.Color = ColorSequence.new(Color3.new(1, 1, 1))
		beam.LightEmission = 1
		beam.LightInfluence = 0
		table.insert(beamsData, {Beam = beam, Time = 0.25})
	end

	for _, data in ipairs(beamsData) do
		local beam = data.Beam
		local time = data.Time

		beam.Attachment0 = attachment0
		beam.Attachment1 = attachment1
		beam.Parent = workspace.Terrain

		local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(beam, tweenInfo, {Width0 = 0, Width1 = 0})
		tween:Play()

		Debris:AddItem(beam, time + 0.05)
	end

	Debris:AddItem(attachment0, maxLifetime + 0.05)
	Debris:AddItem(attachment1, maxLifetime + 0.05)
end

local function PlayMuzzleFX(char, weaponName)
	if not char then return end
	local model = char:FindFirstChild(weaponName)
	if not model then return end

	local handle = model:FindFirstChild("Handle")
	if not handle then return end

	local muzzleFX = handle:FindFirstChild("MuzzleFX")
	if not muzzleFX then return end

	local fireSound = muzzleFX:FindFirstChild("FireSound")
	if fireSound then
		fireSound:Play()
	end

	for _, child in ipairs(muzzleFX:GetChildren()) do
		if child:IsA("ParticleEmitter") then
			local count = child:GetAttribute("EmitCount") or 1
			child:Emit(count)
		end
	end

	local light = muzzleFX:FindFirstChildWhichIsA("Light")
	if light then
		light.Enabled = true
		task.delay(0.05, function()
			if light then light.Enabled = false end
		end)
	end
end

local function PlayDryFire(char, weaponName)
	if not char then return end
	local model = char:FindFirstChild(weaponName)
	if not model then return end

	local handle = model:FindFirstChild("Handle")
	if not handle then return end

	local muzzleFX = handle:FindFirstChild("MuzzleFX")
	if not muzzleFX then return end

	local emptySound = muzzleFX:FindFirstChild("Empty")
	if emptySound then
		emptySound:Play()
	end
end



function RequestEquipWeapon(weaponName, slot)
	WeaponRemote:FireServer("Equip", {
		WeaponName = weaponName,
		Slot = slot
	})
end

local function UpdateAmmoUI(weaponName, ammo, magSize)
	for _, child in ipairs(AmmoList:GetChildren()) do
		if child:IsA("ImageLabel") then
			child:Destroy()
		end
	end

	local weaponModuleScript = ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData:FindFirstChild(weaponName)
	if not weaponModuleScript then return end

	local weaponData = require(weaponModuleScript)
	local weaponType = weaponData.WeaponType
	local weaponAmmo = weaponData.AmmoType

	local template = BulletIconsByType[weaponAmmo]
	if not template then return end

	ammo = math.clamp(ammo, 0, magSize)
	for i = 1, magSize do
		local bullet = template:Clone()
		bullet.LayoutOrder = -i
		bullet.Visible = true
		bullet.Parent = AmmoList

		if i > ammo then
			bullet.ImageColor3 = Color3.fromRGB(45, 45, 45)
		else
			bullet.ImageColor3 = Color3.fromRGB(255, 255, 255)
		end
	end

	ReserveLabel.Text = magSize
	MagLabel.Text = ammo
end

local function UpdateWeaponIcons(weaponName)
	for _, icon in ipairs(WeaponIcons:GetChildren()) do
		if icon:IsA("ImageLabel") then
			icon.Visible = (icon.Name == weaponName)
		end
	end
end

local function LoadWeaponAnimations(weaponName)
	for key, track in pairs(loadedAnims) do
		if typeof(track) == "Instance" and track:IsA("AnimationTrack") then
			track:Stop()
		end
	end
	loadedAnims = {}

	local weaponModuleScript = ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData:FindFirstChild(weaponName)
	if not weaponModuleScript then
		warn("Weapon data not found for:", weaponName)
		return
	end

	local weaponModule = require(weaponModuleScript)

	local stance = GetCurrentStance()

	local animSet = weaponModule.AnimationIds[stance]

	if shoulderSwapped and weaponModule.AnimationIds.Left then
		animSet = weaponModule.AnimationIds.Left
	end

	if not animSet then return end

	local assetsToLoad = {}
	local animMap = {}

	local function stageAnim(key, entry)
		if not entry or not entry.Id then return end
		local anim = Instance.new("Animation")
		anim.AnimationId = entry.Id
		table.insert(assetsToLoad, anim)
		animMap[key] = {Anim = anim, Priority = entry.Priority}
	end

	stageAnim("Equip", animSet.Equip)
	stageAnim("UnEquip", animSet.UnEquip)
	stageAnim("Shoot", animSet.Shoot)
	stageAnim("Aim", animSet.Aim)
	stageAnim("Reload", animSet.Reload)
	stageAnim("Idle", animSet.Idle)
	stageAnim("Sprint", animSet.Sprint)

	ContentProvider:PreloadAsync(assetsToLoad)

	for key, info in pairs(animMap) do
		local track = animator:LoadAnimation(info.Anim)
		if info.Priority then track.Priority = info.Priority end

		if key == "Equip" then
			currentEquipTrack = track
		elseif key == "UnEquip" then
			currentUnequipTrack = track
		elseif key == "Idle" then
			currentIdle = track
			loadedAnims.Idle = track
		else
			loadedAnims[key] = track
		end
	end
end

local function IsSidearm()
	if not weaponStats then return false end
	return weaponStats.WeaponClass == "Sidearm"
end

local function StartSprint()
	if not weaponActive then return end
	if isSprinting then return end
	if isAiming then return end
	if isLocked then return end
	if isBusy then return end
	if not loadedAnims.Sprint then return end

	isSprinting = true

	if loadedAnims.Aim then
		loadedAnims.Aim:Stop(0.15)
	end

	if IsSidearm() and currentIdle then
		currentIdle:Stop(0.25)
	end

	loadedAnims.Sprint:Play(0.35)

	if CameraController then
		CameraController:TweenOffset(CameraConfig.Offsets.Sprint, TweenInfo.new(0.35))
		CameraController:TweenFOV(CameraConfig.FOV.Sprint, TweenInfo.new(0.35))
	end
end

local function StopSprint()
	if not isSprinting then return end
	isSprinting = false

	if loadedAnims.Sprint then
		loadedAnims.Sprint:Stop(0.35)
	end

	if IsSidearm() and currentIdle and weaponActive and not isAiming then
		currentIdle:Play(0.25)
		currentIdle.Looped = true
	end

	if CameraController then
		CameraController:TweenOffset(CameraConfig.Offsets.Default, TweenInfo.new(0.35))
		CameraController:TweenFOV(CameraConfig.FOV.Default, TweenInfo.new(0.35))
	end
end
local function SetAim(state)
	if not weaponActive then return end
	if isBusy and state == true then return end 
	if isAiming == state then return end

	if state and isLocked then return end

	if state then StopSprint() end
	isAiming = state

	if character then
		character:SetAttribute("IsAiming", state)
	end

	CrosshairHandler.SetVisible(state)

	if state then
		if loadedAnims.Aim then loadedAnims.Aim:Play(0.2) end

		if CameraController then
			CameraController:TweenOffset(CameraConfig.Offsets.Aim, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
			CameraController:TweenFOV(CameraConfig.FOV.Aim, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
		end
	else
		if loadedAnims.Aim then loadedAnims.Aim:Stop(0.2) end
		if currentIdle and weaponActive and not isSprinting then
			currentIdle:Play(0.2)
		end

		if CameraController then
			CameraController:TweenOffset(CameraConfig.Offsets.Default, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
			CameraController:TweenFOV(CameraConfig.FOV.Default, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
		end
	end
end


local _unequipInProgress = false

local function UnequipWeapon()
	if _unequipInProgress then return end
	_unequipInProgress = true

	isBusy = true

	local weaponName = currentWeapon
	local slot = currentSlot
	local cachedSlot = slot or "Primary"

	if currentIdle then currentIdle:Stop(0.1) end

	for _, track in pairs(loadedAnims) do
		if track and track.IsPlaying then
			track:Stop(0.1)
		end
	end

	local sentFinish = false
	local function sendFinish(cf)
		if sentFinish then return end
		sentFinish = true

		local finalSlot = cachedSlot or "Primary"

		WeaponRemote:FireServer("FinishUnequip", {
			WeaponName = weaponName or "Unknown",
			Slot = finalSlot,
			FinalCFrame = cf
		})
	end

	if currentUnequipTrack then
		currentUnequipTrack.Looped = false
		currentUnequipTrack:Play()

		currentUnequipTrack.Stopped:Once(function()
			local finalCF = CFrame.new()

			if character and weaponName then
				local weaponModel = character:FindFirstChild(weaponName)
				if weaponModel then
					local handle = weaponModel:FindFirstChild("Handle")
					if handle then
						finalCF = handle.CFrame
					end
				end
			end

			sendFinish(finalCF)
		end)
	else
		sendFinish(CFrame.new())
		weaponActive = false
		currentSlot = nil
	end

	SetAim(false)
	triggerDown = false
	if character then character:SetAttribute("IsAiming", false) end
	StopSprint()

	if CameraController then
		CameraController:TweenOffset(CameraConfig.Offsets.Default, TweenInfo.new(0.4))
		CameraController:TweenFOV(CameraConfig.FOV.Default, TweenInfo.new(0.4))
	end

	print("[WeaponClient] Unequipped safely")

	task.delay(5, function()
		if _unequipInProgress then
			_unequipInProgress = false
			isBusy = false
			currentWeapon = nil
			currentSlot = nil
			weaponActive = false
			CleanupClientWeapon()
			warn("[WeaponClient] Unequip timed out â€” forcing client cleanup")
		end
	end)
end



local function SetWeapon(weaponName, ammo, baseStats, fireMode)
	isBusy = true
	SetAim(false)
	triggerDown = false

	if currentIdle then currentIdle:Stop() end

	currentWeapon = weaponName
	currentAmmo = ammo
	local weaponModel = character:FindFirstChild(weaponName)
	if weaponModel then
		local handle = weaponModel:FindFirstChild("Handle")
		if handle then
			local fx = handle:FindFirstChild("MuzzleFX")
			if fx then
				local s = fx:FindFirstChild("FireSound")
				if s then
					s.PlaybackSpeed = 1
				end
			end
		end
	end

	local incoming = baseStats or {}
	local base = (type(incoming) == "table" and incoming.Base and type(incoming.Base) == "table")
		and incoming.Base or incoming


	weaponStats = base or {}
	weaponStats.FireMode = fireMode or incoming.FireMode or weaponStats.FireMode or "Semi"

	UpdateWeaponIcons(weaponName)
	UpdateAmmoUI(currentWeapon, currentAmmo, weaponStats.MagSize)

	if weaponStats and weaponStats.Spread then
		currentSpread = weaponStats.Spread.Min
	end

	if fireMode ~= nil then
		weaponStats.FireMode = fireMode
	end

	LoadWeaponAnimations(weaponName)

	if currentWeapon ~= weaponName then return end

	CrosshairHandler.SetStyle("Circle")
	print("[SetWeapon] weaponStats.FireMode =", weaponStats.FireMode)

	if weaponStats and weaponStats.FireRate then
		print("[SetWeapon] FireRate:", weaponStats.FireRate)
	end

	local equipTime = 0
	if currentEquipTrack then 
		currentEquipTrack:Play() 
		if currentEquipTrack.Length > 0 then
			equipTime = currentEquipTrack.Length
		end
	end

	task.delay(equipTime, function()
		if currentWeapon == weaponName then
			isBusy = false

			if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
				SetAim(true)
			end
		end
	end)

	local thisWeapon = weaponName

	task.delay(0.25, function()
		if weaponActive and currentWeapon == thisWeapon and currentIdle and not isSprinting then
			currentIdle:Play()
			currentIdle.Looped = true
		end
	end)

	print("[WeaponClient] Equipped", weaponName)
end

local function FireWeapon()
	if currentAmmo <= 0 then 
		PlayDryFire(character, currentWeapon)
		isFiring = true
		task.delay(0.2, function() isFiring = false end)
		return 
	end

	local weaponModel = character:FindFirstChild(currentWeapon)
	if not weaponModel then return end
	local handle = weaponModel:FindFirstChild("Handle")
	if not handle then return end

	local camera = workspace.CurrentCamera
	local mouseLocation = UserInputService:GetMouseLocation()
	local screenRay = camera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y)

	local muzzleFX = handle:FindFirstChild("MuzzleFX")
	local muzzlePos = muzzleFX and muzzleFX.WorldPosition or handle.Position

	local head = character:FindFirstChild("Head")
	if head then
		local origin = head.Position
		local dir = muzzlePos - origin
		local dist = dir.Magnitude

		local obstructionParams = RaycastParams.new()
		obstructionParams.FilterDescendantsInstances = {character, weaponModel, workspace.CurrentCamera}
		obstructionParams.FilterType = Enum.RaycastFilterType.Exclude

		local obstruction = workspace:Raycast(origin, dir.Unit * dist, obstructionParams)
		if obstruction then
			return
		end
	end

	local maxDist = weaponStats and weaponStats.MaxDistance or 2000

	local usedSpread = currentSpread
	if weaponStats.Spread and usedSpread <= weaponStats.Spread.Min then
		usedSpread = 0
	end

	local spreadRadius = (usedSpread / 100) * math.random()
	local spreadAngle = math.random() * math.pi * 2

	local cameraCF = workspace.CurrentCamera.CFrame
	local spreadOffset = (cameraCF.RightVector * math.cos(spreadAngle) * spreadRadius) + (cameraCF.UpVector * math.sin(spreadAngle) * spreadRadius)

	local rayDirection = (screenRay.Direction + spreadOffset).Unit

	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character, weaponModel, camera}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	local targetPos
	local cameraHit = workspace:Raycast(screenRay.Origin, rayDirection * maxDist, raycastParams)

	if cameraHit then
		targetPos = cameraHit.Position
	else
		targetPos = screenRay.Origin + (rayDirection * maxDist)
	end

	local bulletDir = (targetPos - muzzlePos).Unit
	local bulletDist = (targetPos - muzzlePos).Magnitude

	local bulletRayParams = RaycastParams.new()
	bulletRayParams.FilterDescendantsInstances = {character, weaponModel, camera}
	bulletRayParams.FilterType = Enum.RaycastFilterType.Exclude

	local realHitInstance = nil
	local bulletHit = workspace:Raycast(muzzlePos, bulletDir * (bulletDist * 1.1), bulletRayParams)

	if bulletHit then
		targetPos = bulletHit.Position
		realHitInstance = bulletHit.Instance
	end

	isFiring = true 

	if weaponStats and weaponStats.Spread then
		currentSpread = math.min(currentSpread + weaponStats.Spread.IncreasePerShot, weaponStats.Spread.Max)
	end

	if loadedAnims.Shoot then 
		loadedAnims.Shoot.Looped = false 
		loadedAnims.Shoot:Play() 
	end

	-- smoother pitch curve only near the last few bullets (better audio ind)
	local lowStart = math.clamp( math.floor(weaponStats.MagSize * 0.25), 1, weaponStats.MagSize )
	local bulletsLeft = currentAmmo

	local ratio = 0
	if bulletsLeft <= lowStart then
		ratio = 1 - (bulletsLeft / lowStart)
	end

	local fireSound = muzzleFX and muzzleFX:FindFirstChild("FireSound")
	if fireSound then
		fireSound.PlaybackSpeed = 1 + (ratio * 0.6)
	end
	PlayMuzzleFX(character, currentWeapon)

	DrawTracer(muzzlePos, targetPos, muzzleFX)

	if CameraConfig.Settings.DebugTracers then
		DrawDebugRay(muzzlePos, targetPos, Color3.new(0, 1, 0))
	end

	if CameraController and weaponStats and weaponStats.Recoil then
		local vRecoil = weaponStats.Recoil.Vertical or 1
		local hRecoil = weaponStats.Recoil.Horizontal or 0.5
		local kickX = math.random(-hRecoil*10, hRecoil*10) / 100
		local kickY = math.random(vRecoil*50, vRecoil*100) / 100
		CameraController:AddRecoil(kickX, kickY)
		if weaponStats.CameraImpulse then
			local camera = workspace.CurrentCamera
			local impulseData = weaponStats.CameraImpulse
			local localImpulse = impulseData.Vector or Vector3.new(0, 0, 0.15)

			local worldImpulse = (camera.CFrame.RightVector * localImpulse.X) +
				(camera.CFrame.UpVector * localImpulse.Y) +
				(-camera.CFrame.LookVector * localImpulse.Z)

			CameraController:ApplyImpulse(
				worldImpulse, 
				impulseData.FadeInSpeed or 30, 
				impulseData.FadeOutSpeed or 8
			)
		end
	end

	WeaponRemote:FireServer("Shoot", {
		TargetPosition = targetPos,
		HitPosition = targetPos,
		HitPart = realHitInstance,
		Slot = currentSlot
	})

	currentAmmo -= 1
	UpdateAmmoUI(currentWeapon, currentAmmo, weaponStats.MagSize)

	local cooldown = weaponStats.FireRate or 0.15
	task.delay(cooldown, function()
		isFiring = false
	end)
end

local autoFireCoroutine = nil

local function StartAutoFire()
	if autoFireCoroutine then return end

	autoFireCoroutine = task.spawn(function()
		while triggerDown and weaponActive and currentWeapon and isAiming do
			if isBusy or isLocked or currentAmmo <= 0 then
				task.wait(0.01)
				continue
			end

			if weaponStats and weaponStats.FireMode == "Auto" then
				FireWeapon()

				local fireRate = weaponStats.FireRate or 0.15
				task.wait(fireRate)
			else
				break
			end
		end

		autoFireCoroutine = nil
	end)
end

local function StopAutoFire()
	if autoFireCoroutine then
		task.cancel(autoFireCoroutine)
		autoFireCoroutine = nil
	end
end

local function ReloadWeapon()
	if not weaponActive or not currentWeapon then return end
	if isBusy then return end
	if isLocked then return end
	if currentAmmo >= weaponStats.MagSize then return end

	isBusy = true
	triggerDown = false
	StopSprint()

	if loadedAnims.Reload then
		loadedAnims.Reload:Play()

		task.delay(loadedAnims.Reload.Length, function()
			if weaponActive and currentWeapon then
				WeaponRemote:FireServer("Reload", {
					Slot = currentSlot
				})
				isBusy = false
				currentAmmo = weaponStats.MagSize
				UpdateAmmoUI(currentWeapon, currentAmmo, currentAmmo)

			end
		end)
	else
		WeaponRemote:FireServer("Reload")
		currentAmmo = weaponStats.MagSize
		UpdateAmmoUI(currentWeapon, currentAmmo, currentAmmo)
		isBusy = false
	end
end



SetWeaponLock.Event:Connect(function(locked)
	isLocked = locked
	if isLocked then
		SetAim(false)
		StopSprint()
		triggerDown = false
	end
end)

DebugInventory.OnClientEvent:Connect(function(invData)
	LocalInventory = invData or {}

	if PendingEquipSlot then
		local slot = PendingEquipSlot
		PendingEquipSlot = nil 

		if LocalInventory.Weapons and LocalInventory.Weapons[slot] then
			RequestEquipWeapon(LocalInventory.Weapons[slot], slot)
		end
	end
end)

RequestInventory:FireServer()

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		triggerDown = true
		if not weaponActive or not isAiming or isBusy or isLocked or not currentWeapon then return end

		local fireMode = (weaponStats and weaponStats.FireMode) or "Semi"

		if fireMode == "Semi" then
			if not isFiring then FireWeapon() end
			return
		elseif fireMode == "Burst" then
			if not isFiring then
				task.spawn(function()
					for i = 1, weaponStats.BurstCount or 3 do
						if not triggerDown or isFiring or isBusy or isLocked or currentAmmo <= 0 then break end
						FireWeapon()
						task.wait(weaponStats.BurstDelay or 0.06)
					end
				end)
			end
			return
		elseif fireMode == "Auto" then
			StartAutoFire()
			return
		end
	end

	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		if weaponActive and not isBusy then SetAim(true) end
	end

	if input.KeyCode == Enum.KeyCode.R then
		if weaponActive and CameraController then
			if weaponActive then ReloadWeapon() end
		end
	end

	local function HandleSwap(targetSlot)
		if isBusy or isLocked then return end

		if not LocalInventory or not LocalInventory.Weapons then
			PendingEquipSlot = targetSlot
			return 
		end

		local weapon = LocalInventory.Weapons[targetSlot]
		if not weapon then return end

		if weaponActive and currentSlot == targetSlot then
			UnequipWeapon()
			return
		end

		if weaponActive then
			UnequipWeapon()

			task.spawn(function()
				local s = os.clock()
				while weaponActive and (os.clock() - s) < 2 do
					task.wait()
				end
				RequestEquipWeapon(weapon, targetSlot)
			end)
			return
		end

		RequestEquipWeapon(weapon, targetSlot)
	end

	if input.KeyCode == Enum.KeyCode.One then
		HandleSwap("Primary")
	end

	if input.KeyCode == Enum.KeyCode.Two then
		HandleSwap("Secondary")
	end

	if input.KeyCode == Enum.KeyCode.Three then
		HandleSwap("Purchaseable")
	end

	if input.KeyCode == Enum.KeyCode.Q then
		if weaponActive and CameraController and not isLocked and not isBusy then
			CameraController:SwapShoulder()
		end
	end

	if input.KeyCode == Enum.KeyCode.LeftShift then
		if weaponActive and not isBusy then StartSprint() end
	end
end)

UserInputService.InputEnded:Connect(function(input, gp)
	if gp then return end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		triggerDown = false
		StopAutoFire()
	end

	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		SetAim(false)
	end

	if input.KeyCode == Enum.KeyCode.LeftShift then
		StopSprint()
	end
end)

local WhizFolder = Sounds:WaitForChild("Whiz")

local WHIZ_MAX_DIST = 5
local WHIZ_MED_DIST = 12
local WHIZ_LIGHT_DIST = 20
local DISTANT_SHOT_MIN = 150

local function DistanceFromLine(point, a, b)
	local ab = b - a
	local t = ((point - a):Dot(ab)) / (ab:Dot(ab))
	t = math.clamp(t, 0, 1)
	local closest = a + ab * t
	return (point - closest).Magnitude
end

local function PlayRandom(folder)
	local list = folder:GetChildren()
	if #list == 0 then return end
	local chosen = list[math.random(1, #list)]
	if chosen:IsA("Sound") then
		chosen:Play()
	end
end

local function PlayDistantAtMuzzle(muzzle, folder)
	if not (muzzle and folder) then return end

	local sounds = folder:GetChildren()
	if #sounds == 0 then return end

	local chosen = sounds[math.random(1, #sounds)]
	if not chosen:IsA("Sound") then return end

	local clone = chosen:Clone()
	clone.Parent = muzzle
	clone.PlayOnRemove = false

	clone.Ended:Connect(function()
		clone:Destroy()
	end)

	clone:Play()
end

function CleanupClientWeapon()
	for _, t in ipairs(loadedAnims) do
		t:Stop(0)
	end

	if currentIdle then
		currentIdle:Stop(0)
	end
end

local KillPop = Hud:WaitForChild("KillPop")
local Templates = KillPop.Templates

local SMALL_SIZE = UDim2.new(0.053, 0, 0.633, 0)
local BIG_SIZE   = UDim2.new(0.068, 0, 0.814, 0)


local function PopKill(typeName)
	local template = Templates:FindFirstChild(typeName)
	if not template then
		warn("KillPop template missing:", typeName)
		return
	end

	local ui = template:Clone()
	ui.Parent = KillPop
	ui.Visible = true

	ui.ImageTransparency = 1
	ui.Size = SMALL_SIZE

	Sounds.hitmarker.uc2killmarker1:Play()

	local fadeInPop = TweenService:Create(ui, TweenInfo.new(
		0.20, Enum.EasingStyle.Back, Enum.EasingDirection.Out
		), {
			ImageTransparency = 0,
			Size = BIG_SIZE
		})

	local shrinkBack = TweenService:Create(ui, TweenInfo.new(
		0.15, Enum.EasingStyle.Sine, Enum.EasingDirection.Out
		), {
			Size = SMALL_SIZE
		})

	local fadeOut = TweenService:Create(ui, TweenInfo.new(
		0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.In
		), {
			ImageTransparency = 1,
			Size = SMALL_SIZE
		})

	fadeInPop:Play()
	fadeInPop.Completed:Once(function()
		shrinkBack:Play()

		task.delay(1.5, function()
			fadeOut:Play()
			fadeOut.Completed:Once(function()
				ui:Destroy()
			end)
		end)
	end)
end

WeaponRemote.OnClientEvent:Connect(function(action, data)
	if action == "Equipped" then
		weaponActive = true
		currentSlot = data.Slot
		SetWeapon(data.WeaponName, data.Ammo, data.Data, data.FireMode)

	elseif action == "Unequipped" or action == "Holstered" then
		weaponActive = false
		isBusy = false
		currentWeapon = nil
		currentSlot = nil
		currentIdle = nil
		_unequipInProgress = false

		isAiming = false
		isSprinting = false
		triggerDown = false

		if CleanupClientWeapon then
			CleanupClientWeapon()
		else
			for _, track in pairs(loadedAnims) do
				if track and track.IsPlaying then
					track:Stop(0)
				end
			end
			if currentEquipTrack then currentEquipTrack:Stop(0) end
			if currentUnequipTrack then currentUnequipTrack:Stop(0) end
		end

		print("[WeaponClient] Server confirmed holster/unequip -> client cleaned up")

	elseif action == "UnequipConfirmed" then
		weaponActive = false
		currentWeapon = nil
		currentSlot = nil
		currentIdle = nil
		isBusy = false
		_unequipInProgress = false
		if CleanupClientWeapon then CleanupClientWeapon() end

		print("[WeaponClient] UnequipConfirmed received -> cleared state")

	elseif action == "Shot" then
		if data.Player == player then
			currentAmmo = data.Ammo
		else
			if data.Player.Character then
				PlayMuzzleFX(data.Player.Character, data.WeaponName)

				if data.Payload and data.Payload.TargetPosition then
					local otherModel = data.Player.Character:FindFirstChild(data.WeaponName)
					if otherModel then
						local otherHandle = otherModel:FindFirstChild("Handle")
						if otherHandle then
							local otherMuzzle = otherHandle:FindFirstChild("Handle")
							local origin = otherMuzzle and otherMuzzle.WorldPosition or otherHandle.Position

							local camPos = workspace.CurrentCamera.CFrame.Position
							local muzzleDist = (camPos - origin).Magnitude

							if muzzleDist >= DISTANT_SHOT_MIN then
								PlayDistantAtMuzzle(otherMuzzle or otherHandle, WhizFolder.Distant)
							end

							local target = data.Payload.TargetPosition



							if CameraConfig.Settings.DebugTracers then
								DrawDebugRay(origin, target, Color3.new(1, 0.6, 0))
							else
								DrawTracer(origin, target, otherMuzzle)
							end


							local head = character:FindFirstChild("Head")
							if head then
								local headPos = head.Position

								local dist = DistanceFromLine(headPos, origin, target)
								local muzzleDist = (origin - headPos).Magnitude

								if dist <= WHIZ_MAX_DIST then
									PlayRandom(WhizFolder.Heavy)
								elseif dist <= WHIZ_MED_DIST then
									PlayRandom(WhizFolder.Medium)
								elseif dist <= WHIZ_LIGHT_DIST then
									PlayRandom(WhizFolder.Light)
								end
							end
						end
					end
				end
			end
		end

	elseif action == "Reloaded" then
		if data.Player == player then
			currentAmmo = data.Ammo
		end

	elseif action == "ForceStopAllWeaponAnimations" or action == "Holstered" then
		isBusy = false 

		for _, track in pairs(loadedAnims) do
			if track and typeof(track) == "Instance" then track:Stop(0) end
		end
		if currentEquipTrack then currentEquipTrack:Stop(0) end
		if currentUnequipTrack then currentUnequipTrack:Stop(0) end

		if animator then
			for _, t in ipairs(animator:GetPlayingAnimationTracks()) do
				if t.Priority == Enum.AnimationPriority.Action or t.Priority == Enum.AnimationPriority.Action2 or t.Priority == Enum.AnimationPriority.Action3 or t.Priority == Enum.AnimationPriority.Action4 then
					t:Stop(0)
				end
			end
		end

		currentIdle = nil
		isAiming = false
		isSprinting = false
		triggerDown = false
	elseif action == "HitMarker" then
		local isHeadshot = (data.HitPart == "Head")

		if cross then
			cross:HitMarker(isHeadshot)
		end

		if isHeadshot then
			if Sounds.hitmarker:FindFirstChild("headmarker") then
				Sounds.hitmarker.headmarker:Play()
			end
		else
			if Sounds.hitmarker:FindFirstChild("newkillmarker") then
				Sounds.hitmarker.newkillmarker:Play()
			end
		end

	elseif action == "Kill" then
		local isHeadshot = (data.HitPart == "Head")

		if isHeadshot then
			PopKill("Headshot")
		else
			PopKill("Kill")
		end
	end
end)

local lastMoveDir = Vector3.zero

RunService.RenderStepped:Connect(function(dt)
	if not weaponActive then
		if isSprinting then StopSprint() end
		lastMoveDir = humanoid.MoveDirection
		return
	end

	if weaponActive then
		UserInputService.MouseIconEnabled = false

		if weaponStats and weaponStats.Spread then
			local spreadData = weaponStats.Spread
			local minSpread = spreadData.Min
			local decay = spreadData.DecaySpeed * dt

			if currentSpread > minSpread then
				currentSpread = math.max(minSpread, currentSpread - decay)
			end

			CrosshairHandler.SetSpread(currentSpread * 20)
		end
	end

	local moveDir = humanoid.MoveDirection
	local shiftHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

	if moveDir.Magnitude > 0 then
		if shiftHeld and not isSprinting and not isAiming and not isBusy then
			StartSprint()
		end
	else
		if isSprinting then
			StopSprint()
		end
	end

	if isSprinting and not shiftHeld then
		StopSprint()
	end

	lastMoveDir = moveDir
end)

player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	animator = humanoid:WaitForChild("Animator")

	print("[WeaponClient] Character respawn detected â†’ rebuilding animation state")

	loadedAnims = {}
	currentIdle = nil
	currentEquipTrack = nil
	currentUnequipTrack = nil
	weaponActive = false
	currentWeapon = nil
	weaponStats = nil
	isBusy = false
	isLocked = false
	isFiring = false
	triggerDown = false
	isAiming = false

	LocalInventory = nil
	PendingEquipSlot = nil
	RequestInventory:FireServer()

	if currentWeapon then
		print("[WeaponClient] Reloading animations for", currentWeapon)
		LoadWeaponAnimations(currentWeapon)

		task.delay(0.3, function()
			if weaponActive and currentIdle then
				currentIdle:Play()
				currentIdle.Looped = true
			end
		end)
	end
end)
--// END OF SCRIPT: game.StarterPlayer.StarterPlayerScripts.Client | weapon

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterPlayer.StarterPlayerScripts.Team | Enabled: true
--------------------------------------------------------------------
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local OUTLINE_TRANSPARENCY = 0.5
local FILL_TRANSPARENCY = 1 -- no fill

local activeHighlights = {}

local function clearHighlight(character)
	if character and activeHighlights[character] then
		activeHighlights[character]:Destroy()
		activeHighlights[character] = nil
	end
end

local function applyTeammateHighlight(player)
	if player == LocalPlayer then return end
	if not LocalPlayer.Team then return end
	if player.Team ~= LocalPlayer.Team then return end

	local char = player.Character
	if not char then return end
	if activeHighlights[char] then return end

	local highlight = Instance.new("Highlight")
	highlight.Name = "TeamOnlyHighlight"
	highlight.FillTransparency = FILL_TRANSPARENCY
	highlight.OutlineTransparency = OUTLINE_TRANSPARENCY
	highlight.OutlineColor = player.Team.TeamColor.Color
	highlight.Parent = char

	activeHighlights[char] = highlight
end

local function refreshAll()
	for char, hl in pairs(activeHighlights) do
		if hl then hl:Destroy() end
	end
	activeHighlights = {}

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer and plr.Team == LocalPlayer.Team then
			applyTeammateHighlight(plr)
		end
	end
end

local function handlePlayer(player)
	player.CharacterAdded:Connect(function(char)
		task.wait()
		if player.Team == LocalPlayer.Team then
			applyTeammateHighlight(player)
		else
			clearHighlight(char)
		end
	end)

	player:GetPropertyChangedSignal("Team"):Connect(function()
		refreshAll()
	end)
end

for _, plr in ipairs(Players:GetPlayers()) do
	handlePlayer(plr)
end

Players.PlayerAdded:Connect(handlePlayer)

Players.PlayerRemoving:Connect(function(player)
	if player.Character then
		clearHighlight(player.Character)
	end
end)

LocalPlayer:GetPropertyChangedSignal("Team"):Connect(refreshAll)



----------------------------------------------------------------
--   DEATH FADE (ONLY FOR TEAMMATES)
----------------------------------------------------------------
local DeathEvent = RS.Peak.Remotes:WaitForChild("TeamHighlightDeath")

DeathEvent.OnClientEvent:Connect(function(deadPlayer)
	-- must be teammate
	if deadPlayer.Team ~= LocalPlayer.Team then return end
	if deadPlayer == LocalPlayer then return end

	local char = deadPlayer.Character
	if not char then return end

	local hl = activeHighlights[char]
	if not hl then return end

	-- tween fade-out
	local tween = TweenService:Create(
		hl,
		TweenInfo.new(0.75, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{
			FillTransparency = 1,
			OutlineTransparency = 1
		}
	)

	tween:Play()
	tween.Completed:Connect(function()
		clearHighlight(char)
	end)
end)

--// END OF SCRIPT: game.StarterPlayer.StarterPlayerScripts.Team

--------------------------------------------------------------------
--// [Script] Path: game.StarterGui.random plugin | Enabled: false
--------------------------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local enabled = true

if plugin then
	local toolbar = plugin:CreateToolbar("UISelect")
	local Button = toolbar:CreateButton("UI Select", "Allows you to select user interface without having to be on the ui layer.", "rbxassetid://7143000156");
	Button:SetActive(enabled)

	Button.Click:Connect(function()
		enabled = not enabled
		Button:SetActive(enabled)
	end)
end


UserInputService.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 and enabled then	
		local position = UserInputService:GetMouseLocation()
		local guis = game.StarterGui:GetGuiObjectsAtPosition(position.X,position.Y)

		guis = (game.Selection:Get()[1] ~= guis[1] and guis[1]) and game.Selection:Set({guis[1]})
	end
end)
--// END OF SCRIPT: game.StarterGui.random plugin

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterGui.ScreenGui.TextLabel.InventoryDebug | Enabled: true
--------------------------------------------------------------------

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DebugEvent = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes"):WaitForChild("DebugInventory")

local label = script.Parent
if not label or not label:IsA("TextLabel") then
	warn("InventoryDebug: script parent is not a TextLabel")
	return
end

local function formatInventory(inv)
	if type(inv) ~= "table" then
		return "---- DEBUG INVENTORY ----\n(no inventory data received)"
	end

	local lines = {}
	table.insert(lines, "---- DEBUG INVENTORY ----")

	for category, items in pairs(inv) do
		table.insert(lines, "")
		table.insert(lines, "[" .. tostring(category) .. "]")

	
		if type(items) == "table" then
			for item, value in pairs(items) do
				table.insert(lines, string.format("  %s = %s", tostring(item), tostring(value)))
			end
		else
			table.insert(lines, "  " .. tostring(items))
		end
	end

	return table.concat(lines, "\n")
end

DebugEvent.OnClientEvent:Connect(function(inv)
	local ok, text = pcall(formatInventory, inv)
	if ok then
		label.Text = text
	else
		label.Text = "Error formatting inventory: " .. tostring(text)
	end
end)

label.Text = "---- DEBUG INVENTORY ----\n(waiting for server...)"

--// END OF SCRIPT: game.StarterGui.ScreenGui.TextLabel.InventoryDebug

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterGui.LIVES.H.topLeft.Team2Lives.updateLives | Enabled: false
--------------------------------------------------------------------
repeat
	wait()
until game:GetService("ReplicatedStorage"):WaitForChild("WhatTeam").Value ~= nil

local textto = nil
if game:GetService("ReplicatedStorage"):WaitForChild("WhatTeam").Value == "Team2" then
	textto = game:GetService("ReplicatedStorage"):WaitForChild("GAME"):WaitForChild("SupplyRaid"):WaitForChild("LivesTeam2")
else
	textto = game:GetService("ReplicatedStorage"):WaitForChild("GAME"):WaitForChild("SupplyRaid"):WaitForChild("LivesTeam1")
end

textto.Changed:Connect(function()
	script.Parent.Text = tostring(textto.Value)
end)

--// END OF SCRIPT: game.StarterGui.LIVES.H.topLeft.Team2Lives.updateLives

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterGui.LIVES.H.topLeft.Team1Lives.ui | Enabled: false
--------------------------------------------------------------------
repeat
	wait()
	print("Waiting for WhatTeam to be non-nil")
until game:GetService("ReplicatedStorage"):WaitForChild("WhatTeam").Value ~= nil

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local WhatTeam = ReplicatedStorage:WaitForChild("WhatTeam")
local remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("assignTeam")

local function getLivesForTeam(team)
	local supplyRaid = ReplicatedStorage:WaitForChild("GAME"):WaitForChild("SupplyRaid")
	local livesName = "Lives" .. tostring(team)
	local lives = supplyRaid:FindFirstChild(livesName)
	if not lives then
		warn("Lives for team " .. tostring(team) .. " not found. Using default lives value.")
		lives = Instance.new("IntValue")
		lives.Value = 0
		lives.Name = livesName
	end
	return lives
end

local function updateTeamUI(team, player)
	local playerGui = player:FindFirstChild("PlayerGui")
	if not playerGui then
		warn("PlayerGui not found for player: " .. player.Name)
		return
	end

	local livesFrame = playerGui:FindFirstChild("LIVES")
	if not livesFrame then
		warn("LIVES frame not found in PlayerGui for player: " .. player.Name)
		return
	end

	local teamgui = livesFrame.H.topLeft:FindFirstChild("TEAM1")
	local teams = ReplicatedStorage:WaitForChild("GAME"):WaitForChild("Teams"):FindFirstChild(tostring(team))

	local oppTeam = team == "Team1" and "Team2" or "Team1"
	local teamguiopp = livesFrame.H.topLeft:FindFirstChild("TEAM2")
	local teamsopp = ReplicatedStorage:WaitForChild("GAME"):WaitForChild("Teams"):FindFirstChild(tostring(oppTeam))

	-- Debugging information
	print("Updating UI for team:", team)
	print("TEAM1 GUI:", teamgui)
	print("TEAM2 GUI:", teamguiopp)

	if teamgui and teams then
		print("TEAM1 GUI found, updating templates.")
		-- Clear existing templates
		for _, v in pairs(teamgui:GetChildren()) do
			if v.Name:find("Template") then
				v:Destroy()
			end
		end
		-- Create new templates
		local template = teamgui:FindFirstChild("TEMPLATE")
		if template then
			for _, v in pairs(teams:GetChildren()) do
				local newTemplate = template:Clone()
				newTemplate.Visible = true
				newTemplate.Parent = teamgui
				newTemplate.Name = v.Name .. "Template"

				-- Debug: Print the new template name
				print("Created template for:", v.Name)

				local boolv = Instance.new("BoolValue")
				boolv.Name = "CanDestroy"
				boolv.Parent = newTemplate

				local character = workspace:FindFirstChild("Characters"):FindFirstChild(v.Name)
				if character then
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.Health <= 0 then
						newTemplate:FindFirstChild("X").Visible = true
						newTemplate.ImageTransparency = 0.5
					end
				end
			end
		else
			warn("TEMPLATE not found in TEAM1 GUI.")
		end
	else
		warn("TEAM1 GUI or teams not found for team:", team)
	end

	if teamguiopp and teamsopp then
		print("TEAM2 GUI found, updating templates.")
		-- Clear existing templates
		for _, v in pairs(teamguiopp:GetChildren()) do
			if v.Name:find("Template") then
				v:Destroy()
			end
		end
		-- Create new templates
		local template = teamguiopp:FindFirstChild("TEMPLATE")
		if template then
			for _, v in pairs(teamsopp:GetChildren()) do
				local newTemplate = template:Clone()
				newTemplate.Visible = true
				newTemplate.Parent = teamguiopp
				newTemplate.Name = v.Name .. "Template"

				-- Debug: Print the new template name for opponent
				print("Created template for opponent:", v.Name)

				local boolv = Instance.new("BoolValue")
				boolv.Name = "CanDestroy"
				boolv.Parent = newTemplate

				local character = workspace:FindFirstChild("Characters"):FindFirstChild(v.Name)
				if character then
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.Health <= 0 then
						newTemplate:FindFirstChild("X").Visible = true
						newTemplate.ImageTransparency = 0.5
					end
				end
			end
		else
			warn("TEMPLATE not found in TEAM2 GUI.")
		end
	else
		warn("TEAM2 GUI or teams not found for opponent team:", oppTeam)
	end

	local textto = getLivesForTeam(team)
	textto.Changed:Connect(function()
		script.Parent.Text = tostring(textto.Value)
	end)
end

remote.OnClientEvent:Connect(function(team)
	print("Received team assignment:", team)
	WhatTeam.Value = team
	local player = game.Players.LocalPlayer
	updateTeamUI(team, player)
end)

-- Initial setup
local player = game.Players.LocalPlayer
updateTeamUI(WhatTeam.Value, player)

-- Listen for team changes
WhatTeam.Changed:Connect(function()
	print("WhatTeam value changed to:", WhatTeam.Value)
	updateTeamUI(WhatTeam.Value, player)
end)

--// END OF SCRIPT: game.StarterGui.LIVES.H.topLeft.Team1Lives.ui

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterGui.LIVES.H.Countdown.LocalScript | Enabled: false
--------------------------------------------------------------------
local theval = game:GetService("ReplicatedStorage"):WaitForChild("GAME"):WaitForChild("gametime")


theval.Changed:Connect(function()
	if theval then
		script.Parent.Visible = true
		
		local Time = theval.Value
		local min, sec = tostring(math.floor(Time/60)), tostring(Time%60)
		if #sec == 1 then
			sec = sec.."0"
		end
		local FixedTime = tostring(min)..":"..tostring(sec)
		
		script.Parent.Text = FixedTime
	end
end)


--// END OF SCRIPT: game.StarterGui.LIVES.H.Countdown.LocalScript

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterGui.Level.LocalScript | Enabled: false
--------------------------------------------------------------------
local ROGUEBANNER = script.Parent:WaitForChild("LevelBanner")
local tweenserv = game:GetService("TweenService")
local inputserv = game:GetService("UserInputService")
local Sounds = script.Parent.Parent:WaitForChild("uisounds")
local SFX = script.Parent.Parent:WaitForChild("SFX")

local soundeffecttable = Sounds:WaitForChild("Effects"):GetChildren()

--tweens
local quickspeed = TweenInfo.new(0.2)
local normalspeed = TweenInfo.new(1)
local slowspeed = TweenInfo.new(1.5)


local tweenredbar = tweenserv:Create(ROGUEBANNER.REDBAR ,normalspeed, {Size = UDim2.new(2, 0,1, 0)})
local redbartransparency = tweenserv:Create(ROGUEBANNER.REDBAR ,quickspeed, {BackgroundTransparency = 1})

local tweenredbarback = tweenserv:Create(ROGUEBANNER.REDBAR ,quickspeed, {Size = UDim2.new(0, 0,1, 0)})
local tweenROGUEBANNER = tweenserv:Create(ROGUEBANNER ,quickspeed, {Size = UDim2.new(0.01, 0,0.101, 0)})
local tweenROGUEBANNERNORMALSIZE = tweenserv:Create(ROGUEBANNER ,quickspeed, {Size = UDim2.new(0.233, 0,0.101, 0)})

local tweentextROGUEIN = tweenserv:Create(ROGUEBANNER.Rogue ,quickspeed, {TextTransparency = 0})
local tweentextROGUEOUT = tweenserv:Create(ROGUEBANNER.Rogue ,quickspeed, {TextTransparency = 1})
local tweentextGONEIN = tweenserv:Create(ROGUEBANNER.Gone ,quickspeed, {TextTransparency = 0})
local tweentextGONEOUT = tweenserv:Create(ROGUEBANNER.Gone ,quickspeed, {TextTransparency = 1})

local function LEVELUP()
	ROGUEBANNER.REDBAR.BackgroundTransparency = 0.75
	ROGUEBANNER.Visible = true

	tweenROGUEBANNERNORMALSIZE:Play()
	tweenROGUEBANNERNORMALSIZE.Completed:Wait()
	tweentextROGUEIN:Play()
	tweentextGONEIN:Play()

	tweenredbar:Play()
	tweenredbar.Completed:Wait()
	wait(2)
	redbartransparency:Play()
	redbartransparency.Completed:Wait()
	tweenredbarback:Play()
	tweentextROGUEOUT:Play()
	tweentextGONEOUT:Play()
	tweentextGONEOUT.Completed:Wait()
	tweenROGUEBANNER:Play()
	tweenROGUEBANNER.Completed:Wait()
	ROGUEBANNER.Visible = false
	ROGUEBANNER.REDBAR.BackgroundTransparency = 0
end

local PlayerData = game.Players.LocalPlayer:WaitForChild("playerData")
local PlayerStats = PlayerData:WaitForChild("PlayerStats")

local Level = PlayerStats:WaitForChild("LEVEL")

local function playRandomSound()
	local randomIndex = math.random(1, #soundeffecttable)
	local sound = soundeffecttable[randomIndex]
	if sound:IsA("Sound") then
		sound:Play()
	end
end


		Level.Changed:Connect(function()
			Sounds:WaitForChild("Effects"):WaitForChild("1"):Play()
			LEVELUP()	
			

		end)


--// END OF SCRIPT: game.StarterGui.Level.LocalScript

--------------------------------------------------------------------
--// [LocalScript] Path: game.StarterGui.REARMED HUD.H.dmg | Enabled: true
--------------------------------------------------------------------
function getCentreCF(cam)
	local cf = cam.CFrame
	local pos = cf.Position
	return CFrame.new(pos, pos + cf.LookVector * Vector3.new(1, 0, 1))
end

function calculateAngle(cameraCF, worldPosition)
	local relative = cameraCF:PointToObjectSpace(worldPosition)
	return math.deg(math.atan2(relative.Z, relative.X)) + 90
end

local CurrentCamera = workspace.CurrentCamera
local IndicatorTemplate = script:WaitForChild("DamageIndicator")
local ParentFrame = script.Parent
local TweenService = game:GetService("TweenService")
local FadeTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

function damageDealt(attackerPos)
	local indicator = IndicatorTemplate:Clone()
	indicator.DamageIndicatorImage.ImageTransparency = 0
	indicator.Visible = true

	indicator.Rotation = calculateAngle(getCentreCF(CurrentCamera), attackerPos)
	indicator.Parent = ParentFrame

	task.spawn(function()
		while indicator.Parent == ParentFrame do
			indicator.Rotation = calculateAngle(getCentreCF(CurrentCamera), attackerPos)
			game:GetService("RunService").Heartbeat:Wait()
		end
	end)

	task.wait(5)

	local tween = TweenService:Create(indicator.DamageIndicatorImage.ImageLabel, FadeTweenInfo, {
		ImageTransparency = 1,
	})
	tween:Play()
	tween.Completed:Wait()
	indicator:Destroy()
end

game:GetService("ReplicatedStorage").Peak.Remotes.WeaponSys.DamageEvent.OnClientEvent:Connect(damageDealt)

--// END OF SCRIPT: game.StarterGui.REARMED HUD.H.dmg

--------------------------------------------------------------------
--// [LocalScript] Path: game.ReplicatedStorage.RedTeamRadar | Enabled: true
--------------------------------------------------------------------
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

-- Decompiler will be improved VERY SOON!
-- Decompiled with Konstant V2.1, a fast Luau decompiler made in Luau by plusgiant5 (https://discord.gg/brNTY8nX8t)
-- Decompiled on 2025-12-04 18:00:36
-- Luau version 6, Types version 3
-- Time taken: 0.003585 seconds

local LocalPlayer_upvr = game.Players.LocalPlayer
local Character = LocalPlayer_upvr.Character
if not Character then
	Character = LocalPlayer_upvr.CharacterAdded:Wait()
end
local tbl_upvr = {}
local HumanoidRootPart_upvr = Character:WaitForChild("HumanoidRootPart")
local Parent_upvr = script.Parent
local Blip_upvr = script:WaitForChild("Blip")
game:GetService("RunService").RenderStepped:Connect(function() -- Line 11
	--[[ Upvalues[5]:
		[1]: LocalPlayer_upvr (readonly)
		[2]: HumanoidRootPart_upvr (readonly)
		[3]: Parent_upvr (readonly)
		[4]: tbl_upvr (readonly)
		[5]: Blip_upvr (readonly)
	]]
	-- KONSTANTERROR: [0] 1. Error Block 1 start (CF ANALYSIS FAILED)
	-- KONSTANTERROR: [0] 1. Error Block 1 end (CF ANALYSIS FAILED)
	-- KONSTANTERROR: [7] 5. Error Block 29 start (CF ANALYSIS FAILED)
	wait(0.5)
	Parent_upvr.Rotation = math.deg(math.atan2(HumanoidRootPart_upvr.CFrame.RightVector.Z, HumanoidRootPart_upvr.CFrame.LookVector.Z))
	for _, v in ipairs(tbl_upvr) do
		v:Destroy()
	end
	local _, _, _ = ipairs(game.Players:GetPlayers())
	-- KONSTANTERROR: [7] 5. Error Block 29 end (CF ANALYSIS FAILED)
end)
wait(2)
game.ReplicatedStorage.RedTeamRadar:Clone().Parent = script.Parent
for _, v_2 in ipairs(tbl_upvr) do
	v_2:Destroy()
end
script:Destroy()
--// END OF SCRIPT: game.ReplicatedStorage.RedTeamRadar

--------------------------------------------------------------------
--// [LocalScript] Path: game.ReplicatedStorage.BlueTeamRadar | Enabled: true
--------------------------------------------------------------------
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

-- Decompiler will be improved VERY SOON!
-- Decompiled with Konstant V2.1, a fast Luau decompiler made in Luau by plusgiant5 (https://discord.gg/brNTY8nX8t)
-- Decompiled on 2025-12-04 18:00:35
-- Luau version 6, Types version 3
-- Time taken: 0.003170 seconds

local LocalPlayer_upvr = game.Players.LocalPlayer
local Character = LocalPlayer_upvr.Character
if not Character then
	Character = LocalPlayer_upvr.CharacterAdded:Wait()
end
local tbl_upvr = {}
local HumanoidRootPart_upvr = Character:WaitForChild("HumanoidRootPart")
local Parent_upvr = script.Parent
local Blip_upvr = script:WaitForChild("Blip")
game:GetService("RunService").RenderStepped:Connect(function() -- Line 11
	--[[ Upvalues[5]:
		[1]: LocalPlayer_upvr (readonly)
		[2]: HumanoidRootPart_upvr (readonly)
		[3]: Parent_upvr (readonly)
		[4]: tbl_upvr (readonly)
		[5]: Blip_upvr (readonly)
	]]
	-- KONSTANTERROR: [0] 1. Error Block 1 start (CF ANALYSIS FAILED)
	-- KONSTANTERROR: [0] 1. Error Block 1 end (CF ANALYSIS FAILED)
	-- KONSTANTERROR: [7] 5. Error Block 29 start (CF ANALYSIS FAILED)
	wait(0.5)
	Parent_upvr.Rotation = math.deg(math.atan2(HumanoidRootPart_upvr.CFrame.RightVector.Z, HumanoidRootPart_upvr.CFrame.LookVector.Z))
	for _, v in ipairs(tbl_upvr) do
		v:Destroy()
	end
	local _, _, _ = ipairs(game.Players:GetPlayers())
	-- KONSTANTERROR: [7] 5. Error Block 29 end (CF ANALYSIS FAILED)
end)
wait(2)
game.ReplicatedStorage.BlueTeamRadar:Clone().Parent = script.Parent
for _, v_2 in ipairs(tbl_upvr) do
	v_2:Destroy()
end
script:Destroy()
--// END OF SCRIPT: game.ReplicatedStorage.BlueTeamRadar

--------------------------------------------------------------------
--// [Script] Path: game.ReplicatedStorage.Peak.Assets.LensFlare.README | Enabled: false
--------------------------------------------------------------------
--[[
	LensFlare, by gluGPU
	https://devforum.roblox.com/t/lens-flare-system-easily-usable-by-builders-or-scripters/4021857/31
	2025
	
	Version 1.2
	
	Changelog:
		1.1 - Optimized lens flare calculations, added configuration file, reduced default raycast amount.
			1.1.1 - Fixed emitters with no / zero ColorBlend being greyscale
		
		1.2 - Added attachment support, more sun flare behaviors, and more configuration settings. Improved color blending be [trimmed]  -  Edit
  14:14:59.581  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.PlayerData | Enabled: N/A
--------------------------------------------------------------------
local PlayerData = {}

PlayerData.DefaultPlayerData = {

	--  PLAYER CORE PROGRESSION
	Core = {
		Level = 1,
		XP = 0,
		SkillPoints = 0,

		-- Skill tree categories similar to TLOU:
		Skills = {
			Survival = 0,   -- Healing speed, crafting bonuses
			Stealth = 0,    -- Sneaking, silent takedown bonuses
			Combat = 0,     -- Weapon sway reduction, reload speed
		},
	},

	--  INVENTORY SYSTEM
	Inventory = {

		Resources = {
			Alcohol = 0,
			Blades = 0,
			Rags = 0,
			Binding = 0,
			MetalParts = 0,
			Explosives = 0
		},

		Consumables = {
			Medkits = 0,
			Shivs = 0,
			Molotovs = 0,
			SmokeBombs = 0,
			NailBombs = 0,
			Mines = 0,
			Pipebomb = 0,
		},

		Ammo = {
			Secondary = 0,
			Primary = 0,
			Purchasable = 0,
			Secondary2 = 0,
		},

		Weapons = {
			Primary = "Mini-14",
			Purchaseable = "AssaultRifle",
			Secondary = "Beretta",
			Melee = nil,
		},
	},

	--  PLAYER CONDITION (TLOU Survivor Style)
	Status = {
		Health = 100,
		MaxHealth = 100,

		InfectionLevel = 0,
		BleedTimer = 0,
		Stamina = 100,
		MaxStamina = 100,
	},

	--  PLAYER APPEARANCE / COSMETICS
	Cosmetics = {

		Owned = {
			Masks = {},
			Hats = {},
			Shirts = {},
			Pants = {},
			Backpacks = {"Backpack","CamoBag","LeatherBag"},
		},

		Equipped = {
			Mask = nil,
			Hat = nil,
			Shirt = nil,
			Pants = nil,
			Backpack = "Backpack",
		},
	},
	--leather bag co Y pos for clothing 0.04

	--  QUESTS / CHECKPOINTS
	Progression = {
		Story = {
			CurrentChapter = 1,
			Checkpoints = {},
		},
		SideQuests = {},
		Collectibles = {
			FireflyPendants = {},
			Artifacts = {},
			Comics = {},
		}
	},

	--  CRAFTING + WORKBENCH
	Workbench = {
		Upgrades = {
			WeaponSway = 0,
			ReloadSpeed = 0,
			FireRate = 0,
			Damage = 0,
		},

		CraftingRecipesUnlocked = {
			Medkit = true,
			Shiv = true,
			Molotov = false,
			SmokeBomb = false,
		},
	},

	-- GLOBAL STATISTICS
	Stats = {
		TimeSurvived = 0,
		InfectedKilled = 0,
		HumansKilled = 0,
		Deaths = 0,

		Headshots = 0,
		StealthKills = 0,

		DistanceTraveled = 0,
		CraftedItems = 0,
	},
}

return PlayerData

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.PlayerData

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.DataHelper | Enabled: N/A
--------------------------------------------------------------------
-- DataHelper.lua
local DataUtils = {}

-- Returns parent table and last key for a dotted path, e.g. "Inventory.Resources.Alcohol"
local function resolvePath(root, path)
	if not path or path == "" then return nil end
	local current = root
	local lastKey = nil

	for segment in string.gmatch(path, "[^.]+") do
		lastKey = segment
		if current[lastKey] == nil then
			-- don't create automatically; just return what we have
			return current, lastKey
		end
		if type(current[lastKey]) ~= "table" then
			-- if this is final segment it may be number/string, so break
			break
		end
		current = current[lastKey]
	end

	return current, lastKey
end

-- Generic safe getter: returns value at path
local function getPath(root, path)
	if path == nil or path == "" then return nil end
	local current = root
	for segment in string.gmatch(path, "[^.]+") do
		if type(current) ~= "table" then return nil end
		current = current[segment]
		if current == nil then return nil end
	end
	return current
end

-- Adds a value to the data and prints the result
function DataUtils.Add(playerProfile, path, value)
	if not playerProfile or not playerProfile.Data then
		warn("[DataUtils] Add: invalid profile")
		return
	end

	local parent, key = resolvePath(playerProfile.Data, path)
	local currentVal = getPath(playerProfile.Data, path)

	-- If parent is nil or key nil, try top-level assignment
	if not parent or not key then
		-- fallback: set direct key on Data
		local prev = playerProfile.Data[path]
		if type(prev) == "number" then
			playerProfile.Data[path] = prev + (value or 0)
		else
			playerProfile.Data[path] = value
		end

		print("[DATA ADD] ->", path, "=", tostring(playerProfile.Data[path]))
		return
	end

	-- If the resolved value exists and is a table, insert into it
	if type(currentVal) == "table" then
		table.insert(currentVal, value)
		print("[DATA ADD] -> inserted into table:", path, "value =", tostring(value))
		return
	end

	-- If numeric, add
	if type(currentVal) == "number" then
		parent[key] = currentVal + (value or 0)
		print("[DATA ADD] ->", path, "=", tostring(parent[key]))
		return
	end

	-- Otherwise overwrite / set
	parent[key] = value
	print("[DATA ADD] ->", path, "=", tostring(parent[key]))
end

-- Removes a value from the data and prints the result
function DataUtils.Remove(playerProfile, path, value)
	if not playerProfile or not playerProfile.Data then
		warn("[DataUtils] Remove: invalid profile")
		return
	end

	local parent, key = resolvePath(playerProfile.Data, path)
	local currentVal = getPath(playerProfile.Data, path)

	if not parent or not key then
		-- fallback: remove top-level
		playerProfile.Data[path] = nil
		print("[DATA REMOVE] ->", path, " = nil")
		return
	end

	-- If table, remove first matching entry
	if type(currentVal) == "table" then
		for i, v in ipairs(currentVal) do
			if v == value then
				table.remove(currentVal, i)
				print("[DATA REMOVE] -> removed from table:", path, "value =", tostring(value))
				return
			end
		end
		print("[DATA REMOVE] -> value not found in table:", path)
		return
	end

	-- If number, subtract
	if type(currentVal) == "number" and type(value) == "number" then
		parent[key] = currentVal - value
		print("[DATA REMOVE] ->", path, "=", tostring(parent[key]))
		return
	end

	-- Otherwise set nil
	parent[key] = nil
	print("[DATA REMOVE] ->", path, " = nil")
end

return DataUtils

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.DataHelper

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SoundList | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SoundList

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Init? | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Init?

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Init?.ModuleScript | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Init?.ModuleScript

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Data? | Enabled: N/A
--------------------------------------------------------------------
local module = {}

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Data?

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone | Enabled: N/A
--------------------------------------------------------------------
--!nocheck

local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Components = script:WaitForChild("Components")
local Dependencies = script:WaitForChild("Dependencies")

local CeiveImOverlay = require(Dependencies:WaitForChild("Debug"):WaitForChild("ImOverlay"))
local Config = require(Dependencies:WaitForChild("Config"))
local Frustum = require(Dependencies:WaitForChild("Frustum"))
local Utilities = require(Dependencies:WaitForChild("Utilities"))
local ImOverlay

local BoneClass = require(Components:WaitForChild("Bone"))
local BoneTreeClass = require(Components:WaitForChild("BoneTree"))
local ColliderObjectClass = require(Components:WaitForChild("Collision"):WaitForChild("ColliderObject"))

local ActorRuntime = Dependencies:WaitForChild("Runtime")

local function CopyPasteAttributes(Object1: BasePart, Object2: BasePart)
	for k, v in Object1:GetAttributes() do
		Object2:SetAttribute(k, v)
	end
end

export type IBoneTree = BoneTreeClass.IBoneTree
export type IBone = BoneClass.IBone
export type IColliderObject = ColliderObjectClass.IColliderObject
export type IColliderTable = ColliderObjectClass.IColliderTable

type ImOverlay = {
	Begin: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: () -> (),
	Text: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> ()
}

type bool = boolean

local SB_INDENT_LOG = Utilities.SB_INDENT_LOG
local SB_UNINDENT_LOG = Utilities.SB_UNINDENT_LOG
-- local SB_ASSERT_CB = Utilities.SB_ASSERT_CB
local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG
local SB_VERBOSE_WARN = Utilities.SB_VERBOSE_WARN
-- local SB_VERBOSE_ERROR = Utilities.SB_VERBOSE_ERROR

--- @class SmartBone
--- Root for all SmartBone objects.

--- @within SmartBone
--- @readonly
--- @prop ID string
--- Unique ID of the root object

--- @within SmartBone
--- @prop BoneTrees table
--- Table of all bone trees under this root

--- @within SmartBone
--- @prop ColliderObjects table
--- Table of all colliders assigned to this root

--- @within SmartBone
--- @prop ShouldDestroy boolean
--- True if the root has no bonetrees, this is already handled by the runtime

local Class = {}
Class.__index = Class

--- @within SmartBone
--- @return SmartBone
function Class.new()
	local self = setmetatable({
		ID = HttpService:GenerateGUID(false),
		BoneTrees = {},
		ColliderObjects = {},
		ShouldDestroy = false,
	}, Class)

	return self
end

-- Private Functions

--- @private
--- @within SmartBone
--- @param BoneTree table
--- @param BoneObject Bone
--- @param ParentIndex number
--- @param HeirarchyLength number
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Used to add a bone to the provided bone tree
function Class:m_AppendBone(BoneTree: IBoneTree, BoneObject: Bone, ParentIndex: number, HeirarchyLength: number)
	local Settings = Utilities.GatherBoneSettings(BoneObject)
	local Bone: IBone = BoneClass.new(BoneObject, BoneTree.Root, BoneTree.RootPart)

	for k, v in Settings do
		-- "Â¬" represents a nil value, this is done so we can delete attributes at runtime.
		Bone[k] = (v ~= "Â¬") and v or nil
	end

	local ParentBone = BoneTree.Bones[ParentIndex]

	if ParentIndex > 0 then
		local BoneLength = (ParentBone.Position - Bone.Position).Magnitude
		Bone.FreeLength = BoneLength
		Bone.Weight = BoneLength * 0.7 -- Why 0.7?
		Bone.HeirarchyLength = HeirarchyLength

		ParentBone.HasChild = true
		--ParentBone.NumberOfChildren += 1
	end

	if HeirarchyLength <= BoneTree.Settings.AnchorDepth then
		SB_VERBOSE_LOG("Anchoring bone")
		Bone.Anchored = true
	end

	Bone.ParentIndex = ParentIndex

	table.insert(BoneTree.Bones, Bone)
end

--- @private
--- @within SmartBone
--- @param RootPart BasePart
--- @param RootBone Bone
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Creates a bone tree from the RootPart and RootBone and then adds all child bones via m_AppendBone
function Class:m_CreateBoneTree(RootPart: BasePart, RootBone: Bone)
	local BoneTree = BoneTreeClass.new(RootBone, RootPart, Utilities.GatherObjectSettings(RootPart))

	SB_VERBOSE_LOG(`Creating bone tree {RootPart.Name}; {RootBone.Name}`)
	SB_INDENT_LOG()

	local function AddChildren(Bone, ParentIndex, HeirarchyLength)
		SB_VERBOSE_LOG(`Adding bone: {Bone.Name}; {ParentIndex}; {HeirarchyLength}`)
		SB_INDENT_LOG()
		local Children = Bone:GetChildren()
		local HasBoneChild = false

		for _, Child in Children do
			if Child:IsA("Bone") then
				self:m_AppendBone(BoneTree, Child, ParentIndex, HeirarchyLength)

				AddChildren(Child, #BoneTree.Bones, HeirarchyLength + 1)
				HasBoneChild = true
			end
		end

		if string.sub(Bone.Name, #Bone.Name - 3, #Bone.Name) == "_end" or string.sub(Bone.Name, #Bone.Name - 4, #Bone.Name) == "_Tail" then
			HasBoneChild = true
		end

		if not HasBoneChild then -- Add tail bone for transform calculations
			SB_VERBOSE_LOG(`Adding tail bone`)
			local Parent = Bone.Parent
			local ParentWorldPosition = Parent:IsA("Bone") and Parent.WorldPosition or Parent.Position

			local Start = Bone.WorldCFrame + (Bone.WorldCFrame.UpVector.Unit * (Bone.WorldPosition - ParentWorldPosition).Magnitude)
			local tailBone = Instance.new("Bone")
			tailBone.Parent = Bone
			tailBone.Name = Bone.Name .. "_Tail"
			tailBone.WorldCFrame = Start

			CopyPasteAttributes(Bone, tailBone)

			self:m_AppendBone(BoneTree, tailBone, #BoneTree.Bones, HeirarchyLength)
		end

		SB_UNINDENT_LOG()
	end

	self:m_AppendBone(BoneTree, RootBone, 0, 0)

	AddChildren(RootBone, 1, 1)

	table.insert(self.BoneTrees, BoneTree)

	SB_UNINDENT_LOG()
end

--- @private
--- @within SmartBone
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Updates the view frustum used for optimization
function Class:m_UpdateViewFrustum()
	-- Should we do frustum checks this frame, depends on config setting
	if shared.FrameCounter % Config.FRUSTUM_FREQ ~= 0 then
		return
	end
	

local a, b, c, d, e, f, g, h, i = Frustum.GetCFrames(workspace.CurrentCamera, Config.FAR_PLANE) -- Hard coded stud limit on any object

	for _, BoneTree in self.BoneTrees do
		
local FakeObject = {
			CFrame = BoneTree.BoundingBoxCFrame,
			Size = BoneTree.BoundingBoxSize,
		}
		BoneTree.InView = Frustum.ObjectInFrustum(FakeObject, a, b, c, d, e, f, g, h, i)
	
end

end

function Class:m_CleanColliders()
	
local DidDestroy = false

	if #self.ColliderObjects ~= 0 then -- Micro optimizations
		for i, ColliderObject in self.ColliderObjects do
			if #ColliderObject.Colliders == 0 or ColliderObject.Destroyed == true then
				SB_VERBOSE_WARN(`Deleting Collider Object`)
				SB_INDENT_LOG()
				ColliderObject:Destroy()
				SB_UNINDENT_LOG()
				table.remove(self.ColliderObjects, i)

				DidDestroy = true
			end
		end
	end

	if not DidDestroy then -- Prevent warning because we left parallel
	
end
end

--- @private
--- @within SmartBone
--- @param BoneTree table
--- @param Index number
--- @param Delta number
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Updates the provided bone tree with all optimizations
function Class:m_UpdateBoneTree(BoneTree: IBoneTree, Index: number, Delta: number)

	
if BoneTree.Destroyed then
		BoneTree:Destroy()
		table.remove(self.BoneTrees, Index)

		return
	end

	BoneTree:PreUpdate(Delta) -- Pre update MUST be called before we call SkipUpdate!

	if not BoneTree.InView or math.floor(BoneTree.UpdateRate) == 0 or not BoneTree.InWorkspace then
		local AlreadySkipped = BoneTree.IsSkippingUpdates

		BoneTree:SkipUpdate()

		if not AlreadySkipped then

			
task.synchronize()
			BoneTree:ApplyTransform()

			SB_VERBOSE_LOG(
				`Skipping BoneTree, InView: {BoneTree.InView}, Update Rate == 0: {math.floor(BoneTree.UpdateRate) == 0}, InWorkspace: {BoneTree.InWorkspace}`
			)
		end

		return
	end
	

for _, ColliderObject in self.ColliderObjects do
		ColliderObject:Step()
	end

	
local UpdateHz = 1 / BoneTree.UpdateRate
	local DidUpdate = false

	BoneTree.AccumulatedDelta += Delta
	while BoneTree.AccumulatedDelta > UpdateHz do
		BoneTree.AccumulatedDelta -= UpdateHz

		DidUpdate = true

		BoneTree:StepPhysics(UpdateHz)
		BoneTree:Constrain(self.ColliderObjects, UpdateHz)
		BoneTree:SolveTransform(UpdateHz)
	end

	
if DidUpdate then
		task.synchronize()
		BoneTree:ApplyTransform()
	end
end

--- @private
--- @within SmartBone
--- @return boolean
--- :::caution Caution:
--- Private Functions can change syntax at any time without warning. Only use these if you're prepared to fix any issues that arise.
--- :::
--- Returns true if the root should be destroyed
function Class:m_CheckDestroy()
	self.ShouldDestroy = false

	if #self.BoneTrees == 0 then
		self.ShouldDestroy = true
		return true
	end

	return false
end

-- Public Functions

--- @within SmartBone
--- @param Object BasePart
--- Loads the provided object
function Class:LoadObject(Object: BasePart)
	local RootAttribute = Object:GetAttribute("Roots")

	if not RootAttribute then
		warn(`[SmartBone2::LoadObject] Cannot load an object with no roots defined {Object.Name}`)
		return
	end

	local RootNames = RootAttribute:split(",")
	local Bones = {}

	-- Gather bones into table indexed with name
	for _, Descendant in Object:QueryDescendants("Bone") do
		if Bones[Descendant.Name] then
			warn(`[SmartBone2::LoadObject] Duplicate bones of name: {Descendant.Name} in RootPart: {Object.Name}`)
			continue
		end

		Bones[Descendant.Name] = Descendant
	end

	-- Create bone trees
	for _, Name in RootNames do
		local RootBone = Bones[Name]
		if not RootBone then
			warn(`[SmartBone2::LoadObject] Couldn't find Root Bone of name: {Name} in RootPart: {Object.Name}`)
			continue
		end

		self:m_CreateBoneTree(Object, RootBone)
	end
end

--- @within SmartBone
--- @param ColliderModule ModuleScript
--- @param Object BasePart
--- Loads the provided collider module onto the provided object
function Class:LoadColliderModule(ColliderModule: ModuleScript, Object: BasePart)
	assert(ColliderModule, "[SmartBone2::LoadColliderModule] No collider module passed in")

	local RawColliderData = require(ColliderModule)
	local ColliderData = HttpService:JSONDecode(RawColliderData)

	local ColliderObject = ColliderObjectClass.new(ColliderData, Object)

	table.insert(self.ColliderObjects, ColliderObject)
end

--- @within SmartBone
--- @param ColliderData table
--- @param Object BasePart
--- Loads the raw collider data onto the provided object
function Class:LoadRawCollider(ColliderData: IColliderTable, Object: BasePart)
	local ColliderObject = ColliderObjectClass.new(ColliderData, Object)

	table.insert(self.ColliderObjects, ColliderObject)
end

--- @within SmartBone
--- Resets all bone trees to their rest position
function Class:SkipUpdate()
	
for _, BoneTree in self.BoneTrees do
		BoneTree:SkipUpdate()
	end

end

--- @within SmartBone
--- @param Delta number
--- Updates all bone trees
function Class:StepBoneTrees(Delta: number)
	if self:m_CheckDestroy() then
		return
	end

	if Delta <= 0 then
		SB_VERBOSE_WARN("DeltaTime is zero or sub zero, not updating.")
		return
	end

	self:m_CleanColliders()
	self:m_UpdateViewFrustum()
	for i, BoneTree in self.BoneTrees do
		self:m_UpdateBoneTree(BoneTree, i, Delta)
	end
end

--- @client
--- @within SmartBone
--- @param DRAW_COLLIDERS boolean
--- @param DRAW_CONTACTS boolean
--- @param DRAW_PHYSICAL_BONE boolean
--- @param DRAW_BONE boolean
--- @param DRAW_AXIS_LIMITS boolean
--- @param DRAW_ROOT_PART boolean
--- @param DRAW_FILL_COLLIDERS boolean
--- @param DRAW_COLLIDER_INFLUENCE boolean
--- @param DRAW_COLLIDER_AWAKE boolean
--- @param DRAW_COLLIDER_BROADPHASE boolean
--- @param DRAW_BOUNDING_BOX boolean
--- @param DRAW_ROTATION_LIMITS boolean
--- @param DRAW_ACCELERATION_INFO boolean
--- Draws the debug gizmos
function Class:DrawDebug(
	DRAW_COLLIDERS: bool,
	DRAW_CONTACTS: bool,
	DRAW_PHYSICAL_BONE: bool,
	DRAW_BONE: bool,
	DRAW_AXIS_LIMITS: bool,
	DRAW_ROOT_PART: bool,
	DRAW_FILL_COLLIDERS: bool,
	DRAW_COLLIDER_INFLUENCE: bool,
	DRAW_COLLIDER_AWAKE: bool,
	DRAW_COLLIDER_BROADPHASE: bool,
	DRAW_BOUNDING_BOX: bool,
	DRAW_ROTATION_LIMITS: bool,
	DRAW_ACCELERATION_INFO: bool
)
	for _, BoneTree in self.BoneTrees do
		BoneTree:DrawDebug(
			DRAW_CONTACTS,
			DRAW_PHYSICAL_BONE,
			DRAW_BONE,
			DRAW_AXIS_LIMITS,
			DRAW_ROOT_PART,
			DRAW_BOUNDING_BOX,
			DRAW_ROTATION_LIMITS,
			DRAW_ACCELERATION_INFO
		)
	end

	if DRAW_COLLIDERS then
		for _, ColliderObject in self.ColliderObjects do
			ColliderObject:DrawDebug(DRAW_FILL_COLLIDERS, DRAW_COLLIDER_INFLUENCE, DRAW_COLLIDER_AWAKE, DRAW_COLLIDER_BROADPHASE)
		end
	end
end

--- @client
--- @within SmartBone
--- @param Overlay ImOverlay
--- Draws the debug overlay
function Class:DrawOverlay(Overlay: ImOverlay)
	if not Config.DEBUG_OVERLAY_ENABLED then
		return
	end

	local INSTANCE_BACKGROUND_COLOR = Color3.new(1.000000, 0.431373, 0.713725)
	local INSTANCE_TEXT_COLOR = Color3.new(1, 1, 1)
	local ROOT_BACKGROUND_COLOR = Color3.new(0.486275, 0.431373, 1.000000)
	local ROOT_TEXT_COLOR = Color3.new(1, 1, 1)

	Overlay.Begin(`SmartBone Instance ID: {self.ID}`, INSTANCE_BACKGROUND_COLOR, INSTANCE_TEXT_COLOR)
	Overlay.Text(`Frame Counter: {shared.FrameCounter}`)

	if Config.DEBUG_OVERLAY_TREE then
		for i, BoneTree in self.BoneTrees do
			if Config.DEBUG_OVERLAY_MAX_TREES > 0 then
				if Config.DEBUG_OVERLAY_TREE_OFFSET + Config.DEBUG_OVERLAY_MAX_TREES <= i then
					break
				end
			end

			if Config.DEBUG_OVERLAY_TREE_OFFSET > i then
				continue
			end

			Overlay.Begin(`Bone Tree {i}`, ROOT_BACKGROUND_COLOR, ROOT_TEXT_COLOR)
			BoneTree:DrawOverlay(Overlay)
			Overlay.End()
		end
	end

	Overlay.End()
end

--- @within SmartBone
--- Destroys the root and all its children
function Class:Destroy()
	SB_VERBOSE_LOG("Deleting SmartBone Object")

	for _, BoneTree in self.BoneTrees do
		BoneTree:Destroy()
	end

	for _, ColliderObject in self.ColliderObjects do
		ColliderObject:Destroy()
	end

	setmetatable(self, nil)
end

--- @client
--- @within SmartBone
--- @return {Stop: () -> ()}
--- Collects all SmartBone objects and SmartBone colliders and starts running physics + collision on them
function Class.Start(): { Stop: () -> () }
	if not RunService:IsClient() then
		warn("Smartbone.Start() can only be called in client context.")
		return
	end

	if Class.Running then
		warn("Cannot call Smartbone.Start() multiple times")
		return
	end

	if Config.STARTUP_PRINT_ENABLED or Config.LOG_VERBOSE then
		print(`SmartBone2 v{Config.VERSION} Starting`)
	end

	Class.Running = true

	local Player = Players.LocalPlayer
	local PlayerScripts = Player:WaitForChild("PlayerScripts")

	local ActorFolder = Instance.new("Folder")
	ActorFolder.Name = "SmartBone-Actors"
	ActorFolder.Parent = PlayerScripts

	local OverlayEvent = Instance.new("BindableEvent")
	OverlayEvent.Name = "OverlayEvent"
	OverlayEvent.Parent = script

	OverlayEvent.Event:Connect(function(Type, ...)
		if not Config.DEBUG_OVERLAY_ENABLED then
			return
		end

		if Type == "Text" then
			ImOverlay:Text(...)
		elseif Type == "Begin" then
			ImOverlay:Begin(...)
		elseif Type == "End" then
			ImOverlay:End()
		end
	end)

	local ObjectToActor: { [BasePart]: Actor } = {}
	local ActorPool: { Actor } = {}

	local function GetActor(): Actor
		return table.remove(ActorPool) or Instance.new("Actor")
	end

	-- Called when an object is "freed", in this case, it's actor needs to be returned to the actor pool
	local function OnObjectFreed(Object: BasePart)
		local Actor = ObjectToActor[Object]
		ObjectToActor[Object] = nil

		if not Actor then
			return
		end

		Actor.Name = "Pooled Actor"

		table.insert(ActorPool, Actor)
	end

	local function GatherColliders()
		local ColliderObjects = {
			Key = {},
			Raw = {},
		}

		for _, Object in CollectionService:GetTagged("SmartCollider") do
			if not Object:IsA("BasePart") then
				continue
			end

			local ColliderKey = Object:GetAttribute("ColliderKey")

			if ColliderKey then
				ColliderKey = tostring(ColliderKey)

				if not ColliderObjects.Key[ColliderKey] then
					ColliderObjects.Key[ColliderKey] = {}
				end

				table.insert(ColliderObjects.Key[ColliderKey], Object)
			end

			SB_VERBOSE_LOG(`Adding collider: {Object.Name}, Collider Key: {ColliderKey}`)
			table.insert(ColliderObjects.Raw, Object)

			if Config.YIELD_ON_COLLIDER_GATHER then
				task.wait()
			end
		end

		return ColliderObjects
	end

	local function SetupObject(Object: BasePart)
		if not Object:IsA("BasePart") then
			return
		end

		SB_VERBOSE_LOG(`Setup Object: {Object.Name}`)
		SB_INDENT_LOG()

		local GlobalColliders = GatherColliders()
		local ColliderKey = Object:GetAttribute("ColliderKey")
		local ColliderObjects

		if ColliderKey then
			ColliderObjects = GlobalColliders.Key[tostring(ColliderKey)] or {}
		else
			ColliderObjects = GlobalColliders.Raw or {}
		end

		local ColliderDescriptions = {} -- {Description, Object}

		for _, ColliderObject in ColliderObjects do
			table.insert(ColliderDescriptions, { Utilities.GetCollider(ColliderObject), ColliderObject })
		end

		local Actor = GetActor()
		local Runtime = ActorRuntime:Clone()

		Runtime.Parent = Actor
		Runtime.Enabled = true

		Actor.Parent = ActorFolder

		ObjectToActor[Object] = Actor

		-- If we dont yield here a bug happens on occasion where the actor doesn't bind quick enough and misses the setup message
		task.wait()

		Actor:SendMessage("Setup", Object, ColliderDescriptions, script)

		-- Don't have to cleanup this connection since it's tied to the instance
		-- Here we handle freeing up the actor attached to the object when it's destroyed
		Object:GetPropertyChangedSignal("Parent"):Connect(function()
			if Object.Parent ~= nil then
				return
			end

			OnObjectFreed(Object)
		end)

		SB_VERBOSE_LOG(`Runtime Started`)
		SB_UNINDENT_LOG()
	end

	local TagAddedConnection = CollectionService:GetInstanceAddedSignal("SmartBone"):Connect(SetupObject)
	local TagRemovedConnection = CollectionService:GetInstanceRemovedSignal("SmartBone"):Connect(OnObjectFreed)

	for _, Object in CollectionService:GetTagged("SmartBone") do
		SetupObject(Object)
	end

	if Config.DEBUG_OVERLAY_ENABLED then
		ImOverlay = CeiveImOverlay.new()

		local PlayerGui = Players.LocalPlayer.PlayerGui

		local DebugGui = Instance.new("ScreenGui")
		DebugGui.Name = "SmartBoneDebugOverlay"
		DebugGui.IgnoreGuiInset = true
		DebugGui.ResetOnSpawn = false
		DebugGui.Parent = PlayerGui

		ImOverlay.BackFrame.Parent = DebugGui

		RunService.RenderStepped:Connect(function()
			ImOverlay:Render()
		end)
	end

	return {
		Stop = function()
			Class.Running = false

			if not Config.RESET_BONE_ON_DESTROY then
				ActorFolder:Destroy()
				return
			end

			for _, Actor: Actor in ActorFolder:GetChildren() do
				Actor:SendMessage("Destroy")
			end

			if TagAddedConnection then
				TagAddedConnection:Disconnect()
			end

			if TagRemovedConnection then
				TagRemovedConnection:Disconnect()
			end
		end,
	}
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris | Enabled: N/A
--------------------------------------------------------------------
--!optimize 2
local Types = require(script.Types)
local Iris = {} :: Types.Iris
local Internal: Types.Internal = require(script.Internal)(Iris)

Iris.Disabled = false

Iris.Args = {}

Iris.Events = {}

function Iris.HasInit()
	return Internal._started
end

function Iris.Init(parentInstance: BasePlayerGui?, eventConnection: (RBXScriptSignal | () -> ())?): Types.Iris
	if parentInstance == nil then
		-- coalesce to playerGui
		parentInstance = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
	end
	if eventConnection == nil then
		-- coalesce to Heartbeat
		eventConnection = game:GetService("RunService").Heartbeat
	end
	Internal.parentInstance = parentInstance :: BasePlayerGui
	assert(Internal._started == false, "Iris.Init can only be called once.")
	Internal._started = true

	Internal._generateRootInstance()
	Internal._generateSelectionImageObject()

	-- spawns the connection to call `Internal._cycle()` within.
	task.spawn(function()
		if typeof(eventConnection) == "function" then
			while true do
				eventConnection()
				Internal._cycle()
			end
		elseif eventConnection ~= nil then
			eventConnection:Connect(function()
				Internal._cycle()
			end)
		end
	end)

	return Iris
end

function Iris:Connect(callback: () -> ()) -- this uses method syntax for no reason.
	if Internal._started == false then
		warn("Iris:Connect() was called before calling Iris.Init(), the connected function will never run")
	end
	table.insert(Internal._connectedFunctions, callback)
end

function Iris.Append(userInstance: GuiObject)
	local parentWidget: Types.Widget = Internal._GetParentWidget()
	local widgetInstanceParent: GuiObject
	if Internal._config.Parent then
		widgetInstanceParent = Internal._config.Parent :: any
	else
		widgetInstanceParent = Internal._widgets[parentWidget.type].ChildAdded(parentWidget, { type = "userInstance" } :: Types.Widget)
	end
	userInstance.Parent = widgetInstanceParent
end

function Iris.End()
	if Internal._stackIndex == 1 then
		error("Callback has too many calls to Iris.End()", 2)
	end
	Internal._IDStack[Internal._stackIndex] = nil
	Internal._stackIndex -= 1
end

--[[
    ------------------------
        [SECTION] Config
    ------------------------
]]

function Iris.ForceRefresh()
	Internal._globalRefreshRequested = true
end

function Iris.UpdateGlobalConfig(deltaStyle: { [string]: any })
	for index, style in deltaStyle do
		Internal._rootConfig[index] = style
	end
	Iris.ForceRefresh()
end

function Iris.PushConfig(deltaStyle: { [string]: any })
	local ID = Iris.State(-1)
	if ID.value == -1 then
		ID:set(deltaStyle)
	else
		-- compare tables
		if Internal._deepCompare(ID:get(), deltaStyle) == false then
			-- refresh local
			Internal._localRefreshActive = true
			ID:set(deltaStyle)
		end
	end

	Internal._config = setmetatable(deltaStyle, {
		__index = Internal._config,
	}) :: any
end

function Iris.PopConfig()
	Internal._localRefreshActive = false
	Internal._config = getmetatable(Internal._config :: any).__index
end

Iris.TemplateConfig = require(script.config)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark) -- use colorDark and sizeDefault themes by default
Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.utilityDefault)
Internal._globalRefreshRequested = false -- UpdatingGlobalConfig changes this to true, leads to Root being generated twice.

--[[
    --------------------
        [SECTION] ID
    --------------------
]]

function Iris.PushId(id: Types.ID)
	assert(typeof(id) == "string", "Iris expected Iris.PushId id to PushId to be a string.")

	Internal._pushedId = tostring(id)
end

function Iris.PopId()
	Internal._pushedId = nil
end

function Iris.SetNextWidgetID(id: Types.ID)
	Internal._nextWidgetId = id
end

--[[
    -----------------------
        [SECTION] State
    -----------------------
]]

function Iris.State(initialValue: any): Types.State
	local ID: Types.ID = Internal._getID(2)
	if Internal._states[ID] then
		return Internal._states[ID]
	end
	Internal._states[ID] = {
		value = initialValue,
		ConnectedWidgets = {},
		ConnectedFunctions = {},
	} :: any
	setmetatable(Internal._states[ID], Internal.StateClass)
	return Internal._states[ID]
end

function Iris.WeakState(initialValue: any): Types.State
	local ID: Types.ID = Internal._getID(2)
	if Internal._states[ID] then
		if #Internal._states[ID].ConnectedWidgets == 0 then
			Internal._states[ID] = nil
		else
			return Internal._states[ID]
		end
	end
	Internal._states[ID] = {
		value = initialValue,
		ConnectedWidgets = {},
		ConnectedFunctions = {},
	} :: any
	setmetatable(Internal._states[ID], Internal.StateClass)
	return Internal._states[ID]
end

function Iris.ComputedState(firstState: Types.State, onChangeCallback: (firstState: any) -> any): Types.State
	local ID: Types.ID = Internal._getID(2)

	if Internal._states[ID] then
		return Internal._states[ID]
	else
		Internal._states[ID] = {
			value = onChangeCallback(firstState.value),
			ConnectedWidgets = {},
			ConnectedFunctions = {},
		} :: any
		firstState:onChange(function(newValue: any)
			Internal._states[ID]:set(onChangeCallback(newValue))
		end)
		setmetatable(Internal._states[ID], Internal.StateClass)
		return Internal._states[ID]
	end
end

Iris.ShowDemoWindow = require(script.demoWindow)(Iris)

require(script.widgets)(Internal)
require(script.API)(Iris)

return Iris

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

local widgets = {} :: Types.WidgetUtility

return function(Iris: Types.Internal)
    widgets.GuiService = game:GetService("GuiService")
    widgets.RunService = game:GetService("RunService")
    widgets.UserInputService = game:GetService("UserInputService")
    widgets.ContextActionService = game:GetService("ContextActionService")
    widgets.TextService = game:GetService("TextService")

    widgets.ICONS = {
        RIGHT_POINTING_TRIANGLE = "rbxasset://textures/DeveloperFramework/button_arrow_right.png",
        DOWN_POINTING_TRIANGLE = "rbxasset://textures/DeveloperFramework/button_arrow_down.png",
        MULTIPLICATION_SIGN = "rbxasset://textures/AnimationEditor/icon_close.png", -- best approximation for a close X which roblox supports, needs to be scaled about 2x
        BOTTOM_RIGHT_CORNER = "\u{25E2}", -- used in window resize icon in bottom right
        CHECK_MARK = "rbxasset://textures/AnimationEditor/icon_checkmark.png",
        ALPHA_BACKGROUND_TEXTURE = "rbxasset://textures/meshPartFallback.png", -- used for color4 alpha
    }

    widgets.GuiInset = widgets.GuiService:GetGuiInset()

    widgets.IS_STUDIO = widgets.RunService:IsStudio()
    function widgets.getTime()
        -- time() always returns 0 in the context of plugins
        if widgets.IS_STUDIO then
            return os.clock()
        else
            return time()
        end
    end

    function widgets.getMouseLocation(): Vector2
        return widgets.UserInputService:GetMouseLocation() - widgets.GuiInset
    end

    function widgets.findBestWindowPosForPopup(refPos: Vector2, size: Vector2, outerMin: Vector2, outerMax: Vector2): Vector2
        local CURSOR_OFFSET_DIST: number = 20

        if refPos.X + size.X + CURSOR_OFFSET_DIST > outerMax.X then
            if refPos.Y + size.Y + CURSOR_OFFSET_DIST > outerMax.Y then
                -- placed to the top
                refPos += Vector2.new(0, -(CURSOR_OFFSET_DIST + size.Y))
            else
                -- placed to the bottom
                refPos += Vector2.new(0, CURSOR_OFFSET_DIST)
            end
        else
            -- placed to the right
            refPos += Vector2.new(CURSOR_OFFSET_DIST, 0)
        end

        local clampedPos: Vector2 = Vector2.new(math.max(math.min(refPos.X + size.X, outerMax.X) - size.X, outerMin.X), math.max(math.min(refPos.Y + size.Y, outerMax.Y) - size.Y, outerMin.Y))
        return clampedPos
    end

    function widgets.isPosInsideRect(pos: Vector2, rectMin: Vector2, rectMax: Vector2): boolean
        return pos.X > rectMin.X and pos.X < rectMax.X and pos.Y > rectMin.Y and pos.Y < rectMax.Y
    end

    function widgets.extend(superClass: Types.WidgetClass, subClass: Types.WidgetClass): Types.WidgetClass
        local newClass: Types.WidgetClass = table.clone(superClass)
        for index: string, value: any in subClass do
            newClass[index] = value
        end
        return newClass
    end

    function widgets.UIPadding(Parent: GuiObject, PxPadding: Vector2): UIPadding
        local UIPaddingInstance: UIPadding = Instance.new("UIPadding")
        UIPaddingInstance.PaddingLeft = UDim.new(0, PxPadding.X)
        UIPaddingInstance.PaddingRight = UDim.new(0, PxPadding.X)
        UIPaddingInstance.PaddingTop = UDim.new(0, PxPadding.Y)
        UIPaddingInstance.PaddingBottom = UDim.new(0, PxPadding.Y)
        UIPaddingInstance.Parent = Parent
        return UIPaddingInstance
    end

    function widgets.UIListLayout(Parent: GuiObject, FillDirection: Enum.FillDirection, Padding: UDim): UIListLayout
        local UIListLayoutInstance: UIListLayout = Instance.new("UIListLayout")
        UIListLayoutInstance.SortOrder = Enum.SortOrder.LayoutOrder
        UIListLayoutInstance.Padding = Padding
        UIListLayoutInstance.FillDirection = FillDirection
        UIListLayoutInstance.Parent = Parent
        return UIListLayoutInstance
    end

    function widgets.UIStroke(Parent: GuiObject, Thickness: number, Color: Color3, Transparency: number): UIStroke
        local UIStrokeInstance: UIStroke = Instance.new("UIStroke")
        UIStrokeInstance.Thickness = Thickness
        UIStrokeInstance.Color = Color
        UIStrokeInstance.Transparency = Transparency
        UIStrokeInstance.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        UIStrokeInstance.LineJoinMode = Enum.LineJoinMode.Round
        UIStrokeInstance.Parent = Parent
        return UIStrokeInstance
    end

    function widgets.UICorner(Parent: GuiObject, PxRounding: number?): UICorner
        local UICornerInstance: UICorner = Instance.new("UICorner")
        UICornerInstance.CornerRadius = UDim.new(PxRounding and 0 or 1, PxRounding or 0)
        UICornerInstance.Parent = Parent
        return UICornerInstance
    end

    function widgets.UISizeConstraint(Parent: GuiObject, MinSize: Vector2?, MaxSize: Vector2?): UISizeConstraint
        local UISizeConstraintInstance: UISizeConstraint = Instance.new("UISizeConstraint")
        UISizeConstraintInstance.MinSize = MinSize or UISizeConstraintInstance.MinSize -- made these optional
        UISizeConstraintInstance.MaxSize = MaxSize or UISizeConstraintInstance.MaxSize
        UISizeConstraintInstance.Parent = Parent
        return UISizeConstraintInstance
    end

    function widgets.UIReference(Parent: GuiObject, Child: GuiObject, Name: string): ObjectValue
        local ObjectValue: ObjectValue = Instance.new("ObjectValue")
        ObjectValue.Name = Name
        ObjectValue.Value = Child
        ObjectValue.Parent = Parent

        return ObjectValue
    end

    function widgets.getScreenSizeForWindow(thisWidget: Types.Widget): Vector2 -- possible parents are GuiBase2d, CoreGui, PlayerGui
        local size: Vector2
        if thisWidget.usesScreenGUI then
            size = thisWidget.Instance.AbsoluteSize
        else
            local rootParent = thisWidget.Instance.Parent
            if rootParent:IsA("GuiBase2d") then
                size = rootParent.AbsoluteSize
            else
                if rootParent.Parent:IsA("GuiBase2d") then
                    size = rootParent.AbsoluteSize
                else
                    size = workspace.CurrentCamera.ViewportSize
                end
            end
        end
        return size
    end

    -- below uses Iris

    local textParams: GetTextBoundsParams = Instance.new("GetTextBoundsParams")
    textParams.Font = Iris._config.TextFont
    textParams.Size = Iris._config.TextSize
    textParams.Width = math.huge
    function widgets.calculateTextSize(text: string, width: number?): Vector2
        if width then
            textParams.Width = width
        end
        textParams.Text = text

        local size: Vector2 = widgets.TextService:GetTextBoundsAsync(textParams)

        if width then
            textParams.Width = math.huge
        end

        return size
    end

    function widgets.applyTextStyle(thisInstance: TextLabel & TextButton & TextBox)
        thisInstance.FontFace = Iris._config.TextFont
        thisInstance.TextSize = Iris._config.TextSize
        thisInstance.TextColor3 = Iris._config.TextColor
        thisInstance.TextTransparency = Iris._config.TextTransparency
        thisInstance.TextXAlignment = Enum.TextXAlignment.Left

        thisInstance.AutoLocalize = false
        thisInstance.RichText = false
    end

    function widgets.applyInteractionHighlights(Button: GuiButton, Highlightee: GuiObject, Colors: { [string]: any })
        local exitedButton: boolean = false
        Button.MouseEnter:Connect(function()
            Highlightee.BackgroundColor3 = Colors.ButtonHoveredColor
            Highlightee.BackgroundTransparency = Colors.ButtonHoveredTransparency

            exitedButton = false
        end)

        Button.MouseLeave:Connect(function()
            Highlightee.BackgroundColor3 = Colors.ButtonColor
            Highlightee.BackgroundTransparency = Colors.ButtonTransparency

            exitedButton = true
        end)

        Button.InputBegan:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) then
                return
            end
            Highlightee.BackgroundColor3 = Colors.ButtonActiveColor
            Highlightee.BackgroundTransparency = Colors.ButtonActiveTransparency
        end)

        Button.InputEnded:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) or exitedButton then
                return
            end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                Highlightee.BackgroundColor3 = Colors.ButtonHoveredColor
                Highlightee.BackgroundTransparency = Colors.ButtonHoveredTransparency
            end
            if input.UserInputType == Enum.UserInputType.Gamepad1 then
                Highlightee.BackgroundColor3 = Colors.ButtonColor
                Highlightee.BackgroundTransparency = Colors.ButtonTransparency
            end
        end)

        Button.SelectionImageObject = Iris.SelectionImageObject
    end

    function widgets.applyInteractionHighlightsWithMultiHighlightee(Button: GuiButton, Highlightees: { { GuiObject | { [string]: Color3 | number } } })
        local exitedButton: boolean = false
        Button.MouseEnter:Connect(function()
            for _, Highlightee in Highlightees do
                Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonHoveredColor
                Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonHoveredTransparency

                exitedButton = false
            end
        end)

        Button.MouseLeave:Connect(function()
            for _, Highlightee in Highlightees do
                Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonColor
                Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonTransparency

                exitedButton = true
            end
        end)

        Button.InputBegan:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) then
                return
            end
            for _, Highlightee in Highlightees do
                Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonActiveColor
                Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonActiveTransparency
            end
        end)

        Button.InputEnded:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) or exitedButton then
                return
            end
            for _, Highlightee in Highlightees do
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonHoveredColor
                    Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonHoveredTransparency
                end
                if input.UserInputType == Enum.UserInputType.Gamepad1 then
                    Highlightee[1].BackgroundColor3 = Highlightee[2].ButtonColor
                    Highlightee[1].BackgroundTransparency = Highlightee[2].ButtonTransparency
                end
            end
        end)

        Button.SelectionImageObject = Iris.SelectionImageObject
    end

    function widgets.applyTextInteractionHighlights(Button: GuiButton, Highlightee: TextLabel & TextButton & TextBox, Colors: { [string]: any })
        local exitedButton = false
        Button.MouseEnter:Connect(function()
            Highlightee.TextColor3 = Colors.ButtonHoveredColor
            Highlightee.TextTransparency = Colors.ButtonHoveredTransparency

            exitedButton = false
        end)

        Button.MouseLeave:Connect(function()
            Highlightee.TextColor3 = Colors.ButtonColor
            Highlightee.TextTransparency = Colors.ButtonTransparency

            exitedButton = true
        end)

        Button.InputBegan:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) then
                return
            end
            Highlightee.TextColor3 = Colors.ButtonActiveColor
            Highlightee.TextTransparency = Colors.ButtonActiveTransparency
        end)

        Button.InputEnded:Connect(function(input: InputObject)
            if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) or exitedButton then
                return
            end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                Highlightee.TextColor3 = Colors.ButtonHoveredColor
                Highlightee.TextTransparency = Colors.ButtonHoveredTransparency
            end
            if input.UserInputType == Enum.UserInputType.Gamepad1 then
                Highlightee.TextColor3 = Colors.ButtonColor
                Highlightee.TextTransparency = Colors.ButtonTransparency
            end
        end)

        Button.SelectionImageObject = Iris.SelectionImageObject
    end

    function widgets.applyFrameStyle(thisInstance: GuiObject, forceNoPadding: boolean?, doubleyNoPadding: boolean?)
        -- padding, border, and rounding
        -- optimized to only use what instances are needed, based on style
        local FramePadding: Vector2 = Iris._config.FramePadding
        local FrameBorderSize: number = Iris._config.FrameBorderSize
        local FrameBorderColor: Color3 = Iris._config.BorderColor
        local FrameBorderTransparency: number = Iris._config.ButtonTransparency
        local FrameRounding: number = Iris._config.FrameRounding

        if FrameBorderSize > 0 and FrameRounding > 0 then
            thisInstance.BorderSizePixel = 0

            local uiStroke: UIStroke = Instance.new("UIStroke")
            uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            uiStroke.LineJoinMode = Enum.LineJoinMode.Round
            uiStroke.Transparency = FrameBorderTransparency
            uiStroke.Thickness = FrameBorderSize
            uiStroke.Color = FrameBorderColor

            widgets.UICorner(thisInstance, FrameRounding)
            uiStroke.Parent = thisInstance

            if not forceNoPadding then
                widgets.UIPadding(thisInstance, Iris._config.FramePadding)
            end
        elseif FrameBorderSize < 1 and FrameRounding > 0 then
            thisInstance.BorderSizePixel = 0

            widgets.UICorner(thisInstance, FrameRounding)
            if not forceNoPadding then
                widgets.UIPadding(thisInstance, Iris._config.FramePadding)
            end
        elseif FrameRounding < 1 then
            thisInstance.BorderSizePixel = FrameBorderSize
            thisInstance.BorderColor3 = FrameBorderColor
            thisInstance.BorderMode = Enum.BorderMode.Inset

            if not forceNoPadding then
                widgets.UIPadding(thisInstance, FramePadding - Vector2.new(FrameBorderSize, FrameBorderSize))
            elseif not doubleyNoPadding then
                widgets.UIPadding(thisInstance, -Vector2.new(FrameBorderSize, FrameBorderSize))
            end
        end
    end

    function widgets.discardState(thisWidget: Types.Widget)
        for _, state: Types.State in thisWidget.state do
            state.ConnectedWidgets[thisWidget.ID] = nil
        end
    end

    widgets.EVENTS = {
        hover = function(pathToHovered: (thisWidget: Types.Widget) -> GuiObject)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local hoveredGuiObject: GuiObject = pathToHovered(thisWidget)
                    hoveredGuiObject.MouseEnter:Connect(function()
                        thisWidget.isHoveredEvent = true
                    end)
                    hoveredGuiObject.MouseLeave:Connect(function()
                        thisWidget.isHoveredEvent = false
                    end)
                    thisWidget.isHoveredEvent = false
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.isHoveredEvent
                end,
            }
        end,

        click = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastClickedTick = -1
                    
clickedGuiObject.MouseButton1Click:Connect(function()
                        thisWidget.lastClickedTick = Iris._cycleTick + 1
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastClickedTick == Iris._cycleTick
                end,
            }
        end,

        rightClick = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastRightClickedTick = -1
                    
clickedGuiObject.MouseButton2Click:Connect(function()
                        thisWidget.lastRightClickedTick = Iris._cycleTick + 1
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastRightClickedTick == Iris._cycleTick
                end,
            }
        end,

        doubleClick = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastClickedTime = -1                    
thisWidget.lastClickedPosition = Vector2.zero
                    thisWidget.lastDoubleClickedTick = -1
                    
clickedGuiObject.MouseButton1Down:Connect(function(x: number, y: number)
                        local currentTime: number = widgets.getTime()
                        local isTimeValid: boolean = currentTime - thisWidget.lastClickedTime < Iris._config.MouseDoubleClickTime
                        if isTimeValid and (Vector2.new(x, y) - thisWidget.lastClickedPosition).Magnitude < Iris._config.MouseDoubleClickMaxDist then
                            thisWidget.lastDoubleClickedTick = Iris._cycleTick + 1
                        else
                            thisWidget.lastClickedTime = currentTime
                            thisWidget.lastClickedPosition = Vector2.new(x, y)
                        end
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastDoubleClickedTick == Iris._cycleTick
                end,
            }
        end,

        ctrlClick = function(pathToClicked: (thisWidget: Types.Widget) -> GuiButton)
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local clickedGuiObject: GuiButton = pathToClicked(thisWidget)
                    thisWidget.lastCtrlClickedTick = -1
                    
clickedGuiObject.MouseButton1Click:Connect(function()
                        if widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
                            thisWidget.lastCtrlClickedTick = Iris._cycleTick + 1
                        end
                    end)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastCtrlClickedTick == Iris._cycleTick
                end,
            }
        end,

        shortcut = function(pathToKeys: (thisWidget: Types.Widget) -> (Enum.KeyCode, Enum.ModifierKey))
            return {
                ["Init"] = function(thisWidget: Types.Widget)
                    local keycode: Enum.KeyCode, modifier: Enum.ModifierKey = pathToKeys(thisWidget)
                    thisWidget.lastShortcutTick = -1
                    
widgets.ContextActionService:BindAction(thisWidget.ID, function(_, inputState: Enum.UserInputState, inputObject: InputObject)
                        if inputState == Enum.UserInputState.Begin then
                            if inputObject:IsModifierKeyDown(modifier) then
                                thisWidget.lastShortcutTick = Iris._cycleTick + 1
                            end
                        end
                    end, false, keycode)
                end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastShortcutTick == Iris._cycleTick
                end,
            }
        end,
    }

    require(script.Root)(Iris, widgets)
    require(script.Window)(Iris, widgets)

    require(script.Menu)(Iris, widgets)

    require(script.Format)(Iris, widgets)

    require(script.Text)(Iris, widgets)
    require(script.Button)(Iris, widgets)
    require(script.Checkbox)(Iris, widgets)
    require(script.RadioButton)(Iris, widgets)

    require(script.Tree)(Iris, widgets)

    require(script.Input)(Iris, widgets)
    require(script.Combo)(Iris, widgets)

    require(script.Table)(Iris, widgets)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Button | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local abstractButton = {
        hasState = false,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
        },
        Events = {
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["rightClicked"] = widgets.EVENTS.rightClick(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["doubleClicked"] = widgets.EVENTS.doubleClick(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["ctrlClicked"] = widgets.EVENTS.ctrlClick(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.Widget): TextButton
            local Button: TextButton = Instance.new("TextButton")
            Button.Size = UDim2.fromOffset(0, 0)
            Button.BackgroundColor3 = Iris._config.ButtonColor
            Button.BackgroundTransparency = Iris._config.ButtonTransparency
            Button.AutoButtonColor = false

            widgets.applyTextStyle(Button)
            Button.AutomaticSize = Enum.AutomaticSize.XY

            widgets.applyFrameStyle(Button)

            widgets.applyInteractionHighlights(Button, Button, {
                ButtonColor = Iris._config.ButtonColor,
                ButtonTransparency = Iris._config.ButtonTransparency,
                ButtonHoveredColor = Iris._config.ButtonHoveredColor,
                ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
                ButtonActiveColor = Iris._config.ButtonActiveColor,
                ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
            })

            Button.ZIndex = thisWidget.ZIndex
            Button.LayoutOrder = thisWidget.ZIndex

            return Button
        end,
        Update = function(thisWidget: Types.Widget)
            local Button = thisWidget.Instance :: TextButton
            Button.Text = thisWidget.arguments.Text or "Button"
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass
    widgets.abstractButton = abstractButton

    Iris.WidgetConstructor(
        "Button",
        widgets.extend(abstractButton, {
            Generate = function(thisWidget: Types.Widget): TextButton
                local Button: TextButton = abstractButton.Generate(thisWidget)
                Button.Name = "Iris_Button"

                return Button
            end,
        } :: Types.WidgetClass)
    )

    Iris.WidgetConstructor(
        "SmallButton",
        widgets.extend(abstractButton, {
            Generate = function(thisWidget: Types.Widget): TextButton
                local SmallButton = abstractButton.Generate(thisWidget) :: TextButton
                SmallButton.Name = "Iris_SmallButton"

                local uiPadding: UIPadding = SmallButton.UIPadding
                uiPadding.PaddingLeft = UDim.new(0, 2)
                uiPadding.PaddingRight = UDim.new(0, 2)
                uiPadding.PaddingTop = UDim.new(0, 0)
                uiPadding.PaddingBottom = UDim.new(0, 0)

                return SmallButton
            end,
        } :: Types.WidgetClass)
    )
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Button

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Checkbox | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    Iris.WidgetConstructor("Checkbox", {
        hasState = true,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
        },
        Events = {
            ["checked"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastCheckedTick == Iris._cycleTick
                end,
            },
            ["unchecked"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget): boolean
                    return thisWidget.lastUncheckedTick == Iris._cycleTick
                end,
            },
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget): GuiObject
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.Widget): TextButton
            local Checkbox: TextButton = Instance.new("TextButton")
            Checkbox.Name = "Iris_Checkbox"
            Checkbox.BackgroundTransparency = 1
            Checkbox.BorderSizePixel = 0
            Checkbox.Size = UDim2.fromOffset(0, 0)
            Checkbox.Text = ""
            Checkbox.AutomaticSize = Enum.AutomaticSize.XY
            Checkbox.ZIndex = thisWidget.ZIndex
            Checkbox.AutoButtonColor = false
            Checkbox.LayoutOrder = thisWidget.ZIndex

            local checkboxSize: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

            local CheckboxBox: Frame = Instance.new("Frame")
            CheckboxBox.Name = "CheckboxBox"
            CheckboxBox.Size = UDim2.fromOffset(checkboxSize, checkboxSize)
            CheckboxBox.BackgroundColor3 = Iris._config.FrameBgColor
            CheckboxBox.BackgroundTransparency = Iris._config.FrameBgTransparency
            CheckboxBox.ZIndex = thisWidget.ZIndex + 1
            CheckboxBox.LayoutOrder = thisWidget.ZIndex + 1
            widgets.applyFrameStyle(CheckboxBox, true)

            widgets.applyInteractionHighlights(Checkbox, CheckboxBox, {
                ButtonColor = Iris._config.FrameBgColor,
                ButtonTransparency = Iris._config.FrameBgTransparency,
                ButtonHoveredColor = Iris._config.FrameBgHoveredColor,
                ButtonHoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                ButtonActiveColor = Iris._config.FrameBgActiveColor,
                ButtonActiveTransparency = Iris._config.FrameBgActiveTransparency,
            })

            CheckboxBox.Parent = Checkbox

            local padding: number = math.ceil(checkboxSize * 0.1)
            local checkmarkSize: number = checkboxSize - 2 * padding

            local Checkmark: ImageLabel = Instance.new("ImageLabel")
            Checkmark.Name = "Checkmark"
            Checkmark.Size = UDim2.fromOffset(checkmarkSize, checkmarkSize)
            Checkmark.Position = UDim2.fromOffset(padding, padding)
            Checkmark.BackgroundTransparency = 1
            Checkmark.ImageColor3 = Iris._config.CheckMarkColor
            Checkmark.ImageTransparency = Iris._config.CheckMarkTransparency
            Checkmark.ScaleType = Enum.ScaleType.Fit
            Checkmark.ZIndex = thisWidget.ZIndex + 2
            Checkmark.LayoutOrder = thisWidget.ZIndex + 2

            Checkmark.Parent = Checkbox

            Checkbox.MouseButton1Click:Connect(function()
                local wasChecked: boolean = thisWidget.state.isChecked.value
                thisWidget.state.isChecked:set(not wasChecked)
            end)

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            widgets.applyTextStyle(TextLabel)
            TextLabel.AnchorPoint = Vector2.new(0, 0.5)
            TextLabel.Position = UDim2.new(0, checkboxSize + Iris._config.ItemInnerSpacing.X, 0.5, 0)
            TextLabel.ZIndex = thisWidget.ZIndex + 1
            TextLabel.LayoutOrder = thisWidget.ZIndex + 1
            TextLabel.AutomaticSize = Enum.AutomaticSize.XY
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0
            TextLabel.Parent = Checkbox

            return Checkbox
        end,
        Update = function(thisWidget: Types.Widget)
            local Checkbox = thisWidget.Instance :: TextButton
            Checkbox.TextLabel.Text = thisWidget.arguments.Text or "Checkbox"
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
        GenerateState = function(thisWidget: Types.Widget)
            if thisWidget.state.isChecked == nil then
                thisWidget.state.isChecked = Iris._widgetState(thisWidget, "checked", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Widget)
            local Checkbox = thisWidget.Instance :: TextButton
            local Checkmark: ImageLabel = Checkbox.Checkmark
            if thisWidget.state.isChecked.value then
                Checkmark.Image = widgets.ICONS.CHECK_MARK
                thisWidget.lastCheckedTick = Iris._cycleTick + 1
            else
                Checkmark.Image = ""
                thisWidget.lastUncheckedTick = Iris._cycleTick + 1
            end
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Checkbox

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Combo | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local function onSelectionChange(thisWidget)
        if type(thisWidget.state.index.value) == "boolean" then
            thisWidget.state.index:set(not thisWidget.state.index.value)
        else
            thisWidget.state.index:set(thisWidget.arguments.Index)
        end
    end

    Iris.WidgetConstructor("Selectable", {
        hasState = true,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
            ["Index"] = 2,
            ["NoClick"] = 3,
        },
        Events = {
            ["selected"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastSelectedTick == Iris._cycleTick
                end,
            },
            ["unselected"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastUnselectedTick == Iris._cycleTick
                end,
            },
            ["active"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.state.index.value == thisWidget.arguments.Index
                end,
            },
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["rightClicked"] = widgets.EVENTS.rightClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["doubleClicked"] = widgets.EVENTS.doubleClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["ctrlClicked"] = widgets.EVENTS.ctrlClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
        },
        Generate = function(thisWidget: Types.Widget): Frame
            local Selectable: Frame = Instance.new("Frame")
            Selectable.Name = "Iris_Selectable"
            Selectable.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, Iris._config.TextSize))
            Selectable.AutomaticSize = Enum.AutomaticSize.None
            Selectable.BackgroundTransparency = 1
            Selectable.BorderSizePixel = 0
            Selectable.ZIndex = thisWidget.ZIndex
            Selectable.LayoutOrder = thisWidget.ZIndex

            local SelectableButton: TextButton = Instance.new("TextButton")
            SelectableButton.Name = "SelectableButton"
            SelectableButton.Size = UDim2.new(1, 0, 1, Iris._config.ItemSpacing.Y - 1)
            SelectableButton.Position = UDim2.fromOffset(0, -bit32.rshift(Iris._config.ItemSpacing.Y, 1))
            SelectableButton.BackgroundColor3 = Iris._config.HeaderColor
            SelectableButton.ZIndex = thisWidget.ZIndex + 1
            SelectableButton.LayoutOrder = thisWidget.ZIndex + 1

            widgets.applyFrameStyle(SelectableButton)
            widgets.applyTextStyle(SelectableButton)

            thisWidget.ButtonColors = {
                ButtonColor = Iris._config.HeaderColor,
                ButtonTransparency = 1,
                ButtonHoveredColor = Iris._config.HeaderHoveredColor,
                ButtonHoveredTransparency = Iris._config.HeaderHoveredTransparency,
                ButtonActiveColor = Iris._config.HeaderActiveColor,
                ButtonActiveTransparency = Iris._config.HeaderActiveTransparency,
            }

            widgets.applyInteractionHighlights(SelectableButton, SelectableButton, thisWidget.ButtonColors)

            SelectableButton.MouseButton1Click:Connect(function()
                if thisWidget.arguments.NoClick ~= true then
                    onSelectionChange(thisWidget)
                end
            end)

            SelectableButton.Parent = Selectable

            return Selectable
        end,
        Update = function(thisWidget: Types.Widget)
            local Selectable = thisWidget.Instance :: Frame
            local SelectableButton: TextButton = Selectable.SelectableButton
            SelectableButton.Text = thisWidget.arguments.Text or "Selectable"
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
        GenerateState = function(thisWidget: Types.Widget)
            if thisWidget.state.index == nil then
                if thisWidget.arguments.Index ~= nil then
                    error("a shared state index is required for Selectables with an Index argument", 5)
                end
                thisWidget.state.index = Iris._widgetState(thisWidget, "index", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Widget)
            local Selectable = thisWidget.Instance :: Frame
            local SelectableButton: TextButton = Selectable.SelectableButton
            if thisWidget.state.index.value == (thisWidget.arguments.Index or true) then
                thisWidget.ButtonColors.ButtonTransparency = Iris._config.HeaderTransparency
                SelectableButton.BackgroundTransparency = Iris._config.HeaderTransparency
                thisWidget.lastSelectedTick = Iris._cycleTick + 1
            else
                thisWidget.ButtonColors.ButtonTransparency = 1
                SelectableButton.BackgroundTransparency = 1
                thisWidget.lastUnselectedTick = Iris._cycleTick + 1
            end
        end,
    } :: Types.WidgetClass)

    local AnyOpenedCombo = false
    local ComboOpenedTick = -1    
local OpenedCombo

    local function UpdateChildContainerTransform(thisWidget: Types.Widget)
        local Iris_Combo = thisWidget.Instance :: Frame
        local PreviewContainer = Iris_Combo.PreviewContainer :: TextButton
        local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
        local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame

        local labelHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

        local borderWidth: number = Iris._config.PopupBorderSize
        local ChildContainerHeight: number = (labelHeight * math.min(thisWidget.ComboChildrenHeight, 8) - 2 * borderWidth) + (3 * Iris._config.FramePadding.Y)
        local ChildContainerWidth: UDim = UDim.new(0, PreviewContainer.AbsoluteSize.X - 2 * borderWidth)
        ChildContainer.Size = UDim2.new(ChildContainerWidth, UDim.new(0, ChildContainerHeight))

        local ScreenSize: Vector2 = ChildContainer.Parent.AbsoluteSize

        if PreviewLabel.AbsolutePosition.Y + labelHeight + ChildContainerHeight > ScreenSize.Y then
            -- too large to fit below the Combo, so is placed above
            ChildContainer.Position = UDim2.new(0, PreviewLabel.AbsolutePosition.X + borderWidth, 0, PreviewLabel.AbsolutePosition.Y - borderWidth - ChildContainerHeight)
        else
            ChildContainer.Position = UDim2.new(0, PreviewLabel.AbsolutePosition.X + borderWidth, 0, PreviewLabel.AbsolutePosition.Y + labelHeight + borderWidth)
        end
    end

    widgets.UserInputService.InputBegan:Connect(function(inputObject: InputObject)
        if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and inputObject.UserInputType ~= Enum.UserInputType.MouseButton2 and inputObject.UserInputType ~= Enum.UserInputType.Touch then
            return
        end
        if AnyOpenedCombo == false then
            return
        end
        if ComboOpenedTick == Iris._cycleTick then
            return
        end
        local MouseLocation: Vector2 = widgets.getMouseLocation()
        local ChildContainer = OpenedCombo.ChildContainer
        local rectMin: Vector2 = ChildContainer.AbsolutePosition - Vector2.new(0, OpenedCombo.LabelHeight)
        local rectMax: Vector2 = ChildContainer.AbsolutePosition + ChildContainer.AbsoluteSize
        if not widgets.isPosInsideRect(MouseLocation, rectMin, rectMax) then
            OpenedCombo.state.isOpened:set(false)
        end
    end)

    Iris.WidgetConstructor("Combo", {
        hasState = true,
        hasChildren = true,
        Args = {
            ["Text"] = 1,
            ["NoButton"] = 2,
            ["NoPreview"] = 3,
        },
        Events = {
            ["opened"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastOpenedTick == Iris._cycleTick
                end,
            },
            ["closed"] = {
                ["Init"] = function(_thisWidget: Types.Widget) end,
                ["Get"] = function(thisWidget: Types.Widget)
                    return thisWidget.lastClosedTick == Iris._cycleTick
                end,
            },
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.Widget)
            local frameHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y
            thisWidget.ComboChildrenHeight = 0

            local Combo: Frame = Instance.new("Frame")
            Combo.Name = "Iris_Combo"
            Combo.Size = UDim2.fromScale(1, 0)
            Combo.AutomaticSize = Enum.AutomaticSize.Y
            Combo.BackgroundTransparency = 1
            Combo.BorderSizePixel = 0
            Combo.ZIndex = thisWidget.ZIndex
            Combo.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Combo, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.Y + 1))

            local PreviewContainer: TextButton = Instance.new("TextButton")
            PreviewContainer.Name = "PreviewContainer"
            PreviewContainer.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
            PreviewContainer.AutomaticSize = Enum.AutomaticSize.Y
            PreviewContainer.BackgroundTransparency = 1
            PreviewContainer.Text = ""
            PreviewContainer.ZIndex = thisWidget.ZIndex + 2
            PreviewContainer.LayoutOrder = thisWidget.ZIndex + 2
            PreviewContainer.AutoButtonColor = false

            widgets.applyFrameStyle(PreviewContainer, true, true)
            widgets.UIListLayout(PreviewContainer, Enum.FillDirection.Horizontal, UDim.new(0, 0))

            PreviewContainer.Parent = Combo

            local PreviewLabel: TextLabel = Instance.new("TextLabel")
            PreviewLabel.Name = "PreviewLabel"
            PreviewLabel.Size = UDim2.new(1, 0, 0, 0)
            PreviewLabel.AutomaticSize = Enum.AutomaticSize.Y
            PreviewLabel.BackgroundColor3 = Iris._config.FrameBgColor
            PreviewLabel.BackgroundTransparency = Iris._config.FrameBgTransparency
            PreviewLabel.BorderSizePixel = 0
            PreviewLabel.ZIndex = thisWidget.ZIndex + 3
            PreviewLabel.LayoutOrder = thisWidget.ZIndex + 3

            widgets.applyTextStyle(PreviewLabel)
            widgets.UIPadding(PreviewLabel, Iris._config.FramePadding)

            PreviewLabel.Parent = PreviewContainer

            local DropdownButton: TextLabel = Instance.new("TextLabel")
            DropdownButton.Name = "DropdownButton"
            DropdownButton.Size = UDim2.new(0, frameHeight, 0, frameHeight)
            DropdownButton.BorderSizePixel = 0
            DropdownButton.BackgroundColor3 = Iris._config.ButtonColor
            DropdownButton.BackgroundTransparency = Iris._config.ButtonTransparency
            DropdownButton.Text = ""
            DropdownButton.ZIndex = thisWidget.ZIndex + 4
            DropdownButton.LayoutOrder = thisWidget.ZIndex + 4

            local padding: number = math.round(frameHeight * 0.2)
            local dropdownSize: number = frameHeight - 2 * padding

            local Dropdown: ImageLabel = Instance.new("ImageLabel")
            Dropdown.Name = "Dropdown"
            Dropdown.Size = UDim2.fromOffset(dropdownSize, dropdownSize)
            Dropdown.Position = UDim2.fromOffset(padding, padding)
            Dropdown.BackgroundTransparency = 1
            Dropdown.BorderSizePixel = 0
            Dropdown.ImageColor3 = Iris._config.TextColor
            Dropdown.ImageTransparency = Iris._config.TextTransparency
            Dropdown.ZIndex = thisWidget.ZIndex + 5
            Dropdown.LayoutOrder = thisWidget.ZIndex + 5

            Dropdown.Parent = DropdownButton
            DropdownButton.Parent = PreviewContainer

            -- for some reason ImGui Combo has no highlights for Active, only hovered.
            -- so this deviates from ImGui, but its a good UX change
            widgets.applyInteractionHighlightsWithMultiHighlightee(PreviewContainer, {
                {
                    PreviewLabel,
                    {
                        ButtonColor = Iris._config.FrameBgColor,
                        ButtonTransparency = Iris._config.FrameBgTransparency,
                        ButtonHoveredColor = Iris._config.FrameBgHoveredColor,
                        ButtonHoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                        ButtonActiveColor = Iris._config.FrameBgActiveColor,
                        ButtonActiveTransparency = Iris._config.FrameBgActiveTransparency,
                    },
                },
                {
                    DropdownButton,
                    {
                        ButtonColor = Iris._config.ButtonColor,
                        ButtonTransparency = Iris._config.ButtonTransparency,
                        ButtonHoveredColor = Iris._config.ButtonHoveredColor,
                        ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
                        -- Use hovered for active
                        ButtonActiveColor = Iris._config.ButtonHoveredColor,
                        ButtonActiveTransparency = Iris._config.ButtonHoveredColor,
                    },
                },
            })

            PreviewContainer.InputBegan:Connect(function(inputObject)
                if AnyOpenedCombo and OpenedCombo ~= thisWidget then
                    return
                end
                if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
                    thisWidget.state.isOpened:set(not thisWidget.state.isOpened.value)
                end
            end)

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            TextLabel.Size = UDim2.fromOffset(0, frameHeight)
            TextLabel.AutomaticSize = Enum.AutomaticSize.X
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0
            TextLabel.ZIndex = thisWidget.ZIndex + 5
            TextLabel.LayoutOrder = thisWidget.ZIndex + 5

            widgets.applyTextStyle(TextLabel)

            TextLabel.Parent = Combo

            local ChildContainer: ScrollingFrame = Instance.new("ScrollingFrame")
            ChildContainer.Name = "ChildContainer"
            ChildContainer.BackgroundColor3 = Iris._config.WindowBgColor
            ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency
            ChildContainer.BorderSizePixel = 0

            ChildContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
            ChildContainer.ScrollBarImageTransparency = Iris._config.ScrollbarGrabTransparency
            ChildContainer.ScrollBarImageColor3 = Iris._config.ScrollbarGrabColor
            ChildContainer.ScrollBarThickness = Iris._config.ScrollbarSize
            ChildContainer.CanvasSize = UDim2.fromScale(0, 0)
            ChildContainer.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar

            -- appear over everything else
            ChildContainer.ZIndex = thisWidget.ZIndex + 6
            ChildContainer.LayoutOrder = thisWidget.ZIndex + 6
            ChildContainer.ClipsDescendants = true

            -- Unfortunatley, ScrollingFrame does not work with UICorner
            -- if Iris._config.PopupRounding > 0 then
            --     widgets.UICorner(ChildContainer, Iris._config.PopupRounding)
            -- end

            widgets.UIStroke(ChildContainer, Iris._config.WindowBorderSize, Iris._config.BorderColor, Iris._config.BorderTransparency)
            widgets.UIPadding(ChildContainer, Vector2.new(2, 2 * Iris._config.FramePadding.Y))

            local ChildContainerUIListLayout: UIListLayout = widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
            ChildContainerUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top

            local RootPopupScreenGui = Iris._rootInstance and Iris._rootInstance:WaitForChild("PopupScreenGui") :: GuiObject
            ChildContainer.Parent = RootPopupScreenGui
            thisWidget.ChildContainer = ChildContainer

            return Combo
        end,
        Update = function(thisWidget: Types.Widget)
            local Iris_Combo = thisWidget.Instance :: Frame
            local PreviewContainer = Iris_Combo.PreviewContainer :: TextButton
            local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
            local DropdownButton: TextLabel = PreviewContainer.DropdownButton
            local TextLabel: TextLabel = Iris_Combo.TextLabel

            TextLabel.Text = thisWidget.arguments.Text or "Combo"

            if thisWidget.arguments.NoButton then
                DropdownButton.Visible = false
                PreviewLabel.Size = UDim2.new(1, 0, 0, 0)
            else
                DropdownButton.Visible = true
                local DropdownButtonSize = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y
                PreviewLabel.Size = UDim2.new(1, -DropdownButtonSize, 0, 0)
            end

            if thisWidget.arguments.NoPreview then
                PreviewLabel.Visible = false
                PreviewContainer.Size = UDim2.new(0, 0, 0, 0)
                PreviewContainer.AutomaticSize = Enum.AutomaticSize.X
            else
                PreviewLabel.Visible = true
                PreviewContainer.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
                PreviewContainer.AutomaticSize = Enum.AutomaticSize.Y
            end
        end,
        ChildAdded = function(thisWidget: Types.Widget, thisChild: Types.Widget)
            -- default to largest size if there are widgets other than selectables inside the combo
            if thisChild.type ~= "Selectable" then
                thisWidget.ComboChildrenHeight += 10
            else
                thisWidget.ComboChildrenHeight += 1
            end
            UpdateChildContainerTransform(thisWidget)
            return thisWidget.ChildContainer
        end,
        ChildDiscarded = function(thisWidget: Types.Widget, thisChild: Types.Widget)
            if thisChild.type ~= "Selectable" then
                thisWidget.ComboChildrenHeight -= 10
            else
                thisWidget.ComboChildrenHeight -= 1
            end
        end,
        GenerateState = function(thisWidget: Types.Widget)
            if thisWidget.state.index == nil then
                thisWidget.state.index = Iris._widgetState(thisWidget, "index", "No Selection")
            end
            thisWidget.state.index:onChange(function()
                if thisWidget.state.isOpened.value then
                    thisWidget.state.isOpened:set(false)
                end
            end)
            if thisWidget.state.isOpened == nil then
                thisWidget.state.isOpened = Iris._widgetState(thisWidget, "isOpened", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Widget)
            local Iris_Combo = thisWidget.Instance :: Frame
            local PreviewContainer = Iris_Combo.PreviewContainer :: TextButton
            local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
            local DropdownButton = PreviewContainer.DropdownButton :: TextLabel
            local Dropdown: ImageLabel = DropdownButton.Dropdown
            local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame

            if thisWidget.state.isOpened.value then
                AnyOpenedCombo = true
                OpenedCombo = thisWidget
                ComboOpenedTick = Iris._cycleTick
                thisWidget.lastOpenedTick = Iris._cycleTick + 1

                -- ImGui also does not do this, and the Arrow is always facing down
                Dropdown.Image = widgets.ICONS.RIGHT_POINTING_TRIANGLE
                ChildContainer.Visible = true

                UpdateChildContainerTransform(thisWidget)
            else
                if AnyOpenedCombo then
                    AnyOpenedCombo = false
                    OpenedCombo = nil
                    thisWidget.lastClosedTick = Iris._cycleTick + 1
                end
                Dropdown.Image = widgets.ICONS.DOWN_POINTING_TRIANGLE
                ChildContainer.Visible = false
            end

            local stateIndex: any = thisWidget.state.index.value
            PreviewLabel.Text = if typeof(stateIndex) == "EnumItem" then stateIndex.Name else tostring(stateIndex)
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Combo

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Format | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    Iris.WidgetConstructor("Separator", {
        hasState = false,
        hasChildren = false,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local Separator: Frame = Instance.new("Frame")
            Separator.Name = "Iris_Separator"
            Separator.BackgroundColor3 = Iris._config.SeparatorColor
            Separator.BackgroundTransparency = Iris._config.SeparatorTransparency
            Separator.BorderSizePixel = 0
            if thisWidget.parentWidget.type == "SameLine" then
                Separator.Size = UDim2.new(0, 1, 1, 0)
            else
                Separator.Size = UDim2.new(1, 0, 0, 1)
            end
            Separator.ZIndex = thisWidget.ZIndex
            Separator.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Separator, Enum.FillDirection.Vertical, UDim.new(0, 0))
            -- this is to prevent a bug of AutomaticLayout edge case when its parent has automaticLayout enabled

            return Separator
        end,
        Update = function(_thisWidget: Types.Widget) end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass)

    Iris.WidgetConstructor("Indent", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
        },
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local Indent: Frame = Instance.new("Frame")
            Indent.Name = "Iris_Indent"
            Indent.BackgroundTransparency = 1
            Indent.BorderSizePixel = 0
            Indent.Size = UDim2.fromScale(1, 0)
            Indent.AutomaticSize = Enum.AutomaticSize.Y
            Indent.ZIndex = thisWidget.ZIndex
            Indent.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Indent, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
            widgets.UIPadding(Indent, Vector2.new(0, 0))

            return Indent
        end,
        Update = function(thisWidget: Types.Widget)
            local Indent = thisWidget.Instance :: Frame

            local indentWidth: number
            if thisWidget.arguments.Width then
                indentWidth = thisWidget.arguments.Width
            else
                indentWidth = Iris._config.IndentSpacing
            end
            Indent.UIPadding.PaddingLeft = UDim.new(0, indentWidth)
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Widget, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    Iris.WidgetConstructor("SameLine", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
            ["VerticalAlignment"] = 2,
        },
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local SameLine: Frame = Instance.new("Frame")
            SameLine.Name = "Iris_SameLine"
            SameLine.BackgroundTransparency = 1
            SameLine.BorderSizePixel = 0
            SameLine.Size = UDim2.fromScale(1, 0)
            SameLine.AutomaticSize = Enum.AutomaticSize.Y
            SameLine.ZIndex = thisWidget.ZIndex
            SameLine.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(SameLine, Enum.FillDirection.Horizontal, UDim.new(0, 0))

            return SameLine
        end,
        Update = function(thisWidget: Types.Widget)
            local Sameline = thisWidget.Instance :: Frame
            local uiListLayout: UIListLayout = Sameline.UIListLayout
            local itemWidth: number
            if thisWidget.arguments.Width then
                itemWidth = thisWidget.arguments.Width
            else
                itemWidth = Iris._config.ItemSpacing.X
            end
            uiListLayout.Padding = UDim.new(0, itemWidth)
            if thisWidget.arguments.VerticalAlignment then
                uiListLayout.VerticalAlignment = thisWidget.arguments.VerticalAlignment
            else
                uiListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            end
        end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Widget, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    Iris.WidgetConstructor("Group", {
        hasState = false,
        hasChildren = true,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Widget): Frame
            local Group: Frame = Instance.new("Frame")
            Group.Name = "Iris_Group"
            Group.BackgroundTransparency = 1
            Group.BorderSizePixel = 0
            Group.Size = UDim2.fromOffset(0, 0)
            Group.AutomaticSize = Enum.AutomaticSize.XY
            Group.ZIndex = thisWidget.ZIndex
            Group.LayoutOrder = thisWidget.ZIndex
            Group.ClipsDescendants = true

            widgets.UIListLayout(Group, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.X))

            return Group
        end,
        Update = function(_thisWidget: Types.Widget) end,
        Discard = function(thisWidget: Types.Widget)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Widget, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Format

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Input | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
	local numberChanged = {
		["Init"] = function(_thisWidget: Types.Widget) end,
		["Get"] = function(thisWidget: Types.Widget)
			return thisWidget.lastNumberChangedTick == Iris._cycleTick
		end,
	}

	local function getValueByIndex(value: Types.InputDataType, index: number, arguments: Types.Arguments): number
		if typeof(value) == "number" then
			return value
		elseif typeof(value) == "Vector2" then
			if index == 1 then
				return value.X
			elseif index == 2 then
				return value.Y
			end
		elseif typeof(value) == "Vector3" then
			if index == 1 then
				return value.X
			elseif index == 2 then
				return value.Y
			elseif index == 3 then
				return value.Z
			end
		elseif typeof(value) == "UDim" then
			if index == 1 then
				return value.Scale
			elseif index == 2 then
				return value.Offset
			end
		elseif typeof(value) == "UDim2" then
			if index == 1 then
				return value.X.Scale
			elseif index == 2 then
				return value.X.Offset
			elseif index == 3 then
				return value.Y.Scale
			elseif index == 4 then
				return value.Y.Offset
			end
		elseif typeof(value) == "Color3" then
			local color: { number } = arguments.UseHSV and { value:ToHSV() } or { value.R, value.G, value.B }
			if index == 1 then
				return color[1]
			elseif index == 2 then
				return color[2]
			elseif index == 3 then
				return color[3]
			end
		elseif typeof(value) == "Rect" then
			if index == 1 then
				return value.Min.X
			elseif index == 2 then
				return value.Min.Y
			elseif index == 3 then
				return value.Max.X
			elseif index == 4 then
				return value.Max.Y
			end
		elseif typeof(value) == "table" then
			return value[index]
		end

		error(`Incorrect datatype or value: {value} {typeof(value)} {index}`)
	end

	local function updateValueByIndex(value: Types.InputDataType, index: number, newValue: number, arguments: Types.Arguments): Types.InputDataType
		if typeof(value) == "number" then
			return newValue
		elseif typeof(value) == "Vector2" then
			if index == 1 then
				return Vector2.new(newValue, value.Y)
			elseif index == 2 then
				return Vector2.new(value.X, newValue)
			end
		elseif typeof(value) == "Vector3" then
			if index == 1 then
				return Vector3.new(newValue, value.Y, value.Z)
			elseif index == 2 then
				return Vector3.new(value.X, newValue, value.Z)
			elseif index == 3 then
				return Vector3.new(value.X, value.Y, newValue)
			end
		elseif typeof(value) == "UDim" then
			if index == 1 then
				return UDim.new(newValue, value.Offset)
			elseif index == 2 then
				return UDim.new(value.Scale, newValue)
			end
		elseif typeof(value) == "UDim2" then
			if index == 1 then
				return UDim2.new(UDim.new(newValue, value.X.Offset), value.Y)
			elseif index == 2 then
				return UDim2.new(UDim.new(value.X.Scale, newValue), value.Y)
			elseif index == 3 then
				return UDim2.new(value.X, UDim.new(newValue, value.Y.Offset))
			elseif index == 4 then
				return UDim2.new(value.X, UDim.new(value.Y.Scale, newValue))
			end
		elseif typeof(value) == "Rect" then
			if index == 1 then
				return Rect.new(Vector2.new(newValue, value.Min.Y), value.Max)
			elseif index == 2 then
				return Rect.new(Vector2.new(value.Min.X, newValue), value.Max)
			elseif index == 3 then
				return Rect.new(value.Min, Vector2.new(newValue, value.Max.Y))
			elseif index == 4 then
				return Rect.new(value.Min, Vector2.new(value.Max.X, newValue))
			end
		elseif typeof(value) == "Color3" then
			if arguments.UseHSV then
				local h: number, s: number, v: number = value:ToHSV()
				if index == 1 then
					return Color3.fromHSV(newValue, s, v)
				elseif index == 2 then
					return Color3.fromHSV(h, newValue, v)
				elseif index == 3 then
					return Color3.fromHSV(h, s, newValue)
				end
			end
			if index == 1 then
				return Color3.new(newValue, value.G, value.B)
			elseif index == 2 then
				return Color3.new(value.R, newValue, value.B)
			elseif index == 3 then
				return Color3.new(value.R, value.G, newValue)
			end
		end

		error(`Incorrect datatype or value {value} {typeof(value)} {index}`)
	end

	local defaultIncrements: { [Types.InputDataTypes]: { number } } = {
		Num = { 1 },
		Vector2 = { 1, 1 },
		Vector3 = { 1, 1, 1 },
		UDim = { 0.01, 1 },
		UDim2 = { 0.01, 1, 0.01, 1 },
		Color3 = { 1, 1, 1 },
		Color4 = { 1, 1, 1, 1 },
		Rect = { 1, 1, 1, 1 },
	}

	local defaultMin: { [Types.InputDataTypes]: { number } } = {
		Num [trimmed]  -  Edit
  14:14:59.808  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Window | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
	local function relocateTooltips()
		if Iris._rootInstance == nil then
			return
		end
		local PopupScreenGui = Iris._rootInstance:FindFirstChild("PopupScreenGui")
		if not PopupScreenGui then
			return
		end
		local TooltipContainer = PopupScreenGui.TooltipContainer
		local mouseLocation = widgets.getMouseLocation()
		local newPosition = widgets.findBestWindowPosForPopup(
			mouseLocation,
			TooltipContainer.AbsoluteSize,
			Iris._config.DisplaySafeAreaPadding,
			PopupScreenGui.AbsoluteSize
		)
		TooltipContainer.Position = UDim2.fromOffset(newPosition.X, newPosition.Y)
	end

	widgets.UserInputService.InputChanged:Connect(relocateTooltips)

	Iris.WidgetConstructor("Tooltip", {
		hasState = false,
		hasChildren = false,
		Args = {
			["Text"] = 1,
		},
		Events = {},
		Generate = function(thisWidget: Types.Widget)
			thisWidget.parentWidget = Iris._rootWidget -- only allow root as parent

			local Tooltip: Frame = Instance.new("Frame")
			Tooltip.Name = "Iris_Tooltip"
			Tooltip.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
			Tooltip.AutomaticSize = Enum.AutomaticSize.Y
			Tooltip.BorderSizePixel = 0
			Tooltip.BackgroundTransparency = 1
			Tooltip.ZIndex = thisWidget.ZIndex + 1
			Tooltip.LayoutOrder = thisWidget.ZIndex + 1

			local TooltipText: TextLabel = Instance.new("TextLabel")
			TooltipText.Name = "TooltipText"
			TooltipText.Size = UDim2.fromOffset(0, 0)
			TooltipText.AutomaticSize = Enum.AutomaticSize.XY
			TooltipText.BackgroundColor3 = Iris._config.WindowBgColor
			TooltipText.BackgroundTransparency = Iris._config.WindowBgTransparency
			TooltipText.BorderSizePixel = Iris._config.PopupBorderSize
			TooltipText.TextWrapped = true
			TooltipText.ZIndex = thisWidget.ZIndex + 1
			TooltipText.LayoutOrder = thisWidget.ZIndex + 1

			widgets.applyTextStyle(TooltipText)
			widgets.UIStroke(TooltipText, Iris._config.WindowBorderSize, Iris._config.BorderActiveColor, Iris._config.BorderActiveTransparency)
			widgets.UIPadding(TooltipText, Iris._config.WindowPadding)
			if Iris._config.PopupRounding > 0 then
				widgets.UICorner(TooltipText, Iris._config.PopupRounding)
			end

			TooltipText.Parent = Tooltip

			return Tooltip
		end,
		Update = function(thisWidget: Types.Widget)
			local Tooltip = thisWidget.Instance :: Frame
			local TooltipText: TextLabel = Tooltip.TooltipText
			if thisWidget.arguments.Text == nil then
				error("Iris.Text Text Argument is required", 5)
			end
			TooltipText.Text = thisWidget.arguments.Text
			relocateTooltips()
		end,
		Discard = function(thisWidget: Types.Widget)
			thisWidget.Instance:Destroy()
		end,
	} :: Types.WidgetClass)

	local windowDisplayOrder: number = 0 -- incremental count which is used for determining focused windows ZIndex
	local dragWindow: Types.Widget? -- window being dragged, may be nil
	local isDragging: boolean = false
	local moveDeltaCursorPosition: Vector2 -- cursor offset from drag origin (top left of window)

	local resizeWindow: Types.Widget? -- window being resized, may be nil
	local isResizing = false
	local isInsideResize = false -- is cursor inside of the focused window resize outer padding
	local isInsideWindow = false -- is cursor inside of the focused window
	local resizeFromTopBottom: Enum.TopBottom = Enum.TopBottom.Top
	local resizeFromLeftRight: Enum.LeftRight = Enum.LeftRight.Left

	local lastCursorPosition: Vector2

	local focusedWindow: Types.Widget? -- window with focus, may be nil
	local anyFocusedWindow: boolean = false -- is there any focused window?

	local windowWidgets: { [Types.ID]: Types.Widget } = {} -- array of widget objects of type window

	local function quickSwapWindows()
		-- ctrl + tab swapping functionality
		if Iris._config.UseScreenGUIs == false then
			return
		end

		local lowest: number = 0xFFFF
		local lowestWidget: Types.Widget

		for _, widget: Types.Widget in windowWidgets do
			if widget.state.isOpened.value and not widget.arguments.NoNav then
				if widget.Instance:IsA("ScreenGui") then
					local value: number = widget.Instance.DisplayOrder
					if value < lowest then
						lowest = value
						lowestWidget = widget
					end
				end
			end
		end

		if lowestWidget.state.isUncollapsed.value == false then
			lowestWidget.state.isUncollapsed:set(true)
		end
		Iris.SetFocusedWindow(lowestWidget)
	end

	local function fitSizeToWindowBounds(thisWidget: Types.Widget, intentedSize: Vector2): Vector2
		local windowSize: Vector2 = Vector2.new(thisWidget.state.position.value.X, thisWidget.state.position.value.Y)
		local minWindowSize: number = (Iris._config.TextSize + Iris._config.FramePadding.Y * 2) * 2
		local usableSize: Vector2 = widgets.getScreenSizeForWindow(thisWidget)
		local safeAreaPadding: Vector2 = Vector2.new(
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.X,
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.Y
		)

		local maxWindowSize: Vector2 = (usableSize - windowSize - safeAreaPadding)
		return Vector2.new(
			math.clamp(intentedSize.X, minWindowSize, math.max(maxWindowSize.X, minWindowSize)),
			math.clamp(intentedSize.Y, minWindowSize, math.max(maxWindowSize.Y, minWindowSize))
		)
	end

	local function fitPositionToWindowBounds(thisWidget: Types.Widget, intendedPosition: Vector2): Vector2
		local thisWidgetInstance = thisWidget.Instance
		local usableSize: Vector2 = widgets.getScreenSizeForWindow(thisWidget)
		local safeAreaPadding: Vector2 = Vector2.new(
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.X,
			Iris._config.WindowBorderSize + Iris._config.DisplaySafeAreaPadding.Y
		)

		return Vector2.new(
			math.clamp(
				intendedPosition.X,
				safeAreaPadding.X,
				math.max(safeAreaPadding.X, usableSize.X - thisWidgetInstance.WindowButton.AbsoluteSize.X - safeAreaPadding.X)
			),
			math.clamp(
				intendedPosition.Y,
				safeAreaPadding.Y,
				math.max(safeAreaPadding.Y, usableSize.Y - thisWidgetInstance.WindowButton.AbsoluteSize.Y - safeAreaPadding.Y)
			)
		)
	end

	Iris.SetFocusedWindow = function(thisWidget: Types.Widget?)
		if focusedWindow == thisWidget then
			return
		end

		if anyFocusedWindow and focusedWindow ~= nil then
			if windowWidgets[focusedWindow.ID] then
				local Window = focusedWindow.Instance :: Frame
				local WindowButton = Window.WindowButton :: TextButton
				local TitleBar: Frame = WindowButton.TitleBar
				-- update appearance to unfocus
				if focusedWindow.state.isUncollapsed.value then
					TitleBar.BackgroundColor3 = Iris._config.TitleBgColor
					TitleBar.BackgroundTransparency = Iris._config.TitleBgTransparency
				else
					TitleBar.BackgroundColor3 = Iris._config.TitleBgCollapsedColor
					TitleBar.BackgroundTransparency = Iris._config.TitleBgCollapsedTransparency
				end
				WindowButton.UIStroke.Color = Iris._config.BorderColor
			end

			anyFocusedWindow = false
			focusedWindow = nil
		end

		if thisWidget ~= nil then
			-- update appearance to focus
			anyFocusedWindow = true
			focusedWindow = thisWidget
			local Window = thisWidget.Instance :: Frame
			local WindowButton = Window.WindowButton :: TextButton
			local TitleBar: Frame = WindowButton.TitleBar

			TitleBar.BackgroundColor3 = Iris._config.TitleBgActiveColor
			TitleBar.BackgroundTransparency = Iris._config.TitleBgActiveTransparency
			WindowButton.UIStroke.Color = Iris._config.BorderActiveColor

			windowDisplayOrder += 1
			if thisWidget.usesScreenGUI then
				Window.DisplayOrder = windowDisplayOrder + Iris._config.DisplayOrderOffset
			end

			if thisWidget.state.isUncollapsed.value == false then
				thisWidget.state.isUncollapsed:set(true)
			end

			local firstSelectedObject: GuiObject? = widgets.GuiService.SelectedObject
			if firstSelectedObject then
				if TitleBar.Visible then
					widgets.GuiService:Select(TitleBar)
				else
					widgets.GuiService:Select(Window.ChildContainer)
				end
			end
		end
	end

	widgets.UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessedEvent: boolean)
		if not gameProcessedEvent and input.UserInputType == Enum.UserInputType.MouseButton1 then
			Iris.SetFocusedWindow(nil)
		end

		if
			input.KeyCode == Enum.KeyCode.Tab
			and (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl))
		then
			quickSwapWindows()
		end

		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			if isInsideResize and not isInsideWindow and anyFocusedWindow and focusedWindow then
				local midWindow: Vector2 = focusedWindow.state.position.value + (focusedWindow.state.size.value * 0.5)
				local cursorPosition: Vector2 = widgets.getMouseLocation() - midWindow

				-- check which axis its closest to, then check which side is closest with math.sign
				if math.abs(cursorPosition.X) * focusedWindow.state.size.value.Y >= math.abs(cursorPosition.Y) * focusedWindow.state.size.value.X then
					resizeFromTopBottom = Enum.TopBottom.Center
					resizeFromLeftRight = if math.sign(cursorPosition.X) == -1 then Enum.LeftRight.Left else Enum.LeftRight.Right
				else
					resizeFromLeftRight = Enum.LeftRight.Center
					resizeFromTopBottom = if math.sign(cursorPosition.Y) == -1 then Enum.TopBottom.Top else Enum.TopBottom.Bottom
				end
				isResizing = true
				resizeWindow = focusedWindow
			end
		end
	end)

	widgets.UserInputService.TouchTapInWorld:Connect(function(_, gameProcessedEvent: boolean)
		if not gameProcessedEvent then
			Iris.SetFocusedWindow(nil)
		end
	end)

	widgets.UserInputService.InputChanged:Connect(function(input: InputObject)
		if isDragging and dragWindow then
			local mouseLocation: Vector2
			if input.UserInputType == Enum.UserInputType.Touch then
				local location: Vector3 = input.Position
				mouseLocation = Vector2.new(location.X, location.Y)
			else
				mouseLocation = widgets.getMouseLocation()
			end
			local Window = dragWindow.Instance :: Frame
			local dragInstance: TextButton = Window.WindowButton
			local intendedPosition: Vector2 = mouseLocation - moveDeltaCursorPosition
			local newPos: Vector2 = fitPositionToWindowBounds(dragWindow, intendedPosition)

			-- state shouldnt be used like this, but calling :set would run the entire UpdateState function for the window, which is slow.
			dragInstance.Position = UDim2.fromOffset(newPos.X, newPos.Y)
			dragWindow.state.position.value = newPos
		end
		if isResizing and resizeWindow and resizeWindow.arguments.NoResize ~= true then
			local Window = resizeWindow.Instance :: Frame
			local resizeInstance: TextButton = Window.WindowButton
			local windowPosition: Vector2 = Vector2.new(resizeInstance.Position.X.Offset, resizeInstance.Position.Y.Offset)
			local windowSize: Vector2 = Vector2.new(resizeInstance.Size.X.Offset, resizeInstance.Size.Y.Offset)

			local mouseDelta: Vector2 | Vector3
			if input.UserInputType == Enum.UserInputType.Touch then
				mouseDelta = input.Delta
			else
				mouseDelta = widgets.getMouseLocation() - lastCursorPosition
			end

			local intendedPosition: Vector2 = windowPosition
				+ Vector2.new(
					if resizeFromLeftRight == Enum.LeftRight.Left then mouseDelta.X else 0,
					if resizeFromTopBottom == Enum.TopBottom.Top then mouseDelta.Y else 0
				)

			local intendedSize: Vector2 = windowSize
				+ Vector2.new(
					if resizeFromLeftRight == Enum.LeftRight.Left
						then -mouseDelta.X
						elseif resizeFromLeftRight == Enum.LeftRight.Right then mouseDelta.X
						else 0,
					if resizeFromTopBottom == Enum.TopBottom.Top
						then -mouseDelta.Y
						elseif resizeFromTopBottom == Enum.TopBottom.Bottom then mouseDelta.Y
						else 0
				)

			local newSize: Vector2 = fitSizeToWindowBounds(resizeWindow, intendedSize)
			local newPosition: Vector2 = fitPositionToWindowBounds(resizeWindow, intendedPosition)

			resizeInstance.Size = UDim2.fromOffset(newSize.X, newSize.Y)
			resizeWindow.state.size.value = newSize
			resizeInstance.Position = UDim2.fromOffset(newPosition.X, newPosition.Y)
			resizeWindow.state.position.value = newPosition
		end

		lastCursorPosition = widgets.getMouseLocation()
	end)

	widgets.UserInputService.InputEnded:Connect(function(input, _)
		if
			(input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch)
			and isDragging
			and dragWindow
		then
			local Window = dragWindow.Instance :: Frame
			local dragInstance: TextButton = Window.WindowButton
			isDragging = false
			dragWindow.state.position:set(Vector2.new(dragInstance.Position.X.Offset, dragInstance.Position.Y.Offset))
		end
		if
			(input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch)
			and isResizing
			and resizeWindow
		then
			local Window = resizeWindow.Instance :: Frame
			isResizing = false
			resizeWindow.state.size:set(Window.WindowButton.AbsoluteSize)
		end

		if input.KeyCode == Enum.KeyCode.ButtonX then
			quickSwapWindows()
		end
	end)

	Iris.WidgetConstructor("Window", {
		hasState = true,
		hasChildren = true,
		Args = {
			["Title"] = 1,
			["NoTitleBar"] = 2,
			["NoBackground"] = 3,
			["NoCollapse"] = 4,
			["NoClose"] = 5,
			["NoMove"] = 6,
			["NoScrollbar"] = 7,
			["NoResize"] = 8,
			["NoNav"] = 9,
			["NoMenu"] = 10,
		},
		Events = {
			["closed"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastClosedTick == Iris._cycleTick
				end,
			},
			["opened"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastOpenedTick == Iris._cycleTick
				end,
			},
			["collapsed"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastCollapsedTick == Iris._cycleTick
				end,
			},
			["uncollapsed"] = {
				["Init"] = function(_thisWidget: Types.Widget) end,
				["Get"] = function(thisWidget: Types.Widget)
					return thisWidget.lastUncollapsedTick == Iris._cycleTick
				end,
			},
			["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
				local Window = thisWidget.Instance :: Frame
				return Window.WindowButton
			end),
		},
		Generate = function(thisWidget: Types.Widget)
			thisWidget.parentWidget = Iris._rootWidget -- only allow root as parent

			thisWidget.usesScreenGUI = Iris._config.UseScreenGUIs
			windowWidgets[thisWidget.ID] = thisWidget

			local Window
			if thisWidget.usesScreenGUI then
				Window = Instance.new("ScreenGui")
				Window.ResetOnSpawn = false
				Window.DisplayOrder = Iris._config.DisplayOrderOffset
				Window.IgnoreGuiInset = Iris._config.IgnoreGuiInset
			else
				Window = Instance.new("Folder")
			end
			Window.Name = "Iris_Window"

			local WindowButton: TextButton = Instance.new("TextButton")
			WindowButton.Name = "WindowButton"
			WindowButton.Size = UDim2.fromOffset(0, 0)
			WindowButton.BackgroundTransparency = 1
			WindowButton.BorderSizePixel = 0
			WindowButton.Text = ""
			WindowButton.ClipsDescendants = false
			WindowButton.AutoButtonColor = false
			WindowButton.Selectable = false
			WindowButton.SelectionImageObject = Iris.SelectionImageObject
			WindowButton.ZIndex = thisWidget.ZIndex + 1
			WindowButton.LayoutOrder = thisWidget.ZIndex + 1

			WindowButton.SelectionGroup = true
			WindowButton.SelectionBehaviorUp = Enum.SelectionBehavior.Stop
			WindowButton.SelectionBehaviorDown = Enum.SelectionBehavior.Stop
			WindowButton.SelectionBehaviorLeft = Enum.SelectionBehavior.Stop
			WindowButton.SelectionBehaviorRight = Enum.SelectionBehavior.Stop

			widgets.UIStroke(WindowButton, Iris._config.WindowBorderSize, Iris._config.BorderColor, Iris._config.BorderTransparency)

			WindowButton.Parent = Window

			WindowButton.InputBegan:Connect(function(input: InputObject)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Keyboard then
					return
				end
				if thisWidget.state.isUncollapsed.value then
					Iris.SetFocusedWindow(thisWidget)
				end
				if not thisWidget.arguments.NoMove and input.UserInputType == Enum.UserInputType.MouseButton1 then
					dragWindow = thisWidget
					isDragging = true
					moveDeltaCursorPosition = widgets.getMouseLocation() - thisWidget.state.position.value
				end
			end)

			local ChildContainer: ScrollingFrame = Instance.new("ScrollingFrame")
			ChildContainer.Name = "ChildContainer"
			ChildContainer.Size = UDim2.fromScale(1, 1)
			ChildContainer.Position = UDim2.fromOffset(0, 0)
			ChildContainer.BackgroundColor3 = Iris._config.WindowBgColor
			ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency
			ChildContainer.BorderSizePixel = 0

			ChildContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
			ChildContainer.ScrollBarImageTransparency = Iris._config.ScrollbarGrabTransparency
			ChildContainer.ScrollBarImageColor3 = Iris._config.ScrollbarGrabColor
			ChildContainer.CanvasSize = UDim2.fromScale(0, 1)
			ChildContainer.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar

			ChildContainer.ZIndex = thisWidget.ZIndex + 3
			ChildContainer.LayoutOrder = thisWidget.ZIndex + 3
			ChildContainer.ClipsDescendants = true

			widgets.UIPadding(ChildContainer, Iris._config.WindowPadding)

			ChildContainer.Parent = WindowButton

			ChildContainer:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
				-- "wrong" use of state here, for optimization
				thisWidget.state.scrollDistance.value = ChildContainer.CanvasPosition.Y
			end)

			ChildContainer.InputBegan:Connect(function(input: InputObject)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Keyboard then
					return
				end
				if thisWidget.state.isUncollapsed.value then
					Iris.SetFocusedWindow(thisWidget)
				end
			end)

			local TerminatingFrame: Frame = Instance.new("Frame")
			TerminatingFrame.Name = "TerminatingFrame"
			TerminatingFrame.Size = UDim2.fromOffset(0, Iris._config.WindowPadding.Y + Iris._config.FramePadding.Y)
			TerminatingFrame.BackgroundTransparency = 1
			TerminatingFrame.BorderSizePixel = 0
			TerminatingFrame.LayoutOrder = 0x7FFFFFF0

			local ChildContainerUIListLayout: UIListLayout =
				widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
			ChildContainerUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top

			TerminatingFrame.Parent = ChildContainer

			local TitleBar: Frame = Instance.new("Frame")
			TitleBar.Name = "TitleBar"
			TitleBar.Size = UDim2.fromScale(1, 0)
			TitleBar.AutomaticSize = Enum.AutomaticSize.Y
			TitleBar.BorderSizePixel = 0
			TitleBar.ZIndex = thisWidget.ZIndex + 1
			TitleBar.LayoutOrder = thisWidget.ZIndex + 1
			TitleBar.ClipsDescendants = true

			TitleBar.Parent = WindowButton

			TitleBar.InputBegan:Connect(function(input: InputObject)
				if input.UserInputType == Enum.UserInputType.Touch then
					if not thisWidget.arguments.NoMove then
						dragWindow = thisWidget
						isDragging = true
						local location: Vector3 = input.Position
						moveDeltaCursorPosition = Vector2.new(location.X, location.Y) - thisWidget.state.position.value
					end
				end
			end)

			local TitleButtonSize: number = Iris._config.TextSize + ((Iris._config.FramePadding.Y - 1) * 2)

			local CollapseButton: TextButton = Instance.new("TextButton")
			CollapseButton.Name = "CollapseButton"
			CollapseButton.AnchorPoint = Vector2.new(0, 0.5)
			CollapseButton.Size = UDim2.fromOffset(TitleButtonSize, TitleButtonSize)
			CollapseButton.Position = UDim2.new(0, Iris._config.FramePadding.X + 1, 0.5, 0)
			CollapseButton.AutomaticSize = Enum.AutomaticSize.None
			CollapseButton.BackgroundTransparency = 1
			CollapseButton.BorderSizePixel = 0
			CollapseButton.AutoButtonColor = false
			CollapseButton.Text = ""
			CollapseButton.ZIndex = thisWidget.ZIndex + 4

			widgets.UICorner(CollapseButton)

			CollapseButton.Parent = TitleBar

			CollapseButton.MouseButton1Click:Connect(function()
				thisWidget.state.isUncollapsed:set(not thisWidget.state.isUncollapsed.value)
			end)

			widgets.applyInteractionHighlights(CollapseButton, CollapseButton, {
				ButtonColor = Iris._config.ButtonColor,
				ButtonTransparency = 1,
				ButtonHoveredColor = Iris._config.ButtonHoveredColor,
				ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
				ButtonActiveColor = Iris._config.ButtonActiveColor,
				ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
			})

			local CollapseArrow: ImageLabel = Instance.new("ImageLabel")
			CollapseArrow.Name = "Arrow"
			CollapseArrow.AnchorPoint = Vector2.new(0.5, 0.5)
			CollapseArrow.Size = UDim2.fromOffset(math.floor(0.7 * TitleButtonSize), math.floor(0.7 * TitleButtonSize))
			CollapseArrow.Position = UDim2.fromScale(0.5, 0.5)
			CollapseArrow.BackgroundTransparency = 1
			CollapseArrow.BorderSizePixel = 0
			CollapseArrow.Image = widgets.ICONS.MULTIPLICATION_SIGN
			CollapseArrow.ImageColor3 = Iris._config.TextColor
			CollapseArrow.ImageTransparency = Iris._config.TextTransparency
			CollapseArrow.ZIndex = thisWidget.ZIndex + 5
			CollapseArrow.Parent = CollapseButton

			local CloseButton: TextButton = Instance.new("TextButton")
			CloseButton.Name = "CloseButton"
			CloseButton.AnchorPoint = Vector2.new(1, 0.5)
			CloseButton.Size = UDim2.fromOffset(TitleButtonSize, TitleButtonSize)
			CloseButton.Position = UDim2.new(1, -(Iris._config.FramePadding.X + 1), 0.5, 0)
			CloseButton.AutomaticSize = Enum.AutomaticSize.None
			CloseButton.BackgroundTransparency = 1
			CloseButton.BorderSizePixel = 0
			CloseButton.Text = ""

			CloseButton.ZIndex = thisWidget.ZIndex + 4
			CloseButton.AutoButtonColor = false

			widgets.UICorner(CloseButton)

			CloseButton.MouseButton1Click:Connect(function()
				thisWidget.state.isOpened:set(false)
			end)

			widgets.applyInteractionHighlights(CloseButton, CloseButton, {
				ButtonColor = Iris._config.ButtonColor,
				ButtonTransparency = 1,
				ButtonHoveredColor = Iris._config.ButtonHoveredColor,
				ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
				ButtonActiveColor = Iris._config.ButtonActiveColor,
				ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
			})

			CloseButton.Parent = TitleBar

			local CloseIcon: ImageLabel = Instance.new("ImageLabel")
			CloseIcon.Name = "Icon"
			CloseIcon.AnchorPoint = Vector2.new(0.5, 0.5)
			CloseIcon.Size = UDim2.fromOffset(math.floor(0.7 * TitleButtonSize), math.floor(0.7 * TitleButtonSize))
			CloseIcon.Position = UDim2.fromScale(0.5, 0.5)
			CloseIcon.BackgroundTransparency = 1
			CloseIcon.BorderSizePixel = 0
			CloseIcon.Image = widgets.ICONS.MULTIPLICATION_SIGN
			CloseIcon.ImageColor3 = Iris._config.TextColor
			CloseIcon.ImageTransparency = Iris._config.TextTransparency
			CloseIcon.ZIndex = thisWidget.ZIndex + 5
			CloseIcon.Parent = CloseButton

			-- allowing fractional titlebar title location dosent seem useful, as opposed to Enum.LeftRight.

			local titleAlign: number
			if Iris._config.WindowTitleAlign == Enum.LeftRight.Left then
				titleAlign = 0
			elseif Iris._config.WindowTitleAlign == Enum.LeftRight.Center then
				titleAlign = 0.5
			else
				titleAlign = 1
			end

			local Title: TextLabel = Instance.new("TextLabel")
			Title.Name = "Title"
			Title.AnchorPoint = Vector2.new(titleAlign, 0)
			Title.Position = UDim2.fromScale(titleAlign, 0)
			Title.AutomaticSize = Enum.AutomaticSize.XY
			Title.BorderSizePixel = 0
			Title.BackgroundTransparency = 1
			Title.ZIndex = thisWidget.ZIndex + 3

			widgets.applyTextStyle(Title)
			widgets.UIPadding(Title, Iris._config.FramePadding)

			Title.Parent = TitleBar

			local ResizeButtonSize: number = Iris._config.TextSize + Iris._config.FramePadding.X

			local ResizeGrip = Instance.new("TextButton")
			ResizeGrip.Name = "ResizeGrip"
			ResizeGrip.AnchorPoint = Vector2.new(1, 1)
			ResizeGrip.Size = UDim2.fromOffset(ResizeButtonSize, ResizeButtonSize)
			ResizeGrip.Position = UDim2.fromScale(1, 1)
			ResizeGrip.AutoButtonColor = false
			ResizeGrip.BorderSizePixel = 0
			ResizeGrip.BackgroundTransparency = 1
			ResizeGrip.Text = widgets.ICONS.BOTTOM_RIGHT_CORNER
			ResizeGrip.TextSize = ResizeButtonSize
			ResizeGrip.TextColor3 = Iris._config.ButtonColor
			ResizeGrip.TextTransparency = Iris._config.ButtonTransparency
			ResizeGrip.LineHeight = 1.10 -- fix mild rendering issue
			ResizeGrip.Selectable = false
			ResizeGrip.ZIndex = thisWidget.ZIndex + 3
			ResizeGrip.Parent = WindowButton

			widgets.applyTextInteractionHighlights(ResizeGrip, ResizeGrip, {
				ButtonColor = Iris._config.ButtonColor,
				ButtonTransparency = Iris._config.ButtonTransparency,
				ButtonHoveredColor = Iris._config.ButtonHoveredColor,
				ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency,
				ButtonActiveColor = Iris._config.ButtonActiveColor,
				ButtonActiveTransparency = Iris._config.ButtonActiveTransparency,
			})

			ResizeGrip.MouseButton1Down:Connect(function()
				if not anyFocusedWindow or not (focusedWindow == thisWidget) then
					Iris.SetFocusedWindow(thisWidget)
					-- mitigating wrong focus when clicking on buttons inside of a window without clicking the window itself
				end
				isResizing = true
				resizeFromTopBottom = Enum.TopBottom.Bottom
				resizeFromLeftRight = Enum.LeftRight.Right
				resizeWindow = thisWidget
			end)

			local ResizeBorder: TextButton = Instance.new("TextButton")
			ResizeBorder.Name = "ResizeBorder"
			ResizeBorder.Size = UDim2.new(1, Iris._config.WindowResizePadding.X * 2, 1, Iris._config.WindowResizePadding.Y * 2)
			ResizeBorder.Position = UDim2.fromOffset(-Iris._config.WindowResizePadding.X, -Iris._config.WindowResizePadding.Y)
			ResizeBorder.BackgroundTransparency = 1
			ResizeBorder.BorderSizePixel = 0
			ResizeBorder.Text = ""
			ResizeBorder.AutoButtonColor = false
			ResizeBorder.Active = true
			ResizeBorder.Selectable = false
			ResizeBorder.ZIndex = thisWidget.ZIndex
			ResizeBorder.LayoutOrder = thisWidget.ZIndex
			ResizeBorder.ClipsDescendants = false
			ResizeBorder.Parent = WindowButton

			ResizeBorder.MouseEnter:Connect(function()
				if focusedWindow == thisWidget then
					isInsideResize = true
				end
			end)
			ResizeBorder.MouseLeave:Connect(function()
				if focusedWindow == thisWidget then
					isInsideResize = false
				end
			end)

			WindowButton.MouseEnter:Connect(function()
				if focusedWindow == thisWidget then
					isInsideWindow = true
				end
			end)
			WindowButton.MouseLeave:Connect(function()
				if focusedWindow == thisWidget then
					isInsideWindow = false
				end
			end)

			return Window
		end,
		Update = function(thisWidget: Types.Widget)
			local WindowGui = thisWidget.Instance :: GuiObject
			local WindowButton = WindowGui.WindowButton :: TextButton
			local TitleBar = WindowButton.TitleBar :: Frame
			local Title: TextLabel = TitleBar.Title
			local MenuBar: Frame? = WindowButton:FindFirstChild("MenuBar")
			local ChildContainer: ScrollingFrame = WindowButton.ChildContainer
			local ResizeGrip: TextButton = WindowButton.ResizeGrip

			local containerHeight: number = 0
			local menuHeight: number = 0

			if thisWidget.arguments.NoResize ~= true then
				ResizeGrip.Visible = true
			else
				ResizeGrip.Visible = false
			end
			if thisWidget.arguments.NoScrollbar then
				ChildContainer.ScrollBarThickness = 0
			else
				ChildContainer.ScrollBarThickness = Iris._config.ScrollbarSize
			end
			if thisWidget.arguments.NoTitleBar then
				TitleBar.Visible = false
			else
				TitleBar.Visible = true
				--local titlebarSize: number = widgets.calculateTextSize(thisWidget.arguments.Title or "").Y + 2 * Iris._config.FramePadding.Y
				local titlebarSize: number = TitleBar.AbsoluteSize.Y
				containerHeight += titlebarSize
				menuHeight += titlebarSize
			end
			if MenuBar then
				if thisWidget.arguments.NoMenu then
					MenuBar.Visible = false
				else
					MenuBar.Visible = true
					containerHeight += MenuBar.AbsoluteSize.Y
				end
				-- we move the menu bar to the correct position.
				MenuBar.Position = UDim2.fromOffset(0, menuHeight)
			end
			if thisWidget.arguments.NoBackground then
				ChildContainer.BackgroundTransparency = 1
			else
				ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency
			end

			-- TitleBar buttons
			local TitleButtonPaddingSize = Iris._config.FramePadding.X + Iris._config.TextSize + Iris._config.FramePadding.X * 2
			if thisWidget.arguments.NoCollapse then
				TitleBar.CollapseButton.Visible = false
				TitleBar.Title.UIPadding.PaddingLeft = UDim.new(0, Iris._config.FramePadding.X)
			else
				TitleBar.CollapseButton.Visible = true
				TitleBar.Title.UIPadding.PaddingLeft = UDim.new(0, TitleButtonPaddingSize)
			end
			if thisWidget.arguments.NoClose then
				TitleBar.CloseButton.Visible = false
				TitleBar.Title.UIPadding.PaddingRight = UDim.new(0, Iris._config.FramePadding.X)
			else
				TitleBar.CloseButton.Visible = true
				TitleBar.Title.UIPadding.PaddingRight = UDim.new(0, TitleButtonPaddingSize)
			end

			ChildContainer.Size = UDim2.new(1, 0, 1, -containerHeight)
			ChildContainer.CanvasSize = UDim2.new(0, 0, 1, -containerHeight)
			ChildContainer.Position = UDim2.fromOffset(0, containerHeight)

			Title.Text = thisWidget.arguments.Title or ""
		end,
		Discard = function(thisWidget: Types.Widget)
			if focusedWindow == thisWidget then
				focusedWindow = nil
				anyFocusedWindow = false
			end
			if dragWindow == thisWidget then
				dragWindow = nil
				isDragging = false
			end
			if resizeWindow == thisWidget then
				resizeWindow = nil
				isResizing = false
			end
			windowWidgets[thisWidget.ID] = nil
			thisWidget.Instance:Destroy()
			widgets.discardState(thisWidget)
		end,
		ChildAdded = function(thisWidget: Types.Widget)
			local Window = thisWidget.Instance :: Frame
			local WindowButton = Window.WindowButton :: TextButton
			return WindowButton.ChildContainer
		end,
		UpdateState = function(thisWidget: Types.Widget)
			local stateSize: Vector2 = thisWidget.state.size.value
			local statePosition: Vector2 = thisWidget.state.position.value
			local stateIsUncollapsed: boolean = thisWidget.state.isUncollapsed.value
			local stateIsOpened: boolean = thisWidget.state.isOpened.value
			local stateScrollDistance: number = thisWidget.state.scrollDistance.value

			local Window = thisWidget.Instance :: Frame
			local WindowButton = Window.WindowButton :: TextButton
			local TitleBar = WindowButton.TitleBar :: Frame
			local ChildContainer: ScrollingFrame = WindowButton.ChildContainer
			local ResizeGrip: TextButton = WindowButton.ResizeGrip

			WindowButton.Size = UDim2.fromOffset(stateSize.X, stateSize.Y)
			WindowButton.Position = UDim2.fromOffset(statePosition.X, statePosition.Y)

			if stateIsOpened then
				if thisWidget.usesScreenGUI then
					Window.Enabled = true
					WindowButton.Visible = true
				else
					WindowButton.Visible = true
				end
				thisWidget.lastOpenedTick = Iris._cycleTick + 1
			else
				if thisWidget.usesScreenGUI then
					Window.Enabled = false
					WindowButton.Visible = false
				else
					WindowButton.Visible = false
				end
				thisWidget.lastClosedTick = Iris._cycleTick + 1
			end

			if stateIsUncollapsed then
				TitleBar.CollapseButton.Arrow.Image = widgets.ICONS.DOWN_POINTING_TRIANGLE
				ChildContainer.Visible = true
				if thisWidget.arguments.NoResize ~= true then
					ResizeGrip.Visible = true
				end
				WindowButton.AutomaticSize = Enum.AutomaticSize.None
				thisWidget.lastUncollapsedTick = Iris._cycleTick + 1
			else
				local collapsedHeight: number = TitleBar.AbsoluteSize.Y -- Iris._config.TextSize + Iris._config.FramePadding.Y * 2
				TitleBar.CollapseButton.Arrow.Image = widgets.ICONS.RIGHT_POINTING_TRIANGLE

				ChildContainer.Visible = false
				ResizeGrip.Visible = false
				WindowButton.Size = UDim2.fromOffset(stateSize.X, collapsedHeight)
				thisWidget.lastCollapsedTick = Iris._cycleTick + 1
			end

			if stateIsOpened and stateIsUncollapsed then
				Iris.SetFocusedWindow(thisWidget)
			else
				TitleBar.BackgroundColor3 = Iris._config.TitleBgCollapsedColor
				TitleBar.BackgroundTransparency = Iris._config.TitleBgCollapsedTransparency
				WindowButton.UIStroke.Color = Iris._config.BorderColor

				Iris.SetFocusedWindow(nil)
			end

			-- cant update canvasPosition in this cycle because scrollingframe isint ready to be changed
			if stateScrollDistance and stateScrollDistance ~= 0 then
				local callbackIndex: number = #Iris._postCycleCallbacks + 1
				local desiredCycleTick: number = Iris._cycleTick + 1
				Iris._postCycleCallbacks[callbackIndex] = function()
					if Iris._cycleTick == desiredCycleTick then
						ChildContainer.CanvasPosition = Vector2.new(0, stateScrollDistance)
						Iris._postCycleCallbacks[callbackIndex] = nil
					end
				end
			end
		end,
		GenerateState = function(thisWidget: Types.Widget)
			if thisWidget.state.size == nil then
				thisWidget.state.size = Iris._widgetState(thisWidget, "size", Vector2.new(400, 300))
			end
			if thisWidget.state.position == nil then
				thisWidget.state.position = Iris._widgetState(
					thisWidget,
					"position",
					if anyFocusedWindow and focusedWindow then focusedWindow.state.position.value + Vector2.new(15, 45) else Vector2.new(150, 250)
				)
			end
			thisWidget.state.position.value = fitPositionToWindowBounds(thisWidget, thisWidget.state.position.value)
			thisWidget.state.size.value = fitSizeToWindowBounds(thisWidget, thisWidget.state.size.value)

			if thisWidget.state.isUncollapsed == nil then
				thisWidget.state.isUncollapsed = Iris._widgetState(thisWidget, "isUncollapsed", true)
			end
			if thisWidget.state.isOpened == nil then
				thisWidget.state.isOpened = Iris._widgetState(thisWidget, "isOpened", true)
			end
			if thisWidget.state.scrollDistance == nil then
				thisWidget.state.scrollDistance = Iris._widgetState(thisWidget, "scrollDistance", 0)
			end
		end,
	} :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.widgets.Window

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.API | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

return function(Iris: Types.Iris)
	-- basic wrapper for nearly every widget, saves space.
	local function wrapper(name: string): (arguments: Types.WidgetArguments?, states: Types.States?) -> Types.Widget
		return function(arguments: Types.WidgetArguments?, states: Types.States?): Types.Widget
			return Iris.Internal._Insert(name, arguments, states)
		end
	end

	--[[
        ----------------------------
            [SECTION] Window API
        ----------------------------
    ]]

	Iris.Window = wrapper("Window")

	Iris.SetFocusedWindow = Iris.Internal.SetFocusedWindow

	Iris.Tooltip = wrapper("Tooltip")

	Iris.MenuBar = wrapper("MenuBar")

	Iris.Menu = wrapper("Menu")

	Iris.MenuItem = wrapper("MenuItem")

	Iris.MenuToggle = wrapper("MenuToggle")

	Iris.Separator = wrapper("Separator")

	Iris.Indent = wrapper("Indent")

	Iris.SameLine = wrapper("SameLine")

	Iris.Group = wrapper("Group")

	Iris.Text = wrapper("Text")

	Iris.TextWrapped = function(arguments: Types.WidgetArguments): Types.Widget
		arguments[2] = true
		return Iris.Internal._Insert("Text", arguments)
	end

	Iris.TextColored = function(arguments: Types.WidgetArguments): Types.Widget
		arguments[3] = arguments[2]
		arguments[2] = nil
		return Iris.Internal._Insert("Text", arguments)
	end

	Iris.SeparatorText = wrapper("SeparatorText")

	Iris.InputText = wrapper("InputText")

	Iris.Button = wrapper("Button")

	Iris.SmallButton = wrapper("SmallButton")

	Iris.Checkbox = wrapper("Checkbox")

	Iris.RadioButton = wrapper("RadioButton")

	Iris.Tree = wrapper("Tree")

	Iris.CollapsingHeader = wrapper("CollapsingHeader")

	Iris.InputNum = wrapper("InputNum")

	Iris.InputVector2 = wrapper("InputVector2")

	Iris.InputVector3 = wrapper("InputVector3")

	Iris.InputUDim = wrapper("InputUDim")

	Iris.InputUDim2 = wrapper("InputUDim2")

	Iris.InputRect = wrapper("InputRect")

	Iris.DragNum = wrapper("DragNum")

	Iris.DragVector2 = wrapper("DragVector2")

	Iris.DragVector3 = wrapper("DragVector3")

	Iris.DragUDim = wrapper("DragUDim")

	Iris.DragUDim2 = wrapper("DragUDim2")

	Iris.DragRect = wrapper("DragRect")

	Iris.InputColor3 = wrapper("InputColor3")

	Iris.InputColor4 = wrapper("InputColor4")

	Iris.SliderNum = wrapper("SliderNum")

	Iris.SliderVector2 = wrapper("SliderVector2")

	Iris.SliderVector3 = wrapper("SliderVector3")

	Iris.SliderUDim = wrapper("SliderUDim")

	Iris.SliderUDim2 = wrapper("SliderUDim2")

	Iris.SliderRect = wrapper("SliderRect")

	Iris.Selectable = wrapper("Selectable")

	Iris.Combo = wrapper("Combo")

	Iris.ComboArray = function(arguments: Types.WidgetArguments, states: Types.WidgetStates?, selectionArray: { any })
		local defaultState
		if states == nil then
			defaultState = Iris.State(selectionArray[1])
		else
			defaultState = states
		end
		local thisWidget = Iris.Internal._Insert("Combo", arguments, defaultState)
		local sharedIndex: Types.State = thisWidget.state.index
		for _, Selection in selectionArray do
			Iris.Internal._Insert("Selectable", { Selection, Selection }, { index = sharedIndex } :: Types.States)
		end
		Iris.End()

		return thisWidget
	end

	Iris.ComboEnum = function(arguments: Types.WidgetArguments, states: Types.WidgetStates?, enumType: Enum)
		local defaultState
		if states == nil then
			defaultState = Iris.State(enumType[1])
		else
			defaultState = states
		end
		local thisWidget = Iris.Internal._Insert("Combo", arguments, defaultState)
		local sharedIndex = thisWidget.state.index
		for _, Selection in enumType:GetEnumItems() do
			Iris.Internal._Insert("Selectable", { Selection.Name, Selection }, { index = sharedIndex } :: Types.States)
		end
		Iris.End()

		return thisWidget
	end
	Iris.InputEnum = Iris.ComboEnum

	Iris.Table = wrapper("Table")

	Iris.NextColumn = function()
		Iris.Internal._GetParentWidget().RowColumnIndex += 1
	end

	Iris.SetColumnIndex = function(columnIndex: number)
		local ParentWidget: Types.Widget = Iris.Internal._GetParentWidget()
		assert(columnIndex >= ParentWidget.InitialNumColumns, "Iris.SetColumnIndex Argument must be in column range")
		ParentWidget.RowColumnIndex = math.floor(ParentWidget.RowColumnIndex / ParentWidget.InitialNumColumns) + (columnIndex - 1)
	end

	Iris.NextRow = function()
		-- sets column Index back to 0, increments Row
		local ParentWidget: Types.Widget = Iris.Internal._GetParentWidget()
		local InitialNumColumns: number = ParentWidget.InitialNumColumns
		local nextRow: number = math.floor((ParentWidget.RowColumnIndex + 1) / InitialNumColumns) * InitialNumColumns
		ParentWidget.RowColumnIndex = nextRow
	end
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.API

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.config | Enabled: N/A
--------------------------------------------------------------------
local TemplateConfig = {
	colorDark = { -- Dear, ImGui default dark
		TextColor = Color3.fromRGB(255, 255, 255),
		TextTransparency = 0,
		TextDisabledColor = Color3.fromRGB(166, 166, 166),
		TextDisabledTransparency = 0,

		BorderColor = Color3.fromRGB(125, 125, 125),
		-- Dear ImGui uses 110, 110, 125
		-- The Roblox window selection highlight is 67, 191, 254
		BorderActiveColor = Color3.fromRGB(125, 125, 125), -- does not exist in Dear ImGui

		BorderTransparency = 0,
		BorderActiveTransparency = 0,
		-- BorderTransparency will be problematic for non UIStroke border implimentations
		-- is not implimented because of this

		WindowBgColor = Color3.fromRGB(65, 65, 65),
		WindowBgTransparency = 0.047,

		ScrollbarGrabColor = Color3.fromRGB(120, 120, 120),
		ScrollbarGrabTransparency = 0.098,

		TitleBgColor = Color3.fromRGB(89, 89, 89),
		TitleBgTransparency = 0,
		TitleBgActiveColor = Color3.fromRGB(199, 107, 51),
		TitleBgActiveTransparency = 0,
		TitleBgCollapsedColor = Color3.fromRGB(0, 0, 0),
		TitleBgCollapsedTransparency = 0.588,

		MenubarBgColor = Color3.fromRGB(36, 36, 36),
		MenubarBgTransparency = 0,

		FrameBgColor = Color3.fromRGB(46, 46, 46),
		FrameBgTransparency = 0,
		FrameBgHoveredColor = Color3.fromRGB(79, 79, 79),
		FrameBgHoveredTransparency = 0,
		FrameBgActiveColor = Color3.fromRGB(89, 89, 89),
		FrameBgActiveTransparency = 0,

		ButtonColor = Color3.fromRGB(46, 46, 46),
		ButtonTransparency = 0.098,
		ButtonHoveredColor = Color3.fromRGB(109, 109, 109),
		ButtonHoveredTransparency = 0.098,
		ButtonActiveColor = Color3.fromRGB(181, 107, 61),
		ButtonActiveTransparency = 0.098,

		SliderGrabColor = Color3.fromRGB(109, 109, 109),
		SliderGrabTransparency = 0.098,
		SliderGrabActiveColor = Color3.fromRGB(181, 107, 61),
		SliderGrabActiveTransparency = 0.098,

		HeaderColor = Color3.fromRGB(46, 46, 46),
		HeaderTransparency = 0.098,
		HeaderHoveredColor = Color3.fromRGB(109, 109, 109),
		HeaderHoveredTransparency = 0.098,
		HeaderActiveColor = Color3.fromRGB(143, 143, 143),
		HeaderActiveTransparency = 0.098,

		SelectionImageObjectColor = Color3.fromRGB(255, 255, 255),
		SelectionImageObjectTransparency = 0.8,
		SelectionImageObjectBorderColor = Color3.fromRGB(255, 255, 255),
		SelectionImageObjectBorderTransparency = 0,

		TableBorderStrongColor = Color3.fromRGB(53, 53, 53),
		TableBorderStrongTransparency = 0,
		TableBorderLightColor = Color3.fromRGB(169, 169, 169),
		TableBorderLightTransparency = 0,
		TableRowBgColor = Color3.fromRGB(0, 0, 0),
		TableRowBgTransparency = 0.94,
		TableRowBgAltColor = Color3.fromRGB(255, 255, 255),
		TableRowBgAltTransparency = 0.94,

		NavWindowingHighlightColor = Color3.fromRGB(255, 255, 255),
		NavWindowingHighlightTransparency = 0.3,
		NavWindowingDimBgColor = Color3.fromRGB(204, 204, 204),
		NavWindowingDimBgTransparency = 0.65,

		SeparatorColor = Color3.fromRGB(110, 110, 110),
		SeparatorTransparency = 0.196,

		CheckMarkColor = Color3.fromRGB(227, 152, 0),
		CheckMarkTransparency = 0,
	},
	colorLight = { -- Dear, ImGui default light
		TextColor = Color3.fromRGB(0, 0, 0),
		TextTransparency = 0,
		TextDisabledColor = Color3.fromRGB(153, 153, 153),
		TextDisabledTransparency = 0,

		BorderColor = Color3.fromRGB(64, 64, 64),
		-- Dear ImGui uses 0, 0, 0, 77
		-- The Roblox window selection highlight is 67, 191, 254
		BorderActiveColor = Color3.fromRGB(64, 64, 64), -- does not exist in Dear ImGui

		-- BorderTransparency = 0.5,
		-- BorderTransparency will be problematic for non UIStroke border implimentations
		-- will not be implimented because of this

		WindowBgColor = Color3.fromRGB(240, 240, 240),
		WindowBgTransparency = 0,

		TitleBgColor = Color3.fromRGB(245, 245, 245),
		TitleBgTransparency = 0,
		TitleBgActiveColor = Color3.fromRGB(209, 209, 209),
		TitleBgActiveTransparency = 0,
		TitleBgCollapsedColor = Color3.fromRGB(255, 255, 255),
		TitleBgCollapsedTransparency = 0.5,

		MenubarBgColor = Color3.fromRGB(219, 219, 219),
		MenubarBgTransparency = 0,

		ScrollbarGrabColor = Color3.fromRGB(96, 96, 96),
		ScrollbarGrabTransparency = 0,

		FrameBgColor = Color3.fromRGB(255, 255, 255),
		FrameBgTransparency = 0.6,
		FrameBgHoveredColor = Color3.fromRGB(66, 150, 250),
		FrameBgHoveredTransparency = 0.6,
		FrameBgActiveColor = Color3.fromRGB(66, 150, 250),
		FrameBgActiveTransparency = 0.33,

		ButtonColor = Color3.fromRGB(66, 150, 250),
		ButtonTransparency = 0.6,
		ButtonHoveredColor = Color3.fromRGB(66, 150, 250),
		ButtonHoveredTransparency = 0,
		ButtonActiveColor = Color3.fromRGB(15, 135, 250),
		ButtonActiveTransparency = 0,

		HeaderColor = Color3.fromRGB(66, 150, 250),
		HeaderTransparency = 0.31,
		HeaderHoveredColor = Color3.fromRGB(66, 150, 250),
		HeaderHoveredTransparency = 0.2,
		HeaderActiveColor = Color3.fromRGB(66, 150, 250),
		HeaderActiveTransparency = 0,

		SliderGrabColor = Color3.fromRGB(61, 133, 224),
		SliderGrabTransparency = 0,
		SliderGrabActiveColor = Color3.fromRGB(66, 150, 250),
		SliderGrabActiveTransparency = 0,

		SelectionImageObjectColor = Color3.fromRGB(0, 0, 0),
		SelectionImageObjectTransparency = 0.8,
		SelectionImageObjectBorderColor = Color3.fromRGB(0, 0, 0),
		SelectionImageObjectBorderTransparency = 0,

		TableBorderStrongColor = Color3.fromRGB(145, 145, 163),
		TableBorderStrongTransparency = 0,
		TableBorderLightColor = Color3.fromRGB(173, 173, 189),
		TableBorderLightTransparency = 0,
		TableRowBgColor = Color3.fromRGB(0, 0, 0),
		TableRowBgTransparency = 1,
		TableRowBgAltColor = Color3.fromRGB(77, 77, 77),
		TableRowBgAltTransparency = 0.91,

		NavWindowingHighlightColor = Color3.fromRGB(179, 179, 179),
		NavWindowingHighlightTransparency = 0.3,
		NavWindowingDimBgColor = Color3.fromRGB(51, 51, 51),
		NavWindowingDimBgTransparency = 0.8,

		SeparatorColor = Color3.fromRGB(99, 99, 99),
		SeparatorTransparency = 0.38,

		CheckMarkColor = Color3.fromRGB(66, 150, 250),
		CheckMarkTransparency = 0,
	},

	sizeDefault = { -- Dear, ImGui default
		ItemWidth = UDim.new(1, 0),
		ContentWidth = UDim.new(0.65, 0),

		WindowPadding = Vector2.new(8, 8),
		WindowResizePadding = Vector2.new(6, 6),
		FramePadding = Vector2.new(4, 3),
		ItemSpacing = Vector2.new(8, 4),
		ItemInnerSpacing = Vector2.new(4, 4),
		CellPadding = Vector2.new(4, 2),
		DisplaySafeAreaPadding = Vector2.new(0, 0),
		SeparatorTextPadding = Vector2.new(20, 3),
		IndentSpacing = 21,

		TextFont = Font.fromEnum(Enum.Font.RobotoMono),
		TextSize = 13,
		FrameBorderSize = 0,
		FrameRounding = 2,
		GrabRounding = 2,
		WindowRounding = 0, -- these don't actually work but it's nice to have them.
		WindowBorderSize = 1,
		WindowTitleAlign = Enum.LeftRight.Left,
		PopupBorderSize = 1,
		PopupRounding = 0,
		ScrollbarSize = 7,
		GrabMinSize = 10,
		SeparatorTextBorderSize = 3,
	},
	sizeClear = { -- easier to read and manuveure
		ItemWidth = UDim.new(1, 0),
		ContentWidth = UDim.new(0.65, 0),

		WindowPadding = Vector2.new(12, 8),
		WindowResizePadding = Vector2.new(8, 8),
		FramePadding = Vector2.new(6, 4),
		ItemSpacing = Vector2.new(8, 8),
		ItemInnerSpacing = Vector2.new(8, 8),
		CellPadding = Vector2.new(4, 4),
		DisplaySafeAreaPadding = Vector2.new(8, 8),
		SeparatorTextPadding = Vector2.new(24, 6),
		IndentSpacing = 25,

		TextFont = Font.fromEnum(Enum.Font.Ubuntu),
		TextSize = 15,
		FrameBorderSize = 1,
		FrameRounding = 4,
		GrabRounding = 4,
		WindowRounding = 4,
		WindowBorderSize = 1,
		WindowTitleAlign = Enum.LeftRight.Center,
		PopupBorderSize = 1,
		PopupRounding = 4,
		ScrollbarSize = 9,
		GrabMinSize = 14,
		SeparatorTextBorderSize = 4,
	},

	utilityDefault = {
		UseScreenGUIs = true,
		IgnoreGuiInset = true,
		Parent = nil,
		DisplayOrderOffset = 127,
		ZIndexOffset = 0,

		MouseDoubleClickTime = 0.30, -- Time for a double-click, in seconds.
		MouseDoubleClickMaxDist = 6.0, -- Distance threshold to stay in to validate a double-click, in pixels.

		HoverColor = Color3.fromRGB(255, 255, 0),
		HoverTransparency = 0.1,
	},
}

return TemplateConfig

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.config

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.demoWindow | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

return function(Iris: Types.Iris)
	local showMainWindow = Iris.State(true)
	local showRecursiveWindow = Iris.State(false)
	local showRuntimeInfo = Iris.State(false)
	local showStyleEditor = Iris.State(false)
	local showWindowlessDemo = Iris.State(false)
	local showMainMenuBarWindow = Iris.State(false)

    -- stylua: ignore start
    local function helpMarker(helpText)
        Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
        local text = Iris.Text({ "(?)" })
        Iris.PopConfig()

        Iris.PushConfig({ ContentWidth = UDim.new(0, 350) })
        if text.hovered() then
            Iris.Tooltip({ helpText })
        end
        Iris.PopConfig()
    end

    -- shows each widgets functionality
    local widgetDemos = {
        Basic = function()
            Iris.Tree({ "Basic" })
                Iris.SeparatorText({ "Basic" })

                local radioButtonState = Iris.State(1)
                Iris.Button({ "Button" })
                Iris.SmallButton({ "SmallButton" })
                Iris.Text({ "Text" })
                Iris.TextWrapped({ string.rep("Text Wrapped ", 5) })
                Iris.TextColored({ "Colored Text", Color3.fromRGB(255, 128, 0) })
                Iris.Text({ `Rich Text: <b>bold text</b> <i>italic text</i> <u>underline text</u> <s>strikethrough text</s> <font color= "rgb(240, 40, 10)">red text</font> <font size="32">bigger text</font>`, true, nil, true })
                Iris.SameLine()
                    Iris.RadioButton({ "Index '1'", 1 }, { index = radioButtonState })
                    Iris.RadioButton({ "Index 'two'", "two" }, { index = radioButtonState })
                    if Iris.RadioButton({ "Index 'false'", false }, { index = radioButtonState }).active() == false then
                        if Iris.SmallButton({ "Select last" }).clicked() then
                            radioButtonState:set(false)
                        end
                    end
                Iris.End()
                Iris.Text({ "The Index is: " .. tostring(radioButtonState.value) })

                Iris.SeparatorText({ "Inputs" })

                Iris.InputNum({})
                Iris.DragNum({})
                Iris.SliderNum({})

            Iris.End()
        end,

        Tree = function()
            Iris.Tree({ "Trees" })
                Iris.Tree({ "Tree using SpanAvailWidth", [Iris.Args.Tree.SpanAvailWidth] = true })
                    helpMarker("SpanAvailWidth determines if the Tree is selectable from its entire with, or only the text area")
                Iris.End()

                local tree1 = Iris.Tree({ "Tree with Children" })
                    Iris.Text({ "Im inside the first tree!" })
                    Iris.Button({ "Im a button inside the first tree!" })
                    Iris.Tree({ "Im a tree inside the first tree!" })
                        Iris.Text({ "I am the innermost text!" })
                    Iris.End()
                Iris.End()

                Iris.Checkbox({ "Toggle above tree" }, { isChecked = tree1.state.isUncollapsed })

            Iris.End()
        end,

        CollapsingHeader = function()
            Iris.Tree({ "Collapsing Headers" })
                Iris.CollapsingHeader({ "A header" })
                    Iris.Text({ "This is under the first header!" })
                Iris.End()

                local secondHeader = Iris.State(true)
                Iris.CollapsingHeader({ "Another header" }, { isUncollapsed = secondHeader })
                    if Iris.Button({ "Shhh... secret button!" }).clicked() then
                        secondHeader:set(true)
                    end
                Iris.End()
            Iris.End()
        end,

        Group = function()
            Iris.Tree({ "Groups" })
                Iris.SameLine()
                    Iris.Group()
                        Iris.Text({ "I am in group A" })
                        Iris.Button({ "Im also in A" })
                    Iris.End()
                    
                    Iris.Separator()
                    
                    Iris.Group()
                        Iris.Text({ "I am in group B" })
                        Iris.Button({ "Im also in B" })
                        Iris.Button({ "Also group B" })
                    Iris.End()
                Iris.End()
            Iris.End()
        end,

        Indent = function()
            Iris.Tree({ "Indents" })
                Iris.Text({ "Not Indented" })
                Iris.Indent()
                    Iris.Text({ "Indented" })
                    Iris.Indent({ 7 })
                        Iris.Text({ "Indented by 7 more pixels" })
                    Iris.End()

                    Iris.Indent({ -7})
                        Iris.Text({ "Indented by 7 less pixels" })
                    Iris.End()
                Iris.End()
            Iris.End()
        end,

        Input = function()
            Iris.Tree({ "Input" })
                local NoField, NoButtons, Min, Max, Increment, Format = Iris.State(false), Iris.State(false), Iris.State(0), Iris.State(100), Iris.State(1), Iris.State("%d")

                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                local InputNum = Iris.InputNum({
                    "Input Number",
                    -- [Iris.Args.InputNum.NoField] = NoField.value,
                    [Iris.Args.InputNum.NoButtons] = NoButtons.value,
                    [Iris.Args.InputNum.Min] = Min.value,
                    [Iris.Args.InputNum.Max] = Max.value,
                    [Iris.Args.InputNum.Increment] = Increment.value,
                    [Iris.Args.InputNum.Format] = { Format.value },
                })
                Iris.PopConfig()
                Iris.Text({ "The Value is: " .. InputNum.number.value })
                if Iris.Button({ "Randomize Number" }).clicked() then
                    InputNum.number:set(math.random(1, 99))
                end
                local NoFieldCheckbox = Iris.Checkbox({ "NoField" }, { isChecked = NoField })
                local NoButtonsCheckbox = Iris.Checkbox({ "NoButtons" }, { isChecked = NoButtons })
                if NoFieldCheckbox.checked() and NoButtonsCheckbox.isChecked.value == true then
                    NoButtonsCheckbox.isChecked:set(false)
                end
                if NoButtonsCheckbox.checked() and NoFieldCheckbox.isChecked.value == true then
                    NoFieldCheckbox.isChecked:set(false)
                end

                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                Iris.InputVector2({ "InputVector2" })
                Iris.InputVector3({ "InputVector3" })
                Iris.InputUDim({ "InputUDim" })
                Iris.InputUDim2({ "InputUDim2" })
                local UseFloats = Iris.State(false)
                local UseHSV = Iris.State(false)
                local sharedColor = Iris.State(Color3.new())
                local transparency = Iris.State(0)
                Iris.SliderNum({ "Transparency", 0.01, 0, 1 }, { number = transparency })
                Iris.InputColor3({ "InputColor3", UseFloats:get(), UseHSV:get() }, { color = sharedColor })
                Iris.InputColor4({ "InputColor4", UseFloats:get(), UseHSV:get() }, { color = sharedColor, transparency = transparency })
                Iris.SameLine()
                    Iris.Text({ sharedColor:get():ToHex() })
                    Iris.Checkbox({ "Use Floats" }, { isChecked = UseFloats })
                    Iris.Checkbox({ "Use HSV" }, { isChecked = UseHSV })
                Iris.End()

                Iris.PopConfig()

                Iris.Separator()

                Iris.SameLine()
                    Iris.Text({ "Slider Numbers" })
                    helpMarker("ctrl + click slider number widgets to input a number")
                Iris.End()
                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                Iris.SliderNum({ "Slide Int", 1, 1, 8 })
                Iris.SliderNum({ "Slide Float", 0.01, 0, 100 })
                Iris.SliderNum({ "Small Numbers", 0.001, -2, 1, "%f radians" })
                Iris.SliderNum({ "Odd Ranges", 0.001, -math.pi, math.pi, "%f radians" })
                Iris.SliderNum({ "Big Numbers", 1e4, 1e5, 1e7 })
                Iris.SliderNum({ "Few Numbers", 1, 0, 3 })
                Iris.PopConfig()

                Iris.Separator()

                Iris.SameLine()
                    Iris.Text({ "Drag Numbers" })
                    helpMarker("ctrl + click or double click drag number widgets to input a number, hold shift/alt while dragging to increase/decrease speed")
                Iris.End()
                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                Iris.DragNum({ "Drag Int" })
                Iris.DragNum({ "Slide Float", 0.001, -10, 10 })
                Iris.DragNum({ "Percentage", 1, 0, 100, "%d %%" })
                Iris.PopConfig()
            Iris.End()
        end,

        InputText = function()
            Iris.Tree({ "Input Text" })
                Iris.PushConfig({ ContentWidth = UDim.new(0, 250) })
                local InputText = Iris.InputText({ "Input Text Test", [Iris.Args.InputText.TextHint] = "Input Text here" })
                Iris.PopConfig()
                Iris.Text({ "The text is: " .. InputText.text.value })
            Iris.End()
        end,

        MultiInput = function()
            Iris.Tree({"Multi-Component Input"})

                local sharedVector2 = Iris.State(Vector2.new())
                local sharedVector3 = Iris.State(Vector3.new())
                local sharedUDim = Iris.State(UDim.new())
                local sharedUDim2 = Iris.State(UDim2.new())
                local sharedColor3 = Iris.State(Color3.new())
                local SharedRect = Iris.State(Rect.new(0, 0))

                Iris.SeparatorText({"Input"})

                Iris.InputVector2({}, {number = sharedVector2})
                Iris.InputVector3({}, {number = sharedVector3})
                Iris.InputUDim({}, {number = sharedUDim})
                Iris.InputUDim2({}, {number = sharedUDim2})
                Iris.InputRect({}, {number = SharedRect})

                Iris.SeparatorText({"Drag"})

                Iris.DragVector2({}, {number = sharedVector2})
                Iris.DragVector3({}, {number = sharedVector3})
                Iris.DragUDim({}, {number = sharedUDim})
                Iris.DragUDim2({}, {number = sharedUDim2})
                Iris.DragRect({}, {number = SharedRect})

                Iris.SeparatorText({"Slider"})

                Iris.SliderVector2({}, {number = sharedVector2})
                Iris.SliderVector3({}, {number = sharedVector3})
                Iris.SliderUDim({}, {number = sharedUDim})
                Iris.SliderUDim2({}, {number = sharedUDim2})
                Iris.SliderRect({}, {number = SharedRect})

                Iris.SeparatorText({"Color"})

                Iris.InputColor3({}, {color = sharedColor3})
                Iris.InputColor4({}, {color = sharedColor3})

            Iris.End()
        end,

        Tooltip = function()
            Iris.PushConfig({ ContentWidth = UDim.new(0, 250) })
            Iris.Tree({ "Tooltip" })
                if Iris.Text({ "Hover over me to reveal a tooltip" }).hovered() then
                    Iris.Tooltip({ "I am some helpful tooltip text" })
                end
                local dynamicText = Iris.State("Hello ")
                local numRepeat = Iris.State(1)
                if Iris.InputNum({ "# of repeat", 1, 1, 50 }, { number = numRepeat }).numberChanged() then
                    dynamicText:set(string.rep("Hello ", numRepeat:get()))
                end
                if Iris.Checkbox({ "Show dynamic text tooltip" }).isChecked.value then
                    Iris.Tooltip({ dynamicText:get() })
                end
            Iris.End()
            Iris.PopConfig()
        end,

        Selectable = function()
            Iris.Tree({ "Selectable" })
                local sharedIndex = Iris.State(2)
                Iris.Selectable({ "Selectable #1", 1 }, { index = sharedIndex })
                Iris.Selectable({ "Selectable #2", 2 }, { index = sharedIndex })
                if Iris.Selectable({ "Double click Selectable", 3, true }, { index = sharedIndex }).doubleClicked() then
                    sharedIndex:set(3)
                end
                Iris.Selectable({ "Impossible to select", 4, true }, { index = sharedIndex })
                if Iris.Button({ "Select last" }).clicked() then
                    sharedIndex:set(4)
                end
                Iris.Selectable({ "Independent Selectable" })
            Iris.End()
        end,

        Combo = function()
            Iris.Tree({ "Combo" })
                Iris.PushConfig({ ContentWidth = UDim.new(1, -120) })
                local sharedComboIndex = Iris.State("No Selection")
                Iris.SameLine()
                    local NoPreview = Iris.Checkbox({ "No Preview" })
                    local NoButton = Iris.Checkbox({ "No Button" })
                    if NoPreview.checked() and NoButton.isChecked.value == true then
                        NoButton.isChecked:set(false)
                    end
                    if NoButton.checked() and NoPreview.isChecked.value == true then
                        NoPreview.isChecked:set(false)
                    end
                Iris.End()
                Iris.Combo({ "Basic Usage", NoButton.isChecked:get(), NoPreview.isChecked:get() }, { index = sharedComboIndex })
                    Iris.Selectable({ "Select 1", "One" }, { index = sharedComboIndex })
                    Iris.Selectable({ "Select 2", "Two" }, { index = sharedComboIndex })
                    Iris.Selectable({ "Select 3", "Three" }, { index = sharedComboIndex })
                Iris.End()

                Iris.ComboArray({ "Using ComboArray" }, { index = "No Selection" }, { "Red", "Green", "Blue" })

                local sharedComboIndex2 = Iris.State("7 AM")
                Iris.Combo({ "Combo with Inner widgets" }, { index = sharedComboIndex2 })
                    Iris.Tree({ "Morning Shifts" })
                        Iris.Selectable({ "Shift at 7 AM", "7 AM" }, { index = sharedComboIndex2 })
                        Iris.Selectable({ "Shift at 11 AM", "11 AM" }, { index = sharedComboIndex2 })
                        Iris.Selectable({ "Shist at 3 PM", "3 PM" }, { index = sharedComboIndex2 })
                    Iris.End()
                    Iris.Tree({ "Night Shifts" })
                        Iris.Selectable({ "Shift at 6 PM", "6 PM" }, { index = sharedComboIndex2 })
                        Iris.Selectable({ "Shift at 9 PM", "9 PM" }, { index = sharedComboIndex2 })
                    Iris.End()
                Iris.End()

                local ComboEnum = Iris.ComboEnum({ "Using ComboEnum" }, { index = Enum.UserInputState.Begin }, Enum.UserInputState)
                Iris.Text({ "Selected: " .. ComboEnum.index:get().Name })
                Iris.PopConfig()
            Iris.End()
        end,
    }
    local widgetDemosOrder = { "Basic", "Tree", "CollapsingHeader", "Group", "Indent", "Input", "MultiInput", "InputText", "Tooltip", "Selectable", "Combo" }

    local function recursiveTree()
        local theTree = Iris.Tree({ "Recursive Tree" })
        if theTree.state.isUncollapsed.value then
            recursiveTree()
        end
        Iris.End()
    end

    local function recursiveWindow(parentCheckboxState)
        Iris.Window({ "Recursive Window" }, { size = Iris.State(Vector2.new(175, 100)), isOpened = parentCheckboxState })
            local theCheckbox = Iris.Checkbox({ "Recurse Again" })
        Iris.End()
        if theCheckbox.isChecked.value then
            recursiveWindow(theCheckbox.isChecked)
        end
    end

    -- shows list of runtime widgets and states, including IDs. shows other info about runtime and can show widgets/state info in depth.
    local function runtimeInfo()
        local runtimeInfoWindow = Iris.Window({ "Runtime Info" }, { isOpened = showRuntimeInfo })
            local lastVDOM = Iris.Internal._lastVDOM
            local states = Iris.Internal._states

            local numSecondsDisabled = Iris.State(3)
            local rollingDT = Iris.State(0)
            local lastT = Iris.State(os.clock())

            Iris.SameLine()
                Iris.InputNum({ "", [Iris.Args.InputNum.Format] = "%d Seconds", [Iris.Args.InputNum.Max] = 10 }, { number = numSecondsDisabled })
                if Iris.Button({ "Disable" }).clicked() then
                    Iris.Disabled = true
                    task.delay(numSecondsDisabled:get(), function()
                        Iris.Disabled = false
                    end)
                end
            Iris.End()

            local t = os.clock()
            local dt = t - lastT.value
            rollingDT.value += (dt - rollingDT.value) * 0.2
            lastT.value = t
            Iris.Text({ string.format("Average %.3f ms/frame (%.1f FPS)", rollingDT.value * 1000, 1 / rollingDT.value) })

            Iris.Text({
                string.format("Window Position: (%d, %d), Window Size: (%d, %d)", runtimeInfoWindow.position.value.X, runtimeInfoWindow.position.value.Y, runtimeInfoWindow.size.value.X, runtimeInfoWindow.size.value.Y),
            })

            Iris.SameLine()
                Iris.Text({ "Enter an ID to learn more about it." })
                helpMarker("every widget and state has an ID which Iris tracks to remember which widget is which. below lists all widgets and states, with their respective IDs")
            Iris.End()

            Iris.PushConfig({ ItemWidth = UDim.new(1, -150) })
            local enteredText = Iris.InputText({ "ID field" }, { text = Iris.State(runtimeInfoWindow.ID) }).text.value
            Iris.PopConfig()

            Iris.Indent()
                local enteredWidget = lastVDOM[enteredText]
                local enteredState = states[enteredText]
                if enteredWidget then
                    Iris.Table({ 1, [Iris.Args.Table.RowBg] = false })
                        Iris.Text({ string.format('The ID, "%s", is a widget', enteredText) })
                        Iris.NextRow()

                        Iris.Text({ string.format("Widget is type: %s", enteredWidget.type) })
                        Iris.NextRow()

                        Iris.Tree({ "Widget has Args:" }, { isUncollapsed = Iris.State(true) })
                            for i, v in enteredWidget.arguments do
                                Iris.Text({ i .. " - " .. tostring(v) })
                            end
                        Iris.End()
                        Iris.NextRow()

                        if enteredWidget.state then
                            Iris.Tree({ "Widget has State:" }, { isUncollapsed = Iris.State(true) })
                                for i, v in enteredWidget.state do
                                    Iris.Text({ i .. " - " .. tostring(v.value) })
                                end
                            Iris.End()
                        end
                    Iris.End()
                elseif enteredState then
                    Iris.Table({ 1, [Iris.Args.Table.RowBg] = false })
                        Iris.Text({ string.format('The ID, "%s", is a state', enteredText) })
                        Iris.NextRow()

                        Iris.Text({ string.format("Value is type: %s, Value = %s", typeof(enteredState.value), tostring(enteredState.value)) })
                        Iris.NextRow()

                        Iris.Tree({ "state has connected widgets:" }, { isUncollapsed = Iris.State(true) })
                            for i, v in enteredState.ConnectedWidgets do
                                Iris.Text({ i .. " - " .. v.type })
                            end
                        Iris.End()
                        Iris.NextRow()

                        Iris.Text({ string.format("state has: %d connected functions", #enteredState.ConnectedFunctions) })
                    Iris.End()
                else
                    Iris.Text({ string.format('The ID, "%s", is not a state or widget', enteredText) })
                end
            Iris.End()

            if Iris.Tree({ "Widgets" }).isUncollapsed.value then
                local widgetCount = 0
                local widgetStr = ""
                for _, v in lastVDOM do
                    widgetCount += 1
                    widgetStr ..= "\n" .. v.ID .. " - " .. v.type
                end

                Iris.Text({ "Number of Widgets: " .. widgetCount })

                Iris.Text({ widgetStr })
            end
            Iris.End()
            if Iris.Tree({ "States" }).isUncollapsed.value then
                local stateCount = 0
                local stateStr = ""
                for i, v in states do
                    stateCount += 1
                    stateStr ..= "\n" .. i .. " - " .. tostring(v.value)
                end

                Iris.Text({ "Number of States: " .. stateCount })

                Iris.Text({ stateStr })
            end
            Iris.End()
        Iris.End()
    end

    local function recursiveMenu()
        -- stylua: ignore start
        if Iris.Menu({ "Recursive" }).state.isOpened.value then
            Iris.MenuItem({ "New", Enum.KeyCode.N, Enum.ModifierKey.Ctrl })
            Iris.MenuItem({ "Open", Enum.KeyCode.O, Enum.ModifierKey.Ctrl })
            Iris.MenuItem({ "Save", Enum.KeyCode.S, Enum.ModifierKey.Ctrl })
            Iris.Separator()
            Iris.MenuToggle({ "Autosave" })
            Iris.MenuToggle({ "Checked" })
            Iris.Separator()
            Iris.Menu({ "Options" })
                Iris.MenuItem({ "Red" })
                Iris.MenuItem({ "Yellow" })
                Iris.MenuItem({ "Green" })
                Iris.MenuItem({ "Blue" })
                Iris.Separator()
                recursiveMenu()
            Iris.End()
        end
        Iris.End()
        -- stylua: ignore end
        
    end

    local function mainMenuBar()
        Iris.MenuBar()
            Iris.Menu({ "File" })
                Iris.MenuItem({ "New", Enum.KeyCode.N, Enum.ModifierKey.Ctrl })
                Iris.MenuItem({ "Open", Enum.KeyCode.O, Enum.ModifierKey.Ctrl })
                Iris.MenuItem({ "Save", Enum.KeyCode.S, Enum.ModifierKey.Ctrl })
                recursiveMenu()
                Iris.MenuItem({ "Quit", Enum.KeyCode.Q, Enum.ModifierKey.Alt })
            Iris.End()
            
            Iris.Menu({ "Examples" })
                Iris.MenuToggle({ "Recursive Window" }, { isChecked = showRecursiveWindow })
                Iris.MenuToggle({ "Windowless" }, { isChecked = showWindowlessDemo })
                Iris.MenuToggle({ "Main Menu Bar" }, { isChecked = showMainMenuBarWindow })
            Iris.End()

            Iris.Menu({ "Tools" })
                Iris.MenuToggle({ "Runtime Info" }, { isChecked = showRuntimeInfo })
                Iris.MenuToggle({ "Style Editor" }, { isChecked = showStyleEditor })
            Iris.End()
        Iris.End()
    end

    local function mainMenuBarExample()
        local screenSize = Iris.Internal._rootWidget.Instance.PseudoWindowScreenGui.AbsoluteSize
        -- Iris.Window(
        --     {[Iris.Args.Window.NoBackground] = true, [Iris.Args.Window.NoTitleBar] = true, [Iris.Args.Window.NoMove] = true, [Iris.Args.Window.NoResize] = true},
        --     {size = Iris.State(screenSize), position = Iris.State(Vector2.new(0, 0))}
        -- )
        
        mainMenuBar()

        --Iris.End()
    end

    -- allows users to edit state
    local styleEditor
    do
        styleEditor = function()
            local selectedPanel = Iris.State(1)

            local styleList = {
                {
                    "Sizing",
                    function()
                        local UpdatedConfig = Iris.State({})

                        if Iris.Button({ "Update Config" }).clicked() then
                            Iris.UpdateGlobalConfig(UpdatedConfig:get())
                            UpdatedConfig:set({})
                        end

                        local UDims = {
                            { "ItemWidth", nil,  UDim.new(), UDim.new(1, 200) },
                            { "ContentWidth", nil, UDim.new(), UDim.new(1, 200) }
                        }
                        for _, vUDim in UDims do
                            local Input = Iris.SliderUDim({ table.unpack(vUDim) }, { number = Iris.WeakState(Iris._config[vUDim[1] ]) })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vUDim[1] ] = Input.number:get()
                            end
                        end

                        local Vector2s = {
                            { "WindowPadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "WindowResizePadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "FramePadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "ItemSpacing", nil, Vector2.zero, Vector2.one * 20 },
                            { "ItemInnerSpacing", nil, Vector2.zero, Vector2.one * 20 },
                            { "CellPadding", nil, Vector2.zero, Vector2.one * 20 },
                            { "DisplaySafeAreaPadding", nil, Vector2.zero, Vector2.one * 20 },
                        }
                        for _, vVector2 in Vector2s do
                            local Input = Iris.SliderVector2({ table.unpack(vVector2) }, { number = Iris.WeakState(Iris._config[vVector2[1] ]) })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vVector2[1] ] = Input.number:get()
                            end
                        end

                        local Numbers = {
                            { "TextSize", 1, 4, 20 },
                            { "FrameBorderSize", 0.1, 0, 1 },
                            { "FrameRounding", 1, 0, 12 },
                            { "GrabRounding", 1, 0, 12 },
                            { "WindowBorderSize", 0.1, 0, 1 },
                            { "PopupBorderSize", 0.1, 0, 1 },
                            { "PopupRounding", 1, 0, 12 },
                            { "ScrollbarSize", 1, 0, 20 },
                            { "GrabMinSize", 1, 0, 20 },
                        }
                        for _, vNumber in Numbers do
                            local Input = Iris.SliderNum({ table.unpack(vNumber) }, { number = Iris.WeakState(Iris._config[vNumber[1] ]) })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vNumber[1] ] = Input.number:get()
                            end
                        end

                        local Enums = {
                            "WindowTitleAlign",
                            -- "TextFont"
                        }
                        for _, vEnum in Enums do
                            local Input = Iris.ComboEnum({ vEnum }, { index = Iris.WeakState(Iris._config[vEnum]) }, Iris._config[vEnum].EnumType)
                            if Input.closed() then
                                Iris.UpdateGlobalConfig({ [vEnum] = Input.index:get() })
                            end
                        end
                    end,
                },
                {
                    "Colors",
                    function()
                        local UpdatedConfig = Iris.State({})

                        if Iris.Button({ "Update Config" }).clicked() then
                            Iris.UpdateGlobalConfig(UpdatedConfig:get())
                            UpdatedConfig:set({})
                        end
                        
                        local color3s = { "BorderColor", "BorderActiveColor" }

                        for _, vColor in color3s do
                            local Input = Iris.InputColor3({ vColor }, { color = Iris.WeakState(Iris._config[vColor]) })
                            if Input.numberChanged() then
                                Iris.UpdateGlobalConfig({ [vColor] = Input.color:get() })
                            end
                        end

                        local color4s = {
                            "Text",
                            "TextDisabled",
                            "WindowBg",
                            "ScrollbarGrab",
                            "TitleBg",
                            "TitleBgActive",
                            "TitleBgCollapsed",
                            "MenubarBg",
                            "FrameBg",
                            "FrameBgHovered",
                            "FrameBgActive",
                            "Button",
                            "ButtonHovered",
                            "ButtonActive",
                            "SliderGrab",
                            "SliderGrabActive",
                            "Header",
                            "HeaderHovered",
                            "HeaderActive",
                            "SelectionImageObject",
                            "SelectionImageObjectBorder",
                            "TableBorderStrong",
                            "TableBorderLight",
                            "TableRowBg",
                            "TableRowBgAlt",
                            "NavWindowingHighlight",
                            "NavWindowingDimBg",
                            "Separator",
                            "CheckMark",
                        }

                        for _, vColor in color4s do
                            local Input = Iris.InputColor4({ vColor }, {
                                color = Iris.WeakState(Iris._config[vColor .. "Color"]),
                                transparency = Iris.WeakState(Iris._config[vColor .. "Transparency"]),
                            })
                            if Input.numberChanged() then
                                UpdatedConfig:get()[vColor .. "Color"] = Input.color:get()
                                UpdatedConfig:get()[vColor .. "Transparency"] = Input.transparency:get()
                            end
                        end
                    end,
                },
            }

            Iris.Window({ "Style Editor" }, { isOpened = showStyleEditor })
                Iris.Text({ "Customize the look of Iris in realtime." })
                Iris.SameLine()
                    if Iris.SmallButton({ "Light Theme" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight)
                    end
                    if Iris.SmallButton({ "Dark Theme" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark)
                    end
                Iris.End()

                Iris.SameLine()
                    if Iris.SmallButton({ "Classic Size" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
                    end
                    if Iris.SmallButton({ "Larger Size" }).clicked() then
                        Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeClear)
                    end
                Iris.End()

                if Iris.SmallButton({ "Reset Everything" }).clicked() then
                    Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark)
                    Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
                end
                Iris.Separator()

                Iris.SameLine()
                    for i, v in ipairs(styleList) do
                        Iris.RadioButton({ v[1], i }, { index = selectedPanel })
                    end
                Iris.End()

                styleList[selectedPanel:get()][2]()
            Iris.End()
        end
    end

    local function widgetEventInteractivity()
        Iris.CollapsingHeader({ "Widget Event Interactivity" })
        local clickCount = Iris.State(0)
        if Iris.Button({ "Click to increase Number" }).clicked() then
            clickCount:set(clickCount:get() + 1)
        end
        Iris.Text({ "The Number is: " .. clickCount:get() })

        Iris.Separator()

        local showEventText = Iris.State(false)
        local selectedEvent = Iris.State("clicked")
        Iris.SameLine()
        Iris.RadioButton({ "clicked", "clicked" }, { index = selectedEvent })
        Iris.RadioButton({ "rightClicked", "rightClicked" }, { index = selectedEvent })
        Iris.RadioButton({ "doubleClicked", "doubleClicked" }, { index = selectedEvent })
        Iris.RadioButton({ "ctrlClicked", "ctrlClicked" }, { index = selectedEvent })
        Iris.End()
        Iris.SameLine()

        if Iris.Button({ selectedEvent:get() .. " to reveal text" })[selectedEvent:get()]() then
            showEventText:set(not showEventText:get())
        end
        if showEventText:get() then
            Iris.Text({ "Here i am!" })
        end

        Iris.End()

        Iris.Separator()

        local showTextTimer = Iris.State(0)
        Iris.SameLine()
        if Iris.Button({ "Click to show text for 20 frames" }).clicked() then
            showTextTimer:set(20)
        end
        if showTextTimer:get() > 0 then
            Iris.Text({ "Here i am!" })
        end
        Iris.End()
        showTextTimer:set(math.max(0, showTextTimer:get() - 1))
        Iris.Text({ "Text Timer: " .. showTextTimer:get() })

        local checkbox0 = Iris.Checkbox({ "Event-tracked checkbox" })
        Iris.Indent()
        Iris.Text({ "unchecked: " .. tostring(checkbox0.unchecked()) })
        Iris.Text({ "checked: " .. tostring(checkbox0.checked()) })
        Iris.End()
        Iris.SameLine()
        if Iris.Button({ "Hover over me" }).hovered() then
            Iris.Text({ "The button is hovered" })
        end
        Iris.End()
        Iris.End()
    end

    local function widgetStateInteractivity()
        Iris.CollapsingHeader({ "Widget State Interactivity" })
        local checkbox0 = Iris.Checkbox({ "Widget-Generated State" })
        Iris.Text({ `isChecked: {checkbox0.state.isChecked.value}\n` })

        local checkboxState0 = Iris.State(false)
        local checkbox1 = Iris.Checkbox({ "User-Generated State" }, { isChecked = checkboxState0 })
        Iris.Text({ `isChecked: {checkbox1.state.isChecked.value}\n` })

        local checkbox2 = Iris.Checkbox({ "Widget Coupled State" })
        local checkbox3 = Iris.Checkbox({ "Coupled to above Checkbox" }, { isChecked = checkbox2.state.isChecked })
        Iris.Text({ `isChecked: {checkbox3.state.isChecked.value}\n` })

        local checkboxState1 = Iris.State(false)
        local _checkbox4 = Iris.Checkbox({ "Widget and Code Coupled State" }, { isChecked = checkboxState1 })
        local Button0 = Iris.Button({ "Click to toggle above checkbox" })
        if Button0.clicked() then
            checkboxState1:set(not checkboxState1:get())
        end
        Iris.Text({ `isChecked: {checkboxState1.value}\n` })

        local checkboxState2 = Iris.State(true)
        local checkboxState3 = Iris.ComputedState(checkboxState2, function(newValue)
            return not newValue
        end)
        local _checkbox5 = Iris.Checkbox({ "ComputedState (dynamic coupling)" }, { isChecked = checkboxState2 })
        local _checkbox5 = Iris.Checkbox({ "Inverted of above checkbox" }, { isChecked = checkboxState3 })
        Iris.Text({ `isChecked: {checkboxState3.value}\n` })

        Iris.End()
    end

    local function dynamicStyle()
        Iris.CollapsingHeader({ "Dynamic Styles" })
        local colorH = Iris.State(0)
        Iris.SameLine()
        if Iris.Button({ "Change Color" }).clicked() then
            colorH:set(math.random())
        end
        Iris.Text({ "Hue: " .. math.floor(colorH:get() * 255) })
        helpMarker("Using PushConfig with a changing value, this can be done with any config field")
        Iris.End()
        Iris.PushConfig({ TextColor = Color3.fromHSV(colorH:get(), 1, 1) })
        Iris.Text({ "Text with a unique and changable color" })
        Iris.PopConfig()
        Iris.End()
    end

    local function tablesDemo()
        local showTablesTree = Iris.State(false)

        Iris.CollapsingHeader({ "Tables & Columns" }, { isUncollapsed = showTablesTree })
        if showTablesTree.value == false then
            -- optimization to skip code which draws GUI which wont be seen.
            -- its a trade off because when the tree becomes opened widgets will all have to be generated again.
            -- Dear ImGui utilizes the same trick, but its less useful here because the Retained mode Backend
            Iris.End()
        else
            Iris.SameLine()
            Iris.Text({ "Table using NextRow and NextColumn syntax:" })
            helpMarker("calling Iris.NextRow() in the outer loop, and Iris.NextColumn()in the inner loop")
            Iris.End()
            Iris.Table({ 3 })
            for i = 1, 4 do
                Iris.NextRow()
                for i2 = 1, 3 do
                    Iris.NextColumn()
                    Iris.Text({ `Row: {i}, Column: {i2}` })
                end
            end
            Iris.End()

            Iris.Text({ "" })

            Iris.SameLine()
            Iris.Text({ "Table using NextColumn only syntax:" })
            helpMarker("only calling Iris.NextColumn() in the inner loop, the result is identical")
            Iris.End()

            Iris.Table({ 2 })
            for i = 1, 4 do
                for i2 = 1, 2 do
                    Iris.NextColumn()
                    Iris.Text({ `Row: {i}, Column: {i2}` })
                end
            end
            Iris.End()

            Iris.Separator()

            local TableRowBg = Iris.State(false)
            local TableBordersOuter = Iris.State(false)
            local TableBordersInner = Iris.State(true)
            local TableUseButtons = Iris.State(true)
            local TableNumRows = Iris.State(3)

            Iris.Text({ "Table with Customizable Arguments" })
            Iris.Table({
                4,
                [Iris.Args.Table.RowBg] = TableRowBg.value,
                [Iris.Args.Table.BordersOuter] = TableBordersOuter.value,
                [Iris.Args.Table.BordersInner] = TableBordersInner.value,
            })
            for i = 1, TableNumRows:get() do
                for i2 = 1, 4 do
                    Iris.NextColumn()
                    if TableUseButtons.value then
                        Iris.Button({ `Month: {i}, Week: {i2}` })
                    else
                        Iris.Text({ `Month: {i}, Week: {i2}` })
                    end
                end
            end
            Iris.End()

            Iris.Checkbox({ "RowBg" }, { isChecked = TableRowBg })
            Iris.Checkbox({ "BordersOuter" }, { isChecked = TableBordersOuter })
            Iris.Checkbox({ "BordersInner" }, { isChecked = TableBordersInner })
            Iris.SameLine()
            Iris.RadioButton({ "Buttons", true }, { index = TableUseButtons })
            Iris.RadioButton({ "Text", false }, { index = TableUseButtons })
            Iris.End()
            Iris.InputNum({
                "Number of rows",
                [Iris.Args.InputNum.Min] = 0,
                [Iris.Args.InputNum.Max] = 100,
                [Iris.Args.InputNum.Format] = "%d",
            }, { number = TableNumRows })

            Iris.End()
        end
    end

    local function layoutDemo()
        Iris.CollapsingHeader({ "Widget Layout" })
        Iris.Tree({ "Content Width" })
        local value = Iris.State(50)
        local index = Iris.State(Enum.Axis.X)

        Iris.Text({ "The Content Width is a size property which determines the width of input fields." })
        Iris.SameLine()
        Iris.Text({ "By default the value is UDim.new(0.65, 0)" })
        helpMarker("This is the default value from Dear ImGui.\nIt is 65% of the window width.")
        Iris.End()
        Iris.Text({ "This works well, but sometimes we know how wide elements are going to be and want to maximise the space." })
        Iris.Text({ "Therefore, we can use Iris.PushConfig() to change the width" })

        Iris.Separator()

        Iris.SameLine()
        Iris.Text({ "Content Width = 150 pixels" })
        helpMarker("UDim.new(0, 150)")
        Iris.End()
        Iris.PushConfig({ ContentWidth = UDim.new(0, 150) })
        Iris.DragNum({ "number", 1, 0, 100 }, { number = value })
        Iris.ComboEnum({ "axis" }, { index = index }, Enum.Axis)
        Iris.PopConfig()

        Iris.SameLine()
        Iris.Text({ "Content Width = 50% window width" })
        helpMarker("UDim.new(0.5, 0)")
        Iris.End()
        Iris.PushConfig({ ContentWidth = UDim.new(0.5, 0) })
        Iris.DragNum({ "number", 1, 0, 100 }, { number = value })
        Iris.ComboEnum({ "axis" }, { index = index }, Enum.Axis)
        Iris.PopConfig()

        Iris.SameLine()
        Iris.Text({ "Content Width = -150 pixels from the right side" })
        helpMarker("UDim.new(1, -150)")
        Iris.End()
        Iris.PushConfig({ ContentWidth = UDim.new(1, -150) })
        Iris.DragNum({ "number", 1, 0, 100 }, { number = value })
        Iris.InputEnum({ "axis" }, { index = index }, Enum.Axis)
        Iris.PopConfig()
        Iris.End()
        Iris.End()
    end

    -- showcases how widgets placed outside of a window are placed inside root
    local function windowlessDemo()
        Iris.PushConfig({ ItemWidth = UDim.new(0, 150) })
        Iris.SameLine()
        Iris.TextWrapped({ "Windowless widgets" })
        helpMarker("Widgets which are placed outside of a window will appear on the top left side of the screen.")
        Iris.End()
        Iris.Button({})
        Iris.Tree({})
        Iris.InputText({})
        Iris.End()
        Iris.PopConfig()
    end

    -- main demo window
    return function()
        local NoTitleBar = Iris.State(false)
        local NoBackground = Iris.State(false)
        local NoCollapse = Iris.State(false)
        local NoClose = Iris.State(true)
        local NoMove = Iris.State(false)
        local NoScrollbar = Iris.State(false)
        local NoResize = Iris.State(false)
        local NoNav = Iris.State(false)
        local NoMenu = Iris.State(false)

        if showMainWindow.value == false then
            Iris.Checkbox({ "Open main window" }, { isChecked = showMainWindow })
            return
        end

        Iris.Window({
            "Iris Demo Window",
            [Iris.Args.Window.NoTitleBar] = NoTitleBar.value,
            [Iris.Args.Window.NoBackground] = NoBackground.value,
            [Iris.Args.Window.NoCollapse] = NoCollapse.value,
            [Iris.Args.Window.NoClose] = NoClose.value,
            [Iris.Args.Window.NoMove] = NoMove.value,
            [Iris.Args.Window.NoScrollbar] = NoScrollbar.value,
            [Iris.Args.Window.NoResize] = NoResize.value,
            [Iris.Args.Window.NoNav] = NoNav.value,
            [Iris.Args.Window.NoMenu] = NoMenu.value,
        }, { size = Iris.State(Vector2.new(600, 550)), position = Iris.State(Vector2.new(100, 25)), isOpened = showMainWindow })

        mainMenuBar()

        Iris.Text({ "Iris says hello. (2.1.1)" })

        Iris.CollapsingHeader({ "Window Options" })
        Iris.Table({ 3, false, false, false })
        Iris.NextColumn()
        Iris.Checkbox({ "NoTitleBar" }, { isChecked = NoTitleBar })
        Iris.NextColumn()
        Iris.Checkbox({ "NoBackground" }, { isChecked = NoBackground })
        Iris.NextColumn()
        Iris.Checkbox({ "NoCollapse" }, { isChecked = NoCollapse })
        Iris.NextColumn()
        Iris.Checkbox({ "NoClose" }, { isChecked = NoClose })
        Iris.NextColumn()
        Iris.Checkbox({ "NoMove" }, { isChecked = NoMove })
        Iris.NextColumn()
        Iris.Checkbox({ "NoScrollbar" }, { isChecked = NoScrollbar })
        Iris.NextColumn()
        Iris.Checkbox({ "NoResize" }, { isChecked = NoResize })
        Iris.NextColumn()
        Iris.Checkbox({ "NoNav" }, { isChecked = NoNav })
        Iris.NextColumn()
        Iris.Checkbox({ "NoMenu" }, { isChecked = NoMenu })
        Iris.End()
        Iris.End()

        -- stylua: ignore end

        widgetEventInteractivity()

        widgetStateInteractivity()

        Iris.CollapsingHeader({ "Recursive Tree" })
        recursiveTree()
        Iris.End()

        dynamicStyle()

        Iris.Separator()

        Iris.CollapsingHeader({ "Widgets" })
        for _, name in widgetDemosOrder do
            widgetDemos[name]()
        end
        Iris.End()

        tablesDemo()

        layoutDemo()
        Iris.End()

        if showRecursiveWindow.value then
            recursiveWindow(showRecursiveWindow)
        end
        if showRuntimeInfo.value then
            runtimeInfo()
        end
        if showStyleEditor.value then
            styleEditor()
        end
        if showWindowlessDemo.value then
            windowlessDemo()
        end

        if showMainMenuBarWindow.value then
            mainMenuBarExample()
        end
    end
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.demoWindow

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Iris.Internal | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

return function(Iris: Types.Iris): Types.Internal
	local Internal = {} :: Types.Internal

	--[[
        ---------------------------------
            [SECTION] Properties
        ---------------------------------
    ]]

	Internal._started = false -- has Iris.connect been called yet
	Internal._cycleTick = 0 -- increments for each call to Cycle, used to determine the relative age and freshness of generated widgets

	-- Refresh
	Internal._globalRefreshRequested = false -- refresh means that all GUI is destroyed and regenerated, usually because a style change was made and needed to be propogated to all UI
	Internal._localRefreshActive = false -- if true, when _Insert is called, the widget called will be regenerated

	-- Widgets & Instances
	Internal._widgets = {}
	Internal._widgetCount = 0 -- only used to compute ZIndex, resets to 0 for every cycle
	Internal._stackIndex = 1 -- Points to the index that IDStack is currently in, when computing cycle
	Internal._rootInstance = nil
	Internal._rootWidget = {
		ID = "R",
		type = "Root",
		Instance = Internal._rootInstance,
		ZIndex = 0,
	}
	Internal._lastWidget = Internal._rootWidget -- widget which was most recently rendered

	-- Config
	Internal._rootConfig = {} -- root style which all widgets derive from
	Internal._config = Internal._rootConfig

	-- ID
	Internal._IDStack = { "R" }
	Internal._usedIDs = {} -- hash of IDs which are already used in a cycle, value is the # of occurances so that getID can assign a unique ID for each occurance
	Internal._pushedId = nil
	Internal._nextWidgetId = nil

	-- State
	Internal._states = {} -- Iris.States

	-- Callback
	Internal._postCycleCallbacks = {}
	Internal._connectedFunctions = {} -- functions which run each Iris cycle, connected by the user

	Internal._cycleCoroutine = coroutine.create(function()
		while true do
			for _, callback: () -> string in Internal._connectedFunctions do
				
local status: boolean, _error: string = pcall(callback)
				
if not status then
					-- any error reserts the _stackIndex for the next frame and yeilds the error.
					Internal._stackIndex = 1
					coroutine.yield(false, _error)
				end
				if Internal._stackIndex ~= 1 then
					-- has to be larger than 1 because of the check that it isint below 1 in Iris.End
					Internal._stackIndex = 1
					error("Callback has too few calls to Iris.End()", 0)
				end
			end
			-- after all callbacks, we yeild so it only runs once a frame.
			coroutine.yield(true)
		end
	end)

	--[[
        -----------------------
            [SECTION] State
        -----------------------
    ]]

	local StateClass = {}
	StateClass.__index = StateClass

	function StateClass:get(): any -- you can also simply use .value
		return self.value
	end

	function StateClass:set(newValue: any): any
		if newValue == self.value then
			-- no need to update on no change.
			return self.value
		end
		self.value = newValue
		for _, thisWidget: Types.Widget in self.ConnectedWidgets do
			Internal._widgets[thisWidget.type].UpdateState(thisWidget)
		end
		for _, callback in self.ConnectedFunctions do
			callback(newValue)
		end
		return self.value
	end

	function StateClass:onChange(callback: (newValue: any) -> ())
		table.insert(self.ConnectedFunctions, callback)
	end

	Internal.StateClass = StateClass

	--[[
        ---------------------------
            [SECTION] Functions
        ---------------------------
    ]]

	function Internal._cycle()
		--debug.profilebegin("Iris/Cycle")
		if Iris.Disabled then
			return -- Stops all rendering, effectively freezes the current frame with no interaction.
		end

		Internal._rootWidget.lastCycleTick = Internal._cycleTick
		if Internal._rootInstance == nil or Internal._rootInstance.Parent == nil then
			Iris.ForceRefresh()
		end

		for _, w [trimmed]  -  Edit
  14:15:00.084  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Line | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Origin = Transform.Position + (Transform.LookVector * (-Length * 0.5))
	local End = Transform.Position + (Transform.LookVector * (Length * 0.5))

	Ceive.Ray:Draw(Origin, End)
end

function Gizmo:Create(Transform: CFrame, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Length)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Line

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Mesh | Enabled: N/A
--------------------------------------------------------------------
local function Map(n, start, stop, newStart, newStop)
	return ((n - start) / (stop - start)) * (newStop - newStart) + newStart
end

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local maxX = -math.huge
	local maxY = -math.huge
	local maxZ = -math.huge

	local minX = math.huge
	local minY = math.huge
	local minZ = math.huge

	for _, vertex in Vertices do
		maxX = math.max(maxX, vertex.x)
		maxY = math.max(maxY, vertex.y)
		maxZ = math.max(maxZ, vertex.z)

		minX = math.min(minX, vertex.x)
		minY = math.min(minY, vertex.y)
		minZ = math.min(minZ, vertex.z)
	end

	for i, vertex in Vertices do
		local vX = Map(vertex.x, minX, maxX, -0.5, 0.5)
		local vY = Map(vertex.y, minY, maxY, -0.5, 0.5)
		local vZ = Map(vertex.z, minZ, maxZ, -0.5, 0.5)

		local vertexCFrame = Transform * CFrame.new(Vector3.new(vX, vY, vZ) * Size)
		Vertices[i] = vertexCFrame
	end

	for _, face in Faces do
		if #face == 3 then
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
			Ceive.Ray:Draw(vCF3.Position, vCF1.Position)
		else
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]
			local vCF4 = Vertices[face[4].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF1.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF4.Position, vCF2.Position)

			Ceive.Ray:Draw(vCF3.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
		end
	end
end

function Gizmo:Create(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		Vertices = Vertices,
		Faces = Faces,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.Vertices, PropertyTable.Faces)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Mesh

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Plane | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Position: Vector3, Normal: Vector3, Size: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Size *= Vector3.new(1, 1, 0)

	local Transform = CFrame.lookAt(Position, Position + Normal)

	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size * 0.5
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		Ceive.Ray:Draw(TopRight, BottomLeft)

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateZFace(sUv, sRv, sLv)
end

function Gizmo:Create(Position: Vector3, Normal: Vector3, Size: Vector3)
	local PropertyTable = {
		Position = Position,
		Normal = Normal,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Position, PropertyTable.Normal, PropertyTable.Size)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Plane

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Ray | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Origin: Vector3, End: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	if self.Propertys.AlwaysOnTop then
		Ceive.AOTWireframeHandle:AddLine(Origin, End)
	else
		Ceive.WireframeHandle:AddLine(Origin, End)
	end

	self.Ceive.ActiveRays += 1

	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Origin: Vector3, End: Vector3)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Ray

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Sphere | Enabled: N/A
--------------------------------------------------------------------
local Rad90D = math.rad(90)

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Ceive.Circle:Draw(Transform, Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(0, Rad90D, 0), Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(Rad90D, 0, 0), Radius, Subdivisions, Angle)
end

function Gizmo:Create(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Subdivisions = Subdivisions,
		Angle = Angle,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Subdivisions, PropertyTable.Angle)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Sphere

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Text | Enabled: N/A
--------------------------------------------------------------------
local DROP_SHADOW = true
local OFFSET_PERCENTAGE = 0.00175

local Camera = workspace.CurrentCamera

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Origin: Vector3, Text: string, Size: number?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	if self.Propertys.AlwaysOnTop then
		if DROP_SHADOW then
			local DistanceToCamera = (Origin - Camera.CFrame.Position).Magnitude
			local PrevColor = Ceive.PopProperty("Color3")

			Ceive.PushProperty("Color3", Color3.new())
			local Offset = -(Vector3.xAxis + Vector3.yAxis).Unit
			Ceive.AOTWireframeHandle:AddText(Origin + Offset * (DistanceToCamera * OFFSET_PERCENTAGE), Text, Size)
			Ceive.PushProperty("Color3", PrevColor)
		end

		Ceive.AOTWireframeHandle:AddText(Origin, Text, Size)
	else
		if DROP_SHADOW then
			local DistanceToCamera = (Origin - Camera.CFrame.Position).Magnitude
			local PrevColor = Ceive.PopProperty("Color3")

			Ceive.PushProperty("Color3", Color3.new())
			local Offset = -(Vector3.xAxis + Vector3.yAxis).Unit
			Ceive.WireframeHandle:AddText(Origin + Offset * (DistanceToCamera * OFFSET_PERCENTAGE), Text, Size)
			Ceive.PushProperty("Color3", PrevColor)
		end

		Ceive.WireframeHandle:AddText(Origin, Text, Size)
	end

	-- Should text count to active rays?
	--self.Ceive.ActiveRays += 1

	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Origin: Vector3, Text: string, Size: number?)
	local PropertyTable = {
		Origin = Origin,
		Text = Text,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.Text, PropertyTable.Size)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Text

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeArrow | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number, UseCylinder: boolean?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local ArrowCFrame = CFrame.lookAt(End - (End - Origin).Unit * (Length * 0.5), End)

	if UseCylinder == true then
		local BottomCone = ArrowCFrame.Position
		local CylinderLength = (BottomCone - Origin).Magnitude
		local CylinderCFrame = CFrame.lookAt((Origin + BottomCone) * 0.5, End)

		Ceive.VolumeCylinder:Draw(CylinderCFrame, CylinderRadius, CylinderLength)
	else
		Ceive.Ray:Draw(Origin, End)
	end

	Ceive.VolumeCone:Draw(ArrowCFrame, ConeRadius, Length)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number, UseCylinder: boolean?)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		CylinderRadius = CylinderRadius,
		ConeRadius = ConeRadius,
		Length = Length,
		UseCylinder = UseCylinder,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End, PropertyTable.Radius, PropertyTable.Length, PropertyTable.UseCylinder)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeArrow

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeBox | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Size: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Box = self.Request("BoxHandleAdornment")
	Box.Color3 = self.Propertys.Color3
	Box.Transparency = self.Propertys.Transparency

	Box.CFrame = Transform
	Box.Size = Size
	Box.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Box.ZIndex = 1
	Box.Adornee = Terrain
	Box.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Box)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Size: Vector3)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeBox

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCone | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cone = self.Request("ConeHandleAdornment")
	Cone.Color3 = self.Propertys.Color3
	Cone.Transparency = self.Propertys.Transparency

	Cone.CFrame = Transform
	Cone.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cone.ZIndex = 1
	Cone.Height = Length
	Cone.Radius = Radius
	Cone.Adornee = Terrain
	Cone.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cone)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Radius: number, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCone

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCylinder | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cylinder = self.Request("CylinderHandleAdornment")
	Cylinder.Color3 = self.Propertys.Color3
	Cylinder.Transparency = self.Propertys.Transparency

	Cylinder.CFrame = Transform
	Cylinder.Height = Length
	Cylinder.Radius = Radius
	Cylinder.InnerRadius = InnerRadius or 0
	Cylinder.Angle = Angle or 360
	Cylinder.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cylinder.ZIndex = 1
	Cylinder.Adornee = Terrain
	Cylinder.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cylinder)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		InnerRadius = InnerRadius or 0,
		Angle = Angle or 360,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.InnerRadius, PropertyTable.Angle)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeCylinder

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeSphere | Enabled: N/A
--------------------------------------------------------------------
local Terrain = workspace.Terrain

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

function Gizmo:Draw(Transform: CFrame, Radius: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Sphere = self.Request("SphereHandleAdornment")
	Sphere.Color3 = self.Propertys.Color3
	Sphere.Transparency = self.Propertys.Transparency

	Sphere.CFrame = Transform
	Sphere.Radius = Radius
	Sphere.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Sphere.ZIndex = 1
	Sphere.Adornee = Terrain
	Sphere.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Sphere)
	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Transform: CFrame, Radius: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.VolumeSphere

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Wedge | Enabled: N/A
--------------------------------------------------------------------
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Position = Transform.Position
	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size * 0.5
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local YTopLeft
	local YTopRight

	local ZBottomLeft
	local ZBottomRight

	local function CalculateYFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (lUv - lRv - lLv)
		local BottomRight = Position + (lUv + lRv - lLv)

		YTopLeft = TopLeft
		YTopRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		ZBottomLeft = TopLeft
		ZBottomRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateYFace(-sUv, sRv, sLv)

	CalculateZFace(sUv, sRv, -sLv)

	Ceive.Ray:Draw(YTopLeft, ZBottomLeft)
	Ceive.Ray:Draw(YTopRight, ZBottomRight)
	if DrawTriangles ~= false then
		Ceive.Ray:Draw(YTopRight, ZBottomLeft)
	end
end

function Gizmo:Create(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		DrawTriangles = DrawTriangles,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.DrawTriangles)
end

return Gizmo

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.Gizmo.Gizmos.Wedge

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay | Enabled: N/A
--------------------------------------------------------------------
-- TODO: Figure out the metatable stuff we should do here
return require(script.CeiveImOverlay)

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay.CeiveImOverlay | Enabled: N/A
--------------------------------------------------------------------
local GuiService = game:GetService("GuiService")

export type ImOverlay = {
	DefaultY: number,
	TextSize: number,
	BackFrame: Frame,
	ListLayout: UIListLayout,
	DidUpdate: boolean,
	Begin: (self: ImOverlay, Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: (self: ImOverlay) -> (),
	Text: (self: ImOverlay, Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	Render: (self: ImOverlay) -> (),
	Destroy: (self: ImOverlay) -> ()
}

local Font = Font.new("rbxasset://fonts/families/PressStart2P.json")
local UseScrollingFrame = false

local ImOverlay = {}
ImOverlay.__index = ImOverlay

function ImOverlay.new(DefaultY: number?, TextSize: number?, UseInset: boolean?): ImOverlay
	DefaultY = DefaultY or 5
	TextSize = TextSize or 11
	UseInset = (UseInset == nil and true or UseInset)

	-- Magic numbers
	local InsetPosition = UDim2.fromOffset(25, 5 + GuiService:GetGuiInset().Y)
	local InsetSize = UDim2.new(1, -25, 1, -5)

	local DefaultPosition = UDim2.fromOffset(0, 0)
	local DefaultSize = UDim2.fromScale(1, 1)

	local self = setmetatable({}, ImOverlay)

	self.DefaultY = DefaultY
	self.TextSize = TextSize

	self.BackFrame = UseScrollingFrame and Instance.new("ScrollingFrame") or Instance.new("Frame")
	self.BackFrame.Position = (UseInset and InsetPosition or DefaultPosition)
	self.BackFrame.Size = (UseInset and InsetSize or DefaultSize)
	self.BackFrame.Name = "BackFrame"
	self.BackFrame.Transparency = 1

	self.ListLayout = Instance.new("UIListLayout")
	self.ListLayout.Padding = UDim.new(0, 2)
	self.ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	self.ListLayout.Parent = self.BackFrame

	self.m_Indent = 0

	self.DidUpdate = false

	-- Decide if we should re-render this frame
	self.m_State = ""
	self.m_PreviousState = ""

	self.m_RenderGroup = {}
	self.m_ItemPool = {}

	return self
end

function ImOverlay:Begin(Text: string, BackgroundColor: Color3?, TextColor: Color3?)
	if not Text or type(Text) ~= "string" then
		warn("Expected text to ImOverlay::Begin", debug.traceback())
		return
	end

	if BackgroundColor and typeof(BackgroundColor) ~= "Color3" then
		warn("BackgroundColor should be a Color3", debug.traceback())
		return
	end

	if TextColor and typeof(TextColor) ~= "Color3" then
		warn("TextColor should be a Color3", debug.traceback())
		return
	end

	self:Text(Text, BackgroundColor, TextColor)
	self.m_Indent += 1
end

function ImOverlay:End()
	if self.m_Indent - 1 < 0 then
		error("Too many callbacks to ImOverlay::End")
		return
	end

	self.m_Indent -= 1
end

function ImOverlay:Text(Text: string, BackgroundColor: Color3?, TextColor: Color3?)
	if not Text or type(Text) ~= "string" then
		warn("Expected text to ImOverlay::Text", debug.traceback())
		return
	end

	if BackgroundColor and typeof(BackgroundColor) ~= "Color3" then
		warn("BackgroundColor should be a Color3", debug.traceback())
		return
	end

	if TextColor and typeof(TextColor) ~= "Color3" then
		warn("TextColor should be a Color3", debug.traceback())
		return
	end

	BackgroundColor = BackgroundColor or Color3.new()
	TextColor = TextColor or Color3.new(1, 1, 1)

	table.insert(self.m_RenderGroup, {
		Text = Text,
		TextColor = TextColor,
		BackgroundColor = BackgroundColor,
		Indent = self.m_Indent,
	})

	self.m_State ..= `{Text}|{TextColor}|{BackgroundColor}|{self.m_Indent}`
end

function ImOverlay:m_Pool()

	
for _, Obj in self.BackFrame:GetChildren() do
		if Obj:IsA("UIListLayout") or not Obj.Visible then
			continue
		end

		-- Quicker to change visibility than to re-parent
		Obj.Visible = false
		table.insert(self.m_ItemPool, Obj)
	end

end

function ImOverlay:m_Cleanup()
	
self.m_State = ""
	self.m_Indent = 0
	self.m_RenderGroup = {}

end

function ImOverlay:m_CreateLabel(Text: string, TextColor: Color3, BackgroundColor: Color3, Indent: number): Frame
	
local background = Instance.new("Frame")
	background.Name = "Background"
	background.AutomaticSize = Enum.AutomaticSize.XY
	background.BackgroundColor3 = BackgroundColor
	background.BackgroundTransparency = 0.4
	background.BorderSizePixel = 0

	local taskText = Instance.new("TextLabel")
	taskText.Name = "TaskText"
	taskText.FontFace = Font
	taskText.Text = Text
	taskText.TextColor3 = TextColor
	taskText.TextSize = self.TextSize
	taskText.TextXAlignment = Enum.TextXAlignment.Left
	taskText.AutomaticSize = Enum.AutomaticSize.XY
	taskText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	taskText.BackgroundTransparency = 1
	taskText.Position = UDim2.fromOffset(50 * Indent, 0)
	taskText.Size = UDim2.fromOffset(0, self.DefaultY)
	taskText.Parent = background

	local uIPadding2 = Instance.new("UIPadding")
	uIPadding2.Name = "UIPadding"
	uIPadding2.PaddingBottom = UDim.new(0, 2)
	uIPadding2.Parent = taskText

	local uIPadding = Instance.new("UIPadding")
	uIPadding.Name = "UIPadding"
	uIPadding.PaddingRight = UDim.new(0, 5)
	uIPadding.PaddingLeft = UDim.new(0, 5)
	uIPadding.Parent = background
	
return background
end

function ImOverlay:Render()
	-- We arent doing anything this frame
	
if self.m_State == "" then
		self:m_Pool()
		self:m_Cleanup()
		self.DidUpdate = false
		
return
	end

	self.m_State ..= `{self.DefaultY}|{self.TextSize}`

	if self.m_State == self.m_PreviousState then
		self:m_Cleanup()
		self.DidUpdate = false
		
return
	else
		self:m_Pool()
	end

	self.m_PreviousState = self.m_State
	self.DidUpdate = true

	for i, Render in self.m_RenderGroup do
		
if #self.m_ItemPool == 0 then
			local Label = self:m_CreateLabel(Render.Text, Render.TextColor, Render.BackgroundColor, Render.Indent)
			Label.LayoutOrder = i
			Label.Parent = self.BackFrame
			
continue
		end
		

local Label = table.remove(self.m_ItemPool, #self.m_ItemPool)
		local TaskText = Label.TaskText

		Label.LayoutOrder = i
		Label.BackgroundColor3 = Render.BackgroundColor
		TaskText.Text = Render.Text
		TaskText.TextColor3 = Render.TextColor
		TaskText.Position = UDim2.fromOffset(50 * Render.Indent, 0)

		Label.Visible = true
		Label.Parent = self.BackFrame
	


end

	self:m_Cleanup()


end

function ImOverlay:Destroy()
	self.BackFrame:Destroy()

	setmetatable(self, nil)
end

return ImOverlay

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.ImOverlay.CeiveImOverlay

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.DebugUi | Enabled: N/A
--------------------------------------------------------------------
-- -------------------------------------------------------------------------- --
--                      Iris runtime editor for SmartBone                     --
-- -------------------------------------------------------------------------- --

local EditingBones = {}
local EditingColliders = {}

-- Title, Description, Flag
local DebugFlags = {
	{ "Draw Internal Bone", "Draws a sphere with the specified radius of the bone around where SmartBone believes the bone is.", "DRAW_BONE" },
	{ "Draw Physical Bone", "Draws the actual bone objects CFrame with axis arrows.", "DRAW_PHYSICAL_BONE" },
	{ "Draw Root Part", "Draws a bounding box and fills in the root part.", "DRAW_ROOT_PART" },
	{ "Draw Bounding Box", "Draws the bounding box used for frustum culling.", "DRAW_BOUNDING_BOX" },
	{ "Draw Axis Limits", "Draws the axis limits for each bone.", "DRAW_AXIS_LIMITS" },
	{ "Draw Rotation Limits", "Draws the rotation limits for each bone.", "DRAW_ROTATION_LIMITS" },
	{ "Draw Acceleration Info", "Draws the acceleration and the required values to derive it.", "DRAW_ACCELERATION_INFO" },
	{ "Draw Colliders", "Draws all the colliders this root object can collide with.", "DRAW_COLLIDERS" },
	{ "Draw Collider Influence", "Shows the sphere of influence around each collider.", "DRAW_COLLIDER_INFLUENCE" },
	{ "Draw Collider Awake", "Shows if a collider is awake or asleep.", "DRAW_COLLIDER_AWAKE" },
	{ "Draw Collider BroadPhase", "Shows if a collider isn't reaching NarrowPhase.", "DRAW_COLLIDER_BROADPHASE" },
	{ "Draw Fill Colliders", "Fills all colliders this root object can collide with.", "DRAW_FILL_COLLIDERS" },
	{ "Draw Contacts", "Draws the position and normal of the points which bones collide with colliders.", "DRAW_CONTACTS" },
}

local function infoText(Iris, text)
	Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
	Iris.Text({ text })
	Iris.PopConfig()
end

local function helpMarker(Iris, helpText)
	Iris.PushConfig({ TextColor = Iris._config.TextDisabledColor })
	local text = Iris.Text({ "(?)" })
	Iris.PopConfig()

	Iris.PushConfig({ ContentWidth = UDim.new(0, 350) })
	if text.hovered() then
		Iris.Tooltip({ helpText })
	end
	Iris.PopConfig()
end

local function BoneEditor(Iris, BoneObject)
	local Window = Iris.Window({ `Editing bone: {BoneObject.Bone.Name}` })
	Window.isOpened.value = true

	local Radius = Iris.InputNum({ "Radius", 0.1, 0, math.huge, "%.3f" }, { number = BoneObject.Radius })
	BoneObject.Radius = Radius.number.value

	local RotationLimit = Iris.InputNum({ "Rotation Limit", 0.1, 0, 180, "%.3f" }, { number = BoneObject.RotationLimit })
	BoneObject.RotationLimit = RotationLimit.number.value

	local IsAnchored = Iris.Checkbox({ "Anchored" }, { isChecked = BoneObject.Anchored })
	BoneObject.Anchored = IsAnchored.isChecked.value

	Iris.Text("Axis Lock")
	Iris.Indent()

	Iris.SameLine()
	Iris.Text("X: ")
	local XLock = Iris.Checkbox({ "" }, { isChecked = BoneObject.AxisLocked[1] })
	Iris.Text("Y: ")
	local YLock = Iris.Checkbox({ "" }, { isChecked = BoneObject.AxisLocked[2] })
	Iris.Text("Z: ")
	local ZLock = Iris.Checkbox({ "" }, { isChecked = BoneObject.AxisLocked[3] })
	Iris.End()

	Iris.End()

	local XLimit = Iris.State(Vector2.new(BoneObject.XAxisLimits.Min, BoneObject.XAxisLimits.Max))
	local YLimit = Iris.State(Vector2.new(BoneObject.YAxisLimits.Min, BoneObject.YAxisLimits.Max))
	local ZLimit = Iris.State(Vector2.new(BoneObject.ZAxisLimits.Min, BoneObject.ZAxisLimits.Max))

	Iris.Text("Axis Limits")
	Iris.Indent()

	Iris.DragVector2({ "X Axis Limit", 0.05, nil, nil, { "Min: %.2f", "Max: %.2f" } }, { number = XLimit })
	Iris.DragVector2({ "Y Axis Limit", 0.05, nil, nil, { "Min: %.2f", "Max: %.2f" } }, { number = YLimit })
	Iris.DragVector2({ "Z Axis Limit", 0.05, nil, nil, { "Min: %.2f", "Max: %.2f" } }, { number = ZLimit })

	Iris.End()

	Iris.End()

	BoneObject.AxisLocked[1] = XLock.isChecked.value
	BoneObject.AxisLocked[2] = YLock.isChecked.value
	BoneObject.AxisLocked[3] = ZLock.isChecked.value

	BoneObject.XAxisLimits = NumberRange.new(XLimit:get().X, XLimit:get().Y)
	BoneObject.YAxisLimits = NumberRange.new(YLimit:get().X, YLimit:get().Y)
	BoneObject.ZAxisLimits = NumberRange.new(ZLimit:get().X, ZLimit:get().Y)

	if Window.closed() then
		EditingBones[BoneObject] = nil
	end
end

local function ColliderEditor(Iris, Collider)
	local Window = Iris.Window({ `Editing collider of type: {Collider.Type}` })
	Window.isOpened.value = true

	local ColliderType = Iris.State(Collider.Type)
	local ColliderScale = Iris.State(Collider.Scale)
	local ColliderOffset = Iris.State(Collider.Offset)
	local ColliderRotation = Iris.State(Collider.Rotation)

	Iris.Combo({ "Collider Type" }, { index = ColliderType })
	Iris.Selectable({ "Box", "Box" }, { index = ColliderType })
	Iris.Selectable({ "Sphere", "Sphere" }, { index = ColliderType })
	Iris.Selectable({ "Capsule", "Capsule" }, { index = ColliderType })
	Iris.End()

	Iris.DragVector3({ "Scale", 0.1, 0, nil }, { number = ColliderScale })
	Iris.DragVector3({ "Offset", 0.1, nil, nil }, { number = ColliderOffset })
	Iris.DragVector3({ "Rotation", 0.5, -180, 180 }, { number = ColliderRotation })

	Collider.Type = ColliderType:get()
	Collider.Scale = ColliderScale:get()
	Collider.Offset = ColliderOffset:get()
	Collider.Rotation = ColliderRotation:get()

	Iris.End()

	if Window.closed() then
		EditingColliders[Collider] = nil
	end
end

return function(Iris, RootObject, DebugState)
	local BoneObjects = {}

	for _, BoneTree in RootObject.BoneTrees do
		local RootPart = BoneTree.RootPart

		local TreeTable = BoneObjects[RootPart]

		if not TreeTable then
			BoneObjects[RootPart] = {}
			TreeTable = BoneObjects[RootPart]
		end

		table.insert(TreeTable, BoneTree)
	end

	for Bone, _ in EditingBones do
		local BoneId = `{RootObject.ID} - {Bone.ParentIndex + 1}`

		Iris.PushId(BoneId)
		BoneEditor(Iris, Bone)
		Iris.PopId()
	end

	for Collider, _ in EditingColliders do
		local ColliderId = Collider.GUID

		Iris.PushId(ColliderId)
		ColliderEditor(Iris, Collider)
		Iris.PopId()
	end

	local BoneTreeCount = #RootObject.BoneTrees
	local ColliderCount = #RootObject.ColliderObjects

	local BoneTreeText = `{BoneTreeCount} BoneTree{BoneTreeCount == 1 and "" or "s"}`
	local ColliderText = `{ColliderCount} Collider{ColliderCount == 1 and "" or "s"}`

	Iris.Window({ `SmartBone Runtime Editor. {BoneTreeText}, {ColliderText}`, [Iris.Args.Window.NoClose] = true })

	Iris.Tree({ "Debug Gizmos", true }, { isUncollapsed = true })

	for _, Flag in DebugFlags do
		Iris.SameLine()
		Iris.Checkbox({ Flag[1] }, { isChecked = DebugState[Flag[3] ] })
		helpMarker(Iris, Flag[2])
		Iris.End()
	end

	Iris.End()

	Iris.Separator()

	infoText(Iris, "Simulated Objects")

	for RootPart, TreeTable in BoneObjects do
		Iris.Tree(`{RootPart.Name} - Root Part`)

		for i, BoneTree in TreeTable do
			Iris.Tree(`BoneTree #{i}`)
			local ThrottledFps = string.format("%.1f", BoneTree.UpdateRate)
			local TargetFps = string.format("%.1f", BoneTree.Settings.UpdateRate)

			infoText(Iris, `Throttled Update Rate: {ThrottledFps} / {TargetFps} fps`)
			infoText(Iris, `In View: {BoneTree.InView}`)

			local ConstraintIndex = Iris.State(BoneTree.Settings.Constraint)
			local WindIndex = Iris.State(BoneTree.Settings.WindType)

			local UpdateRate = Iris.State(BoneTree.Settings.UpdateRate)
			local ActivationDistance = Iris.State(BoneTree.Settings.ActivationDistance)
			local ThrottleDistance = Iris.State(BoneTree.Settings.ThrottleDistance)

			Iris.SameLine()
			helpMarker(Iris, "The constraint used, distance is more flowy while spring is more rigid.")
			Iris.Combo({ "Constraint Type" }, { index = ConstraintIndex })
			Iris.Selectable({ "Distance", "Distance" }, { index = ConstraintIndex })
			Iris.Selectable({ "Spring", "Spring" }, { index = ConstraintIndex })
			Iris.End()
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The wind solver used, sine is a smoother wind, noise is more chaotic and hybrid is a mix of the two.")
			Iris.Combo({ "Wind Type" }, { index = WindIndex })
			Iris.Selectable({ "Sine", "Sine" }, { index = WindIndex })
			Iris.Selectable({ "Noise", "Noise" }, { index = WindIndex })
			Iris.Selectable({ "Hybrid", "Hybrid" }, { index = WindIndex })
			Iris.End()
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The target update rate for the bone tree")
			Iris.SliderNum({ "Update Rate", 5, 0, 120 }, { number = UpdateRate })
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The distance at which the bone tree stops updating")
			Iris.SliderNum({ "Activation Distance", 1, 0, 500 }, { number = ActivationDistance })
			Iris.End()

			Iris.SameLine()
			helpMarker(Iris, "The distance at which the bone tree starts throttling its update rate")
			Iris.SliderNum({ "Throttle Distance", 1, 0, 500 }, { number = ThrottleDistance })
			Iris.End()

			BoneTree.Settings.Constraint = ConstraintIndex:get()
			BoneTree.Settings.WindType = WindIndex:get()
			BoneTree.Settings.UpdateRate = UpdateRate:get()
			BoneTree.Settings.ActivationDistance = ActivationDistance:get()
			BoneTree.Settings.ThrottleDistance = ThrottleDistance:get()

			Iris.Table({ 4, false, false, false })

			Iris.NextColumn()
			Iris.Text("Bone #")
			Iris.NextColumn()
			Iris.Text("Bone Name")
			Iris.NextColumn()
			Iris.Text("Parent #")
			Iris.NextColumn()
			Iris.Text("Edit")

			Iris.End()

			Iris.Table({ 4 })

			for Index, Bone in BoneTree.Bones do
				-- if Index == #BoneTree.Bones then
				-- 	break
				-- end

				Iris.NextColumn()
				Iris.Text(tostring(Index))
				Iris.NextColumn()
				Iris.Text(Bone.Bone.Name)
				Iris.NextColumn()
				Iris.Text(tostring(Bone.ParentIndex))
				Iris.NextColumn()
				Iris.SameLine()
				Iris.Text("")
				if Iris.SmallButton({ "Edit" }).clicked() then
					EditingBones[Bone] = true
				end
				Iris.End()
			end

			Iris.End()
			Iris.End()
		end

		Iris.End()
	end

	infoText(Iris, "Active Colliders")

	for _, ColliderObject in RootObject.ColliderObjects do
		Iris.Tree({ ColliderObject.m_Object.Name })

		infoText(Iris, "Colliders adorned to this object")

		Iris.Table({ 5, false, false, false })
		Iris.NextColumn()
		Iris.Text("Type")
		Iris.NextColumn()
		Iris.Text("Scale")
		Iris.NextColumn()
		Iris.Text("Offset")
		Iris.NextColumn()
		Iris.Text("Rotation")
		Iris.NextColumn()
		Iris.Text("Edit")
		Iris.End()

		Iris.Table({ 5 })

		for _, Collider in ColliderObject.Colliders do
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Type))
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Scale))
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Offset))
			Iris.NextColumn()
			Iris.Text(tostring(Collider.Rotation))
			Iris.NextColumn()
			Iris.SameLine()
			Iris.Text("")
			if Iris.SmallButton({ "Edit" }).clicked() then
				EditingColliders[Collider] = true
			end
			Iris.End()
		end

		Iris.End()

		Iris.End()
	end

	Iris.End()
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Dependencies.Debug.DebugUi

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Bone | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
--!native
local Dependencies = script.Parent.Parent:WaitForChild("Dependencies")
local Config = require(Dependencies:WaitForChild("Config"))
local Gizmo = require(Dependencies:WaitForChild("Debug"):WaitForChild("Gizmo"))
local Utilities = require(Dependencies:WaitForChild("Utilities"))

local Constraints = script.Parent:WaitForChild("Constraints")
local AxisConstraint = require(Constraints:WaitForChild("AxisConstraint"))
local CollisionConstraint = require(Constraints:WaitForChild("CollisionConstraint"))
local DistanceConstraint = require(Constraints:WaitForChild("DistanceConstraint"))
local FrictionConstraint = require(Constraints:WaitForChild("FrictionConstraint"))
local RopeConstraint = require(Constraints:WaitForChild("RopeConstraint"))
local RotationConstraint = require(Constraints:WaitForChild("RotationConstraint"))
local SpringConstraint = require(Constraints:WaitForChild("SpringConstraint"))

local SB_ASSERT_CB = Utilities.SB_ASSERT_CB
--local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG

-- HACK
local MAX_SPEED = 50

local function SafeUnit(Vector: Vector3): Vector3
	if Vector.Magnitude == 0 then
		return Vector3.zero
	else
		return Vector.Unit
	end
end

type bool = boolean

type ImOverlay = {
	Begin: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: () -> (),
	Text: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> ()
}

export type IBone = {
	Bone: Bone,
	RootBone: Bone,
	RootPart: BasePart,
	FreeLength: number,
	Weight: number,
	ParentIndex: number,
	HeirarchyLength: number,
	Transform: CFrame,
	LocalTransform: CFrame,
	Radius: number,
	Friction: number,
	RotationLimit: number,
	Force: Vector3?,
	Gravity: Vector3?,

	SolvedAnimatedCFrame: bool,
	HasChild: bool,
	--NumberOfChildren: number,
	IsSkippingUpdates: bool,

	--RotationSum: Vector3,

	AnimatedWorldCFrame: CFrame,
	TransformOffset: CFrame,
	LocalTransformOffset: CFrame,
	RestPosition: Vector3,
	CalculatedWorldCFrame: CFrame,

	Position: Vector3,
	LastPosition: Vector3,

	ActiveWeld: bool,
	WeldPosition: Vector3,
	WeldCFrame: CFrame,

	Anchored: bool,
	AxisLocked: { [number]: bool },
	XAxisLimits: NumberRange,
	YAxisLimits: NumberRange,
	ZAxisLimits: NumberRange,

	CollisionHits: { [number]: BasePart }
}

local function IsNaN(Value: any): bool
	if Value ~= Value then
		return true
	end

	return false
end

local SolvedTransformedCFrames = {}

-- I beg roblox to make TransformedWorldCFrame parallel safe
local function QueryTransformedWorldCFrameNonSmartbone(OriginBone: Bone): CFrame
	
local Solved = SolvedTransformedCFrames[OriginBone]
	if Solved then
		if Solved.Frame == shared.FrameCounter then
			return Solved.CFrame
		end
	end

	local Parent = OriginBone.Parent :: Bone | BasePart
	local ParentCFrame

	if Parent:IsA("Bone") then
		ParentCFrame = QueryTransformedWorldCFrameNonSmartbone(Parent)
	else -- This should always be a basepart unless someone has the weirdest model setup ever. If that person is you, why?
		ParentCFrame = Parent.CFrame
	end

	local Result = ParentCFrame * OriginBone.TransformedCFrame

	SolvedTransformedCFrames[OriginBone] = { Frame = shared.FrameCounter, CFrame = Result }
	

return Result
end

-- Gets transformedworldcframe using the parents animatedcframe instead of traversing the tree of bones for each bone, increases performance a ton
local function QueryTransformedWorldCFrame(BoneTree, Bone: IBone): CFrame
	
Bone.SolvedAnimatedCFrame = true

	local ParentIndex = Bone.ParentIndex
	local BoneObject = Bone.Bone

	if ParentIndex < 1 then -- We are no longer in the smartbone tree
		
return QueryTransformedWorldCFrameNonSmartbone(BoneObject)
	end

	local ParentBone: IBone = BoneTree.Bones[ParentIndex]

	if not ParentBone.SolvedAnimatedCFrame then
		ParentBone.AnimatedWorldCFrame = QueryTransformedWorldCFrame(BoneTree, ParentBone)
	end
	

return ParentBone.AnimatedWorldCFrame * BoneObject.TransformedCFrame
end

local function ClipVector(LastPosition: Vector3, Position: Vector3, Vector: Vector3): Vector3
	LastPosition *= (Vector3.one - Vector)
	LastPosition += (Position * Vector)
	return LastPosition
end

local function GetFriction(Object0: BasePart, Object1: BasePart): number
	local Prop0 = Object0.CurrentPhysicalProperties
	local Prop1 = Object1.CurrentPhysicalProperties

	local f0 = Prop0.Friction
	local w0 = Prop0.FrictionWeight

	local f1 = Prop1.Friction
	local w1 = Prop1.FrictionWeight

	return (f0 * w0 + f1 * w1) / (w0 + w1)
end

local function SolveWind(self: IBone, BoneTree: any, Velocity: Vector3): Vector3
	
local Settings = BoneTree.Settings
	local WindType = Settings.WindType

	if WindType ~= "Sine" and WindType ~= "Noise" and WindType ~= "Hybrid" then
		
return Vector3.zero -- If the wind type the user inputted doesn't exist, I would throw an error / warn but that would crash studio :(
	end

	local TimeModifier = BoneTree.WindOffset
		+ (
			((os.clock() - (self.HeirarchyLength * 0.2)) + (self.TransformOffset.Position - BoneTree.Root.WorldPosition).Magnitude * 0.2) -- * 0.2 is / 5
			* Settings.WindInfluence
		)

	local WindSpeed = Settings.WindSpeed
	local WindStrength = Settings.WindStrength

	if WindSpeed <= 1e-6 or WindStrength <= 1e-6 then
		
return Vector3.zero
	end

	-- Velocity multiplier
	local WindDirection = Settings.WindDirection
	local VelocityDirection = SafeUnit(Velocity)
	


local WindDamper = 1 - math.abs(VelocityDirection:Dot(WindDirection))

	-- This section of code manages the following:
	-- If we are going into the wind then if our bone speed is the same as the wind speed then we should apply double the wind speed, contrary
	-- If we are going with the wind if our bone speed is the same as the wind speed then we wind speed should be zero for this bone.
	if WindSpeed > 0 then
		if VelocityDirection:Dot(WindDirection) > 0 then -- Going with the wind
			local SpeedMatch = 1 - Velocity.Magnitude / WindSpeed
			WindDamper *= math.abs(SpeedMatch)
		else -- Going against the wind
			local SpeedMatch = 1 + Velocity.Magnitude / WindSpeed
			WindDamper *= SpeedMatch
		end
	end

	
WindSpeed *= WindDamper

	local function EaseInExpo(x: number): number
		return x == 0 and 0 or 2 ^ (10 * x - 10)
	end

	local SpeedAlpha = Velocity.Magnitude < 100 and Velocity.Magnitude or 100
	local SpeedMultiplier = math.min(EaseInExpo(SpeedAlpha), 100)
	TimeModifier *= math.max(SpeedMultiplier, 1)

	if WindSpeed < 1 then
		WindSpeed *= SpeedMultiplier
	else
		local Mult = SpeedMultiplier / 2
		WindSpeed *= (Mult > 1 and Mult or 1)
	end

	local WindMove

	local function GetNoise(X, Y, Z, Map) -- Returns noise between 0, 1
		
local Value = math.noise(X, Y, Z)
		Value = math.clamp(Value, -1, 1)

		if Map then
			Value ^= 2
		end
		
return Value
	end

	local function SampleGust()
		local Length = 0.3
		local Freq = 1
		return math.sin(TimeModifier * Freq) * Length + (1 - Length)
	end

	local function SampleSin()
		
local Freq = WindStrength ^ 0.8
		local Power = WindSpeed * 2

		-- Multiple octaves of sin waves
		local Sin0 = math.sin(TimeModifier * Freq)
		local Sin1 = math.cos(TimeModifier / 10 * Freq)
		local Sin2 = math.sin(TimeModifier * 2 * Freq)
		local Sin3 = math.cos(TimeModifier * 3 * Freq)
		local Wave = (Sin0 + Sin1 + Sin2 + Sin3) / 4
		local ScaledWave = Wave * 0.5 + 0.5
		Wave *= Power
		ScaledWave *= Power
		
return WindDirection * (ScaledWave > Wave and ScaledWave or Wave)
	end

	local function SampleNoise(CustomAmp, Map)
		
CustomAmp = CustomAmp or 0

		local Freq = WindStrength ^ 0.8
		local Power = WindSpeed * 2
		local Seed = BoneTree.WindOffset

		local X = GetNoise(Freq, 0, Seed, Map) * (Power + CustomAmp)
		local Y = GetNoise(0, Freq, Seed, Map) * (Power + CustomAmp)
		local Z = GetNoise(Seed, 0, Freq, Map) * (Power + CustomAmp)
		
return WindDirection * Vector3.new(X, Y, Z)
	end
	

if Settings.WindType == "Sine" then
		
WindMove = SampleSin() * SampleGust()
	
elseif Settings.WindType == "Noise" then
		
WindMove = SampleNoise(0, true) * SampleGust()
	
elseif Settings.WindType == "Hybrid" then
		
WindMove = SampleSin() * SampleGust()
		WindMove += SampleNoise(0.5, true) * SampleGust()
		WindMove *= 0.5
	
end

	
WindMove /= self.FreeLength < 0.01 and 0.01 or self.FreeLength
	WindMove *= (Settings.WindInfluence * (WindStrength * 0.01)) * (math.clamp(self.HeirarchyLength, 1, 10) * 0.1)
	WindMove *= self.Weight
	

return WindMove
end

--- @class Bone
--- Internal class for all bones
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within Bone
--- @readonly
--- @prop Bone Bone

--- @within Bone
--- @prop FreeLength number

--- @within Bone
--- @prop Weight number

--- @within Bone
--- @readonly
--- @prop ParentIndex number

--- @within Bone
--- @readonly
--- @prop HeirarchyLength number

--- @within Bone
--- @prop Transform CFrame

--- @within Bone
--- @prop LocalTransform CFrame

--- @within Bone
--- @readonly
--- @prop RootPart BasePart

--- @within Bone
--- @readonly
--- @prop RootBone Bone

--- @within Bone
--- @prop Radius number

--- @within Bone
--- @prop Friction number

--- @within Bone
--- @prop RotationLimit number

--- @within Bone
--- @prop Force Vector3?

--- @within Bone
--- @prop Gravity Vector3?

--- @within Bone
--- @prop SolvedAnimatedCFrame boolean
--- Describes if this bone has already solved its animated world cframe, this is used for optimization.

--- @within Bone
--- @prop HasChild boolean

--- @within Bone
--- @readonly
--- @prop AnimatedWorldCFrame CFrame
--- Bone.TransformedWorldCFrame

--- @within Bone
--- @prop StartingCFrame CFrame

--- @within Bone
--- @readonly
--- @prop TransformOffset CFrame

--- @within Bone
--- @readonly
--- @prop LocalTransformOffset CFrame

--- @within Bone
--- @readonly
--- @prop RestPosition Vector3

--- @within Bone
--- @readonly
--- @prop CalculatedWorldCFrame CFrame

--- @within Bone
--- @prop Position Vector3
--- Internal representation of the bone

--- @within Bone
--- @prop LastPosition Vector3
--- Internal representation of the bone's position last frame

--- @within Bone
--- @prop WeldPosition Vector3

--- @within Bone
--- @prop WeldCFrame CFrame

--- @within Bone
--- @prop ActiveWeld boolean
--- Describes if this bone has a weld

--- @within Bone
--- @prop RigidWeld boolean
--- If the bone has a weld, is it rigid

--- @within Bone
--- @prop Anchored boolean

--- @within Bone
--- @prop AxisLocked { boolean, boolean, boolean }
--- XYZ order

--- @within Bone
--- @prop XAxisLimits NumberRange

--- @within Bone
--- @prop YAxisLimits NumberRange

--- @within Bone
--- @prop ZAxisLimits NumberRange

--- @within Bone
--- @prop IsSkippingUpdates boolean

--- @within Bone
--- @prop CollisionHits {}

--- @within Bone
--- @prop CollisionData {}
--- Debug property, holds information about the collisions that the bone had this frame

local Class = {}
Class.__index = Class

function Class.new(Bone: Bone, RootBone: Bone, RootPart: BasePart): IBone
	local ParentCFrame = Bone.Parent:IsA("Bone") and Bone.Parent.TransformedWorldCFrame or RootPart.CFrame

	local self = setmetatable({
		Bone = Bone,
		FreeLength = -1,
		Weight = 0.7,
		ParentIndex = -1,
		HeirarchyLength = 0,
		Transform = Bone.TransformedWorldCFrame:ToObjectSpace(ParentCFrame):Inverse(),
		LocalTransform = Bone.TransformedCFrame:ToObjectSpace(RootBone.TransformedCFrame):Inverse(),
		RootPart = RootPart,
		RootBone = RootBone,
		Radius = 0,
		Friction = 0,
		RotationLimit = 0,
		Force = nil,
		Gravity = nil,

		SolvedAnimatedCFrame = false,
		HasChild = false,
		--NumberOfChildren = 0,
		--RotationSum = Vector3.zero,

		AnimatedWorldCFrame = Bone.TransformedWorldCFrame,
		StartingCFrame = Bone.TransformedCFrame,
		TransformOffset = CFrame.identity,
		LocalTransformOffset = CFrame.identity,
		RestPosition = Vector3.zero,
		CalculatedWorldCFrame = Bone.TransformedWorldCFrame,

		Position = Bone.TransformedWorldCFrame.Position,
		LastPosition = Bone.TransformedWorldCFrame.Position,

		WeldPosition = Vector3.zero,
		WeldCFrame = CFrame.identity,
		ActiveWeld = false,
		RigidWeld = false,

		Anchored = false,
		AxisLocked = { false, false, false },
		XAxisLimits = NumberRange.new(-math.huge, math.huge),
		YAxisLimits = NumberRange.new(-math.huge, math.huge),
		ZAxisLimits = NumberRange.new(-math.huge, math.huge),

		IsSkippingUpdates = false,

		CollisionHits = {},

		-- Debug
		CollisionsData = {},
	}, Class)

	self.AttributeConnection = Bone.AttributeChanged:Connect(function(Attribute)
		-- Do this cause of axis lock
		local Settings = Utilities.GatherBoneSettings(Bone)

		for k, v in Settings do
			-- Â¬ represents a nil value, this is done so we can delete attributes at runtime.
			self[k] = (v ~= "Â¬") and v or nil
		end
	end)

	return self :: IBone
end

--- @within Bone
--- @param Position Vector3
--- @param Vector Vector3
--- Clips velocity on specified vector, Position is where we are at our current physics step (Before we set self.Position)
function Class:ClipVelocity(Position: Vector3, Vector: Vector3)
	self.LastPosition = ClipVector(self.LastPosition, Position, Vector)
end

--- @within Bone
--- @param BoneTree BoneTree
function Class:PreUpdate(BoneTree) -- Parallel safe
	
local Root = BoneTree.Bones[1]
	local Parent = BoneTree.Bones[self.ParentIndex]

	self.AnimatedWorldCFrame = QueryTransformedWorldCFrame(BoneTree, self)

	local SmartWeld = self.Bone:FindFirstChild("SmartWeld")

	-- Pyramid of weld
	self.ActiveWeld = false
	if SmartWeld then
		if SmartWeld:IsA("ObjectValue") then
			local WeldTo = SmartWeld.Value

			self.RigidWeld = (SmartWeld:GetAttribute("Rigid") == true) or false

			if WeldTo then
				if WeldTo:IsA("Attachment") then -- Attachment also covers bones
					self.WeldPosition = WeldTo.WorldPosition
					self.WeldCFrame = WeldTo.WorldCFrame
					self.ActiveWeld = true
				elseif WeldTo:IsA("BasePart") then
					self.WeldPosition = WeldTo.Position
					self.WeldCFrame = WeldTo.CFrame
					self.ActiveWeld = true
				end
			end
		end
	end

	if self.ParentIndex < 1 then -- Force anchor the root bone
		self.Anchored = true
	end

	if self.Bone == self.RootBone then
		-- Curse Non-SmartBone Objects!
		local ParentCFrame

		if self.Bone.Parent:IsA("Bone") then
			ParentCFrame = QueryTransformedWorldCFrameNonSmartbone(self.Bone.Parent)
		else
			ParentCFrame = self.RootPart.CFrame
		end

		self.TransformOffset = ParentCFrame * self.Transform
	else
		self.TransformOffset = Parent.AnimatedWorldCFrame * self.Transform
	end

	self.LocalTransformOffset = Root.Bone.CFrame * self.LocalTransform

end

--- @within Bone
--- @param BoneTree BoneTree
--- @param Force Vector3
--- @param Delta number -- Î”t
--- Force passed in via BoneTree:StepPhysics()
function Class:StepPhysics(BoneTree, Force: Vector3, Delta: number) -- Parallel safe
	
if self.Anchored then
		self.LastPosition = self.AnimatedWorldCFrame.Position
		self.Position = self.AnimatedWorldCFrame.Position
		

return
	end

	-- Custom forces per bone
	if self.Force or self.Gravity then
		
Force = (self.Gravity or BoneTree.Settings.Gravity)

		Force = (Force + (self.Force or BoneTree.Settings.Force))
	
end
	

local Settings = BoneTree.Settings

	local Velocity = (self.Position - self.LastPosition) / Delta
	Velocity = (Velocity.Magnitude > MAX_SPEED and Velocity.Unit * MAX_SPEED or Velocity)

	local Move = BoneTree.ObjectAcceleration * Settings.Inertia
	local WindMove = SolveWind(self, BoneTree, Velocity)
	local Acceleration = Force + Move

	self.LastPosition = self.Position
	--self.Position += (Velocity * (1 - Settings.Damping) + Force + Move) * Delta + WindMove
	self.Position += Velocity * (1 - Settings.Damping) * Delta + Acceleration * Delta * Delta + WindMove


end

--- @within Bone
--- @param BoneTree BoneTree
--- @param ColliderObjects { ColliderObject }
--- @param Delta number -- Î”t
function Class:Constrain(BoneTree, ColliderObjects, Delta: number) -- Parallel safe
	
if self.Anchored then
		
return
	end

	local Position = self.Position
	local RootPart = self.RootPart
	local RootCFrame: CFrame = RootPart.CFrame

	-- Friction must be first
	Position = FrictionConstraint(self, Position, self.LastPosition)

	if #ColliderObjects ~= 0 then
		Position = CollisionConstraint(self, Position, ColliderObjects)
	end

	if BoneTree.Settings.Constraint == "Spring" then
		Position = SpringConstraint(self, Position, nil, BoneTree, Delta)
	elseif BoneTree.Settings.Constraint == "Distance" then
		Position = DistanceConstraint(self, Position, BoneTree)
	elseif BoneTree.Settings.Constraint == "Rope" then
		Position = RopeConstraint(self, Position, BoneTree)
	else
		-- Go to anchored position if our constraint type is incorrect
		Position = self.AnimatedWorldCFrame.Position
	end

	Position = AxisConstraint(self, Position, self.LastPosition, RootCFrame)

	Position = RotationConstraint(self, Position, BoneTree)

	if self.ActiveWeld then
		if self.RigidWeld then
			-- Solve Transform has the rest of this implementation.
			Position = self.WeldPosition
		else
			Position = SpringConstraint(self, Position, self.WeldPosition, BoneTree, Delta)
		end
	end

	self.Friction = 0

	for _, HitPart in self.CollisionHits do
		-- Use whatever object has the higher friction
		local Friction = GetFriction(self.RootPart, HitPart)
		self.Friction = Friction < self.Friction and self.Friction or Friction
	end

	self.Position = Position

end

--- @within Bone
--- Returns bone to rest position
function Class:SkipUpdate()
	if self.IsSkippingUpdates == false and Config.RESET_TRANSFORM_ON_SKIP then
		--SB_VERBOSE_LOG("Skipping bone, resetting transform.")
		self.CalculatedWorldCFrame = self.AnimatedWorldCFrame
		self.IsSkippingUpdates = true
	end

	self.LastPosition = self.AnimatedWorldCFrame.Position + (self.LastPosition - self.Position)
	self.Position = self.AnimatedWorldCFrame.Position
end

--- @within Bone
--- @param BoneTree BoneTree
--- @param Delta number -- Î”t
--- Solves the cframe of the bones
function Class:SolveTransform(BoneTree, Delta: number) -- Parallel safe
	
if self.ParentIndex < 1 then
		
return
	end

	self.IsSkippingUpdates = false

	local ParentBone: IBone = BoneTree.Bones[self.ParentIndex]
	local BoneParent = ParentBone.Bone

	if ParentBone and BoneParent then
		local ReferenceCFrame = ParentBone.TransformOffset
		local v1 = self.Position - ParentBone.Position
		local Rotation = Utilities.GetRotationBetween(ReferenceCFrame.UpVector, v1).Rotation * ReferenceCFrame.Rotation

		local factor = 0.00001
		local alpha = math.min(1 - factor ^ Delta, 1)

		--local ShouldAverage = ParentBone.NumberOfChildren > 1

		if ParentBone.ActiveWeld and ParentBone.RigidWeld then
			ParentBone.CalculatedWorldCFrame = ParentBone.WeldCFrame
		--elseif ShouldAverage then
		--	ParentBone.RotationSum += Vector3.new(Rotation:ToEulerAnglesXYZ())
		else
			ParentBone.CalculatedWorldCFrame = BoneParent.WorldCFrame:Lerp(CFrame.new(ParentBone.Position) * Rotation, alpha)
			--ParentBone.CalculatedWorldCFrame = CFrame.new(ParentBone.Position) * Rotation
		end

		SB_ASSERT_CB(not IsNaN(ParentBone.CalculatedWorldCFrame.Position), warn, "If you see this report this as a bug, (NaN Calc world cframe)")
	end

end

--- @within Bone
--- @param BoneTree BoneTree
--- Sets the world cframes of the bones to the calculated world cframe (solved in Bone:SolveTransform())
function Class:ApplyTransform(BoneTree)

	
self.SolvedAnimatedCFrame = false

	if self.ParentIndex < 1 then
		
return
	end

	local ParentBone: IBone = BoneTree.Bones[self.ParentIndex]
	local BoneParent = ParentBone.Bone

	-- We check if the magnitude of rotation sum is zero because that tells us if it has already been averaged by another bone.
	-- if ParentBone.NumberOfChildren > 1 and ParentBone.RotationSum.Magnitude ~= 0 then
	-- 	local AverageRotation = ParentBone.RotationSum / ParentBone.NumberOfChildren
	-- 	ParentBone.CalculatedWorldCFrame = CFrame.new(ParentBone.Position)
	-- 		* CFrame.fromEulerAnglesXYZ(AverageRotation.X, AverageRotation.Y, AverageRotation.Z)
	-- 	ParentBone.RotationSum = Vector3.zero
	-- end

	if ParentBone and BoneParent then
		if ParentBone.Anchored and not BoneTree.Settings.AnchorsRotate then -- Anchored and anchors do not rotate
			BoneParent.WorldCFrame = ParentBone.TransformOffset
		elseif ParentBone.Anchored then -- Anchored and anchors rotate
			BoneParent.WorldCFrame = CFrame.new(ParentBone.Position) * ParentBone.CalculatedWorldCFrame.Rotation
		else -- Not anchored
			BoneParent.WorldCFrame = ParentBone.CalculatedWorldCFrame
		end
	end

end

--- @client
--- @within Bone
--- @param BoneTree any
--- @param DRAW_CONTACTS boolean
--- @param DRAW_PHYSICAL_BONE boolean
--- @param DRAW_BONE boolean
--- @param DRAW_AXIS_LIMITS boolean
--- @param DRAW_ROTATION_LIMIT boolean
function Class:DrawDebug(BoneTree, DRAW_CONTACTS: bool, DRAW_PHYSICAL_BONE: bool, DRAW_BONE: bool, DRAW_AXIS_LIMITS: bool, DRAW_ROTATION_LIMIT: bool)
	
local BONE_POSITION_COLOR = Color3.fromRGB(255, 0, 0)
	local BONE_LAST_POSITION_COLOR = Color3.fromRGB(255, 94, 0)
	local BONE_POSITION_RAY_COLOR = Color3.fromRGB(234, 1, 255)
	local BONE_SPHERE_COLOR = Color3.fromRGB(0, 255, 255)
	local BONE_FRONT_ARROW_COLOR = Color3.fromRGB(255, 0, 0)
	local BONE_UP_ARROW_COLOR = Color3.fromRGB(0, 255, 0)
	local BONE_RIGHT_ARROW_COLOR = Color3.fromRGB(0, 0, 255)
	local ROTATION_CONE_COLOR = Color3.fromRGB(0, 183, 255)
	local AXIS_X_COLOR = Color3.fromRGB(255, 0, 0)
	local AXIS_Y_COLOR = Color3.fromRGB(0, 255, 0)
	local AXIS_Z_COLOR = Color3.fromRGB(0, 0, 255)
	local AXIS_ARROW_RADIUS = 0.05
	local AXIS_ARROW_LENGTH = 0.15

	local COLLISION_CONTACT_SPHERE_COLOR = Color3.fromRGB(28, 41, 224)
	local COLLISION_CONTACT_NORMAL_COLOR = Color3.fromRGB(255, 27, 27)
	local COLLISION_CONTACT_SPHERE_RADIUS = 0.08
	local COLLISION_CONTACT_ARROW_LENGTH = 0.15
	local COLLISION_CONTACT_ARROW_RADIUS = 0.05
	local COLLISION_CONTACT_ARROW_EXPANSION = 0.5

	local BONE_ARROW_LENGTH = 0.05
	local BONE_ARROW_RADIUS = 0.015
	local BONE_CYLINDER_RADIUS = 0.005
	local BONE_ARROW_EXPANSION = 0.25
	local BONE_RADIUS = 0.08

	local ROTATION_CONE_LENGTH = 1

	local BoneCFrame = self.AnimatedWorldCFrame
	local BonePosition = BoneCFrame.Position
	local BonePositionCFrame = CFrame.new(self.Position)
	local BoneLastPositionCFrame = CFrame.new(self.LastPosition)

	-- Draw our internal bone

	if DRAW_BONE then
		Gizmo.PushProperty("AlwaysOnTop", false)

		Gizmo.PushProperty("Color3", BONE_POSITION_COLOR)
		Gizmo.Sphere:Draw(BonePositionCFrame, self.Radius, 10, 360)

		Gizmo.PushProperty("Color3", BONE_LAST_POSITION_COLOR)
		Gizmo.Sphere:Draw(BoneLastPositionCFrame, self.Radius, 10, 360)

		Gizmo.PushProperty("Color3", BONE_POSITION_RAY_COLOR)
		Gizmo.Ray:Draw(self.Position, self.LastPosition)
	end

	-- Draw our axis Limits

	if DRAW_AXIS_LIMITS and not self.Anchored then
		local XLock = self.AxisLocked[1]
		local YLock = self.AxisLocked[2]
		local ZLock = self.AxisLocked[3]

		local RootPart = self.RootPart
		local Offset = RootPart.CFrame:PointToObjectSpace(BonePosition)

		local XVector = RootPart.CFrame.RightVector
		local YVector = RootPart.CFrame.UpVector
		local ZVector = RootPart.CFrame.LookVector

		local Size = Vector3.new(5, 5, 0)

		if not XLock then
			Gizmo.PushProperty("Color3", AXIS_X_COLOR)
			Gizmo.Arrow:Draw(BonePosition - XVector * 2, BonePosition + XVector * 2, AXIS_ARROW_RADIUS, AXIS_ARROW_LENGTH, 9)

			local MinXLimit = self.XAxisLimits.Min - Offset.X
			local MaxXLimit = self.XAxisLimits.Max - Offset.X

			Gizmo.Plane:Draw(BonePosition + XVector * MinXLimit, XVector, Size)
			Gizmo.Plane:Draw(BonePosition + XVector * MaxXLimit, XVector, Size)
		end

		if not YLock then
			Gizmo.PushProperty("Color3", AXIS_Y_COLOR)
			Gizmo.Arrow:Draw(BonePosition - YVector * 2, BonePosition + YVector * 2, AXIS_ARROW_RADIUS, AXIS_ARROW_LENGTH, 9)

			local MinYLimit = self.YAxisLimits.Min - Offset.Y
			local MaxYLimit = self.YAxisLimits.Max - Offset.Y

			Gizmo.Plane:Draw(BonePosition + YVector * MinYLimit, YVector, Size)
			Gizmo.Plane:Draw(BonePosition + YVector * MaxYLimit, YVector, Size)
		end

		if not ZLock then
			Gizmo.PushProperty("Color3", AXIS_Z_COLOR)
			Gizmo.Arrow:Draw(BonePosition - ZVector * 2, BonePosition + ZVector * 2, AXIS_ARROW_RADIUS, AXIS_ARROW_LENGTH, 9)

			local MinZLimit = self.ZAxisLimits.Min - Offset.Z
			local MaxZLimit = self.ZAxisLimits.Max - Offset.Z

			Gizmo.Plane:Draw(BonePosition - ZVector * MinZLimit, ZVector, Size)
			Gizmo.Plane:Draw(BonePosition - ZVector * MaxZLimit, ZVector, Size)
		end
	end

	-- Draw the physical bone object

	if DRAW_PHYSICAL_BONE then
		Gizmo.PushProperty("Color3", BONE_SPHERE_COLOR)
		Gizmo.Sphere:Draw(BoneCFrame, BONE_RADIUS, 5, 360)

		Gizmo.PushProperty("Color3", BONE_FRONT_ARROW_COLOR)
		Gizmo.VolumeArrow:Draw(
			BonePosition,
			BonePosition + BoneCFrame.LookVector * BONE_ARROW_EXPANSION,
			BONE_CYLINDER_RADIUS,
			BONE_ARROW_RADIUS,
			BONE_ARROW_LENGTH,
			true
		)

		Gizmo.PushProperty("Color3", BONE_UP_ARROW_COLOR)
		Gizmo.VolumeArrow:Draw(
			BonePosition,
			BonePosition + BoneCFrame.UpVector * BONE_ARROW_EXPANSION,
			BONE_CYLINDER_RADIUS,
			BONE_ARROW_RADIUS,
			BONE_ARROW_LENGTH,
			true
		)

		Gizmo.PushProperty("Color3", BONE_RIGHT_ARROW_COLOR)
		Gizmo.VolumeArrow:Draw(
			BonePosition,
			BonePosition + BoneCFrame.RightVector * BONE_ARROW_EXPANSION,
			BONE_CYLINDER_RADIUS,
			BONE_ARROW_RADIUS,
			BONE_ARROW_LENGTH,
			true
		)
	end

	-- Draw our collision contacts

	if DRAW_CONTACTS and not self.Anchored then
		for _, Collision in self.CollisionsData do
			Gizmo.PushProperty("Color3", COLLISION_CONTACT_SPHERE_COLOR)
			Gizmo.Sphere:Draw(CFrame.new(Collision.ClosestPoint), COLLISION_CONTACT_SPHERE_RADIUS, 5, 360)

			Gizmo.PushProperty("Color3", COLLISION_CONTACT_NORMAL_COLOR)
			Gizmo.Arrow:Draw(
				Collision.ClosestPoint,
				Collision.ClosestPoint + Collision.Normal * COLLISION_CONTACT_ARROW_EXPANSION,
				COLLISION_CONTACT_ARROW_RADIUS,
				COLLISION_CONTACT_ARROW_LENGTH,
				9
			)
		end
	end

	-- Draw rotation limit

	if DRAW_ROTATION_LIMIT and self.RotationLimit < 180 and self.RotationLimit > 0 and self.ParentIndex > 0 and self.HasChild then
		local ConeRadius
		local InverseDirection = 1
		if self.RotationLimit < 89.5 then
			ConeRadius = ROTATION_CONE_LENGTH * math.tan(math.rad(self.RotationLimit))
		elseif self.RotationLimit > 90 then
			InverseDirection = -1			
ConeRadius = ROTATION_CONE_LENGTH * math.tan(math.rad(180 - self.RotationLimit))
		else
			ROTATION_CONE_LENGTH = 0
			ConeRadius = 5
		end

		ConeRadius = math.min(ConeRadius, 5)

		if ConeRadius == 5 then
			ROTATION_CONE_LENGTH = 0
		end

		local ConeDirection = (self.Position - BoneTree.Bones[self.ParentIndex].Position).Unit * InverseDirection

		local NewBoneCFrame =
			CFrame.lookAt(BonePosition + ConeDirection * (ROTATION_CONE_LENGTH * 0.5), BonePosition + -ConeDirection * 500, BoneCFrame.LookVector)

		Gizmo.PushProperty("Color3", ROTATION_CONE_COLOR)
		Gizmo.Cone:Draw(NewBoneCFrame, ConeRadius, ROTATION_CONE_LENGTH, 8 + ConeRadius * 2)
	end


end

--- @client
--- @within Bone
function Class:DrawOverlay(Overlay: ImOverlay)
	Overlay.Text(`Bone: {self.Bone.Name}`)

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_NUMERICS then
		Overlay.Text(`Free Length: {self.FreeLength}`)
		Overlay.Text(`Weight: {self.Weight}`)
		Overlay.Text(`Parent Index: {self.ParentIndex}`)
		Overlay.Text(`Heirarchy Length: {self.HeirarchyLength}`)
		Overlay.Text(`Radius: {self.Radius}`)
		Overlay.Text(`Friction: {self.Friction}`)
		Overlay.Text(`Rotation Limit: {self.RotationLimit}`)
	end

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_CONSTRAIN then
		Overlay.Text(`Anchored: {self.Anchored}`)
		Overlay.Text(`Axis Locked: {self.AxisLocked[1]}, {self.AxisLocked[2]}, {self.AxisLocked[3]}`)
		Overlay.Text(`X Axis Limit: {self.XAxisLimits}`)
		Overlay.Text(`Y Axis Limit: {self.YAxisLimits}`)
		Overlay.Text(`Z Axis Limit: {self.ZAxisLimits}`)
	end

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_WELD then
		Overlay.Text(`Active Weld: {self.ActiveWeld}`)
		Overlay.Text(`Rigid Weld: {self.RigidWeld}`)
		Overlay.Text(`Weld Position: {string.format("%.3f, %.3f, %.3f", self.WeldPosition.X, self.WeldPosition.Y, self.WeldPosition.Z)}`)
	end

	if Config.DEBUG_OVERLAY_BONE_INFO or Config.DEBUG_OVERLAY_BONE_FORCES then
		local Force = self.Force and string.format("%.3f, %.3f, %.3f", self.Force.X, self.Force.Y, self.Force.Z) or "-, -, -"
		local Gravity = self.Gravity and string.format("%.3f, %.3f, %.3f", self.Gravity.X, self.Gravity.Y, self.Gravity.Z) or "-, -, -"

		Overlay.Text(`Force: {Force}`)
		Overlay.Text(`Gravity: {Gravity}`)
	end
end

function Class:Destroy()
	if Config.RESET_BONE_ON_DESTROY then
		task.synchronize()
		self.Bone.CFrame = self.StartingCFrame
	end

	self.AttributeConnection:Disconnect()

	setmetatable(self, nil)
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Bone

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.BoneTree | Enabled: N/A
--------------------------------------------------------------------
--!nocheck
--!native

local Lighting = game:GetService("Lighting")
local Dependencies = script.Parent.Parent:WaitForChild("Dependencies")
local BoneClass = require(script.Parent:WaitForChild("Bone"))
local Config = require(Dependencies:WaitForChild("Config"))
local DefaultObjectSettings = require(Dependencies:WaitForChild("DefaultObjectSettings"))
local Gizmo = require(Dependencies:WaitForChild("Debug"):WaitForChild("Gizmo"))
local Utilities = require(Dependencies:WaitForChild("Utilities"))
local MaxVector = Vector3.new(math.huge, math.huge, math.huge)

local WIND_SEED = 1029410295159813
local WIND_RNG = Random.new(WIND_SEED)
local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG

local CollectionService = game:GetService("CollectionService")

export type IBoneTree = {
	WindOffset: number,
	Root: Bone,
	RootPart: BasePart,
	RootPartSize: Vector3,
	Bones: { BoneClass.IBone },
	Settings: { [string]: any },
	UpdateRate: number,
	AccumulatedDelta: number,
	BoundingBoxCFrame: CFrame,
	BoundingBoxSize: Vector3,

	InView: bool,
	Destroyed: bool,
	IsSkippingUpdates: bool,
	InWorkspace: bool,

	Force: Vector3,
	ObjectMove: Vector3,
	ObjectVelocity: Vector3,
	ObjectAcceleration: Vector3,
	ObjectPreviousPosition: Vector3
}

type ImOverlay = {
	Begin: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> (),
	End: () -> (),
	Text: (Text: string, BackgroundColor: Color3?, TextColor: Color3?) -> ()
}

type bool = boolean

local function SafeUnit(v3: Vector3): Vector3
	if v3.Magnitude == 0 then
		--warn("Vector was saved")
		return Vector3.zero
	end

	return v3.Unit
end

local function map(n: number, start: number, stop: number, newStart: number, newStop: number, withinBounds: bool): number
	local value = ((n - start) / (stop - start)) * (newStop - newStart) + newStart

	--// Returns basic value
	if not withinBounds then
		return value
	end

	--// Returns values constrained to exact range
	if newStart < newStop then
		return (value < newStop and value or newStop) > newStart and (value < newStop and value or newStop) or newStart
	else
		return (value < newStart and value or newStart) > newStop and (value < newStart and value or newStart) or newStop
	end
end

--- @class BoneTree
--- Internal class for all bone trees
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within BoneTree
--- @readonly
--- @prop WindOffset number
--- Used in wind calculations so each bone tree has a different solution.

--- @within BoneTree
--- @readonly
--- @prop Root Bone
--- Root bone of the bone tree

--- @within BoneTree
--- @readonly
--- @prop RootPart BasePart

--- @within BoneTree
--- @readonly
--- @prop RootPartSize Vector3
--- Constant value of the root parts size at the start of the simulation

--- @within BoneTree
--- @prop Bones table

--- @within BoneTree
--- @prop Settings {}

--- @within BoneTree
--- @readonly
--- @prop UpdateRate number
--- Throttled update rate

--- @within BoneTree
--- @readonly
--- @prop InView boolean

--- @within BoneTree
--- @readonly
--- @prop BoundingBoxCFrame CFrame

--- @within BoneTree
--- @readonly
--- @prop BoundingBoxSize Size

--- @within BoneTree
--- @readonly
--- @prop AccumulatedDelta number
--- Used in the runtime

--- @within BoneTree
--- @readonly
--- @prop Destroyed boolean
--- True if the root part has been destroyed

--- @within BoneTree
--- @readonly
--- @prop IsSkippingUpdates boolean
--- True if the bone tree is currently skipping updates

--- @within BoneTree
--- @readonly
--- @prop InWorkspace boolean
--- Boolean describing if the rootpart is a descendant of workspace

--- @within BoneTree
--- @readonly
--- @prop Force Vector3

--- @within BoneTree
--- @prop ObjectMove Vector3
--- Difference between root parts last position and current position

--- @within BoneTree
--- @prop ObjectVelocity Vector3
--- Velocity at which the root part is traveling at, calculated via object move.

--- @within BoneTree
--- @prop ObjectPreviousPosition Vector3
--- Root parts previous position

local Class = {}
Class.__index = Class

--- @within BoneTree
--- @param RootBone Bone
--- @param RootPart BasePart
--- @param Settings {any}
--- @return BoneTree
function Class.new(RootBone: Bone, RootPart: BasePart, Settings: { any }): IBoneTree
	local self = setmetatable({
		WindOffset = WIND_RNG:NextNumber(0, 1e6),
		Root = RootBone:IsA("Bone") and RootBone or nil,
		RootPart = RootPart,
		RootPartSize = RootPart.Size,
		Bones = {},
		Settings = Settings,
		UpdateRate = 0,
		InView = true,
		AccumulatedDelta = 0,
		BoundingBoxCFrame = RootPart.CFrame,
		BoundingBoxSize = RootPart.Size,

		Destroyed = false,
		IsSkippingUpdates = false,
		InWorkspace = false,

		Force = Vector3.zero,
		ObjectMove = Vector3.zero,
		ObjectVelocity = Vector3.zero,
		ObjectAcceleration = Vector3.zero,
		ObjectPreviousPosition = RootPart.Position,
	}, Class)

	self.InWorkspace = RootPart:IsDescendantOf(workspace)

	-- TODO: Revisit optimising :IsDescendantOf calls
	self.DestroyConnection = RootPart.AncestryChanged:ConnectParallel(function()
		if not RootPart:IsDescendantOf(game) then
			self.Destroyed = true
		end

		self.InWorkspace = RootPart:IsDescendantOf(workspace)
	end)

	self.AttributeConnection = RootPart.AttributeChanged:ConnectParallel(function(Attribute)
		-- No need validating
		Settings[Attribute] = RootPart:GetAttribute(Attribute) or DefaultObjectSettings[Attribute]
	end)

	self.TagConnection = CollectionService:GetInstanceRemovedSignal("SmartBone"):Connect(function(Object)
		if Object ~= RootPart then
			return
		end

		self.Destroyed = true
	end)

	-- FIXME:
	-- if Settings.MatchWorkspaceWind then
	-- 	self.GlobalWindConnection = workspace:GetPropertyChangedSignal("GlobalWind"):ConnectParallel(function()
	-- 		local GlobalWind = workspace.GlobalWind
	-- 		Settings.WindDirection = SafeUnit(GlobalWind)
	-- 		Settings.WindSpeed = GlobalWind.Magnitude
	-- 	end)
	-- else
	-- 	self.WindDirectionConnection = Lighting:GetAttributeChangedSignal("WindDirection"):ConnectParallel(function()
	-- 		Settings.WindDirection = Lighting:GetAttribute("WindDirection")
	-- 	end)

	-- 	self.WindSpeedConnection = Lighting:GetAttributeChangedSignal("WindSpeed"):ConnectParallel(function()
	-- 		Settings.WindSpeed = Lighting:GetAttribute("WindSpeed")
	-- 	end)

	-- 	self.WindStrengthConnection = Lighting:GetAttributeChangedSignal("WindStrength"):ConnectParallel(function()
	-- 		Settings.WindStrength = Lighting:GetAttribute("WindStrength")
	-- 	end)
	-- end

	return self :: IBoneTree
end

--- @within BoneTree
--- Called in BoneTree:PreUpdate(),
--- Computes the bounding box of all the bones
function Class:UpdateBoundingBox()

	
if not self.InView then
		self.BoundingBoxCFrame = self.RootPart.CFrame
		self.BoundingBoxSize = self.RootPart.Size
		

return
	end

	local BottomCorner = MaxVector
	local TopCorner = -MaxVector
	

for _, Bone in self.Bones do
		
local Velocity = (Bone.Position - Bone.LastPosition)
		local Position = Bone.Position + Velocity

		BottomCorner = BottomCorner:Min(Position)
		TopCorner = TopCorner:Max(Position)
	
end

	
local CenterOfMass = (BottomCorner + TopCorner) * 0.5

	self.BoundingBoxCFrame = CFrame.new(CenterOfMass)
	self.BoundingBoxSize = self.RootPartSize:Max(TopCorner - BottomCorner)


end

--- @within BoneTree
--- @param RootPosition Vector3 -- Position of the root part (Micro Optimization)
--- Called in BoneTree:PreUpdate()
function Class:UpdateThrottling(RootPosition: Vector3)
	
local Settings = self.Settings

	local Camera = workspace.CurrentCamera
	local Distance = (RootPosition - Camera.CFrame.Position).Magnitude

	if Distance > Settings.ActivationDistance then
		self.UpdateRate = 0
		
return
	end

	local UpdateRate = 1 - map(Distance, Settings.ThrottleDistance, Settings.ActivationDistance, 0, 1, true)
	self.UpdateRate = Settings.UpdateRate * UpdateRate

end

--- @within BoneTree
--- @param Delta number -- Î”t
--- Calculates object move, gravity and throttled update rate. Also calls Bone:PreUpdate()
function Class:PreUpdate(Delta: number)
	
local RootPartCFrame = self.RootPart.CFrame
	local RootPartPosition = RootPartCFrame.Position

	local PreviousVelocity = self.ObjectVelocity

	self.ObjectMove = (RootPartPosition - self.ObjectPreviousPosition)
	self.ObjectVelocity = self.ObjectMove
	self.ObjectAcceleration = (PreviousVelocity - self.ObjectVelocity)
	self.ObjectPreviousPosition = RootPartPosition
	self.RootPartSize = self.RootPart.Size

	self:UpdateThrottling(RootPartPosition)
	self:UpdateBoundingBox()

	for _, Bone in self.Bones do
		Bone:PreUpdate(self)
	end

end

--- @within BoneTree
--- @param Delta number -- Î”t
--- Calculates forces and updates wind. Also calls Bone:StepPhysics()
function Class:StepPhysics(Delta: number)
	
local Settings = self.Settings
	local Force = (Settings.Gravity + Settings.Force)

	if Settings.MatchWorkspaceWind == true then
		local GlobalWind = workspace.GlobalWind
		Settings.WindDirection = SafeUnit(GlobalWind)
		Settings.WindSpeed = GlobalWind.Magnitude
	else
		local WindDirection = Lighting:GetAttribute("WindDirection") or DefaultObjectSettings.WindDirection
		local WindSpeed = Lighting:GetAttribute("WindSpeed") or DefaultObjectSettings.WindSpeed

		Settings.WindDirection = SafeUnit(WindDirection)
		Settings.WindSpeed = WindSpeed
	end

	local WindStrength = Lighting:GetAttribute("WindStrength") or DefaultObjectSettings.WindStrength

	Settings.WindStrength = WindStrength

	for _, Bone in self.Bones do
		Bone:StepPhysics(self, Force, Delta)
	end

end

--- @within BoneTree
--- @param ColliderObjects table
--- @param Delta number -- Î”t
function Class:Constrain(ColliderObjects, Delta: number)
	
for _, Bone in self.Bones do
		Bone:Constrain(self, ColliderObjects, Delta)
	end

end

--- @within BoneTree
--- Resets all bones to their rest positions, and sets skipping updates to true,
function Class:SkipUpdate()
	
for _, Bone in self.Bones do
		Bone:SkipUpdate()
	end

	self.IsSkippingUpdates = true

end

--- @within BoneTree
--- @param Delta number -- Î”t
function Class:SolveTransform(Delta: number)
	
for _, Bone in self.Bones do
		Bone:SolveTransform(self, Delta)
	end

	self.IsSkippingUpdates = false

end

--- @within BoneTree
--- Applys all the transforms to bones in serial context.
function Class:ApplyTransform()
	
for _, Bone in self.Bones do
		Bone:ApplyTransform(self)
	end

end

--- @client
--- @within BoneTree
--- @param DRAW_CONTACTS boolean
--- @param DRAW_PHYSICAL_BONE boolean
--- @param DRAW_BONE boolean
--- @param DRAW_AXIS_LIMITS boolean
--- @param DRAW_ROOT_PART boolean
--- @param DRAW_BOUNDING_BOX boolean
--- @param DRAW_ROTATION_LIMITS boolean
--- @param DRAW_ACCELERATION_INFO boolean
function Class:DrawDebug(
	DRAW_CONTACTS: bool,
	DRAW_PHYSICAL_BONE: bool,
	DRAW_BONE: bool,
	DRAW_AXIS_LIMITS: bool,
	DRAW_ROOT_PART: bool,
	DRAW_BOUNDING_BOX: bool,
	DRAW_ROTATION_LIMITS: bool,
	DRAW_ACCELERATION_INFO: bool
)
	
local LINE_CONNECTING_COLOR = Color3.fromRGB(248, 168, 20)
	local ROOT_PART_BOUNDING_BOX_COLOR = Color3.fromRGB(76, 208, 223)
	local ROOT_PART_FILL_COLOR = Color3.fromRGB(255, 89, 89)
	local OBJECT_MOVE_COLOR = Color3.new(1, 0, 0)
	local OBJECT_VELOCITY_COLOR = Color3.new(0, 1, 0)
	local OBJECT_ACCELERATION_COLOR = Color3.new(0, 0, 1)

	if DRAW_ACCELERATION_INFO then
		local Raised = self.RootPart.Position + Vector3.new(0, self.RootPart.Size.Y * 0.5 + 1, 0)

		Gizmo.SetStyle(OBJECT_MOVE_COLOR, 0, true)
		Gizmo.Arrow:Draw(Raised, Raised + self.ObjectMove, 0.025, 0.1, 6)

		Gizmo.SetStyle(OBJECT_VELOCITY_COLOR, 0, true)
		Gizmo.Arrow:Draw(Raised, Raised + self.ObjectVelocity, 0.025, 0.1, 6)

		Gizmo.SetStyle(OBJECT_ACCELERATION_COLOR, 0, true)
		Gizmo.Arrow:Draw(Raised, Raised + self.ObjectAcceleration, 0.025, 0.1, 6)
	end

	Gizmo.PushProperty("AlwaysOnTop", false)

	if DRAW_BOUNDING_BOX then
		Gizmo.PushProperty("Color3", ROOT_PART_BOUNDING_BOX_COLOR)
		Gizmo.Box:Draw(self.BoundingBoxCFrame, self.BoundingBoxSize, true)
	end

	if DRAW_ROOT_PART then
		Gizmo.PushProperty("Color3", ROOT_PART_BOUNDING_BOX_COLOR)
		Gizmo.Box:Draw(self.RootPart.CFrame, self.RootPart.Size, true)

		Gizmo.SetStyle(ROOT_PART_FILL_COLOR, 0.75, false)
		Gizmo.VolumeBox:Draw(self.RootPart.CFrame, self.RootPart.Size)

		Gizmo.PushProperty("Transparency", 0)
	end

	for i, Bone in self.Bones do
		local BonePosition = Bone.Bone.TransformedWorldCFrame.Position
		local ParentBone = self.Bones[Bone.ParentIndex]

		Bone:DrawDebug(self, DRAW_CONTACTS, DRAW_PHYSICAL_BONE, DRAW_BONE, DRAW_AXIS_LIMITS, DRAW_ROTATION_LIMITS)

		if DRAW_PHYSICAL_BONE and i ~= 1 then
			Gizmo.PushProperty("Color3", LINE_CONNECTING_COLOR)
			Gizmo.Ray:Draw(ParentBone.Bone.TransformedWorldCFrame.Position, BonePosition)
		end
	end

end

--- @client
--- @within SmartBone
--- @param Overlay ImOverlay
function Class:DrawOverlay(Overlay: ImOverlay)
	if Config.DEBUG_OVERLAY_TREE_INFO or Config.DEBUG_OVERLAY_TREE_OBJECTS then
		Overlay.Text(`Root Part: {self.RootPart.Name}`)
		Overlay.Text(`Root Bone: {self.Root.Name}`)
		Overlay.Text(`Root Part Size: {string.format("%.3f, %.3f, %.3f", self.RootPart.Size.X, self.RootPart.Size.Y, self.RootPart.Size.Z)}`)
	end

	if Config.DEBUG_OVERLAY_TREE_INFO or Config.DEBUG_OVERLAY_TREE_NUMERICS then
		Overlay.Text(`Update Rate: {string.format("%.3f", self.UpdateRate)}`)
		Overlay.Text(`In View: {self.InView}`)
		Overlay.Text(`Accumulated Delta: {string.format("%.3f", self.AccumulatedDelta)}`)
		Overlay.Text(`Force: {string.format("%.3f, %.3f, %.3f", self.Force.X, self.Force.Y, self.Force.Z)}`)
	end

	local ROOT_BACKGROUND_COLOR = Color3.new(0.486275, 0.431373, 1.000000)
	local ROOT_TEXT_COLOR = Color3.new(1, 1, 1)

	if Config.DEBUG_OVERLAY_BONE then
		for i, Bone in self.Bones do
			if Config.DEBUG_OVERLAY_MAX_BONES > 0 then
				if Config.DEBUG_OVERLAY_BONE_OFFSET + Config.DEBUG_OVERLAY_MAX_BONES <= i then
					break
				end
			end

			if Config.DEBUG_OVERLAY_BONE_OFFSET > i then
				continue
			end

			Overlay.Begin(`Bone {i}`, ROOT_BACKGROUND_COLOR, ROOT_TEXT_COLOR)
			Bone:DrawOverlay(Overlay)
			Overlay.End()
		end
	end
end

function Class:Destroy()
	SB_VERBOSE_LOG("Destroy BoneTree")

	task.synchronize()
	self.DestroyConnection:Disconnect()
	self.AttributeConnection:Disconnect()
	self.TagConnection:Disconnect()

	-- if self.Settings.MatchWorkspaceWind then
	-- 	self.GlobalWindConnection:Disconnect()
	-- else
	-- 	self.WindDirectionConnection:Disconnect()
	-- 	self.WindSpeedConnection:Disconnect()
	-- 	self.WindStrengthConnection:Disconnect()
	-- end

	for _, Bone in self.Bones do
		Bone:Destroy()
	end

	setmetatable(self, nil)
	task.desynchronize()
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.BoneTree

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Collider | Enabled: N/A
--------------------------------------------------------------------
--!nocheck

local HttpService = game:GetService("HttpService")

local Dependencies = script.Parent.Parent.Parent:WaitForChild("Dependencies")
local CollisionSolvers = script.Parent:WaitForChild("Colliders")
local BoxSolver = require(CollisionSolvers:WaitForChild("Box"))
local CapsuleSolver = require(CollisionSolvers:WaitForChild("Capsule"))
local CylinderSolver = require(CollisionSolvers:WaitForChild("Cylinder"))
local SphereSolver = require(CollisionSolvers:WaitForChild("Sphere"))

local Utilities = require(script.Parent.Parent.Parent:WaitForChild("Dependencies"):WaitForChild("Utilities"))

local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG

local Radians = 0.017453
local Gizmo = require(Dependencies:WaitForChild("Debug"):WaitForChild("Gizmo"))

--- @class Collider
--- Internal class for colliders
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within Collider
--- @prop Type string

--- @within Collider
--- @prop Scale Vector3

--- @within Collider
--- @prop Offset Vector3

--- @within Collider
--- @prop Rotation Vector3

--- @within Collider
--- @prop PreviousScale Vector3

--- @within Collider
--- @prop PreviousOffset Vector3

--- @within Collider
--- @prop PreviousRotation Vector3

--- @within Collider
--- @private
--- @readonly
--- @prop m_Object BasePart

--- @within Collider
--- @prop InNarrowphase boolean

--- @within Collider
--- @prop ObjectConnection RBXScriptConnection

--- @within Collider
--- @prop Transform CFrame

--- @within Collider
--- @prop Size Vector3

--- @within Collider
--- @prop GUID string

local Class = {}
Class.__index = Class

--- @within Collider
function Class.new()
	local self = setmetatable({
		Type = "Box",
		Scale = Vector3.zero,
		Offset = Vector3.zero,
		Rotation = Vector3.zero,
		Radius = 0,

		PreviousScale = Vector3.zero,
		PreviousOffset = Vector3.zero,
		PreviousRotation = Vector3.zero,
		PreviousObjectPosition = Vector3.zero,
		PreviousObjectRotation = Vector3.zero,

		m_Object = nil,

		InNarrowphase = false,

		Transform = CFrame.identity,
		Size = Vector3.zero,

		GUID = HttpService:GenerateGUID(false),
	}, Class)

	return self
end

--- @within Collider
--- @param Object BasePart
function Class:SetObject(Object: BasePart)
	self.m_Object = Object

	self:UpdateTransform()
end

--- @within Collider
function Class:UpdateTransform()
	
local Object = self.m_Object
	local ObjectCFrame = Object.CFrame
	local ObjectSize = Object.Size

	local Scale = self.Scale
	local Offset = self.Offset
	local Rotation = self.Rotation

	local ScaledOffset = ObjectSize * Offset
	local ScaledSize = ObjectSize * Scale

	local RotationCFrame = CFrame.Angles(Rotation.X * Radians, Rotation.Y * Radians, Rotation.Z * Radians)

	self.Transform = ObjectCFrame * CFrame.new(ScaledOffset) * RotationCFrame
	self.Size = ScaledSize
	self.Radius = math.sqrt((math.max(ScaledSize.X, ScaledSize.Y, ScaledSize.Z) * 0.5) ^ 2 * 2)

end

--- @within Collider
--- @param Point Vector3
--- @param Radius number
--- @return Vector3 | nil -- Returns nil if specified collider shape is invalid
function Class:GetClosestPoint(Point, Radius)
	if self.m_Object == nil then
		return
	end

	self.InNarrowphase = false

	-- Broadphase influence detection
	local PointDistance = (Point - self.Transform.Position).Magnitude - Radius

	if PointDistance > self.Radius then
		return
	end

	

self.InNarrowphase = true

	local Type = self.Type

	-- Determine which collision solver we should send this off to
	local IsInside, ClosestPoint, Normal

	if Type == "Box" then
		IsInside, ClosestPoint, Normal = BoxSolver(self.Transform, self.Size, Point, Radius)
	end

	if Type == "Capsule" then
		IsInside, ClosestPoint, Normal = CapsuleSolver(self.Transform, self.Size, Point, Radius)
	end

	if Type == "Sphere" then
		IsInside, ClosestPoint, Normal = SphereSolver(self.Transform, self.Size, Point, Radius)
	end

	if Type == "Cylinder" then
		IsInside, ClosestPoint, Normal = CylinderSolver(self.Transform, self.Size, Point, Radius)
	end

	

return IsInside, ClosestPoint, Normal
end

--- @within Collider
function Class:Step()
	
self:UpdateTransform()

end

--- @within Collider
--- @param ColliderObject ColliderObject
--- @param FILL_COLLIDER boolean
--- @param SHOW_INFLUENCE boolean
--- @param SHOW_AWAKE boolean
--- @param SHOW_BROADPHASE boolean
function Class:DrawDebug(ColliderObject, FILL_COLLIDER, SHOW_INFLUENCE, SHOW_AWAKE, SHOW_BROADPHASE)
	local COLLIDER_COLOR = Color3.new(0.509803, 0.933333, 0.427450)
	local FILL_COLOR = Color3.new(0.901960, 0.784313, 0.513725)
	local SLEEP_COLOR = Color3.new(1, 0, 1)
	local BROADPHASE_COLOR = Color3.new(0, 1, 1)
	local INFLUENCE_COLOR = Color3.new(1, 0.3, 0.3)

	local Type = self.Type
	local Transform = self.Transform
	local Size = self.Size

	if not ColliderObject.m_Awake and SHOW_AWAKE then
		COLLIDER_COLOR = SLEEP_COLOR
	end

	if self.InNarrowphase == false and SHOW_BROADPHASE then
		FILL_COLOR = BROADPHASE_COLOR
	end

	if SHOW_INFLUENCE then
		Gizmo.SetStyle(INFLUENCE_COLOR, 0, false)
		Gizmo.Sphere:Draw(Transform, self.Radius, 25, 360)
	end

	if Type == "Box" then
		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Box:Draw(Transform, Size)

		if FILL_COLLIDER then
			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeBox:Draw(Transform, Size)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end

	if Type == "Capsule" then
		local CapsuleRadius = (Size.Y < Size.Z and Size.Y or Size.Z) * 0.5
		local CapsuleLength = Size.X

		local TransformedTransform = Transform * CFrame.Angles(math.rad(90), -math.rad(90), 0)

		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Capsule:Draw(TransformedTransform, CapsuleRadius, CapsuleLength, 15)

		if FILL_COLLIDER then
			local Top = TransformedTransform.Position + TransformedTransform.UpVector * (CapsuleLength * 0.5)
			local Bottom = TransformedTransform.Position - TransformedTransform.UpVector * (CapsuleLength * 0.5)

			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeCylinder:Draw(Transform, CapsuleRadius, CapsuleLength)
			Gizmo.VolumeSphere:Draw(CFrame.new(Top), CapsuleRadius)
			Gizmo.VolumeSphere:Draw(CFrame.new(Bottom), CapsuleRadius)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end

	if Type == "Sphere" then
		local Radius = math.min(Size.X, Size.Y, Size.Z) * 0.5

		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Sphere:Draw(Transform, Radius, 15, 360)

		if FILL_COLLIDER then
			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeSphere:Draw(Transform, Radius)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end

	if Type == "Cylinder" then
		local Radius = (Size.Y < Size.Z and Size.Y or Size.Z) * 0.5

		Gizmo.SetStyle(COLLIDER_COLOR, 0, false)
		Gizmo.Cylinder:Draw(Transform * CFrame.Angles(0, 0, math.rad(90)), Radius, Size.X, 15)

		if FILL_COLLIDER then
			Gizmo.SetStyle(FILL_COLOR, 0.75, false)
			Gizmo.VolumeCylinder:Draw(Transform * CFrame.Angles(0, -math.rad(90), 0), Radius, Size.X, 0, 360)
			Gizmo.PushProperty("Transparency", 0)
		end

		return
	end
end

--- @within Collider
function Class:Destroy()
	SB_VERBOSE_LOG(`Collider destroying, object: {self.m_Object}`)

	setmetatable(self, nil)
end

return Class

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Collider

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.ColliderObject | Enabled: N/A
--------------------------------------------------------------------
local ColliderClass = require(script.Parent:WaitForChild("Collider"))
local Utilities = require(script.Parent.Parent.Parent:WaitForChild("Dependencies"):WaitForChild("Utilities"))

local SB_VERBOSE_LOG = Utilities.SB_VERBOSE_LOG
local SleepCycleInterval = 0.2

type IRawCollider = {
	Type: string,
	ScaleX: number,
	ScaleY: number,
	ScaleZ: number,
	OffsetX: number,
	OffsetY: number,
	OffsetZ: number,
	RotationX: number,
	RotationY: number,
	RotationZ: number
}

type bool = boolean

export type IColliderTable = { [number]: IRawCollider }
export type IColliderObject = {
	m_Object: BasePart,
	m_Awake: bool,
	m_LastSleepCycle: number,
	Destroyed: bool,
	Colliders: IColliderTable
}

--- @class ColliderObject
--- Internal class for collider
--- :::caution Caution:
--- Changes to the syntax in this class will not count to the major version in semver.
--- :::

--- @within ColliderObject
--- @private
--- @readonly
--- @prop m_Object BasePart

--- @within ColliderObject
--- @readonly
--- @prop Destroyed boolean

--- @within ColliderObject
--- @readonly
--- @prop Colliders {}

local Class = {}
 [trimmed]  -  Edit
  14:15:00.416  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Capsule | Enabled: N/A
--------------------------------------------------------------------
--!native
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function solve(p0, d0, len, p1)
	local v = p1 - p0
	local k = v:Dot(d0)
	k = math.clamp(k, -len, len)
	return p0 + d0 * k
end

local function ClosestPointFunc(cframe, length, radius, point)
	local l0 = solve(cframe.Position, cframe.UpVector, length * 0.5, point)

	local distance = (l0 - point).Magnitude
	local normal = SafeUnit(point - l0)
	local is_inside = (distance <= radius)

	return is_inside, l0 + (normal * radius), normal
end

return function(CapsuleCFrame, CapsuleSize, Point, Radius)
	
local CapsuleRadius = (CapsuleSize.Y < CapsuleSize.Z and CapsuleSize.Y or CapsuleSize.Z) * 0.5
	local CapsuleLength = CapsuleSize.X

	CapsuleCFrame *= CFrame.Angles(math.rad(90), -math.rad(90), 0) -- Optomize

	local IsInside, ClosestPoint, Normal = ClosestPointFunc(CapsuleCFrame, CapsuleLength, CapsuleRadius, Point)

	if IsInside then
		return IsInside, ClosestPoint, Normal
	end

	local DistanceToCp = (ClosestPoint - Point).Magnitude

	IsInside = (DistanceToCp < Radius)
	
return IsInside, ClosestPoint, Normal
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Capsule

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Cylinder | Enabled: N/A
--------------------------------------------------------------------
--!native
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function solve(p0, d0, len, p1)
	local v = p1 - p0
	local k = v:Dot(d0)
	k = math.clamp(k, -len, len)
	return p0 + d0 * k, k
end

local function ProjectOnPlane(pos, normal, point)
	local d = point - pos
	local v_dot = d:Dot(normal)
	local v = point - v_dot * normal

	return v
end

local function ClosestPointFunc(cframe, size, point)
	local radius = (size.Y < size.Z and size.Y or size.Z) * 0.5
	local length = size.X * 0.5
	local l0, k = solve(cframe.Position, cframe.RightVector, length, point)

	local endPlane = cframe.Position + -cframe.RightVector * length
	local topPlane = cframe.Position + cframe.RightVector * length

	local endPlaneN = -cframe.RightVector
	local topPlaneN = cframe.RightVector

	local projEnd = ProjectOnPlane(endPlane, endPlaneN, point)
	local projTop = ProjectOnPlane(topPlane, topPlaneN, point)

	local function GetFinalProj(proj, o)
		local projDir = SafeUnit(proj - o)
		local projDistance = (proj - o).Magnitude
		return o + projDir * (projDistance < radius and projDistance or radius)
	end

	projEnd = GetFinalProj(projEnd, endPlane)
	projTop = GetFinalProj(projTop, topPlane)

	local radiusDistance = (l0 - point).Magnitude
	local radiusNormal = SafeUnit(point - l0)
	local radiusInside = (radiusDistance <= radius)
	local radiusPosition = l0 + (radiusNormal * radius)

	local d0 = (projTop - point).Magnitude
	local d1 = (projEnd - point).Magnitude
	local d2 = (radiusPosition - point).Magnitude

	local d = math.min(d0, d1, d2)

	if k == length or d == d0 then
		local dot = SafeUnit(point - projTop):Dot(topPlaneN)
		return dot < 0, projTop, topPlaneN
	elseif k == -length or d == d1 then
		local dot = SafeUnit(point - projEnd):Dot(endPlaneN)
		return dot < 0, projEnd, endPlaneN
	end

	return radiusInside, radiusPosition, radiusNormal
end

return function(CylinderCFrame, CylinderSize, Point, Radius) -- IsInside, PushPosition, PushNormal
	
local IsInside, PushPosition, PushNormal = ClosestPointFunc(CylinderCFrame, CylinderSize, Point)

	if IsInside then
		return IsInside, PushPosition, PushNormal
	end

	local PointDistance = (PushPosition - Point).Magnitude

	IsInside = PointDistance < Radius
	
return IsInside, PushPosition, PushNormal
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Cylinder

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Sphere | Enabled: N/A
--------------------------------------------------------------------
--!native
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function ClosestPointFunc(position, radius, point)
	local distance = (position - point).Magnitude
	local normal = SafeUnit(point - position)
	local is_inside = (distance <= radius)

	return is_inside, position + (normal * radius), normal
end

return function(Sphere0Point, Sphere0Radius, Sphere1Point, Sphere1Radius)
	
Sphere0Point = Sphere0Point.Position
	Sphere0Radius = math.min(Sphere0Radius.X, Sphere0Radius.Y, Sphere0Radius.Z) * 0.5

	local IsInside, ClosestPoint, Normal = ClosestPointFunc(Sphere0Point, Sphere0Radius, Sphere1Point)

	if IsInside then
		return IsInside, ClosestPoint, Normal
	end

	local DistanceToCp = (ClosestPoint - Sphere1Point).Magnitude

	IsInside = (DistanceToCp < Sphere1Radius)
	
return IsInside, ClosestPoint, Normal
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Sphere

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Triangle | Enabled: N/A
--------------------------------------------------------------------
--[[

    !! THIS IS NOT MEANT TO BE USED AS A COLLIDER SOLVER, ITS MEANT TO BE USED IN OTHER COLLIDER SOLVERS !!

]]

--!native
local dot = Vector3.new().Dot
local cross = Vector3.new().Cross
local clamp = math.clamp

local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local function ClosestPointOnLineSegment(A, B, P)
	local AB = B - A
	local t = dot(P - A, AB) / dot(AB, AB)
	return A + clamp(t, 0, 1) * AB
end

local function ProjectOnPlane(pos, normal, point)
	local d = point - pos
	local v_dot = d:Dot(normal)
	local v = point - v_dot * normal

	return v
end

local function SameSide(p1, p2, a, b)
	local cp1 = cross(b - a, p1 - a)
	local cp2 = cross(b - a, p2 - a)
	if dot(cp1, cp2) >= 0 then
		return true
	else
		return false
	end
end

local function PointInTriangle(p, a, b, c)
	if SameSide(p, a, b, c) and SameSide(p, b, a, c) and SameSide(p, c, a, b) then
		return true
	end

	return false
end

local function ClosestPointOnTri(v0, v1, v2, point) -- ClosestPoint, Normal
	
local Edge0 = ClosestPointOnLineSegment(v0, v1, point)
	local Edge1 = ClosestPointOnLineSegment(v1, v2, point)
	local Edge2 = ClosestPointOnLineSegment(v2, v0, point)

	local Normal = SafeUnit(cross(v1 - v0, v2 - v0))
	local Center = (v0 + v1 + v2) * 0.3333
	local Projected = ProjectOnPlane(Center, Normal, point)

	if PointInTriangle(point, v0, v1, v2) then
		
return Projected, Normal
	end

	local d0 = (Edge0 - point).Magnitude
	local d1 = (Edge1 - point).Magnitude
	local d2 = (Edge2 - point).Magnitude

	local d = math.min(d0, d1, d2)

	if d == d0 then
		
return Edge0, Normal
	elseif d == d1 then
		
return Edge1, Normal
	elseif d == d2 then
		
return Edge2, Normal
	end
	

return point, Normal
end

return ClosestPointOnTri

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Collision.Colliders.Triangle

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

local inf = math.huge

return function(self, Position, LastPosition, RootCFrame)
	
local RootOffset = RootCFrame:Inverse() * Position

	local X = RootOffset.X
	local Y = RootOffset.Y
	local Z = RootOffset.Z

	local XLimit = self.XAxisLimits
	local YLimit = self.YAxisLimits
	local ZLimit = self.ZAxisLimits

	local XLock = self.AxisLocked[1] and 0 or 1
	local YLock = self.AxisLocked[2] and 0 or 1
	local ZLock = self.AxisLocked[3] and 0 or 1

	-- Most bones probably wont have an axis limit, this allows us to skip all the other stuff
	if XLimit.Min == -inf and XLimit.Max == inf and YLimit.Min == -inf and YLimit.Max == inf and ZLimit.Min == -inf and ZLimit.Max == inf then
		if XLock == 1 and YLock == 1 and ZLock == 1 then
			
return Position
		else
			return RootCFrame * Vector3.new(X * XLock, Y * YLock, Z * ZLock)
		end
	end

	-- If our radius is > than the diff between min and max
	-- We do this because its faster than math.min() Â¯\_(ãƒ„)_/Â¯
	local XMin = XLimit.Min + self.Radius
	local XMax = XMin <= (XLimit.Max - self.Radius) and XLimit.Max - self.Radius or XMin

	local YMin = YLimit.Min + self.Radius
	local YMax = YMin <= (YLimit.Max - self.Radius) and YLimit.Max - self.Radius or YMin

	local ZMin = ZLimit.Min + self.Radius
	local ZMax = ZMin <= (ZLimit.Max - self.Radius) and ZLimit.Max - self.Radius or ZMin

	X = X < XMin and XMin or (X > XMax and XMax or X)
	Y = Y < YMin and YMin or (Y > YMax and YMax or Y)
	Z = Z < ZMin and ZMin or (Z > ZMax and ZMax or Z)

	X *= XLock
	Y *= YLock
	Z *= ZLock

	local WorldSpace = RootCFrame * Vector3.new(X, Y, Z)

	Position = WorldSpace

	local XAxis = RootCFrame.RightVector
	local YAxis = RootCFrame.UpVector
	local ZAxis = RootCFrame.LookVector

	local DifferenceDirection = SafeUnit(Position - LastPosition)

	-- Remove our velocity on the vectors we collided with, stops any weird jittering.
	if X ~= RootOffset.X then
		local Normal = XAxis:Dot(DifferenceDirection) < 0 and -XAxis or XAxis
		self:ClipVelocity(Position, Normal)
	end

	if Y ~= RootOffset.Y then
		local Normal = YAxis:Dot(DifferenceDirection) < 0 and -YAxis or YAxis
		self:ClipVelocity(Position, Normal)
	end

	if Z ~= RootOffset.Z then
		local Normal = ZAxis:Dot(DifferenceDirection) > 0 and -ZAxis or ZAxis
		self:ClipVelocity(Position, Normal)
	end

	
return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint.spec | Enabled: N/A
--------------------------------------------------------------------
local AxisConstraint = require(script.Parent:WaitForChild("AxisConstraint"))

return function()
	local Bone = {
		Radius = 0,
		XAxisLimits = NumberRange.new(-math.huge, math.huge),
		YAxisLimits = NumberRange.new(-math.huge, math.huge),
		ZAxisLimits = NumberRange.new(-math.huge, math.huge),
		AxisLocked = { false, false, false },
		ClipVelocity = function() end,
	}

	afterEach(function()
		Bone.AxisLocked = { false, false, false }
	end)

	describe("Axis Lock", function()
		it("Should lock X Axis", function()
			Bone.AxisLocked = { true, false, false }

			local Result = AxisConstraint(Bone, Vector3.new(-10, 0, 0), Vector3.zero, CFrame.identity)

			expect(Result.X).to.equal(0)
		end)

		it("Should lock Y Axis", function()
			Bone.AxisLocked = { false, true, false }

			local Result = AxisConstraint(Bone, Vector3.new(0, -10, 0), Vector3.zero, CFrame.identity)

			expect(Result.Y).to.equal(0)
		end)

		it("Should lock Z Axis", function()
			Bone.AxisLocked = { false, false, true }

			local Result = AxisConstraint(Bone, Vector3.new(0, 0, -10), Vector3.zero, CFrame.identity)

			expect(Result.Z).to.equal(0)
		end)
	end)

	describe("Axis Limit", function()
		describe("Should limit X Axis", function()
			it("Min Limit", function()
				Bone.XAxisLimits = NumberRange.new(-5, math.huge)

				local Result = AxisConstraint(Bone, Vector3.new(-10, 0, 0), Vector3.zero, CFrame.identity)

				expect(Result.X).to.equal(-5)
			end)

			it("Max Limit", function()
				Bone.XAxisLimits = NumberRange.new(-math.huge, 5)

				local Result = AxisConstraint(Bone, Vector3.new(10, 0, 0), Vector3.zero, CFrame.identity)

				expect(Result.X).to.equal(5)
			end)
		end)

		describe("Should limit Y Axis", function()
			it("Min Limit", function()
				Bone.YAxisLimits = NumberRange.new(-5, math.huge)

				local Result = AxisConstraint(Bone, Vector3.new(0, -10, 0), Vector3.zero, CFrame.identity)

				expect(Result.Y).to.equal(-5)
			end)

			it("Max Limit", function()
				Bone.YAxisLimits = NumberRange.new(-math.huge, 5)

				local Result = AxisConstraint(Bone, Vector3.new(0, 10, 0), Vector3.zero, CFrame.identity)

				expect(Result.Y).to.equal(5)
			end)
		end)

		describe("Should limit Z Axis", function()
			it("Min Limit", function()
				Bone.ZAxisLimits = NumberRange.new(-5, math.huge)

				local Result = AxisConstraint(Bone, Vector3.new(0, 0, -10), Vector3.zero, CFrame.identity)

				expect(Result.Z).to.equal(-5)
			end)

			it("Max Limit", function()
				Bone.ZAxisLimits = NumberRange.new(-math.huge, 5)

				local Result = AxisConstraint(Bone, Vector3.new(0, 0, 10), Vector3.zero, CFrame.identity)

				expect(Result.Z).to.equal(5)
			end)
		end)
	end)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.AxisConstraint.spec

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.CollisionConstraint | Enabled: N/A
--------------------------------------------------------------------
return function(self, Position, Colliders)
	
local Collisions = {}
	local HitParts = {}

	for _, Collider in Colliders do
		local ColliderCollisions = Collider:GetCollisions(Position, self.Radius)

		if #ColliderCollisions > 0 then
			table.insert(HitParts, Collider:GetObject())
		end

		for _, Collision in ColliderCollisions do
			table.insert(Collisions, Collision)
		end
	end

	for _, Collision in Collisions do
		Position = Collision.ClosestPoint + (Collision.Normal * self.Radius)
		-- self:ClipVelocity(Position, Collision.Normal) -- This causes some weird glitching issues, not sure why tbh
	end

	self.CollisionsData = Collisions
	self.CollisionHits = HitParts

	
return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.CollisionConstraint

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

return function(self, Position, BoneTree)
	
local ParentBone = BoneTree.Bones[self.ParentIndex]

	if ParentBone then
		local RestLength = self.FreeLength
		local BoneDirection = SafeUnit(Position - ParentBone.Position)

		local RestPosition = ParentBone.Position + (BoneDirection * RestLength)
		

return RestPosition
	end
	

return
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceConstraint

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceContraint.spec | Enabled: N/A
--------------------------------------------------------------------
local DistanceConstraint = require(script.Parent:WaitForChild("DistanceConstraint"))

local function CreateBone(Position, FreeLength, Parent)
	return {
		Position = Position,
		FreeLength = FreeLength,
		ParentIndex = Parent,
	}
end

return function()
	local BoneTree = {
		Bones = {
			CreateBone(Vector3.zero, 3, 0),
			CreateBone(Vector3.yAxis, 3, 1),
		},
	}

	describe("Distance Constraint", function()
		local Bone = BoneTree.Bones[2]

		local function Callback()
			local NewPosition = DistanceConstraint(Bone, Bone.Position, BoneTree)

			expect(NewPosition.Magnitude).to.equal(Bone.FreeLength)

			Bone.Position = NewPosition
		end

		for i = 1, 10 do
			it(`Should limit to {Bone.FreeLength} studs #{i}`, Callback)
			Bone.FreeLength = math.random(1, 20)
		end
	end)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.DistanceContraint.spec

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.FrictionConstraint | Enabled: N/A
--------------------------------------------------------------------
return function(self, Position, LastPosition)
	local Alpha = 1 - self.Friction

	return LastPosition:Lerp(Position, Alpha)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.FrictionConstraint

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

return function(self, Position, BoneTree)
	
local ParentBone = BoneTree.Bones[self.ParentIndex]

	if ParentBone then
		local RestLength = self.FreeLength
		local BoneSub = (Position - ParentBone.Position)
		local BoneDirection = SafeUnit(BoneSub)
		local BoneDistance = BoneSub.Magnitude < RestLength and BoneSub.Magnitude or RestLength

		local RestPosition = ParentBone.Position + (BoneDirection * BoneDistance)
		

return RestPosition
	end
	

return
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint.spec | Enabled: N/A
--------------------------------------------------------------------
local RopeConstraint = require(script.Parent:WaitForChild("RopeConstraint"))

local function CreateBone(Position, FreeLength, Parent)
	return {
		Position = Position,
		FreeLength = FreeLength,
		ParentIndex = Parent,
	}
end

return function()
	local BoneTree = {
		Bones = {
			CreateBone(Vector3.zero, 3, 0),
			CreateBone(Vector3.yAxis * 10, 3, 1),
		},
	}

	describe("Rope Constraint", function()
		local Bone = BoneTree.Bones[2]
		local i = 0

		local ReRun

		local function LimitCallback()
			local NewPosition = RopeConstraint(Bone, Bone.Position, BoneTree)

			expect(NewPosition.Magnitude).to.equal(Bone.FreeLength)

			Bone.FreeLength = math.random(1, 20)

			ReRun()
		end

		local function SameCallback()
			local NewPosition = RopeConstraint(Bone, Bone.Position, BoneTree)

			expect(NewPosition.Magnitude).to.equal(Bone.Position.Magnitude)

			Bone.FreeLength = math.random(1, 20)

			ReRun()
		end

		ReRun = function()
			if i >= 10 then
				return
			end

			i += 1

			if Bone.Position.Magnitude < Bone.FreeLength then
				it(`Should stay the same #{i}`, SameCallback)
			else
				it(`Should limit to {Bone.FreeLength} studs #{i}`, LimitCallback)
			end
		end

		ReRun()
	end)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RopeConstraint.spec

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RotationConstraint | Enabled: N/A
--------------------------------------------------------------------
local function SafeUnit(v3)
	if v3.Magnitude == 0 then
		return Vector3.zero
	end

	return v3.Unit
end

return function(self, Position, BoneTree)
	
local ParentIndex = self.ParentIndex
	local ParentBone = BoneTree.Bones[ParentIndex]

	if not ParentBone then
		
return Position
	end

	local ParentBoneLimit = ParentBone.RotationLimit

	if ParentBoneLimit >= 180 then
		
return Position
	end

	local GrandParentBone = BoneTree.Bones[ParentBone.ParentIndex]

	if not GrandParentBone then
		
return Position
	end

	local ParentBonePosition = ParentBone.Position
	local DefaultDirection = SafeUnit(ParentBone.Position - GrandParentBone.Position)

	local DistanceToParent = (Position - ParentBonePosition).Magnitude
	local DirectionToSelf = SafeUnit(Position - ParentBonePosition)

	if ParentBoneLimit <= 0 then
		
return ParentBonePosition + DefaultDirection * DistanceToParent
	end

	local RotationLimit = math.rad(self.RotationLimit)
	local VectorAngle = math.acos(DefaultDirection:Dot(DirectionToSelf))
	local LimitedVector

	if VectorAngle >= RotationLimit then
		local Cross = SafeUnit(DefaultDirection:Cross(DirectionToSelf))
		LimitedVector = CFrame.fromAxisAngle(Cross, RotationLimit) * DefaultDirection
	else
		LimitedVector = DirectionToSelf
	end

	if LimitedVector ~= LimitedVector then -- Somewhat hacky fix
		LimitedVector = DefaultDirection
	end

	Position = ParentBonePosition + LimitedVector * DistanceToParent
	

return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.RotationConstraint

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.SpringConstraint | Enabled: N/A
--------------------------------------------------------------------
--!native
return function(self, Position, RestPosition, BoneTree, Delta)

	
local Settings = BoneTree.Settings
	local Stiffness = Settings.Stiffness
	local Elasticity = Settings.Elasticity

	local ParentBone = BoneTree.Bones[self.ParentIndex]

	if ParentBone then
		local RestLength = self.FreeLength

		if Stiffness > 0 or Elasticity > 0 then
			local ParentBoneCFrame = CFrame.new(ParentBone.Position) * ParentBone.TransformOffset.Rotation
			RestPosition = RestPosition or (ParentBoneCFrame * CFrame.new(self.LocalTransformOffset.Position)).Position

			local ElasticDifference = RestPosition - Position
			Position += ElasticDifference * (Elasticity * Delta)

			if Stiffness > 0 then
				local StiffDifference = RestPosition - Position
				local Length = StiffDifference.Magnitude
				local MaxLength = RestLength * (1 - Stiffness) * 2
				if Length > MaxLength then
					Position += StiffDifference * ((Length - MaxLength) / Length)
				end
			end
		end

		local Difference = ParentBone.Position - Position
		local Length = Difference.Magnitude
		if Length > 0 then
			Position += Difference * ((Length - RestLength) / Length)
		end
	end

	
return Position
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.SmartBone.Components.Constraints.SpringConstraint

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair | Enabled: N/A
--------------------------------------------------------------------
--[[
FUNCTION LIST:

DynamicCrosshair.new()
DynamicCrosshair:Enable()
DynamicCrosshair:Disable()
DynamicCrosshair:Lock()
DynamicCrosshair:Size()
DynamicCrosshair:Destroy()
DynamicCrosshair:Display()
DynamicCrosshair:Set()
DynamicCrosshair:SmoothSet()
DynamicCrosshair:Shove()
DynamicCrosshair:FollowMouse()
DynamicCrosshair:HitMarker()
DynamicCrosshair:Update() (OUTDATED)
]]

local CrosshairModule 		= {}
local Crosshairs			= {}
CrosshairModule.__index 	= CrosshairModule

local GetService			= game.GetService

local TweenService			= GetService(game, "TweenService")
local RunService			= GetService(game, "RunService")
local UserInputService		= GetService(game, "UserInputService")
local GuiService 			= GetService(game, "GuiService")
local Players				= GetService(game, "Players")

local LocalPlayer			= Players.LocalPlayer
local Camera				= workspace.CurrentCamera

local Functions				= require(script:WaitForChild("Functions"))

function CrosshairModule.New(UI, MinSpread, MaxSpread, DecreasePerSecond, IncreasePerSecond, MouseFollow) 
	local self 				= {}

	self.UI 					= UI or Instance.new('ScreenGui', LocalPlayer.PlayerGui)
		
	self.SizeX 					= 5
	self.SizeY 					= 1

	self.Top, self.Bottom, self.Left, self.Right, self.HitMarker, self.CenterDot, self.ImageCrosshair = Functions:CreateHairs(UI, self.SizeX, self.SizeY)
		
	self.Spreading = {
		Spread 					= MinSpread or 20,
		MaxSpread 				= MaxSpread or 60,
		MinSpread 				= MinSpread or 20,
		DecreasePerSecond 		= DecreasePerSecond or 40,
		IncreasePerSecond 		= IncreasePerSecond or 30
	}
		
	self.FollowingMouse			= ((MouseFollow and type(MouseFollow) == "boolean") and MouseFollow) or false
	self.Locked 				= false
	
	
	self.Hairs 					= {
		self.Top,
		self.Bottom,
		self.Left,
		self.Right
	}

	self.EasingStyle 			= Enum.EasingStyle.Linear
	self.EasingDirection 		= Enum.EasingDirection.InOut
	
	self.HitMarker = {
		hitmarker = self.HitMarker;
		size = UDim2.fromOffset(50, 50);
		default = Color3.fromRGB(255, 255, 255);
		headshot = Color3.fromRGB(255, 0, 0);
		fadeTime = 0.25;
		easingStyle = Enum.EasingStyle.Linear;
		easingDirection = Enum.EasingDirection.InOut;
		Image = {
			default = 'rbxassetid://118682730809232';
			headshot = 'rbxassetid://102213744787573';
		};
	}
	
	self.CenterDot = {
		centerdot = self.CenterDot;
		size = UDim2.fromOffset(7.5,7.5);
		enabled = false;
		transparency = 0;
		Image = 'rbxassetid://11003529439';
	}
	
	self.ImageCrosshair = {
		crosshair = self.ImageCrosshair;
		enabled = false;
		Image = 'rbxassetid://12550071496';
	}
	
	table.insert(Crosshairs, self)

	Functions:UpdateEnabled(self.Hairs, false)
	
	return setmetatable(self, CrosshairModule)
end

function CrosshairModule:Enable()
	self.Enabled 						= true
	UserInputService.MouseIconEnabled 	= false
	
	Functions:UpdateEnabled(self.Hairs, self.Enabled)
end
					
function CrosshairModule:Disable()
	self.Enabled 						= false
	UserInputService.MouseIconEnabled 	= true
	
	Functions:UpdateEnabled(self.Hairs, self.Enabled)
end

function CrosshairModule:Lock(Bool : boolean)
	self.Locked 				= Bool or true
end

function CrosshairModule:FollowMouse(Bool : boolean)
	self.FollowingMouse 		= Bool or true
end

function CrosshairModule:Hitmarker(headshot : boolean, fadeTime, easingStyle, easingDirection)
	if headshot then
		self.HitMarker.hitmarker.ImageColor3 = self.HitMarker.headshot
	else
		self.HitMarker.hitmarker.ImageColor3 = self.HitMarker.default
	end
	
	
	self.HitMarker.hitmarker.Size = self.HitMarker.size 
	self.HitMarker.hitmarker.ImageTransparency = 0
	
	TweenService:Create(
		self.HitMarker.hitmarker, 
		TweenInfo.new(fadeTime or self.HitMarker.fadeTime, easingStyle or self.HitMarker.easingStyle, easingDirection or self.HitMarker.easingDirection),
		{ImageTransparency = 1}
	):Play()
end

function CrosshairModule:Size(X : number, Y : number)
	self.SizeX 					= X or self.SizeX
	self.SizeY 					= Y or self.SizeY

	X = self.SizeX; Y = self.SizeY;

	self.Top	.Size 			= UDim2.fromOffset(Y, X)
	self.Bottom	.Size 			= UDim2.fromOffset(Y, X)
	self.Left	.Size 			= UDim2.fromOffset(X, Y)
	self.Right	.Size 			= UDim2.fromOffset(X, Y)
end

function CrosshairModule:Destroy()
	for Index, Value in pairs(self.Hairs) do
		Value:Destroy()
	end
	self.CenterDot.centerdot:Destroy()
	self.ImageCrosshair.crosshair:Destroy()
	table.remove(Crosshairs, table.find(Crosshairs, self))
	table.clear(self)
end

function CrosshairModule:Display(SettingsTable)
	local function ApplyAll(Setting, Value)
		for i, Hair in pairs(self.Hairs) do
			Hair[Setting] = Value
		end
	end

	for Setting, Value in pairs(SettingsTable) do
		local Success = pcall(function() local Check = self.Top[Setting] end)

		if Success then
			ApplyAll(Setting, Value)
		end
	end
end

function CrosshairModule:Set(Radius)
	self.Spreading.Spread 		= tonumber(Radius)
end

function CrosshairModule:SmoothSet(Spread : number, Seconds : number, UpdateMin : boolean)
	local StartTick 	= tick()
	local StartSpread 	= self.Spreading.Spread

	while ( tick() - StartTick ) < Seconds do
		
		local Alpha 	= (tick() - StartTick) / Seconds
		
		Alpha = TweenService:GetValue(
			Alpha,
			self.EasingStyle or Enum.EasingStyle.Linear,
			self.EasingDirection or Enum.EasingDirection.InOut
		)
		
		self.Spreading.Spread = StartSpread + (Spread - StartSpread) * Alpha 

		RunService.Heartbeat:Wait()
	end
	
	if UpdateMin then self.Spreading.MinSpread = self.Spreading.Spread end
	
	self.Spreading.Spread = Spread
end

function CrosshairModule:Shove()
	self.Spreading.Spread += self.Spreading.IncreasePerSecond
end

function CrosshairModule:Update(DeltaTime)
	if not self.Enabled then return end
	if not self.Locked then
		self.Spreading.Spread -= self.Spreading.DecreasePerSecond * DeltaTime
	end

	self.Spreading.Spread = math.clamp(self.Spreading.Spread, self.Spreading.MinSpread, self.Spreading.MaxSpread)

	local originX, originY

	if self.FollowingMouse then
		local mousePos = UserInputService:GetMouseLocation()
		originX = mousePos.X
		originY = mousePos.Y

		if self.UI:IsA("ScreenGui") and not self.UI.IgnoreGuiInset then
			local guiInset = GuiService:GetGuiInset()
			originY -= guiInset.Y
		end
	else
		if self.UI:IsA("ScreenGui") then
			local camera = workspace.CurrentCamera
			local size = camera.ViewportSize

			originX = size.X / 2
			originY = size.Y / 2

			if not self.UI.IgnoreGuiInset then
				local guiInset = GuiService:GetGuiInset()
				originY -= guiInset.Y
			end
		else
			local absPos = self.UI.AbsolutePosition
			local absSize = self.UI.AbsoluteSize

			originX = absPos.X + absSize.X / 2
			originY = absPos.Y + absSize.Y / 2
		end
	end

	local offsetX = originX
	local offsetY = originY

	if not self.UI:IsA("ScreenGui") then
		local uiAbsPos = self.UI.AbsolutePosition
		offsetX -= uiAbsPos.X
		offsetY -= uiAbsPos.Y
	end

	local Origin = UDim2.fromOffset(offsetX, offsetY)
	local VerticalOffset = UDim2.fromOffset(0, self.Spreading.Spread)
	local HorizontalOffset = UDim2.fromOffset(self.Spreading.Spread, 0)

	self.Top.Position 		= Origin - VerticalOffset
	self.Bottom.Position 	= Origin + VerticalOffset
	self.Right.Position 	= Origin - HorizontalOffset
	self.Left.Position 		= Origin + HorizontalOffset
	self.HitMarker.hitmarker.Position = Origin

	if self.CenterDot.enabled then
		local cd = self.CenterDot.centerdot
		cd.Visible = true
		cd.Image = self.CenterDot.Image
		cd.Size = self.CenterDot.size
		cd.ImageTransparency = self.CenterDot.transparency
		cd.Position = Origin
	else
		self.CenterDot.centerdot.Visible = false
	end

	if self.ImageCrosshair.enabled then
		local ic = self.ImageCrosshair.crosshair
		ic.Visible = true
		ic.Image = self.ImageCrosshair.Image
		ic.Size = UDim2.fromOffset(
			(self.SizeX * 2) + self.Spreading.Spread,
			(self.SizeX * 2) + self.Spreading.Spread
		)
		ic.Position = Origin
		Functions:UpdateEnabled(self.Hairs, false)
	else
		self.ImageCrosshair.crosshair.Visible = false
		Functions:UpdateEnabled(self.Hairs, true)
	end
end

function CrosshairModule:Raycast()
	local X, Y = Functions:RandomPointsInsideCrosshair(self.Spreading.Spread - (self.SizeX * 4))
	local Camera = workspace.CurrentCamera
	local ViewportSize = Camera.ViewportSize
	local mousePos = UserInputService:GetMouseLocation()

	local screenX, screenY

	if self.FollowingMouse then
		screenX = mousePos.X
		screenY = mousePos.Y
	else
		screenX = ViewportSize.X / 2
		screenY = ViewportSize.Y / 2
	end

	local raycastX = screenX + X
	local raycastY = screenY + Y

	local unitRay = Camera:ViewportPointToRay(raycastX, raycastY)
	return unitRay.Origin, unitRay.Direction
end


RunService.RenderStepped:Connect(function(Delta)
	for i, v in pairs(Crosshairs) do
		v:Update(Delta)
	end
end)

return CrosshairModule
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair.Functions | Enabled: N/A
--------------------------------------------------------------------
local Functions = {}

function Functions:CreateHairs(Parent, X, Y)
	local Hairs 	= {}

	for I = 1, 7 do
		local Frame 		= Instance.new("ImageLabel")
		Frame.Image 		= ''
		Frame.Name 			= "_hair"
		Frame.Parent 		= Parent
		Frame.AnchorPoint 	= Vector2.new(0.5, 0.5)

		if I < 3 then
			Frame.Size 		= UDim2.fromOffset(Y, X)
		elseif I > 2 and I < 5 then
			Frame.Size 		= UDim2.fromOffset(X, Y)
		elseif I == 5 then
			Frame.BackgroundTransparency	= 1
			Frame.Size 						= UDim2.fromOffset(50, 50)
			Frame.Image 					= 'rbxassetid://285779644'
			Frame.Name 						= "HitMarker"
			Frame.ImageTransparency			= 1
		elseif I == 6 then
			Frame.BackgroundTransparency	= 1
			Frame.Size 						= UDim2.fromOffset(10, 10)
			Frame.Image 					= 'rbxassetid://11003529439'
			Frame.Name 						= "CenterDot"
			Frame.ImageTransparency			= 0
			Frame.Visible 					= false
		else
			Frame.BackgroundTransparency	= 1
			Frame.Name 						= 'ImageCrosshair'
			Frame.Visible 					= false
		end

		table.insert(Hairs, I, Frame)
	end

	return unpack(Hairs)
end

function Functions:RandomPointsInsideCrosshair(Offset)
	local R 			= Offset * math.sqrt(math.random())
	local Theta 		= math.random() * 2 * math.pi
	local X 			= R * math.cos(Theta)
	local Y 			= R * math.sin(Theta)

	return X, Y
end


function Functions:UpdateEnabled(UI, Bool)
	for _, Item in pairs(UI) do
		Item.Visible = Bool
	end
end

return Functions
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair.Functions

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.CrosshairHandler | Enabled: N/A
--------------------------------------------------------------------
--- @ Crosshair Handler
local CrosshairHandler = {}

--- @ Crosshair Handler > Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")

--- @ Crosshair Handler > Dependencies
local DynamicCrosshair = require(ReplicatedStorage.Peak.Modules.Client.DynamicCrosshair)

--- @ Crosshair Handler > Configuration
local CrosshairStyles = {
	["Circle"] = {
		Image = "rbxassetid://6707322206",
		MinSpread = 10,
		MaxSpread = 80,
		Decrease = 0, -- increase and decrease will always be left at 0.
		Increase = 0,
		ImageEnabled = true
	},
	["Dot"] = {
		Image = "rbxassetid://13413677345",
		MinSpread = 5,
		MaxSpread = 40,
		Decrease = 0,
		Increase = 0,
		ImageEnabled = true
	},
}

--- @ Crosshair Handler > Variables
local CrosshairInstance = nil
local CrosshairGUI = nil

--- @ Crosshair Handler > Logic
function CrosshairHandler.Init(player)
	if CrosshairInstance then return end

	local assetsToLoad = {}
	for _, style in pairs(CrosshairStyles) do
		if style.Image then
			table.insert(assetsToLoad, style.Image)
		end
	end

	task.spawn(function()
		local tempInstances = {}
		for _, id in ipairs(assetsToLoad) do
			local img = Instance.new("ImageLabel")
			img.Image = id
			table.insert(tempInstances, img)
		end
		ContentProvider:PreloadAsync(tempInstances)
		for _, img in ipairs(tempInstances) do
			img:Destroy()
		end
	end)

	CrosshairGUI = Instance.new("ScreenGui")
	CrosshairGUI.Name = "CrosshairGUI"
	CrosshairGUI.ResetOnSpawn = false
	CrosshairGUI.IgnoreGuiInset = true
	CrosshairGUI.DisplayOrder = 100 
	CrosshairGUI.Parent = player:WaitForChild("PlayerGui")

	CrosshairInstance = DynamicCrosshair.New(CrosshairGUI, 10, 80, 60, 40, false)
	CrosshairInstance:Disable()

	CrosshairHandler.SetStyle("Circle")
end

function CrosshairHandler.SetStyle(styleName)
	if not CrosshairInstance then return end

	local style = CrosshairStyles[styleName] or CrosshairStyles["Circle"]

	CrosshairInstance.Spreading.MinSpread = style.MinSpread
	CrosshairInstance.Spreading.MaxSpread = style.MaxSpread
	CrosshairInstance.Spreading.Spread = style.MinSpread 
	CrosshairInstance.Spreading.DecreasePerSecond = style.Decrease
	CrosshairInstance.Spreading.IncreasePerSecond = style.Increase

	CrosshairInstance.ImageCrosshair.enabled = style.ImageEnabled
	CrosshairInstance.ImageCrosshair.Image = style.Image

	if CrosshairInstance.ImageCrosshair.crosshair then
		CrosshairInstance.ImageCrosshair.crosshair.Image = style.Image
	end
end

function CrosshairHandler.SetVisible(visible)
	if not CrosshairInstance then return end

	if visible then
		CrosshairInstance:Enable()
	end

	local targetAlpha = visible and 0 or 1
	local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

	local tween = TweenService:Create(CrosshairInstance.ImageCrosshair.crosshair, tweenInfo, {ImageTransparency = targetAlpha})
	tween:Play()

	if not visible then
		task.delay(0.2, function()
			if CrosshairInstance.ImageCrosshair.crosshair.ImageTransparency >= 0.9 then
				CrosshairInstance:Disable()
			end
		end)
	end
end

function CrosshairHandler.SetSpread(value)
	if CrosshairInstance then
		CrosshairInstance:Set(value)
	end
end

return CrosshairHandler
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.CrosshairHandler

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.HitmarkerHandler | Enabled: N/A
--------------------------------------------------------------------
-- HitmarkerCrosshairModule.lua
local HitmarkerCrosshair = {}
HitmarkerCrosshair.__index = HitmarkerCrosshair

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

--====================================================
-- Constructor
--====================================================
function HitmarkerCrosshair.new(parentGui)
	local self = setmetatable({}, HitmarkerCrosshair)

	self.UI = parentGui or Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
	self.UI.Name = "HitmarkerCrosshair"
	self.UI.IgnoreGuiInset = true
	self.UI.ResetOnSpawn = false

	--============================
	-- CROSSHAIR
	--============================
	local cross = Instance.new("ImageLabel")
	cross.Name = "Crosshair"
	cross.BackgroundTransparency = 1
	cross.Image = "rbxassetid://11003529439" -- white dot
	cross.Size = UDim2.fromOffset(6,6)
	cross.AnchorPoint = Vector2.new(.5,.5)
	cross.Visible = false
	cross.Parent = self.UI
	self.Crosshair = cross

	self.FollowMouse = false

	--============================
	-- HITMARKER
	--============================
	local hit = Instance.new("ImageLabel")
	hit.Name = "Hitmarker"
	hit.BackgroundTransparency = 1
	hit.Image = "rbxassetid://118682730809232" -- default
	hit.AnchorPoint = Vector2.new(.5,.5)
	hit.Size = UDim2.fromOffset(50,50)
	hit.ImageTransparency = 1
	hit.Parent = self.UI
	self.Hitmarker = hit

	self.Styles = {
		DefaultImage = "rbxassetid://118682730809232",
		HeadshotImage = "rbxassetid://102213744787573",
		DefaultColor = Color3.new(1,1,1),
		HeadshotColor = Color3.new(1,0,0),
		FadeTime = 0.25
	}

	-- Listen every frame
	RunService.RenderStepped:Connect(function()
		self:_update()
	end)

	return self
end

--====================================================
-- Enable/Disable Crosshair
--====================================================
function HitmarkerCrosshair:EnableCrosshair()
	self.Crosshair.Visible = true
end

function HitmarkerCrosshair:DisableCrosshair()
	self.Crosshair.Visible = false
end

--====================================================
-- Follow Mouse vs Stay Centered
--====================================================
function HitmarkerCrosshair:FollowMouse(bool)
	self.FollowMouse = bool
end

--====================================================
-- HITMARKER
--====================================================
function HitmarkerCrosshair:HitMarker(isHeadshot)
	local hit = self.Hitmarker

	if isHeadshot then
		hit.Image = self.Styles.HeadshotImage
		hit.ImageColor3 = self.Styles.HeadshotColor
	else
		hit.Image = self.Styles.DefaultImage
		hit.ImageColor3 = self.Styles.DefaultColor
	end

	hit.ImageTransparency = 0
	hit.Size = UDim2.fromOffset(50, 50)

	-- Fade out tween
	TweenService:Create(
		hit,
		TweenInfo.new(self.Styles.FadeTime, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),
		{ ImageTransparency = 1 }
	):Play()
end

--====================================================
-- UPDATE LOOP
--====================================================
function HitmarkerCrosshair:_update()
	local x, y

	if self.FollowMouse then
		local pos = UserInputService:GetMouseLocation()
		x = pos.X
		y = pos.Y
	else
		local cam = workspace.CurrentCamera
		local size = cam.ViewportSize
		x = size.X / 2
		y = size.Y / 2
	end

	self.Crosshair.Position = UDim2.fromOffset(x, y)
	self.Hitmarker.Position = UDim2.fromOffset(x, y)
end

return HitmarkerCrosshair

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.HitmarkerHandler

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.ClothingLoading | Enabled: N/A
--------------------------------------------------------------------
local CosmeticLoader = {}
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local CosmeticAssets = ReplicatedStorage.Peak.Assets.Clothing.Player.Backpacks

local function WaitForTorso(character)
	-- R6 Torso or R15 UpperTorso
	local torso = character:FindFirstChild("Torso")
		or character:FindFirstChild("UpperTorso")

	if torso then return torso end

	return character:WaitForChild("Torso", 3)
		or character:WaitForChild("UpperTorso", 3)
end


function CosmeticLoader.ApplyBackpack(player, character, backpackId)
	if not backpackId then return end

	local template = CosmeticAssets:FindFirstChild(backpackId)
	if not template then
		warn("Backpack not found:", backpackId)
		return
	end

	local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
	if not torso then
		warn("No torso for:", character.Name)
		return
	end

	local backpackClone = template:Clone()
	local bpPart = backpackClone:WaitForChild("TestBP")

	local motor = Instance.new("Motor6D")
	motor.Name = "BackpackMotor"
	motor.Part0 = torso
	motor.Part1 = bpPart
	motor.C0 = CFrame.new(0, 0.04, 0)
	motor.Parent = torso

	backpackClone.Parent = character

	print("Backpack attached:", backpackId)
	return backpackClone
end


function CosmeticLoader.LoadCosmetics(player, profileData)
	local character = player.Character
	if not character then return end

	local equipped = profileData.Cosmetics and profileData.Cosmetics.Equipped
	if not equipped then
		-- Retry once cosmetics finish loading
		task.delay(0.1, function()
			if player.Character then
				CosmeticLoader.LoadCosmetics(player, profileData)
			end
		end)
		return
	end

	if equipped.Backpack then
		CosmeticLoader.ApplyBackpack(player, character, equipped.Backpack)
	end
end


function CosmeticLoader.ConnectPlayer(player, profile)
	player.CharacterAdded:Connect(function(character)
		-- wait for character fully loaded
		character:WaitForChild("Humanoid")
		task.wait(0.25) -- More reliable than 0.1

		CosmeticLoader.LoadCosmetics(player, profile.Data)
	end)
end

return CosmeticLoader

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.ClothingLoading

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.CraftingRecipe | Enabled: N/A
--------------------------------------------------------------------

local module = {}

-- Each recipe:
-- name: string
-- ingredients: array of strings (types: "Alcohol", "Rag", "Binding", "Blade", "Explosive", "Canister", "Sugar", "Melee")
-- games: table of which game(s) this recipe appears in ("TLOU1", "TLOU2")
-- note: optional extra (e.g. upgrade behavior / quantity notes)

module.recipes = {
	{
		name = "Health Kit",
		ingredients = { "Alcohol", "Rag" },
		games = { "TLOU1", "TLOU2" },
		note = "Restores player health."
	},
	{
		name = "Molotov",
		ingredients = { "Alcohol", "Rag" },
		games = { "TLOU1", "TLOU2" },
		note = "Thrown incendiary; area damage."
	},
	{
		name = "Shiv",
		ingredients = { "Binding", "Blade" },
		games = { "TLOU1", "TLOU2" },
		note = "Used for stealth kills and unlocking shiv doors (TLOU1)."
	},
	{
		name = "Melee Upgrade",
		ingredients = { "Binding", "Blade", "Melee" },
		games = { "TLOU1", "TLOU2" },
		note = "Applied to melee weapons to increase durability / instant-kill chance."
	},
	{
		name = "Nail Bomb",
		ingredients = { "Blade", "Explosive" },
		games = { "TLOU1" },
		note = "High-damage explosive used in TLOU1."
	},
	{
		name = "Smoke Bomb",
		ingredients = { "Sugar", "Explosive" },
		games = { "TLOU1" },
		note = "Creates smoke to hide movement (TLOU1)."
	},
	{
		name = "Stun Bomb",
		ingredients = { "Canister", "Explosive" },
		games = { "TLOU2" },
		note = "In TLOU2 it's the stun bomb; can become Smoke Bomb if upgraded in-game."
	},
	{
		name = "Trap Mine",
		ingredients = { "Canister", "Explosive" },
		games = { "TLOU2" },
		note = "Placed proximity explosive in TLOU2."
	},
	{
		name = "Silencer",
		ingredients = { "Rag", "Canister" },
		games = { "TLOU2" },
		note = "Attach to pistols/shotguns to reduce sound (TLOU2)."
	},
	{
		name = "Arrows",
		ingredients = { "Binding", "Blade" },
		games = { "TLOU2" },
		note = "Craft ammunition for the bow."
	},
	{
		name = "Explosive Arrows",
		ingredients = { "Explosive", "Binding" },
		games = { "TLOU2" },
		note = "Arrows rigged with explosive for area damage."
	},
	{
		name = "Pipe Bomb",
		ingredients = { "Alcohol", "Canister", "Explosive" },
		games = { "TLOU2" },
		note = "Powerful thrown explosive (TLOU2)."
	},
	{
		name = "Incendiary Shells",
		ingredients = { "Alcohol", "Explosive" },
		games = { "TLOU2" },
		note = "Special shotgun ammo that ignites targets."
	},
	{
		name = "Hunting Pistol Ammo",
		ingredients = { "Explosive", "Blade" },
		games = { "TLOU2" },
		note = "Crafted ammo for hunting pistol in TLOU2."
	},
	{
		name = "Pipe Bomb (legacy/nail-style)",
		ingredients = { "Blade", "Explosive", "Canister" },
		games = { "TLOU1", "TLOU2" },
		note = "If you prefer a single 'pipe-style' explosive entry (some guides vary in naming)."
	},
}

-- Helper: find recipe by name (case-insensitive)
function module.findRecipe(name)
	local lower = name:lower()
	for _, r in ipairs(module.recipes) do
		if r.name:lower() == lower then
			return r
		end
	end
	return nil
end

-- Helper: list recipes available for a given game id ("TLOU1" or "TLOU2")
function module.listForGame(gameId)
	local out = {}
	for _, r in ipairs(module.recipes) do
		for _, g in ipairs(r.games) do
			if g == gameId then
				table.insert(out, r)
				break
			end
		end
	end
	return out
end

-- Helper: check craftable given an inventory (table with counts keyed by material name)
-- inventory example: { Alcohol = 1, Rag = 2, Binding = 1, Blade = 1, Explosive = 0, Canister = 1, Sugar = 0, Melee = 1 }
function module.canCraft(recipe, inventory)
	for _, mat in ipairs(recipe.ingredients) do
		if not inventory[mat] or inventory[mat] <= 0 then
			return false
		end
	end
	return true
end

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.CraftingRecipe
  -  Edit
  14:15:00.834  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.NoobPath | Enabled: N/A
--------------------------------------------------------------------
-- Version 1.811 (optimized visualize, cached Enums, changed CheckForTimeout to CheckTimeout, Jump no long returns the waypoint position[unintended], OnDestroy now fires instantly when destroy is called, did a small change to the Humanoid Jump logic)

--[[

MIT License

Copyright (c) <2025> <grewsxb4>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

]]

local Path = require(script:WaitForChild("Path"))
local GS = require(script:WaitForChild("GoodSignal"))
local RS = game:GetService("RunService")

local module = {}

local NoobPath = {}
NoobPath.__index = NoobPath

local JUMP = Enum.PathWaypointAction.Jump
local AIR = Enum.Material.Air
local JUMPING = Enum.HumanoidStateType.Jumping
local FREEFALL = Enum.HumanoidStateType.Freefall

export type Location = Vector3 | BasePart | Model

local function GetPrimaryPivot(Model : Model)
	return Model.PrimaryPart:GetPivot()
end

local function ToVector3(Location : Location)
	if typeof(Location) == "Vector3" then
		return Location
	elseif Location:IsA("Model") then
		return GetPrimaryPivot(Location).Position
	elseif Location:IsA("BasePart") then
		return Location:GetPivot().Position
	end
end

local function RemoveNetworkOwner(Character : Model)
	local Descendants = Character:GetDescendants()
	for i = 1, #Descendants do
		local Item = Descendants[i]
		if Item:IsA("BasePart") and Item:CanSetNetworkOwnership() then
			Item:SetNetworkOwner(nil)
		end
	end
end

local function Default(AgentParams, NoobPath)
	NoobPath.Path = Path.new(AgentParams)
	NoobPath.Route = {}
	NoobPath.Index = 1
	NoobPath.Idle = true
	NoobPath.InAir = false
	NoobPath.Estimate = {}
	NoobPath.Destroying = false
	NoobPath.Goal = nil
	NoobPath.Partial = false

	NoobPath.Overide = GS.new()
	NoobPath.Reached = GS.new()
	NoobPath.WaypointReached = GS.new()
	NoobPath.Error = GS.new()
	NoobPath.Trapped = GS.new()
	NoobPath.Stopped = GS.new()
	NoobPath.OnDestroy = GS.new()

	NoobPath.Timeout = true -- trigger trapped if didn't arrive in time, time is auto estimated using speed
	NoobPath.Speed = 16 -- default speed
	NoobPath.Visualize = true -- if there are many npcs with visualize on, it can create lag & disrupt pathfind
end

local Server = RS:IsServer()

-- Constructor
function module.new(Character: Model, AgentParams: Path.AgentParams, Move: (Vector3) -> nil, Jump: () -> nil, JumpFinished: RBXScriptSignal, MoveFinished: RBXScriptSignal)
	if Server then
		RemoveNetworkOwner(Character)
	end
	
	local self = setmetatable({
		Character = Character,

		Move = Move,
		Jump = Jump,
		MoveFinished = MoveFinished,
		JumpFinished = JumpFinished,

		MoveFinishedC = nil,
		JumpFinishedC = nil,

	}, NoobPath)
	
	Default(AgentParams, self)
	
	self:Activate()
	
	return self
end

-- Constructor With Default Humanoid Signals
function module.Humanoid(Character : Model, AgentParams : Path.AgentParams?, Precise : boolean?)
	local Humanoid : Humanoid = Character:FindFirstChildOfClass("Humanoid")
	local Move = function(WaypointPosition) Humanoid:MoveTo(WaypointPosition) end
	
	local JumpFinished = GS.new()
	local MoveFinished = Humanoid.MoveToFinished
	
	local self = module.new(Character, AgentParams, Move, nil, JumpFinished, MoveFinished)
	
	local Jump = function() 
		if Humanoid.FloorMaterial ~= AIR then
			Humanoid:ChangeState(JUMPING)
			return
		end
		
		local C : RBXScriptConnection
		local A : RBXScriptConnection
		local B : RBXScriptConnection
		
		if Precise then
			C = self.Overide:Connect(function()
				C:Disconnect()
				A:Disconnect()
				B:Disconnect()
			end)
		else
			C = self.Overide:Connect(function()
				C:Disconnect()
				A:Disconnect()
				B:Disconnect()
				self.InAir = false -- this allow the agent to still compute path even in air, which is often inaccurate. However, it works exceptionally well when given a relatively low jump power and obstacles that fits with such a jump power, and works nicely for default humanoids with a jump power of 50.
				-- copy this down if you want this behavior in custom implementations, otherwise computing path is paused while the agent is in air by default.
			end)
		end
		
		A = Humanoid:GetPropertyChangedSignal("FloorMaterial"):Connect(function()
			if Humanoid.FloorMaterial ~= AIR then
				Humanoid:ChangeState(JUMPING)
				C:Disconnect()
				A:Disconnect()
				B:Disconnect()
			end
		end)
		B = self.OnDestroy:Connect(function()
			C:Disconnect()
			A:Disconnect()
			B:Disconnect()
		end)
	end
	
	local C = Humanoid.StateChanged:Connect(function(Old, New)
		if (Old == JUMPING or Old == FREEFALL) and (New ~= JUMPING and New ~= FREEFALL) then
			JumpFinished:Fire()
		end
	end)
	
	local A
	A = self.OnDestroy:Connect(function()
		A:Disconnect()
		C:Disconnect()
	end)
	
	self.Jump = Jump
	
	return self
end

function module.View(AgentParams : Path.AgentParams)
	local self = setmetatable({
		View = true,

	}, NoobPath)
	
	Default(AgentParams, self)
	
	return self
end

function NoobPath:Compute(PointA : Vector3, PointB : Vector3)
	local Route, Partial = self.Path:Generate(PointA, PointB)
	
	if self.Destroying ~= false then
		return
	end

	if not self:ValidateRoute(Route, Partial) then
		return
	end
	
	self.Route = Route
	self.Partial = Partial
	
	if self.Timeout then
		if not self.Speed then
			error("No Speed Provided")
		end
		self:Predict()
	end

	if self.Visualize then
		self:Show()
	end
	
	return true
end

function NoobPath:Show()
	self.Path:Show(self.Route)
end

function NoobPath:Hide()
	self.Path:Hide()
end

function NoobPath:Predict()
	self.Estimate = self.Path:Estimate(self.Route, self.Speed)
end

function NoobPath:GetEstimateTotal()
	local Estimate = self.Estimate
	
	local Sum = 0
	for i = 1, #Estimate do
		Sum += Estimate[i]
	end
	
	return Sum
end

function NoobPath:Activate()
	if Server then
		self.DescendantAddedC = self.Character.DescendantAdded:Connect(function(Item)
			if Item:IsA("BasePart") and Item:CanSetNetworkOwnership() then
				Item:SetNetworkOwner(nil)
			end
		end)
	end
	
	self.MoveFinishedC = self.MoveFinished:Connect(function(Success) -- if you are using custom MoveFinished, Fire(true) if successfully reached
		if self.Idle then
			return
		end
		if Success then
			local NextWaypoint = self:GetNextWaypoint()
			if NextWaypoint then
				self:TravelNextWaypoint()
				self.WaypointReached:Fire(self:GetWaypoint(), NextWaypoint)

			else
				self:Arrive()
			end
		else
			self:Stop()
			self.Trapped:Fire("ReachFailed")
		end
	end)
	self.JumpFinishedC = self.JumpFinished:Connect(function()
		self.InAir = false
	end)
end

function NoobPath:PauseUntilLanded()
	local C :RBXScriptConnection
	local A : RBXScriptConnection
	local B :RBXScriptConnection
	
	C = self.Overide:Connect(function()
		C:Disconnect()
		A:Disconnect()
		B:Disconnect()
	end)
	
	A = self.JumpFinished:Connect(function()
		C:Disconnect()
		A:Disconnect()
		B:Disconnect()
		self:Run()
	end)
	
	B = self.OnDestroy:Connect(function()
		C:Disconnect()
		A:Disconnect()
		B:Disconnect()
	end)
end

function NoobPath:ValidateRoute(Route : Path.Route, Partial : boolean)
	if not Route then
		self.Error:Fire("ComputationError") -- No Route Generated/Error when generating
		return
	end
	if #Route == 0 then
		self.Error:Fire("TargetUnreachable") -- Can't Find Path
		return
	end
	if #Route < 2 then -- Route too short, likely already arrived
		self:Arrive(Route, Partial)
		return
	end
	return true
end

-- Caculate Route To Location & Move The Character There
function NoobPath:Run(Location : Location)
	if self.Destroying ~= false then
		return
	end
	
	self.Overide:Fire()
	
	if Location then
		self.Goal = Location
	else
		Location = self.Goal or error("No Destination Provided")
	end
	
	if self.InAir then
		self:PauseUntilLanded()
		return
	end
	
	if not self:Compute(GetPrimaryPivot(self.Character).Position, ToVector3(Location)) then
		return
	end
	
	self.Index = 1
	self.Idle = false
	
	self:TravelNextWaypoint()
end

-- Stop The Character From Moving
function NoobPath:Stop()
	if self.Destroying ~= false then
		return
	end
	self.Idle = true
	
	self.Overide:Fire()
	self.Move(GetPrimaryPivot(self.Character).Position)
	self.Stopped:Fire()
end

function NoobPath:GetLastWaypoint()
	local Route = self.Route
	return Route[#Route]
end

function NoobPath:GetWaypoint()
	return self.Route[self.Index]
end

function NoobPath:GetNextWaypoint()
	return self.Route[self.Index + 1]
end

function NoobPath:GetEstimateTime()
	return self.Estimate[self.Index]
end

function NoobPath:CheckTimeout()
	local Time = self:GetEstimateTime()
	if not Time then
		return
	end
	
	local Route = self.Route
	local Index = self.Index
	
	task.delay(Time * 2, function() -- usually double time work best, not too sensitive
		if not self.Idle and self.Route == Route and self.Index == Index then
			self.Trapped:Fire("ReachTimeout")
		end
	end)
end

function NoobPath:TravelNextWaypoint()
	self.Index += 1
	self:TravelWaypoint()
end

function NoobPath:TravelWaypoint()
	local Waypoint = self:GetWaypoint()
	if self.Idle or not Waypoint then
		return
	end
	self.Move(Waypoint.Position)
	if self.Timeout then
		self:CheckTimeout()
	end
	if Waypoint.Action == JUMP then
		self.InAir = true
		self.Jump()
	end
end

function NoobPath:Arrive(Route, Partial)
	Route = Route or self.Route
	local Waypoint = Route[#Route]
	
	self.Idle = true
	self.Overide:Fire()
	self.Reached:Fire(Waypoint, Partial or self.Partial)
end

local function Terminate(self)
	self.Path:Destroy()
	self.Reached:DisconnectAll()
	self.WaypointReached:DisconnectAll()
	self.Trapped:DisconnectAll()
	self.Error:DisconnectAll()
	self.Overide:DisconnectAll()
	self.OnDestroy:DisconnectAll()

	table.clear(self)
	setmetatable(self, nil)
	self = nil
end

function NoobPath:Dump()
	self.Destroying = true
	self.OnDestroy:Fire()
	
	task.defer(Terminate, self) -- defer for things to settle down
end

-- Destroy The NoobPath Object
function NoobPath:Destroy()
	self:Stop()
	self.Destroying = true
	
	self.MoveFinishedC:Disconnect()
	self.JumpFinishedC:Disconnect()
	
	if Server then
		self.DescendantAddedC:Disconnect()
	end
	
	self:Dump()
end

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.NoobPath

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.NoobPath.Path | Enabled: N/A
--------------------------------------------------------------------
local PFS = game:GetService("PathfindingService")

local module = {}

local Path = {}
Path.__index = Path

local JUMP = Enum.PathWaypointAction.Jump
local PARTIAL = Enum.PathStatus.ClosestNoPath

export type Route = {PathWaypoint}
export type AgentParams = {
	AgentRadius : number, --(The Radius Of The Object(Half Its width))
	AgentHeight : number, --(The Height Of The Object)
	AgentCanClimb : boolean, --(Whether or not it can climb)
	AgentCanJump : boolean, --(Whether or not it allows jumps)
	Costs : {}, --(What Material or Pathfinding Modifiers should be avoided(High = Avoid, Low = Okay))
	WaypointSpacing : number, --(Spacing between Waypoints)
	PathSettings : {SupportPartialPath : boolean}
}

function module.new(AgentParams: AgentParams)
	local self = setmetatable({
		Path = PFS:CreatePath(AgentParams),
		Visual = {},
		Destroying = false,
	}, Path)

	return self
end

-- Generate a Path from PointA to PointB, Return Route, IsPartialPath
function Path:Generate(PointA : Vector3, PointB : Vector3) : Route & boolean
	local Success, Message = pcall(function()
		self.Path:ComputeAsync(PointA, PointB)
	end)
	if not Success then
		warn(Message)
		return
	end
	
	if self.Destroying ~= false then
		return
	end

	local Route : Route = self.Path:GetWaypoints()

	for i = #Route - 1, 1, -1 do
		local Waypoint = Route[i]
		local NextWaypoint = Route[i + 1]
		local Distance = (Waypoint.Position - NextWaypoint.Position).Magnitude

		if Waypoint.Action ~= JUMP and Distance < 2 then
			table.remove(Route, i)
		end
	end
	return Route, self.Path.Status == PARTIAL
end

local VisualFolder = workspace:FindFirstChild("VisualWaypoints")
if not VisualFolder then
	VisualFolder = Instance.new("Folder")
	VisualFolder.Name = "VisualWaypoints"
	VisualFolder.Parent = workspace
end

local NoobPath = script.Parent

local NEON = Enum.Material.Neon
local SIZE = Vector3.new(0.5, 0.5, 0.5)
local BALL = Enum.PartType.Ball
local ZERO = Vector3.zero

local GREEN = BrickColor.new("Bright green").Color
local YELLOW = BrickColor.new("Bright yellow").Color
local BLUE = BrickColor.new("Bright blue").Color
local RED = BrickColor.new("Bright red").Color

local function CreatePoint(Position : Vector3)
	local Point = Instance.new("Part")
	Point.Color = GREEN
	Point.CastShadow = false
	Point.Material = NEON
	Point.Size = SIZE
	Point.Shape = BALL
	Point.CanCollide = false
	Point.CanTouch = false
	Point.CanQuery = false
	Point.Anchored = true
	Point.Position = Position
	Point.Parent = VisualFolder

	return Point
end

local function GraphLine(Position : Vector3, Next : Vector3)
	local Point = CreatePoint(Position)
	local Direction = Next - Position

	local Line = Instance.new("LineHandleAdornment")
	Line.Parent = Point
	Line.Adornee = Point
	Line.CFrame = CFrame.new(ZERO, Direction)
	Line.Length = Direction.Magnitude
	Line.Color3 = BLUE

	Line.Thickness = 3

	return Point, Line
end

-- Visualize the given Route
function Path:Show(Route)
	self:Hide()
	local Visual = self.Visual
	local Length = #Route

	if NoobPath:GetAttribute("GraphPath") then
		for i = 1, Length - 1 do
			local Waypoint = Route[i]
			local Point = GraphLine(Waypoint.Position, Route[i + 1].Position)

			if Waypoint.Action == JUMP then
				Point.Color = YELLOW
			end

			Visual[i] = Point
		end
	else
		for i = 1, Length - 1 do
			local Waypoint = Route[i]
			local Point = CreatePoint(Waypoint.Position)

			if Waypoint.Action == JUMP then
				Point.Color = YELLOW
			end

			Visual[i] = Point
		end
	end

	local Point = CreatePoint(Route[Length].Position)
	Point.Color = RED

	Visual[Length] = Point
end

-- Hide all Path Visualizations
function Path:Hide()
	local Visual = self.Visual
	for i = 1, #Visual do
		Visual[i]:Destroy()
	end
end

-- Estimate time required to travel the given Route based on given Speed
function Path:Estimate(Route, Speed)
	local Estimate : {number} = {}
	
	for i = 1, #Route - 1 do
		local Waypoint = Route[i]
		local NextWaypoint = Route[i + 1]

		local Distance = (Waypoint.Position - NextWaypoint.Position).Magnitude
		local Time = Distance / Speed -- Estimated time
		
		Estimate[i] = Time
	end

	return Estimate
end

-- Get the current status of the Path
function Path:GetStatus() : Enum.PathStatus
	return self.Path.Status
end

-- Destroy the Object
function Path:Destroy()
	self.Destroying = true
	self:Hide()
	self.Path:Destroy()
	table.clear(self)
	setmetatable(self, nil)
	self = nil
end

return module

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.NoobPath.Path

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Client.Helpers.NoobPath.GoodSignal | Enabled: N/A
--------------------------------------------------------------------
--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Client.Helpers.NoobPath.GoodSignal

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.LeanController | Enabled: N/A
--------------------------------------------------------------------
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LeanController = {}

--- @ Core System
local remotes = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes")
local ReplicateLean = remotes:WaitForChild("ReplicateLean")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local character = nil
local rootPart, rootJoint, neck = nil, nil, nil

local isRunning = false
local renderConnection = nil

--- @ Core System > Configuration
local Config = {
	bodyHorizontalFactor = 0.2, 
	bodyVerticalFactor = 0.2,
	headHorizontalFactor = 0.6, 
	headVerticalFactor = 0.6,
	frequency = 36,
	damping = 0.2,
	ReplicationRate = 1/20,
	InterpolationSpeed = 15,
}

--- @ Core System > State
local allOriginalC0s = setmetatable({}, {__mode = "k"})
local foreignState = {} 

local globalStrength = 1.0
local intensities = {
	bodyHorizontal = 1.0, 
	bodyVertical = 1.0,
	headHorizontal = 1.0, 
	headVertical = 1.0,
}

local bodyRoll, bodyRoll_v = 0, 0
local bodyPitch, bodyPitch_v = 0, 0
local headRoll, headRoll_v = 0, 0
local headPitch, headPitch_v = 0, 0

local lastReplicationTime = 0

--- @ Core System > Logic
local function lerp(a, b, t)
	return a + (b - a) * t
end

local function updateSpring(current, velocity, target, f, d, dt)
	local acceleration = (target - current) * f * dt
	velocity = (velocity + acceleration) / (1 + d * dt)
	return current + velocity * dt, velocity
end

local function getOriginalC0s(char)
	if not allOriginalC0s[char] then
		local rp = char:FindFirstChild("HumanoidRootPart")
		local torso = char:FindFirstChild("Torso")
		if rp and torso then
			local rj = rp:FindFirstChild("RootJoint")
			local nk = torso:FindFirstChild("Neck")
			if rj and nk then
				allOriginalC0s[char] = {
					root = rj.C0,
					neck = nk.C0
				}
			end
		end
	end
	return allOriginalC0s[char]
end

--- @ Core System > Logic > Render Loop
local function onRenderStep(deltaTime)
	deltaTime = math.min(deltaTime, 1/30)

	-- 1. Handle Local Player Spring Physics
	if isRunning and rootPart then
		local camDir = rootPart.CFrame:VectorToObjectSpace(camera.CFrame.LookVector)

		-- Apply Config multipliers AND Dynamic Intensities AND Global Strength
		local targetBR = -camDir.X * Config.bodyHorizontalFactor * intensities.bodyHorizontal * globalStrength
		local targetBP = -camDir.Y * Config.bodyVerticalFactor * intensities.bodyVertical * globalStrength
		local targetHR = -camDir.X * Config.headHorizontalFactor * intensities.headHorizontal * globalStrength
		local targetHP = -camDir.Y * Config.headVerticalFactor * intensities.headVertical * globalStrength

		local f = Config.frequency * 2 * math.pi
		local d = Config.damping * f

		bodyRoll, bodyRoll_v = updateSpring(bodyRoll, bodyRoll_v, targetBR, f, d, deltaTime)
		bodyPitch, bodyPitch_v = updateSpring(bodyPitch, bodyPitch_v, targetBP, f, d, deltaTime)
		headRoll, headRoll_v = updateSpring(headRoll, headRoll_v, targetHR, f, d, deltaTime)
		headPitch, headPitch_v = updateSpring(headPitch, headPitch_v, targetHP, f, d, deltaTime)

		local orig = getOriginalC0s(character)
		if orig and rootJoint and neck then
			rootJoint.C0 = orig.root * CFrame.Angles(bodyPitch, 0, bodyRoll)
			neck.C0 = orig.neck * CFrame.Angles(headPitch, 0, headRoll)
		end

		-- Replication Throttling
		local now = os.clock()
		if now - lastReplicationTime > Config.ReplicationRate then
			ReplicateLean:FireServer(bodyPitch, bodyRoll, headPitch, headRoll)
			lastReplicationTime = now
		end
	end

	-- 2. Handle Foreign Players Interpolation
	for plr, data in pairs(foreignState) do
		if plr.Character and plr.Character.Parent then
			data.current.bp = lerp(data.current.bp, data.target.bp, deltaTime * Config.InterpolationSpeed)
			data.current.br = lerp(data.current.br, data.target.br, deltaTime * Config.InterpolationSpeed)
			data.current.hp = lerp(data.current.hp, data.target.hp, deltaTime * Config.InterpolationSpeed)
			data.current.hr = lerp(data.current.hr, data.target.hr, deltaTime * Config.InterpolationSpeed)

			local orig = getOriginalC0s(plr.Character)
			local rj = plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.HumanoidRootPart:FindFirstChild("RootJoint")
			local nk = plr.Character:FindFirstChild("Torso") and plr.Character.Torso:FindFirstChild("Neck")

			if orig and rj and nk then
				rj.C0 = orig.root * CFrame.Angles(data.current.bp, 0, data.current.br)
				nk.C0 = orig.neck * CFrame.Angles(data.current.hp, 0, data.current.hr)
			end
		else
			foreignState[plr] = nil 
		end
	end
end

--- @ Core System > Networking
ReplicateLean.OnClientEvent:Connect(function(playerWhoSent, bp, br, hp, hr)
	if playerWhoSent == player then return end

	if not foreignState[playerWhoSent] then
		foreignState[playerWhoSent] = {
			current = {bp=bp, br=br, hp=hp, hr=hr},
			target = {bp=bp, br=br, hp=hp, hr=hr}
		}
	end

	local state = foreignState[playerWhoSent]
	state.target.bp = bp
	state.target.br = br
	state.target.hp = hp
	state.target.hr = hr
end)

--- @ Core System > API
function LeanController.SetIntensity(leanType, value)
	if intensities[leanType] then
		intensities[leanType] = math.clamp(value, 0, 100) / 100
	else
		warn("LeanController: Invalid leanType '" .. tostring(leanType) .. "'")
	end
end

function LeanController.SetGlobalStrength(value)
	globalStrength = math.clamp(value, 0, 100) / 100
end

--- @ Core System > Lifecycle
function LeanController.Start()
	if isRunning then return end

	character = player.Character or player.CharacterAdded:Wait()
	rootPart = character:WaitForChild("HumanoidRootPart")
	rootJoint = rootPart:WaitForChild("RootJoint")
	local torso = character:WaitForChild("Torso")
	neck = torso:WaitForChild("Neck")

	getOriginalC0s(character)

	isRunning = true
	renderConnection = RunService.RenderStepped:Connect(onRenderStep)
end

function LeanController.Stop()
	if not isRunning then return end
	isRunning = false
	if renderConnection then renderConnection:Disconnect() end

	local orig = getOriginalC0s(character)
	if orig and rootJoint and neck then
		rootJoint.C0 = orig.root
		neck.C0 = orig.neck
	end
end

return LeanController
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.LeanController

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.R6IK | Enabled: N/A
--------------------------------------------------------------------
local R6IK = {}
R6IK.__index = R6IK

local function clamp(val, min, max)
	return math.max(min, math.min(max, val))
end

local function SolveIK(originCF, targetPos, l1, l2, poleVector)
	local planeWorld = CFrame.lookAt(originCF.Position, targetPos, originCF:VectorToWorldSpace(poleVector))
	local planeLocal = originCF:ToObjectSpace(planeWorld)

	local localizedPos = originCF:PointToObjectSpace(targetPos)
	local dist = localizedPos.Magnitude
	local maxReach = l1 + l2
	local minReach = math.abs(l1 - l2)

	if dist >= maxReach - 0.001 then
		return planeLocal, math.pi/2, 0
	elseif dist <= minReach + 0.001 then
		local pushBack = maxReach - dist
		return planeLocal * CFrame.new(0, 0, -pushBack), -math.pi/2, math.pi
	else
		local cosA1 = (-(l2 * l2) + (l1 * l1) + (dist * dist)) / (2 * l1 * dist)
		local a1 = -math.acos(clamp(cosA1, -1, 1))
		local cosA2 = ((l2 * l2) - (l1 * l1) + (dist * dist)) / (2 * l2 * dist)
		local a2 = math.acos(clamp(cosA2, -1, 1))
		return planeLocal, a1 + math.pi/2, a2 - a1
	end
end

local function WorldCFrameToC0ObjectSpace(motor6DJoint, worldCFrame)
	local part0 = motor6DJoint.Part0
	local c1Store = motor6DJoint.C1
	local relativeToPart0 = part0.CFrame:Inverse() * worldCFrame * c1Store
	return relativeToPart0
end

function R6IK.New(Character)
	local self = setmetatable({}, R6IK)

	self.Character = Character
	self.Torso = Character:WaitForChild("Torso")
	self.LeftArm = Character:WaitForChild("Left Arm")
	self.RightArm = Character:WaitForChild("Right Arm")
	self.LeftLeg = Character:WaitForChild("Left Leg")
	self.RightLeg = Character:WaitForChild("Right Leg")

	self.Motor6Ds = {
		["Left Shoulder"] = self.Torso["Left Shoulder"],
		["Right Shoulder"] = self.Torso["Right Shoulder"],
		["Left Hip"] = self.Torso["Left Hip"],
		["Right Hip"] = self.Torso["Right Hip"],
	}

	self.OriginalC0s = {}
	self.C1s = {}

	for name, motor in pairs(self.Motor6Ds) do
		self.OriginalC0s[name] = motor.C0
		self.C1s[name] = motor.C1
	end

	self.UpperLen = 1
	self.LowerLen = 1

	return self
end

function R6IK:ApplyC0(motorName, finalWorldCF, rigidMode, influence)
	local motor = self.Motor6Ds[motorName]
	local originalC0 = self.OriginalC0s[motorName]

	local targetC0 = WorldCFrameToC0ObjectSpace(motor, finalWorldCF)

	if rigidMode then
		targetC0 = targetC0 * motor.Transform:Inverse()
	end

	influence = clamp(influence or 1, 0, 1)

	if influence >= 0.99 then
		motor.C0 = targetC0
	elseif influence <= 0.01 then
		motor.C0 = originalC0
	else
		motor.C0 = originalC0:Lerp(targetC0, influence)
	end
end

function R6IK:ArmIK(Side, Position, rigidMode, influence)
	local motorName = Side .. " Shoulder"
	local arm = (Side == "Left") and self.LeftArm or self.RightArm
	local motor = self.Motor6Ds[motorName]
	if not motor then return end

	local baseOffset = (Side == "Left") and self.C1s[motorName].X or -self.C1s[motorName].X
	local originCF = self.Torso.CFrame * self.OriginalC0s[motorName] * CFrame.new(0, 0, baseOffset)

	local poleVector = Vector3.yAxis 
	local planeLocal, shoulderAng, elbowAng = SolveIK(originCF, Position, self.UpperLen, self.LowerLen, poleVector)

	local shoulderAngleCF = CFrame.Angles(shoulderAng, 0, 0)
	local elbowAngleCF = CFrame.Angles(elbowAng, 0, 0)

	local localArmCF = planeLocal 
		* shoulderAngleCF 
		* CFrame.new(0, -self.UpperLen * 0.5, 0)
		* elbowAngleCF 
		* CFrame.new(0, -self.LowerLen * 0.5, 0)
		* CFrame.new(0, (arm.Size.Y - self.LowerLen)*0.5, 0)

	local finalWorldCF = originCF * localArmCF

	self:ApplyC0(motorName, finalWorldCF, rigidMode, influence)
end

function R6IK:LegIK(Side, Position, rigidMode, influence)
	local motorName = Side .. " Hip"
	local leg = (Side == "Left") and self.LeftLeg or self.RightLeg
	local motor = self.Motor6Ds[motorName]
	if not motor then return end

	local rotOffset = (Side == "Left") and CFrame.Angles(0, math.pi/2, 0) or CFrame.Angles(0, -math.pi/2, 0)
	local originCF = self.Torso.CFrame * self.OriginalC0s[motorName] * rotOffset

	local poleVector = Vector3.new(0, 0, -1)
	local planeLocal, hipAng, kneeAng = SolveIK(originCF, Position, self.UpperLen, self.LowerLen, poleVector)

	local hipAngleCF = CFrame.Angles(hipAng, 0, 0)
	local kneeAngleCF = CFrame.Angles(kneeAng, 0, 0)

	local localLegCF = planeLocal 
		* hipAngleCF 
		* CFrame.new(0, -self.UpperLen * 0.5, 0) 
		* kneeAngleCF 
		* CFrame.new(0, -self.LowerLen * 0.5, 0) 
		* CFrame.new(0, (leg.Size.Y - self.LowerLen)*0.5, 0)

	local finalWorldCF = originCF * localLegCF

	self:ApplyC0(motorName, finalWorldCF, rigidMode, influence)
end

function R6IK:Stop(Side)
	if Side == "Left" or Side == "Right" then
		local armName = Side .. " Shoulder"
		local legName = Side .. " Hip"
		if self.Motor6Ds[armName] then self.Motor6Ds[armName].C0 = self.OriginalC0s[armName] end
		if self.Motor6Ds[legName] then self.Motor6Ds[legName].C0 = self.OriginalC0s[legName] end
	else
		for name, motor in pairs(self.Motor6Ds) do
			motor.C0 = self.OriginalC0s[name]
		end
	end
end

return R6IK
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.R6IK

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.FootPlanting | Enabled: N/A
--------------------------------------------------------------------
local FootPlanting = {}

--- @ Core System
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

--- @ Core System > Configuration
local Config = {
	LegLength = 2,
	RayDistance = 5,
	MaxStretch = 0.4,
	MaxCrouch = -0.2,
	Smoothing = 8,

	Influence = 70,
	RotationInfluence = 30,

	StepForwardRatio = 0.3,
	StepTiltRatio = 0.8, 
}

--- @ Core System > State
local character
local torso
local rightHip, leftHip
local originalRightC0, originalLeftC0
local raycastParams
local connection
local isEnabled = false

--- @ Core System > Logic
local function updateLeg(motor, originalC0, dt)
	if not motor or not character then return end

	local hipWorldCFrame = torso.CFrame * originalC0
	local rayOrigin = hipWorldCFrame.Position
	local rayDirection = Vector3.new(0, -Config.RayDistance, 0)

	local ignoreList = {character}
	raycastParams.FilterDescendantsInstances = ignoreList

	local result
	for i = 1, 10 do
		result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
		if not result then break end

		local part = result.Instance

		if part:IsDescendantOf(character) or part.CanCollide == false or part.Transparency == 1 then
			table.insert(ignoreList, part)
			raycastParams.FilterDescendantsInstances = ignoreList
			result = nil
		else
			break
		end
	end

	local goalC0 = originalC0

	if result then
		local distanceToGround = (rayOrigin - result.Position).Magnitude
		local offset = distanceToGround - Config.LegLength

		if offset > Config.MaxStretch then offset = Config.MaxStretch end
		if offset < Config.MaxCrouch then offset = Config.MaxCrouch end

		local raise = math.max(0, -offset)
		local forwardShift = raise * Config.StepForwardRatio
		local hipBend = raise * Config.StepTiltRatio

		local localNormal = torso.CFrame:VectorToObjectSpace(result.Normal)
		local upVector = Vector3.new(0, 1, 0)
		local axis = upVector:Cross(localNormal)
		local angle = math.acos(math.clamp(localNormal.Y, -1, 1))
		local rotationCF = CFrame.fromAxisAngle(axis, angle)

		local hipPos = originalC0.Position
		local hipRot = originalC0.Rotation

		local posCF = CFrame.new(hipPos) * CFrame.new(0, -offset, -forwardShift)
		local targetRotC0 = posCF * rotationCF * CFrame.Angles(hipBend, 0, 0) * hipRot
		local heightOnlyC0 = posCF * CFrame.Angles(hipBend, 0, 0) * hipRot
		local blendedC0 = heightOnlyC0:Lerp(targetRotC0, Config.RotationInfluence / 100)

		goalC0 = originalC0:Lerp(blendedC0, Config.Influence / 100)
	end

	motor.C0 = motor.C0:Lerp(goalC0, 1 - math.exp(-dt * Config.Smoothing))
end

local function onRenderStep(dt)
	if not character or not torso then return end
	updateLeg(rightHip, originalRightC0, dt)
	updateLeg(leftHip, originalLeftC0, dt)
end

--- @ Core System > API
function FootPlanting.Start()
	if isEnabled then return end
	isEnabled = true

	local player = Players.LocalPlayer
	character = player.Character or player.CharacterAdded:Wait()
	torso = character:WaitForChild("Torso")
	rightHip = torso:WaitForChild("Right Hip")
	leftHip = torso:WaitForChild("Left Hip")

	originalRightC0 = rightHip.C0
	originalLeftC0 = leftHip.C0

	raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	if connection then connection:Disconnect() end
	connection = RunService.RenderStepped:Connect(onRenderStep)
end

function FootPlanting.Stop()
	if not isEnabled then return end
	isEnabled = false

	if connection then connection:Disconnect() end

	local resetTime = 0
	local tempConnection
	tempConnection = RunService.RenderStepped:Connect(function(dt)
		resetTime += dt
		if resetTime > 0.2 then
			if rightHip then rightHip.C0 = originalRightC0 end
			if leftHip then leftHip.C0 = originalLeftC0 end
			tempConnection:Disconnect()
			return
		end

		if rightHip then rightHip.C0 = rightHip.C0:Lerp(originalRightC0, 0.2) end
		if leftHip then leftHip.C0 = leftHip.C0:Lerp(originalLeftC0, 0.2) end
	end)
end

function FootPlanting.SetEnabled(state)
	if state then
		FootPlanting.Start()
	else
		FootPlanting.Stop()
	end
end

function FootPlanting.SetInfluence(value)
	Config.Influence = math.clamp(value, 0, 100)
end

function FootPlanting.SetRotationInfluence(value)
	Config.RotationInfluence = math.clamp(value, 0, 100)
end

return FootPlanting
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.FootPlanting

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule | Enabled: N/A
--------------------------------------------------------------------
local PlayerService = game:GetService("Players")
local RunService = game:GetService("RunService")

local Client = PlayerService.LocalPlayer

local CollisionParams = RaycastParams.new()
CollisionParams.IgnoreWater = true
CollisionParams.RespectCanCollide = true
CollisionParams.FilterType = Enum.RaycastFilterType.Exclude

local CollisionParams2 = OverlapParams.new()
CollisionParams2.RespectCanCollide = true
CollisionParams2.FilterType = Enum.RaycastFilterType.Exclude

local RootMotionModule = {}
local TemporaryParts = {
	["Connection"] = nil :: RBXScriptConnection?,
	["AutoStopThread"] = nil :: thread?
}

local activeCharacter = nil
local activeHumanoid = nil
local activeTorso = nil
local activeHead = nil

local function VerifyCollision(OldCFrame, NewCFrame, Size)
	local BlockRay = workspace:Blockcast(OldCFrame, Size, (NewCFrame.Position - OldCFrame.Position), CollisionParams)
	local TouchingParts = workspace:GetPartBoundsInBox(NewCFrame, Size, CollisionParams2)

	if (BlockRay and BlockRay.Instance :: Instance? ~= nil) then
		return false        
	end

	if #TouchingParts >= 1 then
		return false
	end

	return true
end

function RootMotionModule:StartCorrection(Configuration)
	self:DestroyDependencies(false, false)

	local Character = Client.Character
	if not Character then return end

	local Humanoid = Character:WaitForChild("Humanoid", 10)
	local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 10)
	local Head = Character:WaitForChild("Head", 10)

	if not Humanoid or not HumanoidRootPart then return end

	activeCharacter = Character
	activeHumanoid = Humanoid
	activeHead = Head

	local HRPSize = HumanoidRootPart.Size
	local Motor = nil :: Motor6D?
	local Torso = nil

	if Humanoid.RigType == Enum.HumanoidRigType.R15 then
		Torso = Character:FindFirstChild("LowerTorso") :: Part
		Motor = (Torso :: Part):FindFirstChild("Root") :: Motor6D
	else
		Torso = Character:FindFirstChild("Torso") :: Part
		Motor = HumanoidRootPart:FindFirstChild("RootJoint") :: Motor6D
	end

	activeTorso = Torso

	local CFrameToRead = HumanoidRootPart.CFrame

	if Configuration.AlignHRPCFrame then
		local LookDirection = (Vector3.yAxis:Cross(HumanoidRootPart.CFrame.RightVector)).Unit 
		CFrameToRead = CFrame.lookAt(HumanoidRootPart.Position, HumanoidRootPart.Position + LookDirection * Vector3.new(1, 0, 1)) 
	end

	CollisionParams:AddToFilter(Character)
	CollisionParams2:AddToFilter(Character)

	if Configuration.Whitelist ~= nil then
		CollisionParams:AddToFilter(Configuration.Whitelist :: {Instance}) 
		CollisionParams2:AddToFilter(Configuration.Whitelist :: {Instance})
	end

	if Motor ~= nil then
		Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		Humanoid.AutoRotate = false

		for Index, Limbs in Character:GetChildren() do
			if Limbs:IsA("BasePart") then
				(Limbs :: Part).CanCollide = false 
			end
		end

		Torso.Anchored = true 

		HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
		HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero
		Torso.AssemblyLinearVelocity = Vector3.zero
		Torso.AssemblyAngularVelocity = Vector3.zero

		HumanoidRootPart.CFrame = CFrameToRead

		local OldPosition = CFrameToRead.Position
		local OldXRotation, OldYRotation, OldZRotation = CFrameToRead:ToOrientation()

		local C0 = Motor.C0
		local C1 = Motor.C1

		TemporaryParts.Connection = RunService.PreSimulation:Connect(function(DeltaTime) 
			debug.profilebegin("Root motion")

			if not HumanoidRootPart or not Motor then return end

			local Transform = Motor.Transform
			local NewCFrame = CFrame.identity

			local NewTorsoCFrame = HumanoidRootPart.CFrame * C0 * Transform * C1:Inverse()
			local CurrentTorsoCFrame = HumanoidRootPart.CFrame

			local RootMotionDelta = CurrentTorsoCFrame:ToObjectSpace(NewTorsoCFrame)

			if Configuration.TranslationScale then
				local scaledPos = RootMotionDelta.Position * Configuration.TranslationScale
				RootMotionDelta = CFrame.new(scaledPos) * RootMotionDelta.Rotation
			end

			NewCFrame = CFrameToRead * RootMotionDelta

			if not Configuration.IgnoreCollision and not VerifyCollision(HumanoidRootPart.CFrame, NewCFrame, HRPSize) then 
				NewCFrame = CFrame.new(HumanoidRootPart.Position) * NewCFrame.Rotation
			end

			HumanoidRootPart.CFrame = NewCFrame
			Motor.Transform = CFrame.identity

			if Configuration.MaintainVelocity then
				local NewPosition = NewCFrame.Position
				local NewXRotation, NewYRotation, NewZRotation = NewCFrame:ToOrientation()
				local LinearVelocity = (NewPosition - OldPosition) / DeltaTime
				local AngularVelocity = Vector3.new(math.deg(NewXRotation - OldXRotation), math.deg(NewYRotation - OldYRotation), math.deg(NewZRotation - OldZRotation)) * 0.02

				HumanoidRootPart.AssemblyLinearVelocity = LinearVelocity
				HumanoidRootPart.AssemblyAngularVelocity = AngularVelocity
				Torso.AssemblyLinearVelocity = LinearVelocity
				Torso.AssemblyAngularVelocity = AngularVelocity

				OldPosition = NewPosition
				OldXRotation, OldYRotation, OldZRotation = NewXRotation, NewYRotation, NewZRotation 
			end

			debug.profileend()
		end) 

		if Configuration.Track then
			Configuration.Track:Play()

			task.spawn(function()
				local track = Configuration.Track

				while track.Length == 0 do
					task.wait()
				end

				local stopTime = math.max(0, track.Length - 0.1)

				TemporaryParts.AutoStopThread = task.delay(stopTime, function()
					TemporaryParts.AutoStopThread = nil 
					self:DestroyDependencies(true, false)
					track:Stop(0) 
				end)
			end)
		end
	end
end

function RootMotionModule:DestroyDependencies(ReverseAllEffects : boolean, Replicate : boolean)    
	if TemporaryParts.Connection ~= nil then
		TemporaryParts.Connection:Disconnect()
		TemporaryParts.Connection = nil
	end

	if TemporaryParts.AutoStopThread then
		task.cancel(TemporaryParts.AutoStopThread)
		TemporaryParts.AutoStopThread = nil
	end

	CollisionParams.FilterDescendantsInstances = {}
	CollisionParams2.FilterDescendantsInstances = {}

	if activeTorso ~= nil then
		activeTorso.Anchored = false
	end

	if ReverseAllEffects and activeHumanoid then
		activeHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		activeHumanoid.AutoRotate = true

		if activeTorso ~= nil then
			activeTorso.CanCollide = true
		end

		if activeHead ~= nil then
			activeHead.CanCollide = true
		end
	end
end

return RootMotionModule
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule.DebugDraw | Enabled: N/A
--------------------------------------------------------------------
local Debris = game:GetService("Debris")
local DebugDraw = {}

local DEFAULT_COLOR = Color3.fromRGB(255, 0, 0)
local DEFAULT_DURATION = 3

function DebugDraw.Line(origin: Vector3, endPos: Vector3, color: Color3?, duration: number?)
	local distance = (endPos - origin).Magnitude
	local p = Instance.new("Part")

	p.Name = "DebugLine"
	p.Anchored = true
	p.CanCollide = false
	p.CanQuery = false
	p.CastShadow = false
	p.Material = Enum.Material.Neon
	p.Color = color or DEFAULT_COLOR
	p.Size = Vector3.new(0.1, 0.1, distance)

	p.CFrame = CFrame.lookAt(origin, endPos) * CFrame.new(0, 0, -distance/2)
	p.Parent = workspace.Terrain

	Debris:AddItem(p, duration or DEFAULT_DURATION)
end

function DebugDraw.Sphere(position: Vector3, radius: number?, color: Color3?, duration: number?)
	local p = Instance.new("Part")
	local size = radius or 0.5

	p.Name = "DebugSphere"
	p.Anchored = true
	p.CanCollide = false
	p.CanQuery = false
	p.CastShadow = false
	p.Shape = Enum.PartType.Ball
	p.Material = Enum.Material.Neon
	p.Color = color or DEFAULT_COLOR
	p.Size = Vector3.new(size, size, size)
	p.Position = position
	p.Parent = workspace.Terrain

	Debris:AddItem(p, duration or DEFAULT_DURATION)
end

return DebugDraw
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.RootMotionModule.DebugDraw

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Character Manipulation.Animations.Animations | Enabled: N/A
--------------------------------------------------------------------
local Animations = {}

--- @ Core System
local ContentProvider = game:GetService("ContentProvider")

--- @ Core System > Configuration
--- @ Core System > Animations
local AnimationList = {
	-- movement
	Idle = { Id = "rbxassetid://78425065897558", Priority = Enum.AnimationPriority.Idle },
	Walk = { Id = "rbxassetid://113803262890384", Priority = Enum.AnimationPriority.Movement },
	Run  = { Id = "rbxassetid://121673499241134", Priority = Enum.AnimationPriority.Movement },

	CrouchIdle  = { Id = "rbxassetid://93492672587360", Priority = Enum.AnimationPriority.Idle },
	CrouchWalk  = { Id = "rbxassetid://108247959331945", Priority = Enum.AnimationPriority.Movement },

	ProneIdle  = { Id = "rbxassetid://92202783591585", Priority = Enum.AnimationPriority.Idle },
	ProneWalk  = { Id = "rbxassetid://102031427994404", Priority = Enum.AnimationPriority.Movement },

	--stance actions
	CrouchToProne  = { Id = "rbxassetid://93314542735298", Priority = Enum.AnimationPriority.Action },
	StandToCrouch  = { Id = "rbxassetid://88598341349330", Priority = Enum.AnimationPriority.Action },

	--backpack -standing
	BpStandingOn = { Id = "rbxassetid://114052209660012", Priority = Enum.AnimationPriority.Action },
	BpStandingOff = { Id = "rbxassetid://140198126915613", Priority = Enum.AnimationPriority.Action },
	--backpack -crouching
	BpCrouchingOn = { Id = "rbxassetid://123040051320408", Priority = Enum.AnimationPriority.Action },
	BpCrouchingOff = { Id = "rbxassetid://112277920930681", Priority = Enum.AnimationPriority.Action },
	--backpack -prone
	BpProneOn = { Id = "rbxassetid://101870072841274", Priority = Enum.AnimationPriority.Action },
	BpProneOff = { Id = "rbxassetid://92038037938033", Priority = Enum.AnimationPriority.Action },
	
	--base idles / actions
	BpIdle = { Id = "rbxassetid://94593828210874", Priority = Enum.AnimationPriority.Action },
	BpCraftLoop = { Id = "rbxassetid://125069610495737", Priority = Enum.AnimationPriority.Action2 },
	BpProneIdle = { Id = "rbxassetid://114584694505649", Priority = Enum.AnimationPriority.Action },
	BpProneCraftLoop = { Id = "rbxassetid://85991541209761", Priority = Enum.AnimationPriority.Action2 },
	--vaulting
	Vault = { Id = "rbxassetid://107592423336646", Priority = Enum.AnimationPriority.Action, BaseDistance = 6, ForwardOffset = 3.5 },

}

--STANDING ANIMATIONS
--backpackoff - 71289003009549
--backpack on - 87321975347140
--backpack idle - 99116978113436
--backpack crafting loop - 76209966750178

--CROUCHING ANIMATIONS
--backpack off - 80991751202429
--backpack on - 110632590807070


--unarmed
--crouch idle - 86995006751357
--crouch walk - 112781589825536
-- crouch2prone - 105749305366297
--stand2crouch - 80817862725486

--prone idle - 135865185555412
--prone crawl - 98524457967574


--- @ Core System > API
function Animations.GetData(name)
	return AnimationList[name]
end

function Animations.GetId(name)
	local data = AnimationList[name]
	return data and data.Id or nil
end

function Animations.GetList()
	return AnimationList
end


return Animations
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Character Manipulation.Animations.Animations

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Camera.CameraController | Enabled: N/A
--------------------------------------------------------------------
local CameraController = {}

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local function getOrCreate(parent, className, name)
	local child = parent:FindFirstChild(name)
	if not child then
		child = Instance.new(className)
		child.Name = name
		child.Parent = parent
	end
	return child
end

local RemotesFolder = ReplicatedStorage:WaitForChild("Peak"):WaitForChild("Remotes")
local CameraApiFolder = getOrCreate(RemotesFolder, "Folder", "CameraAPI")
local setControlEvent = getOrCreate(CameraApiFolder, "BindableEvent", "SetCameraExternalControl")
local releaseControlEvent = getOrCreate(CameraApiFolder, "BindableEvent", "ReleaseCameraExternalControl")

local player, mouse, character, humanoid, hrp, head
local camera = Workspace.CurrentCamera
local CameraPart

local Config = {
	BaseFOV = 60,
	CurrentFOV = 60,

	Offset = Vector3.new(2, 0.5, 7), 
	LookSensitivity = 1,
	AimSensitivityMultiplier = 0.8, 

	SideFactor = 1, 

	MinPitch = -80,
	MaxPitch = 80,

	ObstructionBuffer = 0.2,
	ExclusionTag = "CameraExclude",

	DefaultAnchorSpeed = 15, 

	RecoilSpeed = 60,

	PositionalLagAmount = 0.05,
	PositionalLagSpeed = 10,

	DefaultImpulseInSpeed = 20,
	DefaultImpulseOutSpeed = 5,
}

local cameraAngleX, cameraAngleY = 0, 0
local recoilPendingX, recoilPendingY = 0, 0
local isMouseForceUnlocked = false
local isCameraExternallyControlled = false

local cameraAnchor
local transitionOffset = Vector3.zero
local lagOffset = Vector3.zero
local currentAnchorSpeed = Config.DefaultAnchorSpeed

local impulseTarget = Vector3.zero
local impulseCurrent = Vector3.zero
local currentImpulseInSpeed = Config.DefaultImpulseInSpeed
local currentImpulseOutSpeed = Config.DefaultImpulseOutSpeed

local flinchTargetPos = Vector3.zero
local flinchCurrentPos = Vector3.zero
local flinchTargetRot = Vector3.zero
local flinchCurrentRot = Vector3.zero
local currentFlinchInSpeed = Config.DefaultImpulseInSpeed
local currentFlinchOutSpeed = Config.DefaultImpulseOutSpeed

local noiseIntensity = Vector3.zero
local targetNoiseIntensity = Vector3.zero
local currentNoiseSpeed = 1
local targetNoiseSpeed = 1
local noiseLerpSpeed = 5
local noiseTime = 0

local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Exclude
raycastParams.IgnoreWater = true

local OffsetValue = Instance.new("Vector3Value")
OffsetValue.Value = Config.Offset
OffsetValue.Parent = Workspace.Game
OffsetValue.Name = "Offset"

local FOVValue = Instance.new("NumberValue") 
FOVValue.Value = Config.BaseFOV

local currentRawOffset = Config.Offset

local function isInstanceExcluded(instance)
	if not instance then return false end
	local current = instance
	while current do
		if CollectionService:HasTag(current, Config.ExclusionTag) then
			return true
		end
		current = current.Parent
	end
	return false
end

function CameraController:TweenOffset(newOffset, tweenInfo)
	if not newOffset then return end
	currentRawOffset = newOffset 

	local actualOffset = Vector3.new(newOffset.X * Config.SideFactor, newOffset.Y, newOffset.Z)

	local tween = TweenService:Create(
		OffsetValue,
		tweenInfo or TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
		{ Value = actualOffset }
	)

	tween.Completed:Connect(function()
		Config.Offset = OffsetValue.Value
	end)

	tween:Play()
	return tween
end

function CameraController:TweenFOV(targetFOV, tweenInfo)
	if not targetFOV then return end
	local tween = TweenService:Create(
		FOVValue,
		tweenInfo or TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
		{ Value = targetFOV }
	)

	tween.Completed:Connect(function()
		Config.CurrentFOV = FOVValue.Value
	end)

	tween:Play()
	return tween
end

function CameraController:AddRecoil(x, y)
	if not x or not y then return end
	recoilPendingX -= x
	recoilPendingY += y
end

function CameraController:ApplyImpulse(vector, fadeInSpeed, fadeOutSpeed)
	if not vector then return end
	impulseTarget = impulseTarget + vector
	currentImpulseInSpeed = fadeInSpeed or Config.DefaultImpulseInSpeed
	currentImpulseOutSpeed = fadeOutSpeed or Config.DefaultImpulseOutSpeed
end

function CameraController:ApplyFlinch(posVector, rotVector, fadeInSpeed, fadeOutSpeed)
	if posVector then
		flinchTargetPos = flinchTargetPos + posVector
	end
	if rotVector then
		flinchTargetRot = flinchTargetRot + rotVector
	end
	currentFlinchInSpeed = fadeInSpeed or Config.DefaultImpulseInSpeed
	currentFlinchOutSpeed = fadeOutSpeed or Config.DefaultImpulseOutSpeed
end

function CameraController:SwapShoulder()
	Config.SideFactor = Config.SideFactor * -1
	self:TweenOffset(currentRawOffset, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
end

function CameraController:SetPerlin(intensity, speed, interpolationSpeed)
	targetNoiseIntensity = intensity or Vector3.zero
	targetNoiseSpeed = speed or 1
	noiseLerpSpeed = interpolationSpeed or 5
end

local function forceUnlockMouse()
	isMouseForceUnlocked = true
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true
end

local function forceLockMouse()
	if isCameraExternallyControlled then return end
	isMouseForceUnlocked = false
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseIconEnabled = false
end

local function handleMouseInput(input, gameProcessed)
	if gameProcessed or isMouseForceUnlocked or isCameraExternallyControlled then return end
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Delta

		local isAiming = character and character:GetAttribute("IsAiming")
		local aimMult = isAiming and Config.AimSensitivityMultiplier or 1

		local sensitivity = UserInputService.MouseDeltaSensitivity * Config.LookSensitivity * aimMult

		cameraAngleX -= delta.X * sensitivity
		cameraAngleY = math.clamp(cameraAngleY - delta.Y * sensitivity, Config.MinPitch, Config.MaxPitch)
	end
end

local function updateCamera(deltaTime)
	if isCameraExternallyControlled then 
		if CameraPart then camera.CFrame = CameraPart.CFrame end
		return 
	end

	if not character or not character.Parent or not humanoid or humanoid.Health <= 0 or not head or not head.Parent then return end
	if not cameraAnchor or not cameraAnchor.Parent then cameraAnchor = head end

	Config.Offset = OffsetValue.Value
	Config.CurrentFOV = FOVValue.Value
	camera.FieldOfView = Config.CurrentFOV

	if transitionOffset.Magnitude > 0.001 then
		transitionOffset = transitionOffset:Lerp(Vector3.zero, 1 - math.exp(-deltaTime * currentAnchorSpeed))
	else
		transitionOffset = Vector3.zero
	end

	impulseTarget = impulseTarget:Lerp(Vector3.zero, 1 - math.exp(-deltaTime * currentImpulseOutSpeed))
	impulseCurrent = impulseCurrent:Lerp(impulseTarget, 1 - math.exp(-deltaTime * currentImpulseInSpeed))

	flinchTargetPos = flinchTargetPos:Lerp(Vector3.zero, 1 - math.exp(-deltaTime * currentFlinchOutSpeed))
	flinchCurrentPos = flinchCurrentPos:Lerp(flinchTargetPos, 1 - math.exp(-deltaTime * currentFlinchInSpeed))

	flinchTargetRot = flinchTargetRot:Lerp(Vector3.zero, 1 - math.exp(-deltaTime * currentFlinchOutSpeed))
	flinchCurrentRot = flinchCurrentRot:Lerp(flinchTargetRot, 1 - math.exp(-deltaTime * currentFlinchInSpeed))

	local velocity = cameraAnchor.AssemblyLinearVelocity
	local targetLag = -velocity * Config.PositionalLagAmount

	targetLag = Vector3.new(targetLag.X, math.clamp(targetLag.Y, -0.5, 0.5), targetLag.Z)

	lagOffset = lagOffset:Lerp(targetLag, 1 - math.exp(-deltaTime * Config.PositionalLagSpeed))

	local recoilFactor = 1 - math.exp(-deltaTime * Config.RecoilSpeed)
	local moveX = recoilPendingX * recoilFactor
	local moveY = recoilPendingY * recoilFactor

	cameraAngleX += moveX
	cameraAngleY += moveY

	recoilPendingX -= moveX
	recoilPendingY -= moveY

	cameraAngleY = math.clamp(cameraAngleY, Config.MinPitch, Config.MaxPitch)

	local rotation = CFrame.Angles(0, math.rad(cameraAngleX), 0) * CFrame.Angles(math.rad(cameraAngleY), 0, 0)

	local anchorPos = cameraAnchor.Position
	local effectiveOrigin = anchorPos + transitionOffset + lagOffset + impulseCurrent + flinchCurrentPos

	local currentOffset = Config.Offset

	local desiredPosition = (CFrame.new(effectiveOrigin) * rotation):PointToWorldSpace(currentOffset)
	local direction = (desiredPosition - effectiveOrigin)
	local finalPosition = desiredPosition

	if direction.Magnitude > 0.01 then
		local ignoreList = {character, CameraPart}
		raycastParams.FilterDescendantsInstances = ignoreList

		local result = Workspace:Raycast(effectiveOrigin, direction, raycastParams)
		if result then
			if not isInstanceExcluded(result.Instance) and result.Instance.Transparency < 1 then
				finalPosition = effectiveOrigin + direction.Unit * math.max(0.5, (result.Position - effectiveOrigin).Magnitude - Config.ObstructionBuffer)
			end
		end
	end

	local lerpFactor = 1 - math.exp(-deltaTime * noiseLerpSpeed)
	noiseIntensity = noiseIntensity:Lerp(targetNoiseIntensity, lerpFactor)
	currentNoiseSpeed = currentNoiseSpeed + (targetNoiseSpeed - currentNoiseSpeed) * lerpFactor

	noiseTime = noiseTime + (deltaTime * currentNoiseSpeed)

	local noiseX = math.noise(noiseTime, 0, 0) * noiseIntensity.X
	local noiseY = math.noise(0, noiseTime, 0) * noiseIntensity.Y
	local noiseZ = math.noise(0, 0, noiseTime) * noiseIntensity.Z
	local noiseCFrame = CFrame.Angles(math.rad(noiseX), math.rad(noiseY), math.rad(noiseZ))

	local flinchRotCFrame = CFrame.Angles(math.rad(flinchCurrentRot.X), math.rad(flinchCurrentRot.Y), math.rad(flinchCurrentRot.Z))

	local finalCFrame = CFrame.new(finalPosition) * rotation * flinchRotCFrame * noiseCFrame

	if CameraPart then
		CameraPart.CFrame = finalCFrame
		camera.CFrame = CameraPart.CFrame
	end
end

local function setExternalControl(enabled, targetCFrame, tweenInfo)
	isCameraExternallyControlled = enabled
	if enabled then
		forceUnlockMouse()
		if targetCFrame and CameraPart then TweenService:Create(CameraPart, tweenInfo or TweenInfo.new(0), {CFrame = targetCFrame}):Play() end
	else
		forceLockMouse()
	end
end

local function initCameraPart()
	if CameraPart then return end
	CameraPart = Instance.new("Part")
	CameraPart.Name = "PlayerCameraPart"
	CameraPart.Size = Vector3.one * 0.1
	CameraPart.Transparency = 1
	CameraPart.Anchored = true
	CameraPart.CanCollide = false
	CameraPart.CanTouch = false
	CameraPart.CanQuery = false
	CameraPart.Parent = camera
	raycastParams.FilterDescendantsInstances = {character, CameraPart}
end

local function onCharacterAdded(newChar)
	if not newChar then return end

	character = newChar
	humanoid = newChar:WaitForChild("Humanoid", 10)
	hrp = newChar:WaitForChild("HumanoidRootPart", 10)
	head = newChar:WaitForChild("Head", 10)

	if hrp and humanoid and head then
		humanoid.AutoRotate = true
		raycastParams.FilterDescendantsInstances = {newChar, CameraPart}

		cameraAnchor = head
		transitionOffset = Vector3.zero
		lagOffset = Vector3.zero
		impulseTarget = Vector3.zero
		impulseCurrent = Vector3.zero
		flinchTargetPos = Vector3.zero
		flinchCurrentPos = Vector3.zero
		flinchTargetRot = Vector3.zero
		flinchCurrentRot = Vector3.zero
	end
end

function CameraController:SetAnchor(instance, transitionSpeed)
	if instance and instance:IsA("BasePart") and instance ~= cameraAnchor then
		if cameraAnchor then
			local diff = cameraAnchor.Position - instance.Position
			transitionOffset = transitionOffset + diff
		end

		cameraAnchor = instance
		currentAnchorSpeed = transitionSpeed or Config.DefaultAnchorSpeed
	end
end

function CameraController:Init(localPlayer)
	player = localPlayer
	mouse = player:GetMouse()
	character = player.Character or player.CharacterAdded:Wait()
	initCameraPart()

	local requestMouseUnlock = getOrCreate(CameraApiFolder, "BindableEvent", "RequestMouseUnlock")
	local requestMouseLock = getOrCreate(CameraApiFolder, "BindableEvent", "RequestMouseLock")

	requestMouseUnlock.Event:Connect(forceUnlockMouse)
	requestMouseLock.Event:Connect(forceLockMouse)

	UserInputService.InputChanged:Connect(handleMouseInput)
	player.CharacterAdded:Connect(onCharacterAdded)

	setControlEvent.Event:Connect(function(targetCFrame, tweenInfo) 
		setExternalControl(true, targetCFrame, tweenInfo) 
	end)

	releaseControlEvent.Event:Connect(function(syncCFrame)
		if syncCFrame and typeof(syncCFrame) == "CFrame" then
			local lookVector = syncCFrame.LookVector
			cameraAngleX = math.deg(math.atan2(-lookVector.X, -lookVector.Z))
			local pitch = math.asin(-lookVector.Y)
			cameraAngleY = math.deg(pitch)
		end
		setExternalControl(false)
	end)

	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.LeftAlt then
			if isMouseForceUnlocked then forceLockMouse() else forceUnlockMouse() end
		end
	end)

	RunService:BindToRenderStep("PeakCameraUpdate", Enum.RenderPriority.Camera.Value + 1, updateCamera)

	onCharacterAdded(character)
	forceLockMouse()
end

return CameraController

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Camera.CameraController

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Camera.CameraFX | Enabled: N/A
--------------------------------------------------------------------
local Visuals = {}

--- @ Services
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- run CameraFX.Start() to start the camera effects

--- @ Internal Storage
local effects = {
	blur = nil,
	color = nil
}

--- @ Configuration
local Config = {
	OutdoorExposure = 0,
	IndoorExposure = 1.5,
	CheckDistance = 500,
	CloseWallDist = 6,
	WallDarkness = -2.0,
	NeonReaction = -0.7,
	SunReaction = -5.0,
	SunLookThreshold = 0.90,
	SunBlurSize = 20,
	OutdoorTint = Color3.fromRGB(255, 255, 255),
	OutdoorContrast = 0,
	IndoorTint = Color3.fromRGB(255, 240, 220),
	IndoorContrast = 0.15,
	SunLerpSpeed = 0.2,
	GeneralLerpSpeed = 1.0,
	NoiseSpeed = 0.5,
	NoiseAmount = 0.1,
}

--- @ State Variables
local currentExposure = Lighting.ExposureCompensation
local targetExposure = Config.OutdoorExposure
local currentTint = Config.OutdoorTint
local currentContrast = Config.OutdoorContrast
local noiseSeed = math.random(1000)

--- @ State Variables > Master Toggle
local masterAlpha = 1 
local targetMasterAlpha = 1
local fadeSpeed = 1 

--- @ Asset Management
local function GetOrCreateEffect(className, name)
	local existing = Lighting:FindFirstChild(name)
	if existing and existing:IsA(className) then
		return existing
	end

	local newEffect = Instance.new(className)
	newEffect.Name = name
	newEffect.Parent = Lighting
	return newEffect
end

local function CreateAssets()
	effects.blur = GetOrCreateEffect("BlurEffect", "Visuals_SunBlur")
	effects.blur.Size = 0 -- Start invisible

	effects.color = GetOrCreateEffect("ColorCorrectionEffect", "Visuals_ColorCorrection")
end

--- @ Utility Functions > Raycasting
local function getRayParams()
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	local ignoreList = {}
	if player.Character then table.insert(ignoreList, player.Character) end
	params.FilterDescendantsInstances = ignoreList
	params.IgnoreWater = true
	return params
end

--- @ Utility Functions > Environment
local function checkEnvironment()
	local char = player.Character
	if not char or not char:FindFirstChild("Head") then return false end
	local result = workspace:Raycast(char.Head.Position, Vector3.new(0, 50, 0), getRayParams())
	return result ~= nil
end

--- @ Utility Functions > Camera Look
local function getCameraLookData()
	local rayDir = camera.CFrame.LookVector * Config.CheckDistance
	local result = workspace:Raycast(camera.CFrame.Position, rayDir, getRayParams())
	if result then
		return result.Instance.Material, (result.Position - camera.CFrame.Position).Magnitude
	end
	return nil, 9999
end

--- @ Utility Functions > Sun Check
local function checkSun()
	local sunDir = Lighting:GetSunDirection()
	local lookDir = camera.CFrame.LookVector
	if lookDir:Dot(sunDir) > Config.SunLookThreshold then
		local result = workspace:Raycast(camera.CFrame.Position, sunDir * 1000, getRayParams())
		return result == nil
	end
	return false
end

--- @ Core System > Controls
function Visuals.SetEnabled(enabled, duration)
	targetMasterAlpha = enabled and 1 or 0
	if duration and duration > 0 then
		fadeSpeed = 1 / duration
	else
		masterAlpha = targetMasterAlpha
		fadeSpeed = 0
	end
end

--- @ Core System > Start
function Visuals.Start()
	CreateAssets() -- ! Generate effects on start

	RunService.RenderStepped:Connect(function(dt)
		local char = player.Character
		if not char then return end

		--- @ Core System > Master Fader
		if masterAlpha ~= targetMasterAlpha then
			local change = fadeSpeed * dt
			if targetMasterAlpha > masterAlpha then
				masterAlpha = math.min(masterAlpha + change, 1)
			else
				masterAlpha = math.max(masterAlpha - change, 0)
			end
		end

		-- If fully disabled, reset everything and stop processing
		if masterAlpha <= 0 then
			Lighting.ExposureCompensation = 0
			if effects.blur then effects.blur.Size = 0 end
			if effects.color then 
				effects.color.TintColor = Color3.new(1,1,1)
				effects.color.Contrast = 0 
			end
			return 
		end

		--- @ Core System > Checks
		local isIndoors = checkEnvironment()
		local hitMat, hitDist = getCameraLookData()
		local lookingAtSun = checkSun()

		local targetTint = Config.OutdoorTint
		local targetContrast = Config.OutdoorContrast
		local targetBlur = 0

		--- @ Core System > Logic Calculation
		if isIndoors then
			targetExposure = Config.IndoorExposure
			targetTint = Config.IndoorTint
			targetContrast = Config.IndoorContrast
		else
			targetExposure = Config.OutdoorExposure
		end

		local currentSpeed = Config.GeneralLerpSpeed

		if lookingAtSun then
			targetExposure = targetExposure + Config.SunReaction
			targetBlur = Config.SunBlurSize
			currentSpeed = Config.SunLerpSpeed
		elseif hitDist < Config.CloseWallDist then
			local proximityFactor = 1 - (hitDist / Config.CloseWallDist)
			targetExposure = targetExposure + (Config.WallDarkness * proximityFactor)
		elseif hitMat == Enum.Material.Neon then
			targetExposure = targetExposure + Config.NeonReaction
		end

		local timeVal = tick() * Config.NoiseSpeed
		local drift = math.noise(timeVal, noiseSeed, 0) * Config.NoiseAmount
		targetExposure = targetExposure + drift

		--- @ Core System > Apply Visuals
		currentExposure = currentExposure + (targetExposure - currentExposure) * (currentSpeed * dt)
		Lighting.ExposureCompensation = currentExposure * masterAlpha

		local blurSpeed = (targetBlur > effects.blur.Size) and 0.5 or 2.0
		local rawBlur = effects.blur.Size + (targetBlur - effects.blur.Size) * (blurSpeed * dt)
		effects.blur.Size = rawBlur * masterAlpha

		currentTint = currentTint:Lerp(targetTint, currentSpeed * dt)
		currentContrast = currentContrast + (targetContrast - currentContrast) * (currentSpeed * dt)

		effects.color.TintColor = Color3.new(1,1,1):Lerp(currentTint, masterAlpha)
		effects.color.Contrast = currentContrast * masterAlpha
	end)
end

return Visuals
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Camera.CameraFX

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Loot.LootModule | Enabled: N/A
--------------------------------------------------------------------
local LootModule = {}




LootModule.Pools = {
	Common = {
		{ Item = "Sugar", Chance = 30 },
		{ Item = "Rag", Chance = 25 },
		{ Item = "Explosive", Chance = 20 },
		{ Item = "Blade", Chance = 15 },
		{ Item = "Binding", Chance = 5 },
		{ Item = "Alcohol", Chance = 5 },
	},
}

function LootModule:RollLoot(poolName)
	local pool = self.Pools[poolName]
	if not pool then return nil end

	local totalChance = 0
	for _, entry in ipairs(pool) do
		totalChance = totalChance + entry.Chance
	end

	local roll = math.random(1, totalChance)
	local currentChance = 0

	for _, entry in ipairs(pool) do
		currentChance = currentChance + entry.Chance
		if roll <= currentChance then
			return entry.Item
		end
	end

	return nil
end

return LootModule

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Loot.LootModule

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris | Enabled: N/A
--------------------------------------------------------------------
--!optimize 2
local Types = require(script.Types)

--[=[
    @class Iris

    Iris; contains the all user-facing functions and properties.
    A set of internal functions can be found in `Iris.Internal` (only use if you understand).

    In its simplest form, users may start Iris by using
    ```lua
    Iris.Init()

    Iris:Connect(function()
        Iris.Window({"My First Window!"})
            Iris.Text({"Hello, World"})
            Iris.Button({"Save"})
            Iris.InputNum({"Input"})
        Iris.End()
    end)
    ```
]=]
local Iris = {} :: Types.Iris

local Internal: Types.Internal = require(script.Internal)(Iris)

--[=[
    @within Iris
    @prop Disabled boolean

    While Iris.Disabled is true, execution of Iris and connected functions will be paused.
    The widgets are not destroyed, they are just frozen so no changes will happen to them.
]=]
Iris.Disabled = false

--[=[
    @within Iris
    @prop Args { [string]: { [string]: any } }

    Provides a list of every possible Argument for each type of widget to it's index.
    For instance, `Iris.Args.Window.NoResize`.
    The Args table is useful for using widget Arguments without remembering their order.
    ```lua
    Iris.Window({"My Window", [Iris.Args.Window.NoResize] = true})
    ```
]=]
Iris.Args = {}

--[=[
    @ignore
    @within Iris
    @prop Events table

    -todo: work out what this is used for.
]=]
Iris.Events = {}

--[=[
    @within Iris
    @function Init
    @param parentInstance Instance? -- where Iris will place widgets UIs under, defaulting to [PlayerGui]
    @param eventConnection (RBXScriptSignal | () -> () | false)? -- the event to determine an Iris cycle, defaulting to [Heartbeat]
    @return Iris

    Initializes Iris and begins rendering. Can only be called once.
    See [Iris.Shutdown] to stop Iris, or [Iris.Disabled] to temporarily disable Iris.

    Once initialized, [Iris:Connect] can be used to create a widget.

    If the `eventConnection` is `false` then Iris will not create a cycle loop and the user will need to call [Internal._cycle] every frame.
]=]
function Iris.Init(parentInstance: Instance?, eventConnection: (RBXScriptSignal | () -> () | false)?): Types.Iris
    assert(Internal._started == false, "Iris.Init can only be called once.")
    assert(Internal._shutdown == false, "Iris.Init cannot be called once shutdown.")

    if parentInstance == nil then
        -- coalesce to playerGui
        parentInstance = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
    end
    if eventConnection == nil then
        -- coalesce to Heartbeat
        eventConnection = game:GetService("RunService").Heartbeat
    end
    Internal.parentInstance = parentInstance :: Instance
    Internal._started = true

    Internal._generateRootInstance()
    Internal._generateSelectionImageObject()

    for _, callback: () -> () in Internal._initFunctions do
        callback()
    end

    -- spawns the connection to call `Internal._cycle()` within.
    task.spawn(function()
        if typeof(eventConnection) == "function" then
            while Internal._started do
                eventConnection()
                Internal._cycle()
            end
        elseif eventConnection ~= nil and eventConnection ~= false then
            Internal._eventConnection = eventConnection:Connect(function()
                Internal._cycle()
            end)
        end
    end)

    return Iris
end

--[=[
    @within Iris
    @function Shutdown

    Shuts Iris down. This can only be called once, and Iris cannot be started once shut down.
]=]
function Iris.Shutdown()
    Internal._started = false
    Internal._shutdown = true

    if Internal._eventConnection then
        Internal._eventConnection:Disconnect()
    end
    Internal._eventConnection = nil

    if Internal._rootWidget then
        if Internal._rootWidget.Instance then
            Internal._widgets["Root"].Discard(Internal._rootWidget)
        end
        Internal._rootInstance = nil
    end

    if Internal.SelectionImageObject then
        Internal.SelectionImageObject:Destroy()
    end

    for _, connection: RBXScriptConnection in Internal._connections do
        connection:Disconnect()
    end
end

--[=[
    @within Iris
    @method Connect
    @param callback () -> () -- the callback containg the Iris code
    @return () -> () -- call to disconnect it
    
    Connects a function which will execute every Iris cycle. [Iris.Init] must be called before connecting.

    A cycle is determined by the `eventConnection` passed to [Iris.Init] (default to [RunService.Heartbeat]).

    Multiple callbacks can be added to Iris from many different scripts or modules.
]=]
function Iris:Connect(callback: () -> ()): () -> () -- this uses method syntax for no reason.
    if Internal._started == false then
        warn("Iris:Connect() was called before calling Iris.Init(), the connected function will never run")
    end
    local connectionIndex: number = #Internal._connectedFunctions + 1
    Internal._connectedFunctions[connectionIndex] = callback
    return function()
        Internal._connectedFunctions[connectionIndex] = nil
    end
end

--[=[
    @within Iris
    @function Append
    @param userInstance GuiObject -- the Roblox [Instance] to insert into Iris

    Inserts any Roblox [Instance] into Iris.
    
    The parent of the inserted instance can either be determined by the `_config.Parent`
    property or by the current parent widget from the stack.
]=]
function Iris.Append(userInstance: GuiObject)
    local parentWidget: Types.ParentWidget = Internal._GetParentWidget()
    local widgetInstanceParent: GuiObject
    if Internal._config.Parent then
        widgetInstanceParent = Internal._config.Parent :: any
    else
        widgetInstanceParent = Internal._widgets[parentWidget.type].ChildAdded(parentWidget, { type = "userInstance" } :: Types.Widget)
    end
    userInstance.Parent = widgetInstanceParent
end

--[=[
    @within Iris
    @function End

    Marks the end of any widgets which contain children. For example:
    ```lua
    -- Widgets placed here **will not** be inside the tree
    Iris.Text({"Above and outside the tree"})

    -- A Tree widget can contain children.
    -- We must therefore remember to call `Iris.End()` 
    Iris.Tree({"My First Tree"})
        -- Widgets placed here **will** be inside the tree
        Iris.Text({"Tree item 1"})
        Iris.Text({"Tree item 2"})
    Iris.End()

    -- Widgets placed here **will not** be inside the tree
    Iris.Text({"Below and outside the tree"})
    ```
    :::caution Caution: Error
    Seeing the error `Callback has too few calls to Iris.End()` or `Callback has too many calls to Iris.End()`?
    Using the wrong amount of `Iris.End()` calls in your code will lead to an error.
    
    Each widget called which might have children should be paired with a call to `Iris.End()`, **even if the Widget doesnt currently have any children**.
    :::
]=]
function Iris.End()
    if Internal._stackIndex == 1 then
        error("Callback has too many calls to Iris.End()", 2)
    end

    Internal._IDStack[Internal._stackIndex] = nil
    Internal._stackIndex -= 1
end

--[[
    ------------------------
        [SECTION] Config
    ------------------------
]]

--[=[
    @within Iris
    @function ForceRefresh

    Destroys and regenerates all instances used by Iris. Useful if you want to propogate state changes.
    :::caution Caution: Performance
    Because this function Deletes and Initializes many instances, it may cause **performance issues** when used with many widgets.
    In **no** case should it be called every frame.
    :::
]=]
function Iris.ForceRefresh()
    Internal._globalRefreshRequested = true
end

--[=[
    @within Iris
    @function UpdateGlobalConfig
    @param deltaStyle { [string]: any } -- a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`

    Customizes the configuration which **every** widget will inherit from.

    It can be used along with [Iris.TemplateConfig] to easily swap styles, for example:
    ```lua
    Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) -- use light theme
    ```
    :::caution Caution: Performance
    This function internally calls [Iris.ForceRefresh] so that style changes are propogated.

    As such, it may cause **performance issues** when used with many widgets.
    In **no** case should it be called every frame.
    :::
]=]
function Iris.UpdateGlobalConfig(deltaStyle: { [string]: any })
    for index, style in deltaStyle do
        Internal._rootConfig[index] = style
    end
    Iris.ForceRefresh()
end

--[=[
    @within Iris
    @function PushConfig
    @param deltaStyle { [string]: any } -- a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`

    Allows cascading of a style by allowing styles to be locally and hierarchically applied.

    Each call to Iris.PushConfig must be paired with a call to [Iris.PopConfig], for example:
    ```lua
    Iris.Text({"boring text"})

    Iris.PushConfig({TextColor = Color3.fromRGB(128, 0, 256)})
        Iris.Text({"Colored Text!"})
    Iris.PopConfig()

    Iris.Text({"boring text"})
    ```
]=]
function Iris.PushConfig(deltaStyle: { [string]: any })
    local ID = Iris.State(-1)
    if ID.value == -1 then
        ID:set(deltaStyle)
    else
        -- compare tables
        if Internal._deepCompare(ID:get(), deltaStyle) == false then
            -- refresh local
            Internal._localRefreshActive = true
            ID:set(deltaStyle)
        end
    end

    Internal._config = setmetatable(deltaStyle, {
        __index = Internal._config,
    }) :: any
end

--[=[
    @within Iris
    @function PopConfig

    Ends a [Iris.PushConfig] style.

    Each call to [Iris.PopConfig] should match a call to [Iris.PushConfig].
]=]
function Iris.PopConfig()
    Internal._localRefreshActive = false
    Internal._config = getmetatable(Internal._config :: any).__index
end

--[=[
    @within Iris
    @prop TemplateConfig { [string]: { [string]: any } }

    TemplateConfig provides a table of default styles and configurations which you may apply to your UI.
]=]
Iris.TemplateConfig = require(script.config)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark) -- use colorDark and sizeDefault themes by default
Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault)
Iris.UpdateGlobalConfig(Iris.TemplateConfig.utilityDefault)
Internal._globalRefreshRequested = false -- UpdatingGlobalConfig changes this to true, leads to Root being generated twice.

--[[
    --------------------
        [SECTION] ID
    --------------------
]]

--[=[
    @within Iris
    @function PushId
    @param id ID -- custom id

    Sets the id discriminator for the next widgets. Use [Iris.PopId] to remove it.
]=]
function Iris.PushId(ID: Types.ID)
    assert(typeof(ID) == "string", "Iris expected Iris.PushId id to PushId to be a string.")

    Internal._pushedId = tostring(ID)
end

--[=[
    @within Iris
    @function PopID

    Removes the id discriminator set by [Iris.PushId].
]=]
function Iris.PopId()
    Internal._pushedId = nil
end

--[=[
    @within Iris
    @function SetNextWidgetID
    @param id ID -- custom id.

    Sets the id for the next widget. Useful for using [Iris.Append] on the same widget.
    ```lua
    Iris.SetNextWidgetId("demo_window")
    Iris.Window({ "Window" })
        Iris.Text({ "Text one placed here." })
    Iris.End()

    -- later in the code

    Iris.SetNextWidgetId("demo_window")
    Iris.Window()
        Iris.Text({ "Text two placed here." })
    Iris.End()

    -- both text widgets will be placed under the same window despite being called separately.
    ```
]=]
function Iris.SetNextWidgetID(ID: Types.ID)
    Internal._nextWidgetId = ID
end

--[[
    -----------------------
        [SECTION] State
    -----------------------
]]

--[=[
    @within Iris
    @function State<T>
    @param initialValue T -- the initial value for the state
    @return State<T>
    @tag State

    Constructs a new [State] object. Subsequent ID calls will return the same object.
    :::info
    Iris.State allows you to create "references" to the same value while inside your UI drawing loop.
    For example:
    ```lua
    Iris:Connect(function()
        local myNumber = 5
        myNumber = myNumber + 1
        Iris.Text({"The number is: " .. myNumber})
    end)
    ```
    This is problematic. Each time the function is called, a new myNumber is initialized, instead of retrieving the old one.
    The above code will always display 6.
    ***
    Iris.State solves this problem:
    ```lua
    Iris:Connect(function()
        local myNumber = Iris.State(5)
        myNumber:set(myNumber:get() + 1)
        Iris.Text({"The number is: " .. myNumber})
    end)
    ```
    In this example, the code will work properly, and increment every frame.
    :::
]=]
function Iris.State<T>(initialValue: T): Types.State<T>
    local ID: Types.ID = Internal._getID(2)
    if Internal._states[ID] then
        return Internal._states[ID]
    end
    Internal._states[ID] = {
        ID = ID,
        value = initialValue,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: any
    setmetatable(Internal._states[ID], Internal.StateClass)
    return Internal._states[ID]
end

--[=[
    @within Iris
    @function WeakState<T>
    @param initialValue T -- the initial value for the state
    @return State<T>
    @tag State

    Constructs a new state object, subsequent ID calls will return the same object, except all widgets connected to the state are discarded, the state reverts to the passed initialValue
]=]
function Iris.WeakState<T>(initialValue: T): Types.State<T>
    local ID: Types.ID = Internal._getID(2)
    if Internal._states[ID] then
        if next(Internal._states[ID].ConnectedWidgets) == nil then
            Internal._states[ID] = nil
        else
            return Internal._states[ID]
        end
    end
    Internal._states[ID] = {
        ID = ID,
        value = initialValue,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: any
    setmetatable(Internal._states[ID], Internal.StateClass)
    return Internal._states[ID]
end

--[=[
    @within Iris
    @function VariableState<T>
    @param variable T -- the variable to track
    @param callback (T) -> () -- a function which sets the new variable locally
    @return State<T>
    @tag State

    Returns a state object linked to a local variable.
    
    The passed variable is used to check whether the state object should update. The callback method is used to change the local variable when the state changes.

    The existence of such a function is to make working with local variables easier.
    Since Iris cannot directly manipulate the memory of the variable, like in C++, it must instead rely on the user updating it through the callback provided.
    Additionally, because the state value is not updated when created or called we cannot return the new value back, instead we require a callback for the user to update.

    ```lua
    local myNumber = 5

    local state = Iris.VariableState(myNumber, function(value)
        myNumber = value
    end)
    Iris.DragNum({ "My number" }, { number = state })
    ```

    This is how Dear ImGui does the same in C++ where we can just provide the memory location to the variable which is then updated directly.
    ```cpp
    static int myNumber = 5;
    ImGui::DragInt("My number", &myNumber); // Here in C++, we can directly pass the variable.
    ```
    
    :::warning Update Order
    If the variable and state value are different when calling this, the variable value takes precedence.

    Therefore, if you update the state using `state.value = ...` then it will be overwritten by the variable value.
    You must use `state:set(...)` if you want the variable to update to the state's value.
    :::
]=]
function Iris.VariableState<T>(variable: T, callback: (T) -> ()): Types.State<T>
    local ID: Types.ID = Internal._getID(2)
    local state: Types.State<T>? = Internal._states[ID]

    if state then
        if variable ~= state.value then
            state:set(variable)
        end
        return state
    end

    local newState = {
        ID = ID,
        value = variable,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: Types.State<T>
    setmetatable(newState, Internal.StateClass)
    Internal._states[ID] = newState

    newState:onChange(callback)

    return newState
end

--[=[
    @within Iris
    @function TableState<K, V>
    @param table { [K]: V } -- the table containing the value
    @param key K -- the key to the value in table
    @param callback ((newValue: V) -> false?)? -- a function called when the state is changed
    @return State<V>
    @tag State

    Similar to Iris.VariableState but takes a table and key to modify a specific value and a callback to determine whether to update the value.
    
    The passed table and key are used to check the value. The callback is called when the state changes value and determines whether we update the table.
    This is useful if we want to monitor a table value which needs to call other functions when changed.
    
    Since tables are pass-by-reference, we can modify the table anywhere and it will update all other instances. Therefore, we don't need a callback by default.
    ```lua
    local data = {
        myNumber = 5
    }

    local state = Iris.TableState(data, "myNumber")
    Iris.DragNum({ "My number" }, { number = state })
    ```

    Here the `data._started` should never be updated directly, only through the `toggle` function. However, we still want to monitor the value and be able to change it.
    Therefore, we use the callback to toggle the function for us and prevent Iris from updating the table value by returning false.
    ```lua
    local data ={
        _started = false
    }

    local function toggle(enabled: boolean)
        data._started = enabled
        if data._started then
            start(...)
        else
            stop(...)
        end
    end

    local state = Iris.TableState(data, "_started", function(stateValue: boolean)
       toggle(stateValue)
       return false
    end)
    Iris.Checkbox({ "Started" }, { isChecked = state })
    ```

    :::warning Update Order
    If the table value and state value are different when calling this, the table value value takes precedence.

    Therefore, if you update the state using `state.value = ...` then it will be overwritten by the table value.
    You must use `state:set(...)` if you want the table value to update to the state's value.
    :::
]=]
function Iris.TableState<K, V>(tab: { [K]: V }, key: K, callback: ((newValue: V) -> false?)?): Types.State<V>
    local value: V = tab[key]
    local ID: Types.ID = Internal._getID(2)
    local state: Types.State<V>? = Internal._states[ID]

    -- If the table values changes, then we update the state to match.
    if state then
        if value ~= state.value then
            state:set(value)
        end
        return state
    end

    local newState = {
        ID = ID,
        value = value,
        ConnectedWidgets = {},
        ConnectedFunctions = {},
    } :: Types.State<V>
    setmetatable(newState, Internal.StateClass)
    Internal._states[ID] = newState

    -- When a change happens to the state, we update the table value.
    newState:onChange(function()
        if callback ~= nil then
            if callback(newState.value) then
                tab[key] = newState.value
            end
        else
            tab[key] = newState.value
        end
    end)
    return newState
end

--[=[
    @within Iris
    @function ComputedState<T, U>
    @param firstState State<T> -- State to bind to.
    @param onChangeCallback (firstValue: T) -> U -- callback which should return a value transformed from the firstState value
    @return State<U>

    Constructs a new State object, but binds its value to the value of another State.
    :::info
    A common use case for this constructor is when a boolean State needs to be inverted:
    ```lua
    Iris.ComputedState(otherState, function(newValue)
        return not newValue
    end)
    ```
    :::
]=]
function Iris.ComputedState<T, U>(firstState: Types.State<T>, onChangeCallback: (firstValue: T) -> U): Types.State<U>
    local ID: Types.ID = Internal._getID(2)

    if Internal._states[ID] then
        return Internal._states[ID]
    else
        Internal._states[ID] = {
            ID = ID,
            value = onChangeCallback(firstState.value),
            ConnectedWidgets = {},
            ConnectedFunctions = {},
        } :: Types.State<U>
        firstState:onChange(function(newValue: T)
            Internal._states[ID]:set(onChangeCallback(newValue))
        end)
        setmetatable(Internal._states[ID], Internal.StateClass)
        return Internal._states[ID]
    end
end

--[=[
    @within Iris
    @function ShowDemoWindow

    ShowDemoWindow is a function which creates a Demonstration window. this window contains many useful utilities for coders,
    and serves as a refrence for using each part of the library. Ideally, the DemoWindow should always be available in your UI.
    It is the same as any other callback you would connect to Iris using [Iris.Connect]
    ```lua
    Iris:Connect(Iris.ShowDemoWindow)
    ```
]=]

require(script.widgets)(Internal)
require(script.API)(Iris)

return Iris

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.API | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Types)

return function(Iris: Types.Iris)
    -- basic wrapper for nearly every widget, saves space.
    local function wrapper(name: string)
        return function(arguments: Types.WidgetArguments?, states: Types.WidgetStates?): Types.Widget
            return Iris.Internal._Insert(name, arguments, states)
        end
    end

    --[[
        ----------------------------
            [SECTION] Window API
        ----------------------------
    ]]
    --[=[
        @class Window
        
        Windows are the fundamental widget for Iris. Every other widget must be a descendant of a window.

        ```lua
        Iris.Window({ "Example Window" })
            Iris.Text({ "This is an example window!" })
        Iris.End()
        ```

        ![Example window](../assets/basicWindow.png)

        If you do not want the code inside a window to run unless it is open then you can use the following:
        ```lua
        local window = Iris.Window({ "Many Widgets Window" })

        if window.state.isOpened.value and window.state.isUncollapsed.value then
            Iris.Text({ "I will only be created when the window is open." })
        end
        Iris.End() -- must always call Iris.End(), regardless of whether the window is open or not.
        ```
    ]=]

    --[=[
        @within Window
        @prop Window Iris.Window
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        The top-level container for all other widgets to be created within.
        Can be moved and resized across the screen. Cannot contain embedded windows.
        Menus can be appended to windows creating a menubar.
        
        ```lua
        hasChildren = true
        hasState = true
        Arguments = {
            Title: string,
            NoTitleBar: boolean? = false,
            NoBackground: boolean? = false, -- the background behind the widget container.
            NoCollapse: boolean? = false,
            NoClose: boolean? = false,
            NoMove: boolean? = false,
            NoScrollbar: boolean? = false, -- the scrollbar if the window is too short for all widgets.
            NoResize: boolean? = false,
            NoNav: boolean? = false, -- unimplemented.
            NoMenu: boolean? -- whether the menubar will show if created.
        }
        Events = {
            opened: () -> boolean, -- once when opened.
            closed: () -> boolean, -- once when closed.
            collapsed: () -> boolean, -- once when collapsed.
            uncollapsed: () -> boolean, -- once when uncollapsed.
            hovered: () -> boolean -- fires when the mouse hovers over any of the window.
        }
        States = {
            size = State<Vector2>? = Vector2.new(400, 300),
            position = State<Vector2>?,
            isUncollapsed = State<boolean>? = true,
            isOpened = State<boolean>? = true,
            scrollDistance = State<number>? -- vertical scroll distance, if too short.
        }
        ```
    ]=]
    Iris.Window = wrapper("Window")

    --[=[
        @within Iris
        @function SetFocusedWindow
        @param window Types.Window -- the window to focus.

        Sets the focused window to the window provided, which brings it to the front and makes it active.
    ]=]
    Iris.SetFocusedWindow = Iris.Internal.SetFocusedWindow

    --[=[
        @within Window
        @prop Tooltip Iris.Tooltip
        @tag Widget

        Displays a text label next to the cursor

        ```lua
        Iris.Tooltip({"My custom tooltip"})
        ```

        ![Basic tooltip example](../assets/basicTooltip.png)
        
        ```lua
        hasChildren = false
        hasState = false
        Arguments = {
            Text: string
        }
        ```
    ]=]
    Iris.Tooltip = wrapper("Tooltip")

    --[[
        ---------------------------------
            [SECTION] Menu Widget API
        ---------------------------------
    ]]
    --[=[
        @class Menu
        Menu API
    ]=]

    --[=[
        @within Menu
        @prop MenuBar Iris.MenuBar
        @tag Widget
        @tag HasChildren
        
        Creates a MenuBar for the current window. Must be called directly under a Window and not within a child widget.
        :::info
            This does not create any menus, just tells the window that we going to add menus within.
        :::
        
        ```lua
        hasChildren = true
        hasState = false
        ```
    ]=]
    Iris.MenuBar = wrapper("MenuBar")

    --[=[
        @within Menu
        @prop Menu Iris.Menu
        @tag Widget
        @tag HasChildren
        @tag HasState
        
        Creates an collapsable menu. If the Menu is created directly under a MenuBar, then the widget will
        be placed horizontally below the window title. If the menu Menu is created within another menu, then
        it will be placed vertically alongside MenuItems and display an arrow alongside.

        The opened menu will be a vertically listed box below or next to the button.

        :::info
        There are widgets which are designed for being parented to a menu whilst other happens to work. There is nothing
        preventing you from adding any widget as a child, but the behaviour is unexplained and not intended, despite allowed.
        :::
        
        ```lua
        hasChildren = true
        hasState = true
        Arguments = {
            Text: string -- menu text.
        }
        Events = {
            clicked: () -> boolean,
            opened: () -> boolean, -- once when opened.
            closed: () -> boolean, -- once when closed.
            hovered: () -> boolean
        }
        States = {
            isOpened: State<boolean>? -- whether the menu is open, including any sub-menus within.
        }
        ```
    ]=]
    Iris.Menu = wrapper("Menu")

    --[=[
        @within Menu
        @prop MenuItem Iris.MenuItem
        @tag Widget
        
        Creates a button within a menu. The optional KeyCode and ModiferKey a [trimmed]  -  Edit
  14:15:01.174  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Combo | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    --stylua: ignore
    Iris.WidgetConstructor("Selectable", {
        hasState = true,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
            ["Index"] = 2,
            ["NoClick"] = 3,
        },
        Events = {
            ["selected"] = {
                ["Init"] = function(_thisWidget: Types.Selectable) end,
                ["Get"] = function(thisWidget: Types.Selectable)
                    return thisWidget.lastSelectedTick == Iris._cycleTick
                end,
            },
            ["unselected"] = {
                ["Init"] = function(_thisWidget: Types.Selectable) end,
                ["Get"] = function(thisWidget: Types.Selectable)
                    return thisWidget.lastUnselectedTick == Iris._cycleTick
                end,
            },
            ["active"] = {
                ["Init"] = function(_thisWidget: Types.Selectable) end,
                ["Get"] = function(thisWidget: Types.Selectable)
                    return thisWidget.state.index.value == thisWidget.arguments.Index
                end,
            },
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["rightClicked"] = widgets.EVENTS.rightClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["doubleClicked"] = widgets.EVENTS.doubleClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["ctrlClicked"] = widgets.EVENTS.ctrlClick(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                local Selectable = thisWidget.Instance :: Frame
                return Selectable.SelectableButton
            end),
        },
        Generate = function(thisWidget: Types.Selectable)
            local Selectable: Frame = Instance.new("Frame")
            Selectable.Name = "Iris_Selectable"
            Selectable.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, Iris._config.TextSize + 2 * Iris._config.FramePadding.Y - Iris._config.ItemSpacing.Y))
            Selectable.BackgroundTransparency = 1
            Selectable.BorderSizePixel = 0
            Selectable.ZIndex = 0
            Selectable.LayoutOrder = thisWidget.ZIndex

            local SelectableButton: TextButton = Instance.new("TextButton")
            SelectableButton.Name = "SelectableButton"
            SelectableButton.Size = UDim2.new(1, 0, 0, Iris._config.TextSize + 2 * Iris._config.FramePadding.Y)
            SelectableButton.Position = UDim2.fromOffset(0, -bit32.rshift(Iris._config.ItemSpacing.Y, 1)) -- divide by 2
            SelectableButton.BackgroundColor3 = Iris._config.HeaderColor
            SelectableButton.ClipsDescendants = true

            widgets.applyFrameStyle(SelectableButton)
            widgets.applyTextStyle(SelectableButton)
            widgets.UISizeConstraint(SelectableButton, Vector2.xAxis)

            thisWidget.ButtonColors = {
                Color = Iris._config.HeaderColor,
                Transparency = 1,
                HoveredColor = Iris._config.HeaderHoveredColor,
                HoveredTransparency = Iris._config.HeaderHoveredTransparency,
                ActiveColor = Iris._config.HeaderActiveColor,
                ActiveTransparency = Iris._config.HeaderActiveTransparency,
            }

            widgets.applyInteractionHighlights("Background", SelectableButton, SelectableButton, thisWidget.ButtonColors)

            widgets.applyButtonClick(SelectableButton, function()
                if thisWidget.arguments.NoClick ~= true then
                    if type(thisWidget.state.index.value) == "boolean" then
                        thisWidget.state.index:set(not thisWidget.state.index.value)
                    else
                        thisWidget.state.index:set(thisWidget.arguments.Index)
                    end
                end
            end)

            SelectableButton.Parent = Selectable

            return Selectable
        end,
        Update = function(thisWidget: Types.Selectable)
            local Selectable = thisWidget.Instance :: Frame
            local SelectableButton: TextButton = Selectable.SelectableButton
            SelectableButton.Text = thisWidget.arguments.Text or "Selectable"
        end,
        Discard = function(thisWidget: Types.Selectable)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
        GenerateState = function(thisWidget: Types.Selectable)
            if thisWidget.state.index == nil then
                if thisWidget.arguments.Index ~= nil then
                    error("a shared state index is required for Selectables with an Index argument", 5)
                end
                thisWidget.state.index = Iris._widgetState(thisWidget, "index", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Selectable)
            local Selectable = thisWidget.Instance :: Frame
            local SelectableButton: TextButton = Selectable.SelectableButton
            if thisWidget.state.index.value == (thisWidget.arguments.Index or true) then
                thisWidget.ButtonColors.Transparency = Iris._config.HeaderTransparency
                SelectableButton.BackgroundTransparency = Iris._config.HeaderTransparency
                thisWidget.lastSelectedTick = Iris._cycleTick + 1
            else
                thisWidget.ButtonColors.Transparency = 1
                SelectableButton.BackgroundTransparency = 1
                thisWidget.lastUnselectedTick = Iris._cycleTick + 1
            end
        end,
    } :: Types.WidgetClass)

    local AnyOpenedCombo: boolean = false
    local ComboOpenedTick: number = -1
    local OpenedCombo: Types.Combo? = nil

    local function UpdateChildContainerTransform(thisWidget: Types.Combo)
        local Combo = thisWidget.Instance :: Frame
        local PreviewContainer = Combo.PreviewContainer :: TextButton
        local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame

        ChildContainer.Size = UDim2.fromOffset(PreviewContainer.AbsoluteSize.X, 0)

        local previewPosition: Vector2 = PreviewContainer.AbsolutePosition - widgets.GuiOffset
        local previewSize: Vector2 = PreviewContainer.AbsoluteSize
        local containerSize: Vector2 = ChildContainer.AbsoluteSize
        local borderSize: number = Iris._config.PopupBorderSize
        local screenSize: Vector2 = ChildContainer.Parent.AbsoluteSize

        local x: number = previewPosition.X
        local y: number
        local anchor: Vector2 = Vector2.zero

        if previewPosition.Y + containerSize.Y > screenSize.Y then
            y = previewPosition.Y - borderSize
            anchor = Vector2.yAxis
        else
            y = previewPosition.Y + previewSize.Y + borderSize
        end
        ChildContainer.AnchorPoint = anchor
        ChildContainer.Position = UDim2.fromOffset(x, y)
    end

    widgets.registerEvent("InputBegan", function(inputObject: InputObject)
        if not Iris._started then
            return
        end
        if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and inputObject.UserInputType ~= Enum.UserInputType.MouseButton2 and inputObject.UserInputType ~= Enum.UserInputType.Touch then
            return
        end
        if AnyOpenedCombo == false or not OpenedCombo then
            return
        end
        if ComboOpenedTick == Iris._cycleTick then
            return
        end

        local MouseLocation: Vector2 = widgets.getMouseLocation()
        local Combo = OpenedCombo.Instance :: Frame
        local PreviewContainer: TextButton = Combo.PreviewContainer
        local ChildContainer = OpenedCombo.ChildContainer
        local rectMin: Vector2 = PreviewContainer.AbsolutePosition - widgets.GuiOffset
        local rectMax: Vector2 = PreviewContainer.AbsolutePosition - widgets.GuiOffset + PreviewContainer.AbsoluteSize
        if widgets.isPosInsideRect(MouseLocation, rectMin, rectMax) then
            return
        end

        rectMin = ChildContainer.AbsolutePosition - widgets.GuiOffset
        rectMax = ChildContainer.AbsolutePosition - widgets.GuiOffset + ChildContainer.AbsoluteSize
        if widgets.isPosInsideRect(MouseLocation, rectMin, rectMax) then
            return
        end

        OpenedCombo.state.isOpened:set(false)
    end)

    --stylua: ignore
    Iris.WidgetConstructor("Combo", {
        hasState = true,
        hasChildren = true,
        Args = {
            ["Text"] = 1,
            ["NoButton"] = 2,
            ["NoPreview"] = 3,
        },
        Events = {
            ["opened"] = {
                ["Init"] = function(_thisWidget: Types.Combo) end,
                ["Get"] = function(thisWidget: Types.Combo)
                    return thisWidget.lastOpenedTick == Iris._cycleTick
                end,
            },
            ["closed"] = {
                ["Init"] = function(_thisWidget: Types.Combo) end,
                ["Get"] = function(thisWidget: Types.Combo)
                    return thisWidget.lastClosedTick == Iris._cycleTick
                end,
            },
            ["clicked"] = widgets.EVENTS.click(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.Combo)
            local frameHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

            local Combo: Frame = Instance.new("Frame")
            Combo.Name = "Iris_Combo"
            Combo.Size = UDim2.fromScale(1, 0)
            Combo.AutomaticSize = Enum.AutomaticSize.Y
            Combo.BackgroundTransparency = 1
            Combo.BorderSizePixel = 0
            Combo.LayoutOrder = thisWidget.ZIndex

            local UIListLayout: UIListLayout = widgets.UIListLayout(Combo, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
            UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

            local PreviewContainer: TextButton = Instance.new("TextButton")
            PreviewContainer.Name = "PreviewContainer"
            PreviewContainer.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0))
            PreviewContainer.AutomaticSize = Enum.AutomaticSize.Y
            PreviewContainer.BackgroundTransparency = 1
            PreviewContainer.Text = ""
            PreviewContainer.ZIndex = thisWidget.ZIndex + 2
            PreviewContainer.AutoButtonColor = false

            widgets.applyFrameStyle(PreviewContainer, true)
            widgets.UIListLayout(PreviewContainer, Enum.FillDirection.Horizontal, UDim.new(0, 0))
            widgets.UISizeConstraint(PreviewContainer, Vector2.new(frameHeight + 1))

            PreviewContainer.Parent = Combo

            local PreviewLabel: TextLabel = Instance.new("TextLabel")
            PreviewLabel.Name = "PreviewLabel"
            PreviewLabel.Size = UDim2.new(UDim.new(1, 0), Iris._config.ContentHeight)
            PreviewLabel.AutomaticSize = Enum.AutomaticSize.Y
            PreviewLabel.BackgroundColor3 = Iris._config.FrameBgColor
            PreviewLabel.BackgroundTransparency = Iris._config.FrameBgTransparency
            PreviewLabel.BorderSizePixel = 0
            PreviewLabel.ClipsDescendants = true

            widgets.applyTextStyle(PreviewLabel)
            widgets.UIPadding(PreviewLabel, Iris._config.FramePadding)

            PreviewLabel.Parent = PreviewContainer

            local DropdownButton: TextLabel = Instance.new("TextLabel")
            DropdownButton.Name = "DropdownButton"
            DropdownButton.Size = UDim2.new(0, frameHeight, Iris._config.ContentHeight.Scale, math.max(Iris._config.ContentHeight.Offset, frameHeight))
            DropdownButton.BorderSizePixel = 0
            DropdownButton.BackgroundColor3 = Iris._config.ButtonColor
            DropdownButton.BackgroundTransparency = Iris._config.ButtonTransparency
            DropdownButton.Text = ""

            local padding: number = math.round(frameHeight * 0.2)
            local dropdownSize: number = frameHeight - 2 * padding

            local Dropdown: ImageLabel = Instance.new("ImageLabel")
            Dropdown.Name = "Dropdown"
            Dropdown.AnchorPoint = Vector2.new(0.5, 0.5)
            Dropdown.Size = UDim2.fromOffset(dropdownSize, dropdownSize)
            Dropdown.Position = UDim2.fromScale(0.5, 0.5)
            Dropdown.BackgroundTransparency = 1
            Dropdown.BorderSizePixel = 0
            Dropdown.ImageColor3 = Iris._config.TextColor
            Dropdown.ImageTransparency = Iris._config.TextTransparency

            Dropdown.Parent = DropdownButton

            DropdownButton.Parent = PreviewContainer

            -- for some reason ImGui Combo has no highlights for Active, only hovered.
            -- so this deviates from ImGui, but its a good UX change
            widgets.applyInteractionHighlightsWithMultiHighlightee("Background", PreviewContainer, {
                {
                    PreviewLabel,
                    {
                        Color = Iris._config.FrameBgColor,
                        Transparency = Iris._config.FrameBgTransparency,
                        HoveredColor = Iris._config.FrameBgHoveredColor,
                        HoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                        ActiveColor = Iris._config.FrameBgActiveColor,
                        ActiveTransparency = Iris._config.FrameBgActiveTransparency,
                    },
                },
                {
                    DropdownButton,
                    {
                        Color = Iris._config.ButtonColor,
                        Transparency = Iris._config.ButtonTransparency,
                        HoveredColor = Iris._config.ButtonHoveredColor,
                        HoveredTransparency = Iris._config.ButtonHoveredTransparency,
                        -- Use hovered for active
                        ActiveColor = Iris._config.ButtonHoveredColor,
                        ActiveTransparency = Iris._config.ButtonHoveredTransparency,
                    },
                },
            })

            widgets.applyButtonClick(PreviewContainer, function()
                if AnyOpenedCombo and OpenedCombo ~= thisWidget then
                    return
                end
                thisWidget.state.isOpened:set(not thisWidget.state.isOpened.value)
            end)

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            TextLabel.Size = UDim2.fromOffset(0, frameHeight)
            TextLabel.AutomaticSize = Enum.AutomaticSize.X
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0

            widgets.applyTextStyle(TextLabel)

            TextLabel.Parent = Combo

            local ChildContainer: ScrollingFrame = Instance.new("ScrollingFrame")
            ChildContainer.Name = "ComboContainer"
            ChildContainer.AutomaticSize = Enum.AutomaticSize.Y
            ChildContainer.BackgroundColor3 = Iris._config.PopupBgColor
            ChildContainer.BackgroundTransparency = Iris._config.PopupBgTransparency
            ChildContainer.BorderSizePixel = 0

            ChildContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
            ChildContainer.ScrollBarImageTransparency = Iris._config.ScrollbarGrabTransparency
            ChildContainer.ScrollBarImageColor3 = Iris._config.ScrollbarGrabColor
            ChildContainer.ScrollBarThickness = Iris._config.ScrollbarSize
            ChildContainer.CanvasSize = UDim2.fromScale(0, 0)
            ChildContainer.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar

            -- appear over everything else
            ChildContainer.ClipsDescendants = true

            -- Unfortunatley, ScrollingFrame does not work with UICorner
            -- if Iris._config.PopupRounding > 0 then
            --     widgets.UICorner(ChildContainer, Iris._config.PopupRounding)
            -- end

            widgets.UIStroke(ChildContainer, Iris._config.WindowBorderSize, Iris._config.BorderColor, Iris._config.BorderTransparency)
            widgets.UIPadding(ChildContainer, Vector2.new(2, Iris._config.WindowPadding.Y))
            widgets.UISizeConstraint(ChildContainer, Vector2.new(100))

            local ChildContainerUIListLayout: UIListLayout = widgets.UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
            ChildContainerUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top

            local RootPopupScreenGui = Iris._rootInstance and Iris._rootInstance:WaitForChild("PopupScreenGui") :: GuiObject
            ChildContainer.Parent = RootPopupScreenGui

            thisWidget.ChildContainer = ChildContainer
            return Combo
        end,
        Update = function(thisWidget: Types.Combo)
            local Iris_Combo = thisWidget.Instance :: Frame
            local PreviewContainer = Iris_Combo.PreviewContainer :: TextButton
            local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
            local DropdownButton: TextLabel = PreviewContainer.DropdownButton
            local TextLabel: TextLabel = Iris_Combo.TextLabel

            TextLabel.Text = thisWidget.arguments.Text or "Combo"

            if thisWidget.arguments.NoButton then
                DropdownButton.Visible = false
                PreviewLabel.Size = UDim2.new(UDim.new(1, 0), PreviewLabel.Size.Height)
            else
                DropdownButton.Visible = true
                local DropdownButtonSize = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y
                PreviewLabel.Size = UDim2.new(UDim.new(1, -DropdownButtonSize), PreviewLabel.Size.Height)
            end

            if thisWidget.arguments.NoPreview then
                PreviewLabel.Visible = false
                PreviewContainer.Size = UDim2.new(0, 0, 0, 0)
                PreviewContainer.AutomaticSize = Enum.AutomaticSize.XY
            else
                PreviewLabel.Visible = true
                PreviewContainer.Size = UDim2.new(Iris._config.ContentWidth, Iris._config.ContentHeight)
                PreviewContainer.AutomaticSize = Enum.AutomaticSize.Y
            end
        end,
        ChildAdded = function(thisWidget: Types.Combo, _thisChild: Types.Widget)
            UpdateChildContainerTransform(thisWidget)
            return thisWidget.ChildContainer
        end,
        GenerateState = function(thisWidget: Types.Combo)
            if thisWidget.state.index == nil then
                thisWidget.state.index = Iris._widgetState(thisWidget, "index", "No Selection")
            end
            thisWidget.state.index:onChange(function()
                if thisWidget.state.isOpened.value then
                    thisWidget.state.isOpened:set(false)
                end
            end)
            if thisWidget.state.isOpened == nil then
                thisWidget.state.isOpened = Iris._widgetState(thisWidget, "isOpened", false)
            end
        end,
        UpdateState = function(thisWidget: Types.Combo)
            local Combo = thisWidget.Instance :: Frame
            local ChildContainer = thisWidget.ChildContainer :: ScrollingFrame
            local PreviewContainer = Combo.PreviewContainer :: TextButton
            local PreviewLabel: TextLabel = PreviewContainer.PreviewLabel
            local DropdownButton = PreviewContainer.DropdownButton :: TextLabel
            local Dropdown: ImageLabel = DropdownButton.Dropdown

            if thisWidget.state.isOpened.value then
                AnyOpenedCombo = true
                OpenedCombo = thisWidget
                ComboOpenedTick = Iris._cycleTick
                thisWidget.lastOpenedTick = Iris._cycleTick + 1

                -- ImGui also does not do this, and the Arrow is always facing down
                Dropdown.Image = widgets.ICONS.RIGHT_POINTING_TRIANGLE
                ChildContainer.Visible = true

                UpdateChildContainerTransform(thisWidget)
            else
                if AnyOpenedCombo then
                    AnyOpenedCombo = false
                    OpenedCombo = nil
                    thisWidget.lastClosedTick = Iris._cycleTick + 1
                end
                Dropdown.Image = widgets.ICONS.DOWN_POINTING_TRIANGLE
                ChildContainer.Visible = false
            end

            local stateIndex: any = thisWidget.state.index.value
            PreviewLabel.Text = if typeof(stateIndex) == "EnumItem" then stateIndex.Name else tostring(stateIndex)
        end,
        Discard = function(thisWidget: Types.Combo)
            thisWidget.Instance:Destroy()
            widgets.discardState(thisWidget)
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Combo

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Format | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    --stylua: ignore
    Iris.WidgetConstructor("Separator", {
        hasState = false,
        hasChildren = false,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Separator)
            local Separator: Frame = Instance.new("Frame")
            Separator.Name = "Iris_Separator"
            Separator.BackgroundColor3 = Iris._config.SeparatorColor
            Separator.BackgroundTransparency = Iris._config.SeparatorTransparency
            Separator.BorderSizePixel = 0
            if thisWidget.parentWidget.type == "SameLine" then
                Separator.Size = UDim2.new(0, 1, 1, 0)
            else
                Separator.Size = UDim2.new(1, 0, 0, 1)
            end
            Separator.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Separator, Enum.FillDirection.Vertical, UDim.new(0, 0))
            -- this is to prevent a bug of AutomaticLayout edge case when its parent has automaticLayout enabled

            return Separator
        end,
        Update = function(_thisWidget: Types.Separator) end,
        Discard = function(thisWidget: Types.Separator)
            thisWidget.Instance:Destroy()
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("Indent", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
        },
        Events = {},
        Generate = function(thisWidget: Types.Indent)
            local Indent: Frame = Instance.new("Frame")
            Indent.Name = "Iris_Indent"
            Indent.BackgroundTransparency = 1
            Indent.BorderSizePixel = 0
            Indent.Size = UDim2.fromScale(1, 0)
            Indent.AutomaticSize = Enum.AutomaticSize.Y
            Indent.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(Indent, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))
            widgets.UIPadding(Indent, Vector2.zero)

            return Indent
        end,
        Update = function(thisWidget: Types.Indent)
            local Indent = thisWidget.Instance :: Frame

            local indentWidth: number
            if thisWidget.arguments.Width then
                indentWidth = thisWidget.arguments.Width
            else
                indentWidth = Iris._config.IndentSpacing
            end
            Indent.UIPadding.PaddingLeft = UDim.new(0, indentWidth)
        end,
        Discard = function(thisWidget: Types.Indent)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Indent, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("SameLine", {
        hasState = false,
        hasChildren = true,
        Args = {
            ["Width"] = 1,
            ["VerticalAlignment"] = 2,
            ["HorizontalAlignment"] = 3,
        },
        Events = {},
        Generate = function(thisWidget: Types.SameLine)
            local SameLine: Frame = Instance.new("Frame")
            SameLine.Name = "Iris_SameLine"
            SameLine.BackgroundTransparency = 1
            SameLine.BorderSizePixel = 0
            SameLine.Size = UDim2.fromScale(1, 0)
            SameLine.AutomaticSize = Enum.AutomaticSize.Y
            SameLine.LayoutOrder = thisWidget.ZIndex

            widgets.UIListLayout(SameLine, Enum.FillDirection.Horizontal, UDim.new(0, 0))

            return SameLine
        end,
        Update = function(thisWidget: Types.SameLine)
            local Sameline = thisWidget.Instance :: Frame
            local uiListLayout: UIListLayout = Sameline.UIListLayout
            local itemWidth: number
            if thisWidget.arguments.Width then
                itemWidth = thisWidget.arguments.Width
            else
                itemWidth = Iris._config.ItemSpacing.X
            end
            uiListLayout.Padding = UDim.new(0, itemWidth)
            if thisWidget.arguments.VerticalAlignment then
                uiListLayout.VerticalAlignment = thisWidget.arguments.VerticalAlignment
            else
                uiListLayout.VerticalAlignment = Enum.VerticalAlignment.Top
            end
            if thisWidget.arguments.HorizontalAlignment then
                uiListLayout.HorizontalAlignment = thisWidget.arguments.HorizontalAlignment
            else
                uiListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            end
        end,
        Discard = function(thisWidget: Types.SameLine)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.SameLine, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)

    --stylua: ignore
    Iris.WidgetConstructor("Group", {
        hasState = false,
        hasChildren = true,
        Args = {},
        Events = {},
        Generate = function(thisWidget: Types.Group)
            local Group: Frame = Instance.new("Frame")
            Group.Name = "Iris_Group"
            Group.AutomaticSize = Enum.AutomaticSize.XY
            Group.Size = UDim2.fromOffset(0, 0)
            Group.BackgroundTransparency = 1
            Group.BorderSizePixel = 0
            Group.LayoutOrder = thisWidget.ZIndex
            Group.ClipsDescendants = false

            widgets.UIListLayout(Group, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.X))

            return Group
        end,
        Update = function(_thisWidget: Types.Group) end,
        Discard = function(thisWidget: Types.Group)
            thisWidget.Instance:Destroy()
        end,
        ChildAdded = function(thisWidget: Types.Group, _thisChild: Types.Widget)
            return thisWidget.Instance
        end,
    } :: Types.WidgetClass)
end

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Format

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.Librarys.Iris.widgets.Input | Enabled: N/A
--------------------------------------------------------------------
local Types = require(script.Parent.Parent.Types)

type InputDataTypes = "Num" | "Vector2" | "Vector3" | "UDim" | "UDim2" | "Color3" | "Color4" | "Rect" | "Enum" | "" | string

return function(Iris: Types.Internal, widgets: Types.WidgetUtility)
    local numberChanged = {
        ["Init"] = function(_thisWidget: Types.Widget) end,
        ["Get"] = function(thisWidget: Types.Input<any>)
            return thisWidget.lastNumberChangedTick == Iris._cycleTick
        end,
    }

    local function getValueByIndex<T>(value: T, index: number, arguments: any): number
        local t: string = typeof(value)
        local v = value :: any
        if t == "number" then
            return v
        elseif t == "Vector2" then
            if index == 1 then
                return v.X
            elseif index == 2 then
                return v.Y
            end
        elseif t == "Vector3" then
            if index == 1 then
                return v.X
            elseif index == 2 then
                return v.Y
            elseif index == 3 then
                return v.Z
            end
        elseif t == "UDim" then
            if index == 1 then
                return v.Scale
            elseif index == 2 then
                return v.Offset
            end
        elseif t == "UDim2" then
            if index == 1 then
                return v.X.Scale
            elseif index == 2 then
                return v.X.Offset
            elseif index == 3 then
                return v.Y.Scale
            elseif index == 4 then
                return v.Y.Offset
            end
        elseif t == "Color3" then
            local color: { number } = arguments.UseHSV and { v:ToHSV() } or { v.R, v.G, v.B }
            if index == 1 then
                return color[1]
            elseif index == 2 then
                return color[2]
            elseif index == 3 then
                return color[3]
            end
        elseif t == "Rect" then
            if index == 1 then
                return v.Min.X
            elseif index == 2 then
                return v.Min.Y
            elseif index == 3 then
                return v.Max.X
            elseif index == 4 then
                return v.Max.Y
            end
        elseif t == "table" then
            return v[index]
        end

        error(`Incorrect datatype or value: {value} {typeof(value)} {index}`)
    end

    local function updateValueByIndex<T>(value: T, index: number, newValue: number, arguments: Types.Arguments): T
        if typeof(value) == "number" then
            return newValue :: any
        elseif typeof(value) == "Vector2" then
            if index == 1 then
                return Vector2.new(newValue, value.Y) :: any
            elseif index == 2 then
                return Vector2.new(value.X, newValue) :: any
            end
        elseif typeof(value) == "Vector3" then
            if index == 1 then
                return Vector3.new(newValue, value.Y, value.Z) :: any
            elseif index == 2 then
                return Vector3.new(value.X, newValue, value.Z) :: any
            elseif index == 3 then
                return Vector3.new(value.X, value.Y, newValue) :: any
            end
        elseif typeof(value) == "UDim" then
            if index == 1 then
                return UDim.new(newValue, value.Offset) :: any
            elseif index == 2 then
                return UDim.new(value.Scale, newValue) :: any
            end
        elseif typeof(value) == "UDim2" then
            if index == 1 then
                return UDim2.new(UDim.new(newValue, value.X.Offset), value.Y) :: any
            elseif index == 2 then
                return UDim2.new(UDim.new(value.X.Scale, newValue), value.Y) :: any
            elseif index == 3 then
                return UDim2.new(value.X, UDim.new(newValue, value.Y.Offset)) :: any
            elseif index == 4 then
                return UDim2.new(value.X, UDim.new(value.Y.Scale, newValue)) :: any
            end
        elseif typeof(value) == "Rect" then
            if index == 1 then
                return Rect.new(Vector2.new(newValue, value.Min.Y), value.Max) :: any
            elseif index == 2 then
                return Rect.new(Vector2.new(value.Min.X, newValue), value.Max) :: any
            elseif index == 3 then
                return Rect.new(value.Min, Vector2.new(newValue, value.Max.Y)) :: any
            elseif index == 4 then
                return Rect.new(value.Min, Vector2.new(value.Max.X, newValue)) :: any
            end
        elseif typeof(value) == "Color3" then
            if arguments.UseHSV then
                local h: number, s: number, v: number = value:ToHSV()
                if index == 1 then
                    return Color3.fromHSV(newValue, s, v) :: any
                elseif index == 2 then
                    return Color3.fromHSV(h, newValue, v) :: any
                elseif index == 3 then
                    return Color3.fromHSV(h, s, newValue) :: any
                end
            end
            if index == 1 then
                return Color3.new(newValue, value.G, value.B) :: any
            elseif index == 2 then
                return Color3.new(value.R, newValue, value.B) :: any
            elseif index == 3 then
                return Color3.new(value.R, value.G, newValue) :: any
            end
        end

        error(`Incorrect datatype or value {value} {typeof(value)} {index}`)
    end

    local defaultIncrements: { [InputDataTypes]: { number } } = {
        Num = { 1 },
        Vector2 = { 1, 1 },
        Vector3 = { 1, 1, 1 },
        UDim = { 0.01, 1 },
        UDim2 = { 0.01, 1, 0.01, 1 },
        Color3 = { 1, 1, 1 },
        Color4 = { 1, 1, 1, 1 },
        Rect = { 1, 1, 1, 1 },
    }

    local defaultMin: { [InputDataTypes]: { number } } = {
        Num = { 0 },
        Vector2 = { 0, 0 },
        Vector3 = { 0, 0, 0 },
        UDim = { 0, 0 },
        UDim2 = { 0, 0, 0, 0 },
        Rect = { 0, 0, 0, 0 },
    }

    local defaultMax: { [InputDataTypes]: { number } } = {
        Num = { 100 },
        Vector2 = { 100, 100 },
        Vector3 = { 100, 100, 100 },
        UDim = { 1, 960 },
        UDim2 = { 1, 960, 1, 960 },
        Rect = { 960, 960, 960, 960 },
    }

    local defaultPrefx: { [InputDataTypes]: { string } } = {
        Num = { "" },
        Vector2 = { "X: ", "Y: " },
        Vector3 = { "X: ", "Y: ", "Z: " },
        UDim = { "", "" },
        UDim2 = { "", "", "", "" },
        Color3_RGB = { "R: ", "G: ", "B: " },
        Color3_HSV = { "H: ", "S: ", "V: " },
        Color4_RGB = { "R: ", "G: ", "B: ", "T: " },
        Color4_HSV = { "H: ", "S: ", "V: ", "T: " },
        Rect = { "X: ", "Y: ", "X: ", "Y: " },
    }

    local defaultSigFigs: { [InputDataTypes]: { number } } = {
        Num = { 0 },
        Vector2 = { 0, 0 },
        Vector3 = { 0, 0, 0 },
        UDim = { 3, 0 },
        UDim2 = { 3, 0, 3, 0 },
        Color3 = { 0, 0, 0 },
        Color4 = { 0, 0, 0, 0 },
        Rect = { 0, 0, 0, 0 },
    }

    --[[
        Input
    ]]
    local generateInputScalar: <T>(dataType: InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
    do
        local function generateButtons(thisWidget: Types.Input<number>, parent: GuiObject, rightPadding: number, textHeight: number)
            rightPadding += 2 * Iris._config.ItemInnerSpacing.X + 2 * textHeight

            local SubButton = widgets.abstractButton.Generate(thisWidget) :: TextButton
            SubButton.Name = "SubButton"
            SubButton.ZIndex = 5
            SubButton.LayoutOrder = 5
            SubButton.TextXAlignment = Enum.TextXAlignment.Center
            SubButton.Text = "-"
            SubButton.Size = UDim2.fromOffset(Iris._config.TextSize + 2 * Iris._config.FramePadding.Y, Iris._config.TextSize)
            SubButton.Parent = parent

            widgets.applyButtonClick(SubButton, function()
                local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
                local changeValue: number = (thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, 1, thisWidget.arguments :: Types.Argument) or 1) * (isCtrlHeld and 100 or 1)
                local newValue: number = thisWidget.state.number.value - changeValue
                if thisWidget.arguments.Min ~= nil then
                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, 1, thisWidget.arguments :: Types.Argument))
                end
                if thisWidget.arguments.Max ~= nil then
                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, 1, thisWidget.arguments :: Types.Argument))
                end
                thisWidget.state.number:set(newValue)
                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
            end)

            local AddButton = widgets.abstractButton.Generate(thisWidget) :: TextButton
            AddButton.Name = "AddButton"
            AddButton.ZIndex = 6
            AddButton.LayoutOrder = 6
            AddButton.TextXAlignment = Enum.TextXAlignment.Center
            AddButton.Text = "+"
            AddButton.Size = UDim2.fromOffset(Iris._config.TextSize + 2 * Iris._config.FramePadding.Y, Iris._config.TextSize)
            AddButton.Parent = parent

            widgets.applyButtonClick(AddButton, function()
                local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
                local changeValue: number = (thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, 1, thisWidget.arguments :: Types.Argument) or 1) * (isCtrlHeld and 100 or 1)
                local newValue: number = thisWidget.state.number.value + changeValue
                if thisWidget.arguments.Min ~= nil then
                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, 1, thisWidget.arguments :: Types.Argument))
                end
                if thisWidget.arguments.Max ~= nil then
                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, 1, thisWidget.arguments :: Types.Argument))
                end
                thisWidget.state.number:set(newValue)
                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
            end)

            return rightPadding
        end

        function generateInputScalar<T>(dataType: InputDataTypes, components: number, defaultValue: any)
            return {
                hasState = true,
                hasChildren = false,
                Args = {
                    ["Text"] = 1,
                    ["Increment"] = 2,
                    ["Min"] = 3,
                    ["Max"] = 4,
                    ["Format"] = 5,
                },
                Events = {
                    ["numberChanged"] = numberChanged,
                    ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                        return thisWidget.Instance
                    end),
                },
                Generate = function(thisWidget: Types.Input<T>)
                    local Input: Frame = Instance.new("Frame")
                    Input.Name = "Iris_Input" .. dataType
                    Input.Size = UDim2.fromScale(1, 0)
                    Input.BackgroundTransparency = 1
                    Input.BorderSizePixel = 0
                    Input.LayoutOrder = thisWidget.ZIndex
                    Input.AutomaticSize = Enum.AutomaticSize.Y
                    local UIListLayout: UIListLayout = widgets.UIListLayout(Input, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
                    UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                    -- we add plus and minus buttons if there is only one box. This can be disabled through the argument.
                    local rightPadding: number = 0
                    local textHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

                    if components == 1 then
                        rightPadding = generateButtons(thisWidget :: any, Input, rightPadding, textHeight)
                    end

                    -- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
                    -- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
                    -- 4 pixels shorter, all for the sake of flush.
                    local componentWidth: UDim = UDim.new(Iris._config.ContentWidth.Scale / components, (Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1)) - rightPadding) / components)
                    local totalWidth: UDim = UDim.new(componentWidth.Scale * (components - 1), (componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)) + rightPadding)
                    local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

                    -- we handle each component individually since they don't need to interact with each other.
                    for index = 1, components do
                        local InputField: TextBox = Instance.new("TextBox")
                        InputField.Name = "InputField" .. tostring(index)
                        InputField.LayoutOrder = index
                        if index == components then
                            InputField.Size = UDim2.new(lastComponentWidth, Iris._config.ContentHeight)
                        else
                            InputField.Size = UDim2.new(componentWidth, Iris._config.ContentHeight)
                        end
                        InputField.AutomaticSize = Enum.AutomaticSize.Y
                        InputField.BackgroundColor3 = Iris._config.FrameBgColor
                        InputField.BackgroundTransparency = Iris._config.FrameBgTransparency
                        InputField.ClearTextOnFocus = false
                        InputField.TextTruncate = Enum.TextTruncate.AtEnd
                        InputField.ClipsDescendants = true

                        widgets.applyFrameStyle(InputField)
                        widgets.applyTextStyle(InputField)
                        widgets.UISizeConstraint(InputField, Vector2.xAxis)

                        InputField.Parent = Input

                        InputField.FocusLost:Connect(function()
                            local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
                            if newValue ~= nil then
                                if thisWidget.arguments.Min ~= nil then
                                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
                                end
                                if thisWidget.arguments.Max ~= nil then
                                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments :: any))
                                end

                                if thisWidget.arguments.Increment then
                                    newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)) * getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                end

                                thisWidget.state.number:set(updateValueByIndex(thisWidget.state.number.value, index, newValue, thisWidget.arguments :: any))
                                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
                            end
                            local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                            if thisWidget.arguments.Prefix then
                                format = thisWidget.arguments.Prefix[index] .. format
                            end
                            InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))

                            thisWidget.state.editingText:set(0)
                        end)

                        InputField.Focused:Connect(function()
                            -- this highlights the entire field
                            InputField.CursorPosition = #InputField.Text + 1
                            InputField.SelectionStart = 1

                            thisWidget.state.editingText:set(index)
                        end)
                    end

                    local TextLabel: TextLabel = Instance.new("TextLabel")
                    TextLabel.Name = "TextLabel"
                    TextLabel.BackgroundTransparency = 1
                    TextLabel.BorderSizePixel = 0
                    TextLabel.LayoutOrder = 7
                    TextLabel.AutomaticSize = Enum.AutomaticSize.XY

                    widgets.applyTextStyle(TextLabel)

                    TextLabel.Parent = Input

                    return Input
                end,
                Update = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Input {dataType}`

                    if components == 1 then
                        Input.SubButton.Visible = not thisWidget.arguments.NoButtons
                        Input.AddButton.Visible = not thisWidget.arguments.NoButtons
                    end

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        -- we calculate the format for the s.f. using the max, min and increment arguments.
                        local format: { string } = {}
                        for index = 1, components do
                            local sigfigs: number = defaultSigFigs[dataType][index]

                            if thisWidget.arguments.Increment then
                                local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Max then
                                local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Min then
                                local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if sigfigs > 0 then
                                -- we know it's a float.
                                format[index] = `%.{sigfigs}f`
                            else
                                format[index] = "%d"
                            end
                        end

                        thisWidget.arguments.Format = format
                        thisWidget.arguments.Prefix = defaultPrefx[dataType]
                    end
                end,
                Discard = function(thisWidget: Types.Input<T>)
                    thisWidget.Instance:Destroy()
                    widgets.discardState(thisWidget)
                end,
                GenerateState = function(thisWidget: Types.Input<T>)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", 0)
                    end
                end,
                UpdateState = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject

                    for index = 1, components do
                        local InputField: TextBox = Input:FindFirstChild("InputField" .. tostring(index))
                        local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                        if thisWidget.arguments.Prefix then
                            format = thisWidget.arguments.Prefix[index] .. format
                        end
                        InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))
                    end
                end,
            }
        end
    end

    --[[
        Drag
    ]]
    local generateDragScalar: <T>(dataType: InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
    local generateColorDragScalar: (dataType: InputDataTypes, ...any) -> Types.WidgetClass
    do
        local PreviouseMouseXPosition: number = 0
        local AnyActiveDrag: boolean = false
        local ActiveDrag: Types.Input<Types.InputDataType>? = nil
        local ActiveIndex: number = 0
        local ActiveDataType: InputDataTypes | "" = ""

        local function updateActiveDrag()
            local currentMouseX: number = widgets.getMouseLocation().X
            local mouseXDelta: number = currentMouseX - PreviouseMouseXPosition
            PreviouseMouseXPosition = currentMouseX
            if AnyActiveDrag == false then
                return
            end
            if ActiveDrag == nil then
                return
            end

            local state: Types.State<Types.InputDataType> = ActiveDrag.state.number
            if ActiveDataType == "Color3" or ActiveDataType == "Color4" then
                local Drag = ActiveDrag :: any
                state = Drag.state.color
                if ActiveIndex == 4 then
                    state = Drag.state.transparency
                end
            end

            local increment: number = ActiveDrag.arguments.Increment and getValueByIndex(ActiveDrag.arguments.Increment, ActiveIndex, ActiveDrag.arguments) or defaultIncrements[ActiveDataType][ActiveIndex]
            increment *= (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightShift)) and 10 or 1
            increment *= (widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightAlt)) and 0.1 or 1
            -- we increase the speed for Color3 and Color4 since it's too slow because the increment argument needs to be low.
            increment *= (ActiveDataType == "Color3" or ActiveDataType == "Color4") and 5 or 1

            local value: number = getValueByIndex(state.value, ActiveIndex, ActiveDrag.arguments)
            local newValue: number = value + (mouseXDelta * increment)

            if ActiveDrag.arguments.Min ~= nil then
                newValue = math.max(newValue, getValueByIndex(ActiveDrag.arguments.Min, ActiveIndex, ActiveDrag.arguments))
            end
            if ActiveDrag.arguments.Max ~= nil then
                newValue = math.min(newValue, getValueByIndex(ActiveDrag.arguments.Max, ActiveIndex, ActiveDrag.arguments))
            end

            state:set(updateValueByIndex(state.value, ActiveIndex, newValue, ActiveDrag.arguments :: any))
            ActiveDrag.lastNumberChangedTick = Iris._cycleTick + 1
        end

        local function DragMouseDown(thisWidget: Types.Input<Types.InputDataType>, dataTypes: InputDataTypes, index: number, x: number, y: number)
            local currentTime: number = widgets.getTime()
            local isTimeValid: boolean = currentTime - thisWidget.lastClickedTime < Iris._config.MouseDoubleClickTime
            local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
            if (isTimeValid and (Vector2.new(x, y) - thisWidget.lastClickedPosition).Magnitude < Iris._config.MouseDoubleClickMaxDist) or isCtrlHeld then
                thisWidget.state.editingText:set(index)
            else
                thisWidget.lastClickedTime = currentTime
                thisWidget.lastClickedPosition = Vector2.new(x, y)

                AnyActiveDrag = true
                ActiveDrag = thisWidget
                ActiveIndex = index
                ActiveDataType = dataTypes
                updateActiveDrag()
            end
        end

        widgets.registerEvent("InputChanged", function()
            if not Iris._started then
                return
            end
            updateActiveDrag()
        end)

        widgets.registerEvent("InputEnded", function(inputObject: InputObject)
            if not Iris._started then
                return
            end
            if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and AnyActiveDrag then
                AnyActiveDrag = false
                ActiveDrag = nil
                ActiveIndex = 0
            end
        end)

        function generateDragScalar<T>(dataType: InputDataTypes, components: number, defaultValue: any)
            return {
                hasState = true,
                hasChildren = false,
                Args = {
                    ["Text"] = 1,
                    ["Increment"] = 2,
                    ["Min"] = 3,
                    ["Max"] = 4,
                    ["Format"] = 5,
                },
                Events = {
                    ["numberChanged"] = numberChanged,
                    ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                        return thisWidget.Instance
                    end),
                },
                Generate = function(thisWidget: Types.Input<T>)
                    thisWidget.lastClickedTime = -1
                    thisWidget.lastClickedPosition = Vector2.zero

                    local Drag: Frame = Instance.new("Frame")
                    Drag.Name = "Iris_Drag" .. dataType
                    Drag.Size = UDim2.fromScale(1, 0)
                    Drag.BackgroundTransparency = 1
                    Drag.BorderSizePixel = 0
                    Drag.LayoutOrder = thisWidget.ZIndex
                    Drag.AutomaticSize = Enum.AutomaticSize.Y
                    local UIListLayout: UIListLayout = widgets.UIListLayout(Drag, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
                    UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                    -- we add a color box if it is Color3 or Color4.
                    local rightPadding: number = 0
                    local textHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

                    if dataType == "Color3" or dataType == "Color4" then
                        rightPadding += Iris._config.ItemInnerSpacing.X + textHeight

                        local ColorBox: ImageLabel = Instance.new("ImageLabel")
                        ColorBox.Name = "ColorBox"
                        ColorBox.BorderSizePixel = 0
                        ColorBox.Size = UDim2.fromOffset(textHeight, textHeight)
                        ColorBox.LayoutOrder = 5
                        ColorBox.Image = widgets.ICONS.ALPHA_BACKGROUND_TEXTURE
                        ColorBox.ImageTransparency = 1

                        widgets.applyFrameStyle(ColorBox, true)

                        ColorBox.Parent = Drag
                    end

                    -- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
                    -- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
                    -- 4 pixels shorter, all for the sake of flush.
                    local componentWidth: UDim = UDim.new(Iris._config.ContentWidth.Scale / components, (Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1)) - rightPadding) / components)
                    local totalWidth: UDim = UDim.new(componentWidth.Scale * (components - 1), (componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)) + rightPadding)
                    local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

                    for index = 1, components do
                        local DragField: TextButton = Instance.new("TextButton")
                        DragField.Name = "DragField" .. tostring(index)
                        DragField.LayoutOrder = index
                        if index == components then
                            DragField.Size = UDim2.new(lastComponentWidth, Iris._config.ContentHeight)
                        else
                            DragField.Size = UDim2.new(componentWidth, Iris._config.ContentHeight)
                        end
                        DragField.AutomaticSize = Enum.AutomaticSize.Y
                        DragField.BackgroundColor3 = Iris._config.FrameBgColor
                        DragField.BackgroundTransparency = Iris._config.FrameBgTransparency
                        DragField.AutoButtonColor = false
                        DragField.Text = ""
                        DragField.ClipsDescendants = true

                        widgets.applyFrameStyle(DragField)
                        widgets.applyTextStyle(DragField)
                        widgets.UISizeConstraint(DragField, Vector2.xAxis)

                        DragField.TextXAlignment = Enum.TextXAlignment.Center

                        DragField.Parent = Drag

                        widgets.applyInteractionHighlights("Background", DragField, DragField, {
                            Color = Iris._config.FrameBgColor,
                            Transparency = Iris._config.FrameBgTransparency,
                            HoveredColor = Iris._config.FrameBgHoveredColor,
                            HoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                            ActiveColor = Iris._config.FrameBgActiveColor,
                            ActiveTransparency = Iris._config.FrameBgActiveTransparency,
                        })

                        local InputField: TextBox = Instance.new("TextBox")
                        InputField.Name = "InputField"
                        InputField.Size = UDim2.new(1, 0, 1, 0)
                        InputField.BackgroundTransparency = 1
                        InputField.ClearTextOnFocus = false
                        InputField.TextTruncate = Enum.TextTruncate.AtEnd
                        InputField.ClipsDescendants = true
                        InputField.Visible = false

                        widgets.applyFrameStyle(InputField, true)
                        widgets.applyTextStyle(InputField)

                        InputField.Parent = DragField

                        InputField.FocusLost:Connect(function()
                            local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
                            local state: Types.State<T> = thisWidget.state.number
                            local widget = thisWidget :: any
                            if dataType == "Color4" and index == 4 then
                                state = widget.state.transparency
                            elseif dataType == "Color3" or dataType == "Color4" then
                                state = widget.state.color
                            end
                            if newValue ~= nil then
                                if dataType == "Color3" or dataType == "Color4" and not widget.arguments.UseFloats then
                                    newValue = newValue / 255
                                end
                                if thisWidget.arguments.Min ~= nil then
                                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
                                end
                                if thisWidget.arguments.Max ~= nil then
                                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments))
                                end

                                if thisWidget.arguments.Increment then
                                    newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)) * getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                end

                                state:set(updateValueByIndex(state.value, index, newValue, thisWidget.arguments :: any))
                                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
                            end

                            local value: number = getValueByIndex(state.value, index, thisWidget.arguments)
                            if dataType == "Color3" or dataType == "Color4" and not widget.arguments.UseFloats then
                                value = math.round(value * 255)
                            end

                            local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                            if thisWidget.arguments.Prefix then
                                format = thisWidget.arguments.Prefix[index] .. format
                            end
                            InputField.Text = string.format(format, value)

                            thisWidget.state.editingText:set(0)
                            InputField:ReleaseFocus(true)
                        end)

                        InputField.Focused:Connect(function()
                            -- this highlights the entire field
                            InputField.CursorPosition = #InputField.Text + 1
                            InputField.SelectionStart = 1

                            thisWidget.state.editingText:set(index)
                        end)

                        widgets.applyButtonDown(DragField, function(x: number, y: number)
                            DragMouseDown(thisWidget :: any, dataType, index, x, y)
                        end)
                    end

                    local TextLabel: TextLabel = Instance.new("TextLabel")
                    TextLabel.Name = "TextLabel"
                    TextLabel.BackgroundTransparency = 1
                    TextLabel.BorderSizePixel = 0
                    TextLabel.LayoutOrder = 6
                    TextLabel.AutomaticSize = Enum.AutomaticSize.XY

                    widgets.applyTextStyle(TextLabel)

                    TextLabel.Parent = Drag

                    return Drag
                end,
                Update = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Drag {dataType}`

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        -- we calculate the format for the s.f. using the max, min and increment arguments.
                        local format: { string } = {}
                        for index = 1, components do
                            local sigfigs: number = defaultSigFigs[dataType][index]

                            if thisWidget.arguments.Increment then
                                local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Max then
                                local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Min then
                                local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if sigfigs > 0 then
                                -- we know it's a float.
                                format[index] = `%.{sigfigs}f`
                            else
                                format[index] = "%d"
                            end
                        end

                        thisWidget.arguments.Format = format
                        thisWidget.arguments.Prefix = defaultPrefx[dataType]
                    end
                end,
                Discard = function(thisWidget: Types.Input<T>)
                    thisWidget.Instance:Destroy()
                    widgets.discardState(thisWidget)
                end,
                GenerateState = function(thisWidget: Types.Input<T>)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
                UpdateState = function(thisWidget: Types.Input<T>)
                    local Drag = thisWidget.Instance :: Frame

                    local widget = thisWidget :: any
                    for index = 1, components do
                        local state: Types.State<T> = thisWidget.state.number
                        if dataType == "Color3" or dataType == "Color4" then
                            state = widget.state.color
                            if index == 4 then
                                state = widget.state.transparency
                            end
                        end
                        local DragField = Drag:FindFirstChild("DragField" .. tostring(index)) :: TextButton
                        local InputField: TextBox = DragField.InputField
                        local value: number = getValueByIndex(state.value, index, thisWidget.arguments)
                        if (dataType == "Color3" or dataType == "Color4") and not widget.arguments.UseFloats then
                            value = math.round(value * 255)
                        end

                        local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                        if thisWidget.arguments.Prefix then
                            format = thisWidget.arguments.Prefix[index] .. format
                        end
                        DragField.Text = string.format(format, value)
                        InputField.Text = tostring(value)

                        if thisWidget.state.editingText.value == index then
                            InputField.Visible = true
                            InputField:CaptureFocus()
                            DragField.TextTransparency = 1
                        else
                            InputField.Visible = false
                            DragField.TextTransparency = Iris._config.TextTransparency
                        end
                    end

                    if dataType == "Color3" or dataType == "Color4" then
                        local ColorBox: ImageLabel = Drag.ColorBox

                        ColorBox.BackgroundColor3 = widget.state.color.value

                        if dataType == "Color4" then
                            ColorBox.ImageTransparency = 1 - widget.state.transparency.value
                        end
                    end
                end,
            }
        end

        function generateColorDragScalar(dataType: InputDataTypes, ...: any)
            local defaultValues: { any } = { ... }
            local input: Types.WidgetClass = generateDragScalar(dataType, dataType == "Color4" and 4 or 3, defaultValues[1])

            return widgets.extend(input, {
                Args = {
                    ["Text"] = 1,
                    ["UseFloats"] = 2,
                    ["UseHSV"] = 3,
                    ["Format"] = 4,
                },
                Update = function(thisWidget: Types.InputColor4)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Drag {dataType}`

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        if thisWidget.arguments.UseFloats then
                            thisWidget.arguments.Format = { "%.3f" }
                        else
                            thisWidget.arguments.Format = { "%d" }
                        end

                        thisWidget.arguments.Prefix = defaultPrefx[dataType .. if thisWidget.arguments.UseHSV then "_HSV" else "_RGB"]
                    end

                    thisWidget.arguments.Min = { 0, 0, 0, 0 }
                    thisWidget.arguments.Max = { 1, 1, 1, 1 }
                    thisWidget.arguments.Increment = { 0.001, 0.001, 0.001, 0.001 }

                    -- since the state values have changed display, we call an update. The check is because state is not
                    -- initialised on creation, so it would error otherwise.
                    if thisWidget.state then
                        Iris._widgets[thisWidget.type].UpdateState(thisWidget)
                    end
                end,
                GenerateState = function(thisWidget: Types.InputColor4)
                    if thisWidget.state.color == nil then
                        thisWidget.state.color = Iris._widgetState(thisWidget, "color", defaultValues[1])
                    end
                    if dataType == "Color4" then
                        if thisWidget.state.transparency == nil then
                            thisWidget.state.transparency = Iris._widgetState(thisWidget, "transparency", defaultValues[2])
                        end
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
            })
        end
    end

    --[[
        Slider
    ]]
    local generateSliderScalar: <T>(dataType: InputDataTypes, components: number, defaultValue: any) -> Types.WidgetClass
    local generateEnumSliderScalar: (enum: Enum, item: EnumItem) -> Types.WidgetClass
    do
        local AnyActiveSlider: boolean = false
        local ActiveSlider: Types.Input<Types.InputDataType>? = nil
        local ActiveIndex: number = 0
        local ActiveDataType: InputDataTypes | "" = ""

        local function updateActiveSlider()
            if AnyActiveSlider == false then
                return
            end
            if ActiveSlider == nil then
                return
            end

            local Slider = ActiveSlider.Instance :: Frame
            local SliderField = Slider:FindFirstChild("SliderField" .. tostring(ActiveIndex)) :: TextButton
            local GrabBar: Frame = SliderField.GrabBar

            local increment: number = ActiveSlider.arguments.Increment and getValueByIndex(ActiveSlider.arguments.Increment, ActiveIndex, ActiveSlider.arguments) or defaultIncrements[ActiveDataType][ActiveIndex]
            local min: number = ActiveSlider.arguments.Min and getValueByIndex(ActiveSlider.arguments.Min, ActiveIndex, ActiveSlider.arguments) or defaultMin[ActiveDataType][ActiveIndex]
            local max: number = ActiveSlider.arguments.Max and getValueByIndex(ActiveSlider.arguments.Max, ActiveIndex, ActiveSlider.arguments) or defaultMax[ActiveDataType][ActiveIndex]

            local GrabWidth: number = GrabBar.AbsoluteSize.X
            local Offset: number = widgets.getMouseLocation().X - (SliderField.AbsolutePosition.X - widgets.GuiOffset.X + GrabWidth / 2)
            local Ratio: number = Offset / (SliderField.AbsoluteSize.X - GrabWidth)
            local Positions: number = math.floor((max - min) / increment)
            local newValue: number = math.clamp(math.round(Ratio * Positions) * increment + min, min, max)

            ActiveSlider.state.number:set(updateValueByIndex(ActiveSlider.state.number.value, ActiveIndex, newValue, ActiveSlider.arguments :: any))
            ActiveSlider.lastNumberChangedTick = Iris._cycleTick + 1
        end

        local function SliderMouseDown(thisWidget: Types.Input<Types.InputDataType>, dataType: InputDataTypes, index: number)
            local isCtrlHeld: boolean = widgets.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or widgets.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
            if isCtrlHeld then
                thisWidget.state.editingText:set(index)
            else
                AnyActiveSlider = true
                ActiveSlider = thisWidget
                ActiveIndex = index
                ActiveDataType = dataType
                updateActiveSlider()
            end
        end

        widgets.registerEvent("InputChanged", function()
            if not Iris._started then
                return
            end
            updateActiveSlider()
        end)

        widgets.registerEvent("InputEnded", function(inputObject: InputObject)
            if not Iris._started then
                return
            end
            if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and AnyActiveSlider then
                AnyActiveSlider = false
                ActiveSlider = nil
                ActiveIndex = 0
                ActiveDataType = ""
            end
        end)

        function generateSliderScalar<T>(dataType: InputDataTypes, components: number, defaultValue: any)
            return {
                hasState = true,
                hasChildren = false,
                Args = {
                    ["Text"] = 1,
                    ["Increment"] = 2,
                    ["Min"] = 3,
                    ["Max"] = 4,
                    ["Format"] = 5,
                },
                Events = {
                    ["numberChanged"] = numberChanged,
                    ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                        return thisWidget.Instance
                    end),
                },
                Generate = function(thisWidget: Types.Input<T>)
                    local Slider: Frame = Instance.new("Frame")
                    Slider.Name = "Iris_Slider" .. dataType
                    Slider.Size = UDim2.fromScale(1, 0)
                    Slider.BackgroundTransparency = 1
                    Slider.BorderSizePixel = 0
                    Slider.LayoutOrder = thisWidget.ZIndex
                    Slider.AutomaticSize = Enum.AutomaticSize.Y
                    local UIListLayout: UIListLayout = widgets.UIListLayout(Slider, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
                    UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

                    -- we divide the total area evenly between each field. This includes accounting for any additional boxes and the offset.
                    -- for the final field, we make sure it's flush by calculating the space avaiable for it. This only makes the Vector2 box
                    -- 4 pixels shorter, all for the sake of flush.
                    local componentWidth: UDim = UDim.new(Iris._config.ContentWidth.Scale / components, (Iris._config.ContentWidth.Offset - (Iris._config.ItemInnerSpacing.X * (components - 1))) / components)
                    local totalWidth: UDim = UDim.new(componentWidth.Scale * (components - 1), (componentWidth.Offset * (components - 1)) + (Iris._config.ItemInnerSpacing.X * (components - 1)))
                    local lastComponentWidth: UDim = Iris._config.ContentWidth - totalWidth

                    for index = 1, components do
                        local SliderField: TextButton = Instance.new("TextButton")
                        SliderField.Name = "SliderField" .. tostring(index)
                        SliderField.LayoutOrder = index
                        if index == components then
                            SliderField.Size = UDim2.new(lastComponentWidth, Iris._config.ContentHeight)
                        else
                            SliderField.Size = UDim2.new(componentWidth, Iris._config.ContentHeight)
                        end
                        SliderField.AutomaticSize = Enum.AutomaticSize.Y
                        SliderField.BackgroundColor3 = Iris._config.FrameBgColor
                        SliderField.BackgroundTransparency = Iris._config.FrameBgTransparency
                        SliderField.AutoButtonColor = false
                        SliderField.Text = ""
                        SliderField.ClipsDescendants = true

                        widgets.applyFrameStyle(SliderField)
                        widgets.applyTextStyle(SliderField)
                        widgets.UISizeConstraint(SliderField, Vector2.xAxis)

                        SliderField.Parent = Slider

                        local OverlayText = Instance.new("TextLabel")
                        OverlayText.Name = "OverlayText"
                        OverlayText.Size = UDim2.fromScale(1, 1)
                        OverlayText.BackgroundTransparency = 1
                        OverlayText.BorderSizePixel = 0
                        OverlayText.ZIndex = 10
                        OverlayText.ClipsDescendants = true

                        widgets.applyTextStyle(OverlayText)

                        OverlayText.TextXAlignment = Enum.TextXAlignment.Center

                        OverlayText.Parent = SliderField

                        widgets.applyInteractionHighlights("Background", SliderField, SliderField, {
                            Color = Iris._config.FrameBgColor,
                            Transparency = Iris._config.FrameBgTransparency,
                            HoveredColor = Iris._config.FrameBgHoveredColor,
                            HoveredTransparency = Iris._config.FrameBgHoveredTransparency,
                            ActiveColor = Iris._config.FrameBgActiveColor,
                            ActiveTransparency = Iris._config.FrameBgActiveTransparency,
                        })

                        local InputField: TextBox = Instance.new("TextBox")
                        InputField.Name = "InputField"
                        InputField.Size = UDim2.new(1, 0, 1, 0)
                        InputField.BackgroundTransparency = 1
                        InputField.ClearTextOnFocus = false
                        InputField.TextTruncate = Enum.TextTruncate.AtEnd
                        InputField.ClipsDescendants = true
                        InputField.Visible = false

                        widgets.applyFrameStyle(InputField, true)
                        widgets.applyTextStyle(InputField)

                        InputField.Parent = SliderField

                        InputField.FocusLost:Connect(function()
                            local newValue: number? = tonumber(InputField.Text:match("-?%d*%.?%d*"))
                            if newValue ~= nil then
                                if thisWidget.arguments.Min ~= nil then
                                    newValue = math.max(newValue, getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments))
                                end
                                if thisWidget.arguments.Max ~= nil then
                                    newValue = math.min(newValue, getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments))
                                end

                                if thisWidget.arguments.Increment then
                                    newValue = math.round(newValue / getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)) * getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                end

                                thisWidget.state.number:set(updateValueByIndex(thisWidget.state.number.value, index, newValue, thisWidget.arguments :: any))
                                thisWidget.lastNumberChangedTick = Iris._cycleTick + 1
                            end

                            local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                            if thisWidget.arguments.Prefix then
                                format = thisWidget.arguments.Prefix[index] .. format
                            end

                            InputField.Text = string.format(format, getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments))

                            thisWidget.state.editingText:set(0)
                            InputField:ReleaseFocus(true)
                        end)

                        InputField.Focused:Connect(function()
                            -- this highlights the entire field
                            InputField.CursorPosition = #InputField.Text + 1
                            InputField.SelectionStart = 1

                            thisWidget.state.editingText:set(index)
                        end)

                        widgets.applyButtonDown(SliderField, function()
                            SliderMouseDown(thisWidget :: any, dataType, index)
                        end)

                        local GrabBar: Frame = Instance.new("Frame")
                        GrabBar.Name = "GrabBar"
                        GrabBar.ZIndex = 5
                        GrabBar.AnchorPoint = Vector2.new(0.5, 0.5)
                        GrabBar.Position = UDim2.new(0, 0, 0.5, 0)
                        GrabBar.BorderSizePixel = 0
                        GrabBar.BackgroundColor3 = Iris._config.SliderGrabColor
                        GrabBar.Transparency = Iris._config.SliderGrabTransparency
                        if Iris._config.GrabRounding > 0 then
                            widgets.UICorner(GrabBar, Iris._config.GrabRounding)
                        end

                        widgets.UISizeConstraint(GrabBar, Vector2.new(Iris._config.GrabMinSize, 0))

                        GrabBar.Parent = SliderField
                    end

                    local TextLabel: TextLabel = Instance.new("TextLabel")
                    TextLabel.Name = "TextLabel"
                    TextLabel.BackgroundTransparency = 1
                    TextLabel.BorderSizePixel = 0
                    TextLabel.LayoutOrder = 5
                    TextLabel.AutomaticSize = Enum.AutomaticSize.XY

                    widgets.applyTextStyle(TextLabel)

                    TextLabel.Parent = Slider

                    return Slider
                end,
                Update = function(thisWidget: Types.Input<T>)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or `Slider {dataType}`

                    if thisWidget.arguments.Format and typeof(thisWidget.arguments.Format) ~= "table" then
                        thisWidget.arguments.Format = { thisWidget.arguments.Format }
                    elseif not thisWidget.arguments.Format then
                        -- we calculate the format for the s.f. using the max, min and increment arguments.
                        local format: { string } = {}
                        for index = 1, components do
                            local sigfigs: number = defaultSigFigs[dataType][index]

                            if thisWidget.arguments.Increment then
                                local value: number = getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Max then
                                local value: number = getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if thisWidget.arguments.Min then
                                local value: number = getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments)
                                sigfigs = math.max(sigfigs, math.ceil(-math.log10(value == 0 and 1 or value)), sigfigs)
                            end

                            if sigfigs > 0 then
                                -- we know it's a float.
                                format[index] = `%.{sigfigs}f`
                            else
                                format[index] = "%d"
                            end
                        end

                        thisWidget.arguments.Format = format
                        thisWidget.arguments.Prefix = defaultPrefx[dataType]
                    end

                    for index = 1, components do
                        local SliderField = Input:FindFirstChild("SliderField" .. tostring(index)) :: TextButton
                        local GrabBar: Frame = SliderField.GrabBar

                        local increment: number = thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments) or defaultIncrements[dataType][index]
                        local min: number = thisWidget.arguments.Min and getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments) or defaultMin[dataType][index]
                        local max: number = thisWidget.arguments.Max and getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments) or defaultMax[dataType][index]

                        local grabScaleSize: number = 1 / math.floor((1 + max - min) / increment)

                        GrabBar.Size = UDim2.new(grabScaleSize, 0, 1, 0)
                    end

                    local callbackIndex: number = #Iris._postCycleCallbacks + 1
                    local desiredCycleTick: number = Iris._cycleTick + 1
                    Iris._postCycleCallbacks[callbackIndex] = function()
                        if Iris._cycleTick >= desiredCycleTick then
                            if thisWidget.lastCycleTick ~= -1 then
                                Iris._widgets[`Slider{dataType}`].UpdateState(thisWidget)
                            end
                            Iris._postCycleCallbacks[callbackIndex] = nil
                        end
                    end
                end,
                Discard = function(thisWidget: Types.Input<T>)
                    thisWidget.Instance:Destroy()
                    widgets.discardState(thisWidget)
                end,
                GenerateState = function(thisWidget: Types.Input<T>)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", defaultValue)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
                UpdateState = function(thisWidget: Types.Input<T>)
                    local Slider = thisWidget.Instance :: Frame

                    for index = 1, components do
                        local SliderField = Slider:FindFirstChild("SliderField" .. tostring(index)) :: TextButton
                        local InputField: TextBox = SliderField.InputField
                        local OverlayText: TextLabel = SliderField.OverlayText
                        local GrabBar: Frame = SliderField.GrabBar

                        local value: number = getValueByIndex(thisWidget.state.number.value, index, thisWidget.arguments)
                        local format: string = thisWidget.arguments.Format[index] or thisWidget.arguments.Format[1]
                        if thisWidget.arguments.Prefix then
                            format = thisWidget.arguments.Prefix[index] .. format
                        end

                        OverlayText.Text = string.format(format, value)
                        InputField.Text = tostring(value)

                        local increment: number = thisWidget.arguments.Increment and getValueByIndex(thisWidget.arguments.Increment, index, thisWidget.arguments) or defaultIncrements[dataType][index]
                        local min: number = thisWidget.arguments.Min and getValueByIndex(thisWidget.arguments.Min, index, thisWidget.arguments) or defaultMin[dataType][index]
                        local max: number = thisWidget.arguments.Max and getValueByIndex(thisWidget.arguments.Max, index, thisWidget.arguments) or defaultMax[dataType][index]

                        local SliderWidth: number = SliderField.AbsoluteSize.X
                        local PaddedWidth: number = SliderWidth - GrabBar.AbsoluteSize.X
                        local Ratio: number = (value - min) / (max - min)
                        local Positions: number = math.floor((max - min) / increment)
                        local ClampedRatio: number = math.clamp(math.floor((Ratio * Positions)) / Positions, 0, 1)
                        local PaddedRatio: number = ((PaddedWidth / SliderWidth) * ClampedRatio) + ((1 - (PaddedWidth / SliderWidth)) / 2)

                        GrabBar.Position = UDim2.new(PaddedRatio, 0, 0.5, 0)

                        if thisWidget.state.editingText.value == index then
                            InputField.Visible = true
                            OverlayText.Visible = false
                            GrabBar.Visible = false
                            InputField:CaptureFocus()
                        else
                            InputField.Visible = false
                            OverlayText.Visible = true
                            GrabBar.Visible = true
                        end
                    end
                end,
            }
        end

        function generateEnumSliderScalar(enum: Enum, item: EnumItem)
            local input: Types.WidgetClass = generateSliderScalar("Enum", 1, item.Value)
            local valueToName = { string }

            for _, enumItem: EnumItem in enum:GetEnumItems() do
                valueToName[enumItem.Value] = enumItem.Name
            end

            return widgets.extend(input, {
                Args = {
                    ["Text"] = 1,
                },
                Update = function(thisWidget: Types.InputEnum)
                    local Input = thisWidget.Instance :: GuiObject
                    local TextLabel: TextLabel = Input.TextLabel
                    TextLabel.Text = thisWidget.arguments.Text or "Input Enum"

                    thisWidget.arguments.Increment = 1
                    thisWidget.arguments.Min = 0
                    thisWidget.arguments.Max = #enum:GetEnumItems() - 1

                    local SliderField = Input:FindFirstChild("SliderField1") :: TextButton
                    local GrabBar: Frame = SliderField.GrabBar

                    local grabScaleSize: number = 1 / math.floor(#enum:GetEnumItems())

                    GrabBar.Size = UDim2.new(grabScaleSize, 0, 1, 0)
                end,
                GenerateState = function(thisWidget: Types.InputEnum)
                    if thisWidget.state.number == nil then
                        thisWidget.state.number = Iris._widgetState(thisWidget, "number", item.Value)
                    end
                    if thisWidget.state.enumItem == nil then
                        thisWidget.state.enumItem = Iris._widgetState(thisWidget, "enumItem", item)
                    end
                    if thisWidget.state.editingText == nil then
                        thisWidget.state.editingText = Iris._widgetState(thisWidget, "editingText", false)
                    end
                end,
            })
        end
    end

    do
        local inputNum: Types.WidgetClass = generateInputScalar("Num", 1, 0)
        inputNum.Args["NoButtons"] = 6
        Iris.WidgetConstructor("InputNum", inputNum)
    end
    Iris.WidgetConstructor("InputVector2", generateInputScalar("Vector2", 2, Vector2.zero))
    Iris.WidgetConstructor("InputVector3", generateInputScalar("Vector3", 3, Vector3.zero))
    Iris.WidgetConstructor("InputUDim", generateInputScalar("UDim", 2, UDim.new()))
    Iris.WidgetConstructor("InputUDim2", generateInputScalar("UDim2", 4, UDim2.new()))
    Iris.WidgetConstructor("InputRect", generateInputScalar("Rect", 4, Rect.new(0, 0, 0, 0)))

    Iris.WidgetConstructor("DragNum", generateDragScalar("Num", 1, 0))
    Iris.WidgetConstructor("DragVector2", generateDragScalar("Vector2", 2, Vector2.zero))
    Iris.WidgetConstructor("DragVector3", generateDragScalar("Vector3", 3, Vector3.zero))
    Iris.WidgetConstructor("DragUDim", generateDragScalar("UDim", 2, UDim.new()))
    Iris.WidgetConstructor("DragUDim2", generateDragScalar("UDim2", 4, UDim2.new()))
    Iris.WidgetConstructor("DragRect", generateDragScalar("Rect", 4, Rect.new(0, 0, 0, 0)))

    Iris.WidgetConstructor("InputColor3", generateColorDragScalar("Color3", Color3.fromRGB(0, 0, 0)))
    Iris.WidgetConstructor("InputColor4", generateColorDragScalar("Color4", Color3.fromRGB(0, 0, 0), 0))

    Iris.WidgetConstructor("SliderNum", generateSliderScalar("Num", 1, 0))
    Iris.WidgetConstructor("SliderVector2", generateSliderScalar("Vector2", 2, Vector2.zero))
    Iris.WidgetConstructor("SliderVector3", generateSliderScalar("Vector3", 3, Vector3.zero))
    Iris.WidgetConstructor("SliderUDim", generateSliderScalar("UDim", 2, UDim.new()))
    Iris.WidgetConstructor("SliderUDim2", generateSliderScalar("UDim2", 4, UDim2.new()))
    Iris.WidgetConstructor("SliderRect", generateSliderScalar("Rect", 4, Rect.new(0, 0, 0, 0)))
    -- Iris.WidgetConstructor("SliderEnum", generateSliderScalar("Enum", 4, 0))

    -- stylua: ignore
    Iris.WidgetConstructor("InputText", {
        hasState = true,
        hasChildren = false,
        Args = {
            ["Text"] = 1,
            ["TextHint"] = 2,
            ["ReadOnly"] = 3,
            ["MultiLine"] = 4,
        },
        Events = {
            ["textChanged"] = {
                ["Init"] = function(thisWidget: Types.InputText)
                    thisWidget.lastTextChangedTick = 0
                end,
                ["Get"] = function(thisWidget: Types.InputText)
                    return thisWidget.lastTextChangedTick == Iris._cycleTick
                end,
            },
            ["hovered"] = widgets.EVENTS.hover(function(thisWidget: Types.Widget)
                return thisWidget.Instance
            end),
        },
        Generate = function(thisWidget: Types.InputText)
            local InputText: Frame = Instance.new("Frame")
            InputText.Name = "Iris_InputText"
            InputText.AutomaticSize = Enum.AutomaticSize.Y
            InputText.Size = UDim2.fromScale(1, 0)
            InputText.BackgroundTransparency = 1
            InputText.BorderSizePixel = 0
            InputText.ZIndex = thisWidget.ZIndex
            InputText.LayoutOrder = thisWidget.ZIndex
            local UIListLayout: UIListLayout = widgets.UIListLayout(InputText, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X))
            UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

            local InputField: TextBox = Instance.new("TextBox")
            InputField.Name = "InputField"
            InputField.Size = UDim2.new(Iris._config.ContentWidth, Iris._config.ContentHeight)
            InputField.AutomaticSize = Enum.AutomaticSize.Y
            InputField.BackgroundColor3 = Iris._config.FrameBgColor
            InputField.BackgroundTransparency = Iris._config.FrameBgTransparency
            InputField.Text = ""
            InputField.TextYAlignment = Enum.TextYAlignment.Top
            InputField.PlaceholderColor3 = Iris._config.TextDisabledColor
            InputField.ClearTextOnFocus = false
            InputField.ClipsDescendants = true

            widgets.applyFrameStyle(InputField)
            widgets.applyTextStyle(InputField)
            widgets.UISizeConstraint(InputField, Vector2.xAxis) -- prevents sizes beaking when getting too small.
            -- InputField.UIPadding.PaddingLeft = UDim.new(0, Iris._config.ItemInnerSpacing.X)
            -- InputField.UIPadding.PaddingRight = UDim.new(0, 0)
            InputField.Parent = InputText

            InputField.FocusLost:Connect(function()
                thisWidget.state.text:set(InputField.Text)
                thisWidget.lastTextChangedTick = Iris._cycleTick + 1
            end)

            local frameHeight: number = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y

            local TextLabel: TextLabel = Instance.new("TextLabel")
            TextLabel.Name = "TextLabel"
            TextLabel.Size = UDim2.fromOffset(0, frameHeight)
            TextLabel.AutomaticSize = Enum.AutomaticSize.X
            TextLabel.BackgroundTransparency = 1
            TextLabel.BorderSizePixel = 0
            TextLabel.LayoutOrder = 1

            widgets.applyTextStyle(TextLabel)

            TextLabel.Parent = InputText

            return InputText
        end,
        Update = function(thisWidget: Types.InputText)
            local InputText = thisWidget.Instance :: Frame
            local TextLabel: TextLabel = InputText.TextLabel
            local InputField: TextBox = InputT [trimmed]  -  Edit
  14:15:01.580  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Mini-14 | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "Mini-14"
module.WeaponType = "Primary"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Left Arm"
module.AmmoType = "LargeFirearm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 8,        -- Clip capacity (Factions MP)
	StartingAmmo = 8,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.17,    -- Time in seconds between shots
	FireMode = "Semi",   -- "Semi", "Burst", "Auto"
	-- Base damage applied to humanoid health
	Damage = {
		Body = 34,
		Head = 68,
	},
	ReloadTime = 1.6,   -- Duration in seconds for the reload action
	Accuracy = 0.8,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.5,
		Horizontal = 1.0,
	},
	CameraImpulse = {
		Vector = Vector3.new(0, 0.1, 0.65), -- X (sideways), Y (up/down), Z (forward/back)
		FadeInSpeed = 30,
		FadeOutSpeed = 8,
	},
	Spread = {
		Min = 1.5,              -- Base spread angle/radius when aiming still
		Max = 6.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 1.5,  -- Amount the spread expands with each shot
		DecaySpeed = 3.0,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://134980275983817", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://110596953973961", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://120131805341379", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://139833795330626", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://114856127484189", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://138782049171297", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://89858576934108", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Crouch = {
		Equip = { Id = "rbxassetid://134606980711746", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://77832019960026", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://125458553529407", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://72834849394610", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://110355161342512", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://108719039152127", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://128839839765543", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Prone = {
		Equip = { Id = "rbxassetid://92140909429396", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://117637871741969", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://108263009869788", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://111841868854161", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://111339754020694", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Mini-14

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.45acp | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "45acp"
module.WeaponType = "SmallFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Right Arm"
module.FireMode = "Semi"   -- "Semi", "Burst", "Auto"
module.AmmoType = "SmallFirearm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 12,        -- Clip capacity (Factions MP)
	StartingAmmo = 12,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.22,    -- Time in seconds between shots
	-- Base damage applied to humanoid health
	Damage = {
		Body = 20,
		Head = 35,
	},
	ReloadTime = 1,   -- Duration in seconds for the reload action
	Accuracy = 0.9,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.0,
		Horizontal = 0.6,
	},
	CameraImpulse = {
		Vector = Vector3.new(0, 0.02, 0.3), -- X (sideways), Y (up/down), Z (forward/back)
		FadeInSpeed = 30,
		FadeOutSpeed = 8,
	},
	Spread = {
		Min = 0.4,              -- Base spread angle/radius when aiming still
		Max = 4.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 0.8,  -- Amount the spread expands with each shot
		DecaySpeed = 4.5,       -- Speed at which the crosshair returns to center
	}
}
-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://88408632559415", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://135228528913490", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://96166468142225", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://76042316323172", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://79017794074571", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://130657637234666", Priority = Enum.AnimationPriority.Action3 },
	},

	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.45acp

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Vepr | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "Vepr"
module.WeaponType = "LargeFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Left Arm"
module.AmmoType = "LargeFirearm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 8,        -- Clip capacity (Factions MP)
	StartingAmmo = 8,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.17,    -- Time in seconds between shots
	FireMode = "Semi",   -- "Semi", "Burst", "Auto"
	-- Base damage applied to humanoid health
	Damage = {
		Body = 25,
		Head = 45,
	},
	ReloadTime = 1.6,   -- Duration in seconds for the reload action
	Accuracy = 0.8,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.5,
		Horizontal = 1.0,
	},
	CameraImpulse = {
		Vector = Vector3.new(0, 0.05, 0.4), -- X (sideways), Y (up/down), Z (forward/back)
		FadeInSpeed = 30,
		FadeOutSpeed = 8,
	},
	Spread = {
		Min = 0.5,              -- Base spread angle/radius when aiming still
		Max = 6.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 1.5,  -- Amount the spread expands with each shot
		DecaySpeed = 3.0,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://134980275983817", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://110596953973961", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://120131805341379", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://139833795330626", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://114856127484189", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://138782049171297", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://89858576934108", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Crouch = {
		Equip = { Id = "rbxassetid://134606980711746", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://77832019960026", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://125458553529407", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://72834849394610", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://110355161342512", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://108719039152127", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://128839839765543", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	Prone = {
		Equip = { Id = "rbxassetid://92140909429396", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://117637871741969", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://108263009869788", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://111841868854161", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://128493332112348", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://111339754020694", Priority = Enum.AnimationPriority.Action },
		--Sprint = { Id = "rbxassetid://125206746816857", Priority = Enum.AnimationPriority.Action3 },
	},
	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Vepr

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.9mm | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "9mm"
module.WeaponType = "SmallFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Right Arm"
module.FireMode = "Semi"   -- "Semi", "Burst", "Auto"
module.AmmoType = "SmallFirearm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 12,        -- Clip capacity (Factions MP)
	StartingAmmo = 12,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.22,    -- Time in seconds between shots
	-- Base damage applied to humanoid health
	Damage = {
		Body = 20,
		Head = 35,
	},
	ReloadTime = 1,   -- Duration in seconds for the reload action
	Accuracy = 0.9,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.0,
		Horizontal = 0.6,
	},
	CameraImpulse = {
		Vector = Vector3.new(0, 0.05, 0.9), -- X (sideways), Y (up/down), Z (forward/back)
		FadeInSpeed = 30,
		FadeOutSpeed = 8,
	},
	Spread = {
		Min = 0.4,              -- Base spread angle/radius when aiming still
		Max = 4.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 0.8,  -- Amount the spread expands with each shot
		DecaySpeed = 4.5,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://88408632559415", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://135228528913490", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://96166468142225", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://76042316323172", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://79017794074571", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://130657637234666", Priority = Enum.AnimationPriority.Action3 },
	},

	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.9mm

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Beretta | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "Beretta"
module.WeaponType = "SmallFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Right Arm"
module.FireMode = "Semi"   -- "Semi", "Burst", "Auto"
module.AmmoType = "SmallFirearm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 12,        -- Clip capacity (Factions MP)
	StartingAmmo = 12,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.22,    -- Time in seconds between shots
	-- Base damage applied to humanoid health
	Damage = {
		Body = 20,
		Head = 35,
	},
	ReloadTime = 1,   -- Duration in seconds for the reload action
	Accuracy = 0.9,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.0,
		Horizontal = 0.6,
	},
	CameraImpulse = {
		Vector = Vector3.new(0, 0.05, 0.3), -- X (sideways), Y (up/down), Z (forward/back)
		FadeInSpeed = 30,
		FadeOutSpeed = 8,
	},
	Spread = {
		Min = 1,              -- Base spread angle/radius when aiming still
		Max = 4.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 0.95,  -- Amount the spread expands with each shot
		DecaySpeed = 4.5,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://88408632559415", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://135228528913490", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://96166468142225", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://76042316323172", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://79017794074571", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://130657637234666", Priority = Enum.AnimationPriority.Action3 },
	},

	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Beretta

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Glock | Enabled: N/A
--------------------------------------------------------------------
local module = {}

module.Name = "9mm"
module.WeaponType = "SmallFirearm"   -- Weapon category definition
module.LoadoutPoints = 2             -- Cost to equip in Factions MP
module.AttachmentPart = "Right Arm"
module.FireMode = "Semi"   -- "Semi", "Burst", "Auto"
module.AmmoType = "SmallFirearm"


-- Base stats (un-upgraded)
module.Base = {
	MagSize = 12,        -- Clip capacity (Factions MP)
	StartingAmmo = 12,   -- Starting ammo when equipped/out of loadout
	FireRate = 0.22,    -- Time in seconds between shots
	-- Base damage applied to humanoid health
	Damage = {
		Body = 20,
		Head = 35,
	},
	ReloadTime = 1,   -- Duration in seconds for the reload action
	Accuracy = 0.9,     -- Base accuracy multiplier (0.0 - 1.0)
	Recoil = {
		Vertical = 1.0,
		Horizontal = 0.6,
	},
	CameraImpulse = {
		Vector = Vector3.new(0, 0.05, 0.6), -- X (sideways), Y (up/down), Z (forward/back)
		FadeInSpeed = 30,
		FadeOutSpeed = 8,
	},
	Spread = {
		Min = 0.4,              -- Base spread angle/radius when aiming still
		Max = 4.0,              -- Maximum spread cap during rapid fire
		IncreasePerShot = 0.8,  -- Amount the spread expands with each shot
		DecaySpeed = 4.5,       -- Speed at which the crosshair returns to center
	}
}

-- Upgrade modifiers (for later â€” if you implement upgrades)
-- According to wiki: upgrades improve reload speed, fire rate, mag size, starting ammo & accuracy.
module.Upgrades = {
	["Upgrade1"] = {
		MagSize = module.Base.MagSize + 2,         -- Increased clip size
		FireRate = module.Base.FireRate * 0.9,     -- Decreased delay between shots
		Accuracy = module.Base.Accuracy + 0.05,
		ReloadTime = module.Base.ReloadTime * 0.9,
	},
	["Upgrade2"] = {
		MagSize = module.Base.MagSize + 4,
		FireRate = module.Base.FireRate * 0.85,
		Accuracy = module.Base.Accuracy + 0.1,
		ReloadTime = module.Base.ReloadTime * 0.85,
	},
}

-- Animation IDs placeholders
module.AnimationIds = {

	-- Normal / Default / Right-Shoulder
	Default = {
		Equip = { Id = "rbxassetid://88408632559415", Priority = Enum.AnimationPriority.Action4 },
		UnEquip = { Id = "rbxassetid://135228528913490", Priority = Enum.AnimationPriority.Action4 },
		Aim = { Id = "rbxassetid://96166468142225", Priority = Enum.AnimationPriority.Action2 },
		Shoot = { Id = "rbxassetid://76042316323172", Priority = Enum.AnimationPriority.Action3 },
		Reload = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		ReloadEmpty = { Id = "rbxassetid://119870639196947", Priority = Enum.AnimationPriority.Action2 },
		Idle = { Id = "rbxassetid://79017794074571", Priority = Enum.AnimationPriority.Action },
		Sprint = { Id = "rbxassetid://130657637234666", Priority = Enum.AnimationPriority.Action3 },
	},

	-- Left-Shoulder / Mirrored Aiming Animations
	Left = {
		Equip  = nil, -- Mirrored versions
		Aim    = nil,
		Shoot  = nil,
		Reload = nil,
		Idle   = nil,
	},
}


-- Function to get either base or upgraded stats (optional)
function module:GetStats(upgradeLevel)
	if upgradeLevel and module.Upgrades[upgradeLevel] then
		return module.Upgrades[upgradeLevel]
	else
		return module.Base
	end
end

return module
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.WeaponSys.WeaponData.Glock

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.UI.Screen3D | Enabled: N/A
--------------------------------------------------------------------
--!strict


--VERSION NOTIFIER (OPTIONAL)
local currentVersion = '2.1.0'
local latestVersion: string?

local versionControl = script:FindFirstChild('VersionControl')

if versionControl and versionControl:FindFirstChild('VersionNotifier') then
	latestVersion = versionControl:InvokeServer()  :: string --comment this line to disable update notifier
end


if latestVersion and currentVersion ~= latestVersion then
	warn(`SCREEN3D - OUTDATED VERSION: {currentVersion} -> {latestVersion}`)
end





local componentGen = require(script.Component3D)
local D = require(script.Definitions)
local guiService = game:GetService('GuiService')


local screenGen : D.screenGen = {} :: D.screenGen

screenGen.__index = screenGen

function screenGen.new(screenGui,displayDistance : number)


	local partIndex : {[GuiObject] : D.component3D} = {}


	local self = setmetatable(
		{
			partIndex = partIndex,
			rootGui = screenGui,
			displayDistance = displayDistance,
			rootOffset = CFrame.new()


		},
		screenGen

	)



	for _,Component2D in ipairs(screenGui:GetDescendants()) do

		if Component2D:IsA("GuiObject") then

			partIndex[Component2D] = componentGen.new(Component2D,self)

		end

	end

	screenGui.DescendantAdded:Connect(function(AddedComponent)
		
		local AddedComponent = AddedComponent :: GuiObject
		
		if partIndex[AddedComponent] then
			return
		end
		
		if AddedComponent:IsA('GuiObject') then
			partIndex[AddedComponent] = componentGen.new(AddedComponent,self)
		end

		for _,Component2D in ipairs(AddedComponent:GetDescendants()) do

			if Component2D:IsA("GuiObject") and not partIndex[Component2D] then

				partIndex[Component2D] = componentGen.new(Component2D,self)

			end

		end

	end)


	return self 
end



function screenGen:GetRealCanvasSize()
	return workspace.CurrentCamera.ViewportSize
end

function screenGen:GetInset()
	local inset = guiService:GetGuiInset()
	return inset
end

function screenGen:GetInsetCanvasSize()

	return self:GetRealCanvasSize() - self:GetInset()
end

function screenGen:GetIntendedCanvasSize()
	if self.rootGui.IgnoreGuiInset then
		return self:GetRealCanvasSize()
	end
	return self:GetInsetCanvasSize()
end


function screenGen:GetComponent3D(Component2D)
	return self.partIndex[Component2D]
end

print('SCREEN3D LOADED')
return screenGen
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.UI.Screen3D

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.UI.Screen3D.Definitions | Enabled: N/A
--------------------------------------------------------------------
export type screen3D = typeof(
	setmetatable(
		{} :: {
			partIndex : {[GuiObject] : component3D},
			rootGui : ScreenGui,
			displayDistance : number,
			rootOffset : CFrame

		}, 
		{} :: screenGen
	)
)

export type component3D = typeof(
	setmetatable(
		{} :: {
			enabled : boolean,
			_compatibility : boolean,
			
			component2D : GuiObject?,
			surfaceGui : SurfaceGui?,
			
			parent2D : GuiObject?,
			screen3D : screen3D,
			parent3D : component3D?,
			
			compatibilityParent3D: component3D?,
			compatibilityParent2D: GuiObject?,
			
			offset : CFrame,
			viewportSize : Vector2,

			
			conn : RBXScriptConnection?
		}, 
		{} :: componentGen
	)
)







export type screenGen = {
	__index : screenGen,
	new: (screenGui : ScreenGui, displayDistance : number) -> screen3D,
	
	GetComponent3D : (screen3D, Component2D : GuiObject) -> component3D?,
	
	GetRealCanvasSize : (screen3D) -> Vector2,
	GetInsetCanvasSize : (screen3D) -> Vector2,
	GetIntendedCanvasSize : (screen3D) -> Vector2,
	GetInset: (screen3D) -> Vector2

}

export type componentGen = {
	__index : componentGen,
	new: (Component2D : GuiObject, Screen3D : screen3D) -> component3D,
	
	Enable: (component3D ) -> (component3D),
	EnableCompatibility: (component3D ) -> (component3D),
	Disable: (component3D ) -> (component3D),
	
	RecomputeParent : (component3D) -> (),
	
	
	GetStudsScreenSize : (component3D, viewportSize : Vector2) -> Vector3,
	ReadWorldCFrame: (component3D) -> (CFrame),
	UDim2ToCFrame : (component3D, position2D : UDim2) -> CFrame,
	GetCompatibilityPosition : (component3D) -> UDim2,
	--AbsoluteUDim2ToCFrame : (component3D, position2D : UDim2) -> CFrame,
	
	GetViewportSize : (component3D) -> Vector2


}




return nil

--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.UI.Screen3D.Definitions

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ReplicatedStorage.Peak.Modules.UI.Screen3D.Component3D | Enabled: N/A
--------------------------------------------------------------------
--!strict
local RunService = game:GetService("RunService")

local Definitions = require(script.Parent.Definitions)

local componentGen : Definitions.componentGen = {} :: Definitions.componentGen
componentGen.__index = componentGen

local function pivot(original: CFrame, pivot: CFrame, angle: CFrame) 
	return original:Inverse() * pivot * angle * pivot:Inverse() * original
end

function componentGen.new(Component2D, Screen3D)
	local self = setmetatable(
		{
			enabled = false,
			_compatibility = false,

			component2D = Component2D,
			surfaceGui = nil,

			parent3D = nil,
			screen3D = Screen3D,

			offset = CFrame.new(),
			viewportSize = Screen3D:GetIntendedCanvasSize(),

			conn = nil
		},

		componentGen
	)

	self.viewportSize = self:GetViewportSize()

	if Component2D.Parent and Component2D.Parent:IsA("GuiObject") then
		self.parent2D = Component2D.Parent
	end

	return self
end

function componentGen:EnableCompatibility()
	
	if not self.parent2D then
		warn('COMPATIBILITY MODE DOES NOT WORK ON COMPONENTS WITH SCREENGUI PARENTS.')
		return self:Enable()
	end
	
	self._compatibility = true

	local Container0 , Container1 = Instance.new('Frame'), Instance.new('Frame')

	Container0.Name = '3DCONTAINER'
	Container1.Name = '3DCONTAINER'

	Container0.Parent = self.parent2D or self.screen3D.rootGui
	Container1.Parent = Container0

	Container0.BackgroundTransparency = 1
	Container1.BackgroundTransparency = 1

	local Container3D_0, Container3D_1 = componentGen.new(Container0,self.screen3D), componentGen.new(Container1,self.screen3D)

	self.screen3D.partIndex[Container0], self.screen3D.partIndex[Container1] = Container3D_0, Container3D_1

	self.compatibilityParent3D = self.parent3D
	self.compatibilityParent2D = self.parent2D

	self.parent2D = Container1
	self.parent3D = Container3D_1

	return self:Enable()
end

function componentGen:Enable()
	if self.enabled or not self.component2D then
		return self
	end	

	self.enabled = true

	local surfaceGui = Instance.new('SurfaceGui')
	local surfacePart = Instance.new('Part')

	surfacePart.CanCollide = false
	surfacePart.Anchored = true
	surfacePart.Parent = surfaceGui

	surfaceGui.Parent = self.parent2D or self.screen3D.rootGui
	surfaceGui.Face =  Enum.NormalId.Back
	surfaceGui.Adornee = surfacePart
	surfaceGui.AlwaysOnTop = true

	self.surfaceGui = surfaceGui

	self.component2D.Parent = self.surfaceGui

	--self:RecomputeParent()

	self.conn = game:GetService('HttpService'):GenerateGUID(false)
	RunService:BindToRenderStep(self.conn,Enum.RenderPriority.Last.Value + 2,function(deltaTime: number)

		if self.conn and not (self.surfaceGui and surfacePart) then
			RunService:UnbindFromRenderStep(self.conn)
			return
		end



		local viewportSize = self:GetViewportSize()

		if self._compatibility and self.parent2D and self.parent3D and self.parent3D.parent2D and self.compatibilityParent2D then
			
			local c_parent = self.compatibilityParent2D

			self.parent3D.parent2D.AnchorPoint = self.component2D.AnchorPoint

			self.parent3D.parent2D.Position = self.component2D.Position
			self.parent2D.Position = UDim2.fromOffset(-self.component2D.AbsolutePosition.X,-self.component2D.AbsolutePosition.Y)


			self.parent2D.Size = UDim2.fromOffset(c_parent.AbsoluteSize.X,c_parent.AbsoluteSize.Y)
			self.parent3D.parent2D.Size = UDim2.fromOffset(self.component2D.AbsoluteSize.X,self.component2D.AbsoluteSize.Y)
		end


		self.viewportSize = viewportSize

		surfaceGui.CanvasSize = viewportSize
		surfacePart.Size = self:GetStudsScreenSize(viewportSize)
		surfacePart.CFrame = self:ReadWorldCFrame()

	end)

	return self
end

function componentGen:Disable()
	if not self.enabled then
		return self
	end

	self.enabled = false

	if self.conn then
		RunService:UnbindFromRenderStep(self.conn)
	end

	if self.component2D then

		if self._compatibility then

			self.component2D.Parent = self.compatibilityParent2D or self.screen3D.rootGui

		else

			self.component2D.Parent = self.parent2D or self.screen3D.rootGui

		end
	end

	if self.surfaceGui then
		self.surfaceGui:Destroy()
	end

	return self
end

function componentGen:GetViewportSize(): Vector2
	if self.parent3D and self.parent3D.component2D then
		return self.parent3D.component2D.AbsoluteSize
	end

	return self.screen3D:GetIntendedCanvasSize()
end

function componentGen:UDim2ToCFrame(position2D: UDim2): CFrame
	if not self.component2D then
		return CFrame.new()
	end

	local scaleX, scaleY = position2D.X.Scale, position2D.Y.Scale
	local offsetX, offsetY = position2D.X.Offset, position2D.Y.Offset

	local viewSize = self:GetViewportSize()

	local partSize = self:GetStudsScreenSize(viewSize)
	local trueScaleX, trueScaleY = scaleX +  offsetX/ viewSize.X , scaleY + offsetY / viewSize.Y



	local partSize = self:GetStudsScreenSize(viewSize)

	return CFrame.new(
		(partSize.X) * (trueScaleX - 0.5),
		-(partSize.Y) * (trueScaleY -0.5 ),
		0		
	)	
end

function componentGen:GetStudsScreenSize(viewportSize: Vector2): Vector3
	local trueSize =  self.screen3D:GetRealCanvasSize()

	local currentCamera = workspace.CurrentCamera
	local FOV = currentCamera.FieldOfView

	return Vector3.new(
		(trueSize.X / trueSize.Y) * math.tan(math.rad(FOV)/2) * (viewportSize.X / trueSize.X) ,
		math.tan(math.rad(FOV)/2)  * (viewportSize.Y / trueSize.Y),
		0	
	) * self.screen3D.displayDistance

end

function componentGen:RecomputeParent()
	if self.parent2D and self.parent2D:IsA("GuiObject") then
		self.parent3D = self.screen3D:GetComponent3D(self.parent2D)
	end

	if self.surfaceGui then
		local parent = self.parent3D
		local zIndex = 0

		while parent do
			zIndex += 1
			parent = parent.parent3D
		end

		self.surfaceGui.ZOffset = zIndex
	end

	return self
end

function componentGen:GetCompatibilityPosition()
	if not self.enabled and self.component2D and self.parent3D and self.parent3D.component2D then-- everyone is say "hey yqat, add modifiers", well i made modifiers, here is my modifiers

		local offset = (self.component2D.AbsolutePosition - self.parent3D.component2D.AbsolutePosition)
		--+ (   (self.component2D.AnchorPoint)  * self.component2D.AbsoluteSize)
		return UDim2.fromOffset(offset.X, offset.Y)
	end
	return UDim2.new(0,0,0,0)
end

function componentGen:ReadWorldCFrame(): CFrame
	if not self.component2D then
		return CFrame.new()
	end

	self:RecomputeParent()

	local originalCFrame, udimPos, addedPosition

	local udimMax = self:UDim2ToCFrame(UDim2.fromScale(1,1))

	if self.parent3D then


		if not self.parent3D.component2D or not self.parent2D then
			return CFrame.new()
		end



		local anchorPoint = self.parent3D.component2D.AnchorPoint

		originalCFrame = self.parent3D:ReadWorldCFrame()



		udimPos = self.parent3D.component2D.Position 

		local anchorFrame = self:UDim2ToCFrame(UDim2.fromScale(-anchorPoint.X+0.5,-anchorPoint.Y+0.5))

		if not self.parent3D.enabled and self.parent3D.parent3D and self.parent3D.parent3D.component2D then 

			udimPos  = self.parent3D:GetCompatibilityPosition()


			--anchorFrame = self:UDim2ToCFrame(UDim2.fromScale(0.5,0.5))
			--anchorFrame = self:UDim2ToCFrame(UDim2.fromScale(0,0))
			anchorFrame = CFrame.new()
		end

		addedPosition = 
			self.parent3D:UDim2ToCFrame(udimPos)
			* udimMax
			* anchorFrame
			* CFrame.Angles(0,0, -math.rad(self.parent2D.Rotation) ) 

	else

		local viewportDiff = self.screen3D:GetRealCanvasSize() - self.screen3D:GetIntendedCanvasSize()

		originalCFrame = workspace.CurrentCamera.CFrame * CFrame.new(0,0,-(self.screen3D.displayDistance)/2 ) * self.screen3D.rootOffset

		udimPos = UDim2.new(0,viewportDiff.X/2,0,viewportDiff.Y/2)

		addedPosition = self:UDim2ToCFrame(udimPos) * self:UDim2ToCFrame(UDim2.fromScale(1,1)) 

	end


	local finalCFrame = originalCFrame  * addedPosition

	local componentPosition = self.component2D.Position


	if not self.enabled and self.parent3D and self.parent3D.component2D and not self.parent3D.enabled then --whoever thinks that hell should be empty has never seen THIS...

		componentPosition = self:GetCompatibilityPosition()
	end

	local finalPivot =  
		finalCFrame 
		* udimMax:Inverse() 
		* self:UDim2ToCFrame(componentPosition) 
		* udimMax



	return finalCFrame * pivot(finalCFrame,finalPivot,self.offset) 
end

return componentGen
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.UI.Screen3D.Component3D

--------------------------------------------------------------------
--// [Script] Path: game.ReplicatedStorage.Peak.Modules.UI.Screen3D.VersionControl.VersionNotifier | Enabled: true
--------------------------------------------------------------------
--!strict
--this can be safely deleted to disable outdated warnings
local latestVersion : string = require(135246913829828) :: string

function script.Parent.OnServerInvoke()
	return latestVersion
end
--// END OF SCRIPT: game.ReplicatedStorage.Peak.Modules.UI.Screen3D.VersionControl.VersionNotifier

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.lootboxtest | Enabled: true
--------------------------------------------------------------------
local replicated = game:GetService("ReplicatedStorage")
local LootModule = require(replicated.Peak.Modules.Loot:WaitForChild("LootModule"))
local interactEvent = replicated.Peak.Remotes.InteractEvent


local INTERACT_DISTANCE = 10



local function spawnLoot(itemName, lootBox)
	-- Validate lootBox
	if not lootBox or not lootBox:IsA("BasePart") then
		warn("Invalid loot box passed to spawnLoot!")
		return
	end

	-- Get all "Attachment" objects in the loot box
	local attachments = {}
	for _, child in ipairs(lootBox:GetChildren()) do
		if child:IsA("Attachment") and child.Name == "Attachment" then
			table.insert(attachments, child)
		end
	end

	if #attachments == 0 then
		warn("No attachments found in loot box: " .. lootBox.Name)
		return
	end

	-- Choose a random attachment
	local chosenAttachment = attachments[math.random(1, #attachments)]
	local spawnPosition = chosenAttachment.WorldPosition

	-- Create a loot part at the chosen position
	local lootPart = Instance.new("Part")
	lootPart.Name = itemName
	lootPart.Size = Vector3.new(1, 1, 1)
	lootPart.Position = spawnPosition
	lootPart.Anchored = true
	lootPart.Parent = workspace

	-- Optionally add customization (e.g., decal, model, etc.)
end



interactEvent.OnServerEvent:Connect(function(player, lootBox)
	-- Validate the player's character and position
	local character = player.Character
	local root = character and character:FindFirstChild("HumanoidRootPart")
	if not root then return end
	if not lootBox or not lootBox:IsA("BasePart") then return end

	if (root.Position - lootBox.Position).Magnitude > INTERACT_DISTANCE then
		player:Kick("Attempted to interact too far from a loot box!")
		return
	end

	-- Generate loot using the LootModule
	local loot = {}
	local lootCount = math.random(2, 4) -- Example: randomize the number of loot items
	for i = 1, lootCount do
		local item = LootModule:RollLoot("Common") -- Use a loot pool
		if item then
			table.insert(loot, item)
		end
	end

	-- Send validated loot data back to the client
	interactEvent:FireClient(player, loot, lootBox)
end)
--// END OF SCRIPT: game.ServerScriptService.lootboxtest

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.Server | weapon | Enabled: true
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")

local Peak = ReplicatedStorage:WaitForChild("Peak")
local Remotes = Peak:WaitForChild("Remotes")
local Modules = Peak:WaitForChild("Modules")
local Assets = Peak:WaitForChild("Assets")

local WeaponRemotes = Remotes:WaitForChild("WeaponSys")
local CoreRemote = WeaponRemotes:WaitForChild("Core")
local DamageEvent = WeaponRemotes:WaitForChild("DamageEvent")

local ObjectHitEvent = WeaponRemotes:FindFirstChild("ObjectHit")

local RequestInventory = Remotes:FindFirstChild("RequestInventory")
if not RequestInventory then
	RequestInventory = Instance.new("RemoteEvent")
	RequestInventory.Name = "RequestInventory"
	RequestInventory.Parent = Remotes
end

local DebugInventory = Remotes:WaitForChild("DebugInventory") 

local WeaponModulesRoot = Modules:WaitForChild("WeaponSys")
local WeaponDataFolder = WeaponModulesRoot:WaitForChild("WeaponData")
local WeaponModelFolder = Assets:WaitForChild("WeaponModels")

local ServerWeaponState = {} 
local PlayerProfiles = {}

local BackpackC0 = CFrame.new(0.7, -1.2, -0.6) * CFrame.Angles(math.rad(90), 0, 0)
local BackpackC0PurchaseWeapon = CFrame.new(0.9, -1.2, -0.6) * CFrame.Angles(math.rad(90), 0, 0)
local TorsoHolsterC0 = CFrame.new(1, -0.7, 0.65) * CFrame.fromEulerAnglesXYZ(math.rad(-45), math.rad(90), 0)
local HandC0 = CFrame.new() 
local SidearmHolsterC0 = CFrame.new(1, -0.7, 0.65) * CFrame.fromOrientation(math.rad(-45),math.rad(90),0)

local Voicelines = Assets:WaitForChild("Voices")

local DEFAULT_VOICE = "Merc2"
local SPECIAL_PLAYER_NAME = "kaiizyr"
local SPECIAL_VOICE = "Merc1"

local MAX_DISTANCE = 1000 
local DEBUG_VISUALS = false

local ALLOWED_LIMBS = {
	["Head"] = true,
	["Torso"] = true,
	["Left Arm"] = true,
	["Right Arm"] = true,
	["Left Leg"] = true,
	["Right Leg"] = true,
}

local function VisualizeValidation(origin, hitPos, isValid)
	if not DEBUG_VISUALS then return end

	local color = isValid and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
	local distance = (origin - hitPos).Magnitude

	local laser = Instance.new("Part")
	laser.Name = "ServerValidationRay"
	laser.Anchored = true
	laser.CanCollide = false
	laser.CanQuery = false
	laser.CastShadow = false
	laser.Material = Enum.Material.Neon
	laser.Color = color
	laser.Size = Vector3.new(0.05, 0.05, distance)
	laser.CFrame = CFrame.lookAt(origin, hitPos) * CFrame.new(0, 0, -distance / 2)
	laser.Parent = workspace
	Debris:AddItem(laser, 1.5)
end

local function GetProfileForPlayer(player)
	return PlayerProfiles[player] or (_G.Profiles and _G.Profiles[player])
end

local function LoadWeaponModule(weaponName)
	local mod = WeaponDataFolder:FindFirstChild(weaponName)
	if mod then return require(mod) end
	return nil
end

local function GetSlotForWeapon(player, weaponData)
	local t = weaponData.WeaponType
	if t == "Secondary" or t == "SmallFirearm" then return "Secondary"
	elseif t == "Primary" or t == "LargeFirearm" then return "Primary"
	elseif t == "Purchaseable" then return "Purchaseable" end
	return "Primary"
end

local function WaitForBackpack(player)
	local char = player.Character
	if not char then return nil end

	local backpack = char:WaitForChild("Backpack", 2)
	if not backpack then return nil end

	local testBP = backpack:WaitForChild("TestBP", 2)
	if not testBP then return nil end

	return testBP:WaitForChild("Backpack_LP", 2)
end

local function OptimizeHitboxes(char)
	local function ProcessPart(part)
		if part:IsA("BasePart") then
			if not ALLOWED_LIMBS[part.Name] then
				part.CanQuery = false 
				part.CanTouch = false 
			else
				part.CanQuery = true
			end
			if part.Name == "HumanoidRootPart" then
				part.CanQuery = false
			end
		end
	end

	for _, desc in pairs(char:GetDescendants()) do
		ProcessPart(desc)
	end
	char.DescendantAdded:Connect(ProcessPart)
end

local function FindHumanoidAndModel(part)
	local current = part
	while current and current ~= workspace do
		local hum = current:FindFirstChild("Humanoid")
		if hum then
			return hum, current
		end
		current = current.Parent
	end
	return nil, nil
end

local function GetOrSpawnWeapon(player, weaponName, weaponData)
	if not player or not weaponName or not weaponData then return nil, nil, nil end
	local char = player.Character
	if not char or not char.Parent then return nil, nil, nil end

	ServerWeaponState[player] = ServerWeaponState[player] or {}
	local slot = GetSlotForWeapon(player, weaponData) or "Primary"
	local state = ServerWeaponState[player][slot]

	if state and state.Character ~= char then
		ServerWeaponState[player][slot] = nil
		state = nil
	end

	if not state then
		state = {
			Character = char,
			WeaponName = weaponName,
			Data = weaponData,
			Ammo = (weaponData.Base and weaponData.Base.StartingAmmo) or 0,
			Equipped = false,
		}
		ServerWeaponState[player][slot] = state
	end

	local template = WeaponModelFolder:FindFirstChild(weaponName)
	if not template then return nil, nil, nil end

	if not state.Model or not state.Model.Parent then
		state.Model = template:Clone()
		state.Model.Name = weaponName
		state.Model.Parent = char
	end

	local model = state.Model
	local handle = model:FindFirstChild("Handle") or model:WaitForChild("Handle", 2)
	if not handle then model:Destroy() return nil, nil, nil end

	local attachName = weaponData.AttachmentPart or "Right Arm"
	local attachPart = char:FindFirstChild(attachName)
	if not attachPart then attachPart = char:FindFirstChild("Right Arm") or char:FindFirstChild("Torso") end

	state.AttachmentPart = attachPart

	if slot == "Primary" then state.HolsterPart = WaitForBackpack(player)
	elseif slot == "Secondary" then state.HolsterPart = char:FindFirstChild("Torso")
	elseif slot == "Purchaseable" then state.HolsterPart = WaitForBackpack(player) end

	if not state.Equipped then
		if state.Weld then state.Weld:Destroy() end
		local weld = Instance.new("Motor6D")
		weld.Name = "WeaponWeld"
		weld.Part1 = handle
		weld.C1 = CFrame.new()
		weld.Parent = handle
		state.Weld = weld

		if slot == "Primary" then
			weld.Part0 = state.HolsterPart
			weld.C0 = BackpackC0
		elseif slot == "Secondary" then
			local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
			weld.Part0 = torso
			weld.C0 = SidearmHolsterC0
		elseif slot == "Purchaseable" then
			weld.Part0 = state.HolsterPart
			weld.C0 = BackpackC0PurchaseWeapon
		end
	end

	return model, attachPart, slot
end

local function AttachToHand(player, slot)
	local state = ServerWeaponState[player] and ServerWeaponState[player][slot]
	if not state or not state.Model then return end

	local handle = state.Model:FindFirstChild("Handle")
	if not handle then return end

	local char = player.Character
	local armName = state.Data.AttachmentPart or "Right Arm"
	local newArm = char:FindFirstChild(armName) or char:FindFirstChild("Left Arm")

	state.AttachmentPart = newArm
	state.Equipped = true

	if state.Weld then state.Weld:Destroy() end
	local weld = Instance.new("Motor6D")
	weld.Name = "WeaponWeld"
	weld.Part0 = state.AttachmentPart
	weld.Part1 = handle
	weld.C0 = HandC0
	weld.C1 = CFrame.new()
	weld.Parent = handle
	state.Weld = weld

	CoreRemote:FireClient(player, "Equipped", {
		Slot = slot,
		WeaponName = state.WeaponName,
		Ammo = state.Ammo,
		Data = state.Data,
		AttachmentPart = state.Data.AttachmentPart,
	})
end

local function AttachToHolster(player, slot)
	local state = ServerWeaponState[player] and ServerWeaponState[player][slot]
	if not state or not state.Model then return end

	local handle = state.Model:FindFirstChild("Handle")
	if not handle then return end

	state.Equipped = false

	if state.Weld then state.Weld:Destroy() end
	local weld = Instance.new("Motor6D")
	weld.Name = "WeaponWeld"
	weld.Part1 = handle
	weld.C1 = CFrame.new()
	weld.Parent = handle
	state.Weld = weld

	if slot == "Secondary" then
		local torso = player.Character:FindFirstChild("UpperTorso") or player.Character:FindFirstChild("Torso")
		weld.Part0 = torso
		weld.C0 = SidearmHolsterC0
	elseif slot == "Primary" or slot == "Purchaseable" then
		local holster = WaitForBackpack(player)
		state.HolsterPart = holster
		weld.Part0 = holster
		if slot == "Primary" then weld.C0 = BackpackC0 else weld.C0 = BackpackC0PurchaseWeapon end
	end

	CoreRemote:FireClient(player, "Holstered", { Slot = slot })
end

local function PlayVoiceline(killer, category)
	if not killer then return end
	local char = killer.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head then return end

	local voiceName = (killer.Name == SPECIAL_PLAYER_NAME) and SPECIAL_VOICE or DEFAULT_VOICE
	local pack = Voicelines:FindFirstChild(voiceName)
	if pack then
		local folder = pack:FindFirstChild(category)
		if folder then
			local sounds = folder:GetChildren()
			if #sounds > 0 then
				local sound = sounds[math.random(1, #sounds)]:Clone()
				sound.Parent = head
				sound:Play()
				game.Debris:AddItem(sound, sound.TimeLength + 1)
			end
		end
	end
end

local function TagKill(targetHumanoid, killer)
	if targetHumanoid then
		targetHumanoid:SetAttribute("LastDamagePlayer", killer.UserId)
	end
end

local function VerifyAndProcessShot(player, origin, hitInstance, hitPosition, weaponData)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude

	local filterList = {player.Character}

	local slot = GetSlotForWeapon(player, weaponData)
	local state = ServerWeaponState[player] and ServerWeaponState[player][slot]
	if state and state.Model then
		table.insert(filterList, state.Model)
	end

	local victimHum, victimModel = FindHumanoidAndModel(hitInstance)

	if victimModel then
		table.insert(filterList, victimModel)
	end

	if hitInstance then
		table.insert(filterList, hitInstance)
	end

	params.FilterDescendantsInstances = filterList

	local dist = (hitPosition - origin).Magnitude
	if dist > MAX_DISTANCE then
		return false
	end

	local direction = (hitPosition - origin)
	local result = workspace:Raycast(origin, direction, params)

	if result then
		VisualizeValidation(origin, result.Position, false)
		return false
	else
		VisualizeValidation(origin, hitPosition, true)

		if victimHum and victimHum.Health > 0 then
			local victimPlayer = Players:GetPlayerFromCharacter(victimModel)

			if victimPlayer and player.Team and victimPlayer.Team and player.Team == victimPlayer.Team then
				return false
			end

			local damage = weaponData.Base.Damage.Body
			if hitInstance.Name == "Head" then
				damage = weaponData.Base.Damage.Head
			end

			TagKill(victimHum, player)
			victimHum:TakeDamage(damage)

			CoreRemote:FireClient(player, "HitMarker", { HitPart = hitInstance.Name })

			if victimPlayer then
				local attackerHead = player.Character and player.Character:FindFirstChild("Head")
				if attackerHead then
					DamageEvent:FireClient(victimPlayer, attackerHead.Position)
				end
			end

			if victimHum.Health <= 0 then
				CoreRemote:FireClient(player, "Kill", { HitPart = hitInstance.Name, Target = victimModel.Name })
				PlayVoiceline(player, "Kill")
			end

			return true
		else
			-- Calculate shot direction (Unit Vector)
			local shotDirection = direction.Unit
			ObjectHitEvent:Fire(player, hitInstance, hitPosition, weaponData, shotDirection)
			return true
		end
	end
end

CoreRemote.OnServerEvent:Connect(function(player, action, payload)
	local profile = GetProfileForPlayer(player)

	if action == "Shoot" then
		local slot = payload.Slot

		local targetPos = payload.HitPosition or payload.TargetPosition
		local hitPart = payload.HitPart

		if not slot or not targetPos then return end

		local playerState = ServerWeaponState[player]
		if not playerState then return end

		local state = playerState[slot]
		if not state or not state.Model or not state.Equipped then return end

		if state.Ammo > 0 then
			state.Ammo -= 1

			local char = player.Character
			local head = char and char:FindFirstChild("Head")
			local origin = head and head.Position or char.PrimaryPart.Position

			local weaponModel = state.Model
			local handle = weaponModel:FindFirstChild("Handle")
			local muzzle = handle and handle:FindFirstChild("MuzzleFX")
			local visualOrigin = muzzle and muzzle.WorldPosition or origin

			if hitPart then
				VerifyAndProcessShot(player, origin, hitPart, targetPos, state.Data)
			end

			CoreRemote:FireAllClients("Shot", {
				Player = player,
				WeaponName = state.WeaponName,
				Ammo = state.Ammo,
				Payload = payload,
				Origin = visualOrigin,
				EndPoint = targetPos
			})
		else
			CoreRemote:FireClient(player, "DryFire", {})
		end

	elseif action == "Reload" then
		local slot = payload.Slot
		if not slot then return end

		local playerState = ServerWeaponState[player]
		local state = playerState and playerState[slot]
		if not state then return end

		state.Ammo = state.Data.Base.MagSize

		CoreRemote:FireAllClients("Reloaded", {
			Player = player,
			WeaponName = state.WeaponName,
			Ammo = state.Ammo,
			Slot = slot
		})

	elseif action == "Equip" then
		local weaponName = payload.WeaponName
		local mod = LoadWeaponModule(weaponName)

		local playerState = ServerWeaponState[player]
		if playerState then
			for otherSlot, state in pairs(playerState) do
				if state.Equipped then
					AttachToHolster(player, otherSlot)
					CoreRemote:FireClient(player, "Holstered", { Slot = otherSlot })
				end
			end
		end

		if mod then
			local _, _, slot = GetOrSpawnWeapon(player, weaponName, mod)
			AttachToHand(player, slot)
		end

	elseif action == "Unequip" or action == "FinishUnequip" then
		local slot = payload and payload.Slot
		if slot then
			local state = ServerWeaponState[player] and ServerWeaponState[player][slot]
			if state then
				state.Equipped = false
				AttachToHolster(player, slot)
				if action == "Unequip" then
					CoreRemote:FireClient(player, "Unequipped", { Slot = slot })
				end
			end
		end

		if action == "FinishUnequip" then
			local char = player.Character
			local hum = char and char:FindFirstChild("Humanoid")
			if hum then
				for _, t in ipairs(hum:GetPlayingAnimationTracks()) do
					if t.Priority.Value >= Enum.AnimationPriority.Action.Value then
						t:Stop(0.1)
					end
				end
			end
		end

	elseif action == "ShoulderSwap" then
		CoreRemote:FireClient(player, "ShoulderSwap")
	end
end)

RequestInventory.OnServerEvent:Connect(function(player)
	local profile = GetProfileForPlayer(player)
	if profile and profile.Data and profile.Data.Inventory then
		DebugInventory:FireClient(player, profile.Data.Inventory)
	end
end)

Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(char)

		OptimizeHitboxes(char)

		local profile
		for i = 1, 30 do
			profile = GetProfileForPlayer(player)
			if profile then break end
			task.wait(0.5)
		end

		if not profile then return end
		PlayerProfiles[player] = profile

		if profile.Data and profile.Data.Inventory then
			DebugInventory:FireClient(player, profile.Data.Inventory)
		end

		local ok = pcall(function() return WaitForBackpack(player) end)

		local inv = profile.Data and profile.Data.Inventory and profile.Data.Inventory.Weapons
		if not inv then return end

		ServerWeaponState[player] = {Primary = nil, Secondary = nil, Purchaseable = nil}

		local function SpawnWeapon(weaponName)
			local mod = LoadWeaponModule(weaponName)
			if not mod then return end
			local model, attach, slot = GetOrSpawnWeapon(player, weaponName, mod)
			if not model then return end

			AttachToHolster(player, slot)
			local state = ServerWeaponState[player][slot]
			if state then
				CoreRemote:FireClient(player, "Holstered", {
					Slot = slot,
					WeaponName = state.WeaponName,
					Ammo = state.Ammo,
					Data = state.Data, 
					AttachmentPart = state.Data.AttachmentPart,
				})
			end
		end

		if inv.Primary then SpawnWeapon(inv.Primary) end
		if inv.Purchaseable then SpawnWeapon(inv.Purchaseable) end
		if inv.Secondary then SpawnWeapon(inv.Secondary) end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	local state = ServerWeaponState[player]
	if state then
		for _, s in pairs(state) do
			if s and s.Model then s.Model:Destroy() end
		end
	end
	ServerWeaponState[player] = nil
	PlayerProfiles[player] = nil
end)

local deathhighlight = Remotes.TeamHighlightDeath
Players.PlayerAdded:Connect(function(plr)
	plr.CharacterAdded:Connect(function(char)
		local hum = char:WaitForChild("Humanoid")
		hum.Died:Connect(function()
			deathhighlight:FireAllClients(plr) 
		end)
	end)
end)
--// END OF SCRIPT: game.ServerScriptService.Server | weapon

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.Flashlight | Enabled: true
--------------------------------------------------------------------
local PhysicsService = game:GetService("PhysicsService")
local Players = game:GetService("Players")

local FLASHLIGHT_GROUP = "Flashlight"
local CHARACTER_GROUP = "Character"

-- Create a collision group if it doesnâ€™t exist
local function ensureGroupExists(name)
	for _, group in PhysicsService:GetRegisteredCollisionGroups() do
		if group.name == name then
			return
		end
	end
	PhysicsService:RegisterCollisionGroup(name)
end

-- Ensure groups exist
ensureGroupExists(FLASHLIGHT_GROUP)
ensureGroupExists(CHARACTER_GROUP)

-- Set rules:
-- Flashlight should NEVER collide with character parts
PhysicsService:CollisionGroupSetCollidable(FLASHLIGHT_GROUP, CHARACTER_GROUP, false)
PhysicsService:CollisionGroupSetCollidable(CHARACTER_GROUP, FLASHLIGHT_GROUP, false)

-- Flashlight SHOULD collide with the world
PhysicsService:CollisionGroupSetCollidable(FLASHLIGHT_GROUP, "Default", true)


Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)

		-- Put all character BaseParts into "Character" group
		for _, d in ipairs(character:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CollisionGroup = CHARACTER_GROUP
			end
		end

		-- Clone flashlight core
		local coreClone = script:WaitForChild("FLCore"):Clone()
		coreClone.Parent = character
		coreClone.Enabled = true

		-- Put all flashlight BaseParts into "Flashlight" group
		for _, d in ipairs(coreClone:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CollisionGroup = FLASHLIGHT_GROUP
			end
		end
	end)
end)

--// END OF SCRIPT: game.ServerScriptService.Flashlight

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerScriptService.Flashlight.FLCore | Enabled: false
--------------------------------------------------------------------
local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")

local FlashlightModule = require(script:WaitForChild("FlashlightModule"))

local UIS = game:GetService("UserInputService")
local CAS = game.ContextActionService

local On = false
local db = false

local function Emission(actionName, inputState, inputObject)
	if inputState ~= Enum.UserInputState.Begin then return end

	-- FORCE ONLY F ALLOWED
	if inputObject.KeyCode ~= Enum.KeyCode.F then
		return
	end

	if db then return end
	db = true

	if Humanoid.Health > 0 then
		On = not On

		if On then
			FlashlightModule.CreateFlashlight(Character)
			CAS:SetTitle("Flashlight", "Off")
		else
			FlashlightModule.RemoveFlashlight(Character)
			CAS:SetTitle("Flashlight", "On")
		end
	end

	task.wait(0.25)
	db = false
end

Humanoid.Died:Connect(function()
	if On then
		FlashlightModule.RemoveFlashlight(Character)
	end
end)

-- Bind strictly to F
CAS:BindAction(
	"Flashlight",
	Emission,
	false,           -- â— disable touch button (important)
	Enum.KeyCode.F   -- only this key triggers it
)

-- (Optional) remove the UI button completely so CAS won't add "/" fallback
CAS:SetTitle("Flashlight", "")
CAS:SetPosition("Flashlight", UDim2.new(-1,0,-1,0)) -- hides it fully

--// END OF SCRIPT: game.ServerScriptService.Flashlight.FLCore

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ServerScriptService.Flashlight.FLCore.FlashlightModule | Enabled: N/A
--------------------------------------------------------------------
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")

local FlashlightModule = {
	Lerp = false,
	LerpSpeed = 0.6,
	TweenSpeed = 0.11,

	LightPart = nil,
	UpdateConnection = nil,
	FromAttach = nil,
	
	OnSound = "rbxassetid://89707816463137",
	OffSound = "rbxassetid://78509455631020",
	

	_onSoundObj = nil,
	_offSoundObj = nil,
}

local function GetSound(parent, soundId)
	local s = Instance.new("Sound")
	s.SoundId = soundId
	s.Volume = 1
	s.RollOffMaxDistance = 45
	s.Parent = parent

	-- Preload so Play() never fails
	ContentProvider:PreloadAsync({s})

	return s
end

-------------------------------------------------------
-- GET FLASHLIGHT ATTACHMENT
-------------------------------------------------------
local function GetFlashlightAttachment(character)
	local backpackModel = character:FindFirstChild("Backpack")
	if not backpackModel then return end

	local testBP = backpackModel:FindFirstChild("TestBP")
	if not testBP then return end

	local bpLP = testBP:FindFirstChild("Backpack_LP")
	if not bpLP then return end

	local flashlight = bpLP:FindFirstChild("Flashlight")
	if not flashlight then return end

	local fromAttach = flashlight:FindFirstChild("From")
	if not fromAttach or not fromAttach:IsA("Attachment") then return end

	return fromAttach, flashlight
end

-------------------------------------------------------
-- CREATE FLASHLIGHT (Only runs once)
-------------------------------------------------------
FlashlightModule.CreateFlashlight = function(character)
	
	if FlashlightModule.LightPart then
		FlashlightModule.LightPart.Light.Enabled = true
		FlashlightModule.LightPart.Ring.Transparency = 0.747

		if FlashlightModule._onSoundObj then
			FlashlightModule._onSoundObj:Play()
		end
		return
	end

	local fromAttach, flashlightPart = GetFlashlightAttachment(character)
	if not fromAttach then
		return warn("FlashlightModule: Could not locate flashlight attachment.")
	end
	FlashlightModule.FromAttach = fromAttach

	local LightPart = script:WaitForChild("LightPart"):Clone()
	FlashlightModule.LightPart = LightPart

	local Ring = LightPart.Ring
	local Light = LightPart.Light

	LightPart.Parent = Camera
	LightPart.CFrame = fromAttach.WorldCFrame

	Light.Enabled = true
	Ring.Transparency = 0.747

	-- Create ON sound once & preload
	if not FlashlightModule._onSoundObj then
		FlashlightModule._onSoundObj = GetSound(flashlightPart, FlashlightModule.OnSound)
	end
	FlashlightModule._onSoundObj:Play()

	-- Update loop
	if FlashlightModule.UpdateConnection then
		FlashlightModule.UpdateConnection:Disconnect()
	end

	FlashlightModule.UpdateConnection = RunService.RenderStepped:Connect(function(dt)
		if not FlashlightModule.LightPart or not FlashlightModule.FromAttach then return end

		local light = FlashlightModule.LightPart
		local attach = FlashlightModule.FromAttach

		-- POSITION ALWAYS EXACT (no delay)
		local origin = attach.WorldPosition

		-- Desired facing direction (toward mouse/camera)
		local desiredCF = CFrame.lookAt(origin, origin + Camera.CFrame.LookVector)

		-- Extract rotation only
		local currentCF = light.CFrame
		local currentRot = currentCF - currentCF.Position
		local desiredRot = desiredCF - desiredCF.Position

		-- Smooth rotation only (LERP)
		local alpha = 1 - math.exp(-20 * dt) -- super smooth
		local smoothedRot = currentRot:Lerp(desiredRot, alpha)

		-- Apply back to the correct position
		light.CFrame = smoothedRot + origin
	end)


end

-------------------------------------------------------
-- TURN FLASHLIGHT OFF (no destruction)
-------------------------------------------------------
FlashlightModule.RemoveFlashlight = function(character)
	if not FlashlightModule.LightPart then return end

	FlashlightModule.LightPart.Light.Enabled = false
	FlashlightModule.LightPart.Ring.Transparency = 1

	if not FlashlightModule._offSoundObj then
		FlashlightModule._offSoundObj = GetSound(character, FlashlightModule.OffSound)
	end

	FlashlightModule._offSoundObj:Play()
end


return FlashlightModule

--// END OF SCRIPT: game.ServerScriptService.Flashlight.FLCore.FlashlightModule

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.AmbientSoundController | Enabled: false
--------------------------------------------------------------------

local SoundSystemModule = require(script.Parent.Modules.SoundSystemModule)
local workspaceFolder = workspace:WaitForChild("Environment")

SoundSystemModule.StartAmbientCreakSystem(workspaceFolder)

--// END OF SCRIPT: game.ServerScriptService.AmbientSoundController

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.Spawntest | Enabled: true
--------------------------------------------------------------------
local Players = game:GetService("Players")
local SPAWNS = workspace:WaitForChild("Spawn")

local INITIAL_FOLDERS = {
	Fireflies = SPAWNS:WaitForChild("Fireflies"):GetChildren(),
	Hunters = SPAWNS:WaitForChild("Hunters"):GetChildren()
}

local RANDOM_SPAWNS = SPAWNS:WaitForChild("Random"):GetChildren()

local ENEMY_RADIUS = 35
local PlayerHasSpawned = {}

-- Get closest enemy distance from spawn point
local function getClosestEnemyDist(pos, playerTeam)
	local closest = math.huge

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Team and plr.Team ~= playerTeam and plr.Character then
			local root = plr.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local d = (root.Position - pos).Magnitude
				if d < closest then
					closest = d
				end
			end
		end
	end

	return closest
end

-- NO SORTING. Finds best spawn manually.
local function pickSafeSpawn(playerTeam)
	local safeSpawns = {}

	for _, sp in ipairs(RANDOM_SPAWNS) do
		if sp:IsA("BasePart") then
			local dist = getClosestEnemyDist(sp.Position, playerTeam)

			if dist > ENEMY_RADIUS then
				table.insert(safeSpawns, sp)
			end
		end
	end

	-- If we have safe spawns â†’ pick a random one
	if #safeSpawns > 0 then
		return safeSpawns[math.random(1, #safeSpawns)]
	end

	-- fallback: NO safe spawns â†’ pick ANY spawn randomly
	return RANDOM_SPAWNS[math.random(1, #RANDOM_SPAWNS)]
end

local function chooseSpawn(player)
	local teamName = player.Team and player.Team.Name
	if not teamName then return end

	-- FIRST SPAWN: use team folder
	if not PlayerHasSpawned[player] then
		local folder = INITIAL_FOLDERS[teamName]
		if folder and #folder > 0 then
			PlayerHasSpawned[player] = true
			return folder[math.random(1, #folder)]
		end
	end

	-- AFTERWARDS: use random safe spawn
	return pickSafeSpawn(player.Team)
end


-- APPLY SPAWNS
Players.PlayerAdded:Connect(function(plr)
	plr.CharacterAdded:Connect(function(char)
		task.wait() -- let the character load
		local spawnPoint = chooseSpawn(plr)

		if spawnPoint then
			local hrp = char:WaitForChild("HumanoidRootPart")
			hrp.CFrame = spawnPoint.CFrame + Vector3.new(0, 2, 0)
		end
	end)
end)

--// END OF SCRIPT: game.ServerScriptService.Spawntest

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.Overseer.Clients.Data | Enabled: true
--------------------------------------------------------------------
--- @ CORE DATA 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Peak = ReplicatedStorage:WaitForChild("Peak")
local Remotes = Peak:WaitForChild("Remotes")
local Modules = Peak:WaitForChild("Modules")
local ClientModules = Modules:WaitForChild("Client")
local Helpers = ClientModules:WaitForChild("Helpers")
local AssetsFolder = Peak:WaitForChild("Assets")

local Clothing = AssetsFolder:WaitForChild("Clothing")
local PlayerClothing = Clothing:WaitForChild("Player")
local Backpacks = PlayerClothing:WaitForChild("Backpacks")

local DataEvent = Remotes:WaitForChild("DataEvent")
local DebugEvent = Remotes:WaitForChild("DebugInventory")

local DataUtils = require(Modules:WaitForChild("DataHelper"))
local PlayerDataModule = require(Modules:WaitForChild("PlayerData"))
local CosmeticLoader = require(Helpers:WaitForChild("ClothingLoading"))

local ProfileService = require(game.ServerScriptService.Overseer.Modules:WaitForChild("ProfileService"))
local PlayerStore = ProfileService.GetProfileStore("r1", PlayerDataModule.DefaultPlayerData)

local Profiles = {}
_G.Profiles = Profiles
local SAVEONLEAVE = true

local function WaitForCharacter(player)
	if player.Character and player.Character.Parent then
		return player.Character
	end
	local char = player.CharacterAdded:Wait()
	return char
end

local function LoadProfile(player)
	local key = "Player_" .. player.UserId
	local profile
	local tries = 0

	repeat
		tries += 1
		profile = PlayerStore:LoadProfileAsync(key)

		if not profile then
			warn("[ProfileService] FAILED load for", player.Name, " try:", tries)
			task.wait(0.5)
		end

		if tries >= 10 and not profile then
			player:Kick("Data failed to load after multiple attempts")
			return nil
		end
	until profile

	---------------------------------------------------
	-- VALID PROFILE RECEIVED
	---------------------------------------------------
	profile:AddUserId(player.UserId)
	profile:Reconcile()

	if not profile.Data then
		warn("[PROFILE ERROR] Missing .Data for", player.Name)
		profile.Data = PlayerDataModule.DefaultPlayerData
		
	end

	profile:ListenToRelease(function()
		pcall(function()
			player:Kick("Your data was released â€” please rejoin.")
		end)
	end)

	Profiles[player] = profile
	return profile
end

local function LoadPlayerCosmetics(player, profile)
	local char = player.Character or player.CharacterAdded:Wait()

	char:WaitForChild("Humanoid")
	char:WaitForChild("Torso", 1)
	char.Parent = workspace.Game.Characters
	task.wait(0.25) -- ensure replication
	CosmeticLoader.LoadCosmetics(player, profile.Data)
end

Players.PlayerAdded:Connect(function(player)
	print(">> Loading Profile for", player.Name)

	local profile = LoadProfile(player)
	if not profile then
		return
	end

	-- Send inventory to client for debug panel
	task.defer(function()
		DebugEvent:FireClient(player, profile.Data.Inventory)
	end)

	-- Load cosmetics after character spawns
	player.CharacterAdded:Connect(function(newChar)
		newChar.Parent = workspace.Game.Characters
		task.defer(function()
			if Profiles[player] then
				LoadPlayerCosmetics(player, profile)
			end
		end)
	end)

	-- If character spawned too early
	if player.Character then
		task.defer(function()
			if Profiles[player] then
				LoadPlayerCosmetics(player, profile)
			end
		end)
	end

	print("[ProfileService] Finished loading data for", player.Name)
end)


Players.PlayerRemoving:Connect(function(player)
	local profile = Profiles[player]
	if profile then
		if SAVEONLEAVE then
			profile:Release()
		else
			warn("[DATA] SAVE DISABLED â€” Not saving for", player.Name)
		end
		Profiles[player] = nil
	end
end)


-- Remote event handling
DataEvent.OnServerEvent:Connect(function(player, action, path, value)
	local profile = Profiles[player]
	if not profile or not profile.Data then
		warn("[DataEvent] NO profile for", player.Name)
		return
	end

	if action == "Add" then
		DataUtils.Add(profile, path, value)
	elseif action == "Remove" then
		DataUtils.Remove(profile, path, value)
	else
		warn("[DataEvent] Unknown action", action)
	end

	task.defer(function()
		DebugEvent:FireClient(player, profile.Data.Inventory)
	end)
end)
--// END OF SCRIPT: game.ServerScriptService.Overseer.Clients.Data

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.Overseer.Server.Players.Framework | Enabled: true
--------------------------------------------------------------------
local Replicated = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")

	local existingAnimator = humanoid:FindFirstChildOfClass("Animator")
	if existingAnimator then
		existingAnimator:Destroy()
	end

	local animator = Instance.new("Animator")
	animator.Name = "Animator"
	animator.Parent = humanoid

	local defaultAnimate = character:WaitForChild("Animate")
	if defaultAnimate then
		defaultAnimate:Destroy()
	end
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterAdded)
	if player.Character then
		onCharacterAdded(player.Character)
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)

for _, player in ipairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
--// END OF SCRIPT: game.ServerScriptService.Overseer.Server.Players.Framework

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.Overseer.Server.Handlers.DestructibleHandler | Enabled: true
--------------------------------------------------------------------
--[[
	ATTRIBUTE DOCUMENTATION:
	
	1. Health (Number)
	   - How much damage the object takes before breaking.
	   
	2. DestroyMode (String)
	   - "Delete": Instantly removes the part.
	   - "Unanchor": Unanchors the part so it falls and interacts with physics.
	   
	3. ImpulseForce (Number)
	   - How hard the part is pushed when it breaks (if Unanchored).
	   
	4. RotationForce (Number)
	   - How much the part spins when it breaks (if Unanchored).
	   
	5. Spread (Number)
	   - The exact number of EXTRA parts to affect.
	
	6. SoundSource (String)
	   - The name of the folder inside script.DestructionSounds to use.
	   
	7. ParticleSource (String)
	   - The name of the folder inside script.DestructionParticles to use.
]]

local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local PhysicsService = game:GetService("PhysicsService")
local Debris = game:GetService("Debris")

local Peak = ReplicatedStorage:WaitForChild("Peak")
local Remotes = Peak:WaitForChild("Remotes")
local WeaponRemotes = Remotes:WaitForChild("WeaponSys")
local ObjectHitEvent = WeaponRemotes:WaitForChild("ObjectHit")

local SoundRootFolder = script:WaitForChild("DestructionSounds")
local ParticleRootFolder = script:WaitForChild("DestructionParticles")

local TAG_NAME = "Destructible"
local DEBUG_MODE = false

local GROUP_DESTRUCTIBLE = "Destructible"
local GROUP_BROKEN = "BrokenPiece"
local GROUP_DEFAULT = "Default"

local function SetupCollisionGroups()
	local function RegisterGroup(name)
		pcall(function() PhysicsService:RegisterCollisionGroup(name) end)
	end

	RegisterGroup(GROUP_DESTRUCTIBLE)
	RegisterGroup(GROUP_BROKEN)
	
	PhysicsService:CollisionGroupSetCollidable(GROUP_BROKEN, GROUP_DEFAULT, true)
	PhysicsService:CollisionGroupSetCollidable(GROUP_BROKEN, GROUP_BROKEN, false) 
	PhysicsService:CollisionGroupSetCollidable(GROUP_BROKEN, GROUP_DESTRUCTIBLE, false)
	PhysicsService:CollisionGroupSetCollidable(GROUP_DESTRUCTIBLE, GROUP_DEFAULT, true)
	PhysicsService:CollisionGroupSetCollidable(GROUP_DESTRUCTIBLE, GROUP_DESTRUCTIBLE, true)
end
SetupCollisionGroups()

local function InitializeDestructibleObject(instance)
	if instance:IsA("BasePart") then
		instance.CollisionGroup = GROUP_DESTRUCTIBLE
	end
	if instance:IsA("Model") then
		for _, desc in ipairs(instance:GetDescendants()) do
			if desc:IsA("BasePart") then
				desc.CollisionGroup = GROUP_DESTRUCTIBLE
			end
		end
		instance.DescendantAdded:Connect(function(desc)
			if desc:IsA("BasePart") then
				desc.CollisionGroup = GROUP_DESTRUCTIBLE
			end
		end)
	end
end

for _, obj in pairs(CollectionService:GetTagged(TAG_NAME)) do
	InitializeDestructibleObject(obj)
end
CollectionService:GetInstanceAddedSignal(TAG_NAME):Connect(InitializeDestructibleObject)

local searchParams = OverlapParams.new()
searchParams.FilterType = Enum.RaycastFilterType.Exclude

local function GetNeighbors(part)
	local size = part.Size * 1.2
	local cframe = part.CFrame

	searchParams.FilterDescendantsInstances = {part}

	local foundParts = workspace:GetPartBoundsInBox(cframe, size, searchParams)
	local neighbors = {}

	for _, p in ipairs(foundParts) do
		if (CollectionService:HasTag(p.Parent, TAG_NAME) or CollectionService:HasTag(p, TAG_NAME)) then
			table.insert(neighbors, p)
		end
	end
	return neighbors
end

local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local function HandleDebugVisuals(part)
	local highlight = part:FindFirstChild("DebugHitHighlight")
	if not highlight then
		highlight = Instance.new("Highlight")
		highlight.Name = "DebugHitHighlight"
		highlight.FillColor = Color3.fromRGB(255, 255, 255)
		highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
		highlight.DepthMode = Enum.HighlightDepthMode.Occluded
		highlight.Parent = part
	end

	highlight.FillTransparency = 0.7
	highlight.OutlineTransparency = 0

	TweenService:Create(highlight, fadeInfo, {FillTransparency = 1, OutlineTransparency = 1}):Play()
end

local function PlayBreakSound(part)
	local sourceName = part:GetAttribute("SoundSource") or part.Parent:GetAttribute("SoundSource")
	if not sourceName then return end

	local folder = SoundRootFolder:FindFirstChild(sourceName)
	if not folder then return end

	local sounds = folder:GetChildren()
	if #sounds == 0 then return end

	local soundTemplate = sounds[math.random(1, #sounds)]
	if not soundTemplate then return end

	local sound = soundTemplate:Clone()

	local randomPitch = math.random(90, 110) / 100
	sound.PlaybackSpeed = sound.PlaybackSpeed * randomPitch

	local mode = part:GetAttribute("DestroyMode") or part.Parent:GetAttribute("DestroyMode") or "Delete"

	if mode == "Unanchor" then
		sound.Parent = part
	else
		local att = Instance.new("Attachment")
		att.WorldPosition = part.Position
		att.Parent = workspace.Terrain
		sound.Parent = att
		Debris:AddItem(att, sound.TimeLength + 0.5)
	end

	sound:Play()
	Debris:AddItem(sound, sound.TimeLength + 0.5)
end

local function PlayBreakParticles(part)
	local sourceName = part:GetAttribute("ParticleSource") or part.Parent:GetAttribute("ParticleSource")
	if not sourceName then return end

	local folder = ParticleRootFolder:FindFirstChild(sourceName)
	if not folder then return end

	local att = Instance.new("Attachment")
	local mode = part:GetAttribute("DestroyMode") or part.Parent:GetAttribute("DestroyMode") or "Delete"

	if mode == "Unanchor" then
		att.Parent = part
	else
		att.WorldPosition = part.Position
		att.Parent = workspace.Terrain
	end

	for _, template in ipairs(folder:GetChildren()) do
		if template:IsA("ParticleEmitter") then
			local emitter = template:Clone()
			emitter.Parent = att

			local count = template:GetAttribute("Emit") or 10
			emitter:Emit(count)
		end
	end

	Debris:AddItem(att, 3)
end

local function CollapsePart(part)
	part.CollisionGroup = GROUP_BROKEN

	part.Anchored = false
	part:BreakJoints() 

	local randomRot = Vector3.new(math.random(), math.random(), math.random()) * 5
	part:ApplyAngularImpulse(randomRot * part.AssemblyMass)

	Debris:AddItem(part, 4) 
end

local function ProcessFloatingParts(startPart)
	local cluster = {}
	local queue = {startPart}
	local visited = {[startPart] = true}
	local isGrounded = false

	while #queue > 0 do
		local current = table.remove(queue, 1)
		table.insert(cluster, current)

		searchParams.FilterDescendantsInstances = {current}
		local touching = workspace:GetPartBoundsInBox(current.CFrame, current.Size * 1.1, searchParams)

		for _, p in ipairs(touching) do
			if p.Anchored and p.CollisionGroup ~= GROUP_BROKEN and 
				not CollectionService:HasTag(p, TAG_NAME) and 
				not CollectionService:HasTag(p.Parent, TAG_NAME) then
				isGrounded = true
				break
			end
		end

		if isGrounded then break end

		local neighbors = GetNeighbors(current)
		for _, n in ipairs(neighbors) do
			if not visited[n] and n.CollisionGroup == GROUP_DESTRUCTIBLE then
				visited[n] = true
				table.insert(queue, n)
			end
		end
	end

	if not isGrounded then
		for _, p in ipairs(cluster) do
			CollapsePart(p)
		end
	end
end

local function HurtPart(part, damage, dir, weaponData, skipFloatCheck)
	local model = part.Parent

	local currentHealth = part:GetAttribute("Health") or model:GetAttribute("Health")
	if not currentHealth then return end 

	if not part:GetAttribute("MaxHealth") then
		part:SetAttribute("MaxHealth", currentHealth)
	end

	local newHealth = currentHealth - damage
	part:SetAttribute("Health", newHealth)

	if DEBUG_MODE then HandleDebugVisuals(part) end

	if newHealth <= 0 then
		local potentialFloating = {}
		if not skipFloatCheck then
			potentialFloating = GetNeighbors(part)
		end

		PlayBreakSound(part)
		PlayBreakParticles(part)

		local mode = part:GetAttribute("DestroyMode") or model:GetAttribute("DestroyMode") or "Delete"

		if mode == "Unanchor" then
			local pushForce = part:GetAttribute("ImpulseForce") or model:GetAttribute("ImpulseForce") or (weaponData and weaponData.ImpulseForce) or 50
			local spinForce = part:GetAttribute("RotationForce") or model:GetAttribute("RotationForce") or (weaponData and weaponData.RotationForce) or 10

			part.CollisionGroup = GROUP_BROKEN
			part.Anchored = false
			part:BreakJoints()

			dir = dir or Vector3.new(0, 1, 0)
			part:ApplyImpulse(dir * (pushForce * part.AssemblyMass))

			local randomSpin = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit
			part:ApplyAngularImpulse(randomSpin * (spinForce * part.AssemblyMass))

			Debris:AddItem(part, 5)
		else
			part.CollisionGroup = GROUP_BROKEN
			part:Destroy()
		end

		if not skipFloatCheck then
			task.defer(function()
				local checked = {}
				for _, neighbor in ipairs(potentialFloating) do
					if neighbor.Parent and neighbor.CollisionGroup == GROUP_DESTRUCTIBLE and not checked[neighbor] then
						ProcessFloatingParts(neighbor)
						checked[neighbor] = true 
					end
				end
			end)
		end
	end
end

local function OnObjectHit(player, hitPart, hitPosition, weaponData, shotDirection)
	local model = hitPart.Parent
	local isDestructible = CollectionService:HasTag(model, TAG_NAME) or CollectionService:HasTag(hitPart, TAG_NAME)

	if not isDestructible then return end

	if hitPart.CollisionGroup ~= GROUP_BROKEN then
		hitPart.CollisionGroup = GROUP_DESTRUCTIBLE
	end

	local damage = (weaponData.Base and weaponData.Base.Damage.Body) or 10
	local spreadCount = hitPart:GetAttribute("Spread") or model:GetAttribute("Spread") or 0

	HurtPart(hitPart, damage, shotDirection, weaponData)

	if spreadCount > 0 then
		local candidates = {}
		local visited = {[hitPart] = true}
		local queue = {hitPart}

		local safetyLimit = spreadCount * 3 

		while #queue > 0 and #candidates < safetyLimit do
			local current = table.remove(queue, 1)
			if current and current.Parent then
				local neighbors = GetNeighbors(current)
				for _, n in ipairs(neighbors) do
					if not visited[n] then
						visited[n] = true
						table.insert(candidates, n)
						table.insert(queue, n)
					end
				end
			end
		end

		table.sort(candidates, function(a, b)
			return (a.Position - hitPart.Position).Magnitude < (b.Position - hitPart.Position).Magnitude
		end)

		for i = 1, spreadCount do
			local p = candidates[i]
			if p then
				HurtPart(p, damage, shotDirection, weaponData)
			end
		end
	end
end

ObjectHitEvent.Event:Connect(OnObjectHit)
--// END OF SCRIPT: game.ServerScriptService.Overseer.Server.Handlers.DestructibleHandler
  -  Edit
  14:15:01.969  --------------------------------------------------------------------
--// [ModuleScript] Path: game.ServerScriptService.Overseer.Modules.ProfileService | Enabled: N/A
--------------------------------------------------------------------
-- local Madwork = _G.Madwork
--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
		
	Members:
	
		ProfileService.ServiceLocked         [bool]
		
		ProfileService.IssueSignal           [ScriptSignal] (error_message, profile_store_name, profile_key)
		ProfileService.CorruptionSignal      [ScriptSignal] (profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state)
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]
			profile_store_index   [string] -- DataStore name
			OR
			profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables
				{
					Name = "StoreName", -- [string] -- DataStore name
					-- Optional arguments:
					Scope = "StoreScope", -- [string] -- DataStore scope
				}
			profile_template      [table] -- Profiles will default to given table (hard-copy) when no data was saved previously

		ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)
			-- Returns true if ProfileService is connected to live Roblox DataStores
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile] or nil -- not_released_handler(place_id, game_job_id)
			profile_key            [string] -- DataStore key
			not_released_handler   nil or []: -- Defaults to "ForceLoad"
				[string] "ForceLoad" -- Force loads profile on first call
				OR
				[string] "Steal" -- Steals the profile ignoring it's session lock
				OR
				[function] (place_id, game_job_id) --> [string] "Repeat", "Cancel", "ForceLoad" or "Steal"
					place_id      [number] or nil
					game_job_id   [string] or nil

				-- not_released_handler [function] will be triggered in cases where the profile is not released by a session. This
				--	function may yield for as long as desirable and must return one of three string values:

						["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
						["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
						["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
							and release the profile for another session that has loaded the profile
						["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
							a session lock for this session.

		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates] or nil
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
			profile_key      [string] -- DataStore key
			update_handler   [function] (global_updates [GlobalUpdates])
			
		ProfileStore:ViewProfileAsync(profile_key, version) --> [Profile] or nil
			-- Reads profile without requesting a session lock; Data will not be saved and profile doesn't need to be released
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --> [ProfileVersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool]
			-- Completely wipes out profile data from the DataStore / mock DataStore with no way to recover it.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)

	Methods [ProfileVersionQuery]:

		ProfileVersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile has the same rules as profile returned by :ViewProfileAsync()
		
	Members [Profile]:
	
		Profile.Data              [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData          [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)

		Profile.MetaTagsUpdated   [ScriptSignal] (meta_tags_latest) -- Fires after every auto-save, after
			--	Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved;
			--  .MetaTagsUpdated will fire regardless of whether .MetaTagsLatest changed after update;
			--	.MetaTagsUpdated may fire after the Profile is released - changes to Profile.Data are not saved
			--	after release.

		Profile.RobloxMetaData    [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds           [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo           [DataStoreKeyInfo]
		Profile.KeyInfoUpdated    [ScriptSignal] (key_info [DataStoreKeyInfo])
		
		Profile.GlobalUpdates     [GlobalUpdates]
		
	Methods [Profile]:
	
		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to
			
		Profile:GetMetaTag(tag_name) --> value [any]
			tag_name   [string]
		
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
		
		Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
			-- WARNING: Profiles can be released externally if another session force-loads
			--	this profile - use :ListenToRelease() to handle player leaving cleanup.
			
		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)

		Profile:ListenToHopReady(listener) --> [ScriptConnection] () -- Passed listener will be executed after the releasing UpdateAsync call finishes;
			--	Wrap universe teleport requests with this method AFTER releasing the profile to improve session lock sharing between universe places;
			--  :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a release happens
			--	next to an auto-update in regular usage scenarios.

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)
			user_id   [number]

		Profile:Identify() --> [string] -- Returns a string containing DataStore name, scope and key; Used for debug;
			-- Example return: "[Store:"GameData";Scope:"Live";Key:"Player_2312310"]"
		
		Profile:SetMetaTag(tag_name, value) -- Equivalent of Profile.MetaData.MetaTags[tag_name] = value
			tag_name   [string]
			value      [any]
		
		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)

		-- VIEW-MODE ONLY:

		Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

		Profile:OverwriteAsync() -- (Yields) Saves the profile payload to the DataStore and removes the session lock
		
	Methods [GlobalUpdates]:
	
	-- ALWAYS PUBLIC:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data [table]}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data [table]}, ...}
		
	-- ONLY WHEN FROM "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:LockActiveUpdate(update_id)  -- WARNING: will error after profile expires
		GlobalUpdates:ClearLockedUpdate(update_id) -- WARNING: will error after profile expires
		
	-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
			update_data   [table]
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
			update_data   [table]
		GlobalUpdates:ClearActiveUpdate(update_id)
		
--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	RobloxWriteCooldown = 7, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 8, -- Steps taken before ForceLoad request steals the active session for a profile
	AssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead
		-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.
	
	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds
	
	MetaTagsUpdatedValues = { -- Technical stuff - do not alter
		ProfileCreateTime = true,
		SessionLoadCount = true,
		ActiveSession = true,
		ForceLoadSession = true,
		LastUpdate = true,
	},
	
}

local Madwork -- Standalone Madwork reference for portable version of ProfileService
do

	local MadworkScriptSignal = {}

	local FreeRunnerThread = nil
	
	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		FreeRunnerThread = acquired_runner_thread
	end
	
	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end
	
	-- ScriptConnection object:

	local ScriptConnection = {
		--[[
			_listener = listener,
			_script_signal = script_signal,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,
			
			_next = next_script_connection,
			_is_connected = is_connected,
		--]]
	}
	ScriptConnection.__index = ScriptConnection

	function ScriptConnection:Disconnect()

		if self._is_connected == false then
			return
		end

		self._is_connected = false
		self._script_signal._listener_count -= 1

		if self._script_signal._head == self then
			self._script_signal._head = self._next
		else
			local prev = self._script_signal._head
			while prev ~= nil and prev._next ~= self do
				prev = prev._next
			end
			if prev ~= nil then
				prev._next = self._next
			end
		end

		if self._disconnect_listener ~= nil then
			if not FreeRunnerThread then
				FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
			end
			task.spawn(FreeRunnerThread, self._disconnect_listener, self._disconnect_param)
			self._disconnect_listener = nil
		end

	end
	
	-- ScriptSignal object:

	local ScriptSignal = {
		--[[
			_head = nil,
			_listener_count = 0,
		--]]
	}
	ScriptSignal.__index = ScriptSignal

	function ScriptSignal:Connect(listener, disconnect_listener, disconnect_param) --> [ScriptConnection]

		local script_connection = {
			_listener = listener,
			_script_signal = self,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,

			_next = self._head,
			_is_connected = true,
		}
		setmetatable(script_connection, ScriptConnection)

		self._head = script_connection
		self._listener_count += 1

		return script_connection

	end

	function ScriptSignal:GetListenerCount() --> [number]
		return self._listener_count
	end

	function ScriptSignal:Fire(...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item._listener, ...)
			end
			item = item._next
		end
	end

	function ScriptSignal:FireUntil(continue_callback, ...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				item._listener(...)
				if continue_callback() ~= true then
					return
				end
			end
			item = item._next
		end
	end

	function MadworkScriptSignal.NewScriptSignal() --> [ScriptSignal]
		return {
			_head = nil,
			_listener_count = 0,
			Connect = ScriptSignal.Connect,
			GetListenerCount = ScriptSignal.GetListenerCount,
			Fire = ScriptSignal.Fire,
			FireUntil = ScriptSignal.FireUntil,
		}
	end

	-- Madwork framework namespace:
	
	Madwork = {
		NewScriptSignal = MadworkScriptSignal.NewScriptSignal,
		ConnectToOnClose = function(task, run_in_studio_mode)
			if game:GetService("RunService"):IsStudio() == false or run_in_studio_mode == true then
				game:BindToClose(task)
			end
		end,
	}

end

----- Service Table -----

local ProfileService = {

	ServiceLocked = false, -- Set to true once the server is shutting down

	IssueSignal = Madwork.NewScriptSignal(), -- (error_message, profile_store_name, profile_key) -- Fired when a DataStore API call throws an error
	CorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
	-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value

	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true
	-- (You may alert players with this, or set up analytics)

	ServiceIssueCount = 0,

	_active_profile_stores = {}, -- {profile_store, ...}

	_auto_save_list = {}, -- {profile, ...} -- loaded profile table which will be circularly auto-saved

	_issue_queue = {}, -- [table] {issue_time, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / os.clock() = critical state start

	-- Debug:
	_mock_data_store = {},
	_user_mock_data_store = {},

	_use_mock_data_store = false,

}

--[[
	Saved profile structure:
	
	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
			LastUpdate = 0, -- os.time()
		},
		RobloxMetaData = {},
		UserIds = {},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
	
	OR
	
	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local IsLiveCheckActive = false

local UseMockDataStore = false
local MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled

local UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock
local UseMockTag = {}

local CustomWriteQueue = {
	--[[
		[store] = {
			[key] = {
				LastWrite = os.clock(),
				Queue = {callback, ...},
				CleanupJob = nil,
			},
			...
		},
		...
	--]]
}

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

----- Private functions -----

local function IdentifyProfile(store_name, store_scope, key)
	return string.format(
		"[Store:\"%s\";%sKey:\"%s\"]",
		store_name,
		store_scope ~= nil and string.format("Scope:\"%s\";", store_scope) or "",
		key
	)
end

local function CustomWriteQueueCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		CustomWriteQueue[store][key] = nil
		if next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueMarkForCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		if CustomWriteQueue[store][key] ~= nil then

			local queue_data = CustomWriteQueue[store][key]
			local queue = queue_data.Queue

			if queue_data.CleanupJob == nil then

				queue_data.CleanupJob = RunService.Heartbeat:Connect(function()
					if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
						queue_data.CleanupJob:Disconnect()
						CustomWriteQueueCleanup(store, key)
					end
				end)

			end

		elseif next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueAsync(callback, store, key) --> ... -- Passed return from callback

	if CustomWriteQueue[store] == nil then
		CustomWriteQueue[store] = {}
	end
	if CustomWriteQueue[store][key] == nil then
		CustomWriteQueue[store][key] = {LastWrite = 0, Queue = {}, CleanupJob = nil}
	end

	local queue_data = CustomWriteQueue[store][key]
	local queue = queue_data.Queue

	-- Cleanup job:

	if queue_data.CleanupJob ~= nil then
		queue_data.CleanupJob:Disconnect()
		queue_data.CleanupJob = nil
	end

	-- Queue logic:

	if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
		queue_data.LastWrite = os.clock()
		return callback()
	else
		table.insert(queue, callback)
		while true do
			if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and queue[1] == callback then
				table.remove(queue, 1)
				queue_data.LastWrite = os.clock()
				return callback()
			end
			task.wait()
		end
	end

end

local function IsCustomWriteQueueEmptyFor(store, key) --> is_empty [bool]
	local lookup = CustomWriteQueue[store]
	if lookup ~= nil then
		lookup = lookup[key]
		return lookup == nil or #lookup.Queue == 0
	end
	return true
end

local function WaitForLiveAccessCheck() -- This function was created to prevent the ProfileService module yielding execution when required
	while IsLiveCheckActive == true do
		task.wait()
	end
end

local function WaitForPendingProfileStore(profile_store)
	while profile_store._is_pending == true do
		task.wait()
	end
end

local function RegisterIssue(error_message, store_name, store_scope, profile_key) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error " .. IdentifyProfile(store_name, store_scope, profile_key) .. " - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterCorruption(store_name, store_scope, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Resolved profile corruption " .. IdentifyProfile(store_name, store_scope, profile_key))
	ProfileService.CorruptionSignal:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = transform
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data),
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock, is_get_call, version) --> loaded_data, key_info
	local loaded_data, key_info
	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local data_corrupted = false
			local global_updates_data = {0, {}}

			if latest_data == nil then
				missing_profile = true
			elseif type(latest_data) ~= "table" then
				missing_profile = true
				data_corrupted = true
			end

			if type(latest_data) == "table" then
				-- Case #1: Profile was loaded
				if type(latest_data.Data) == "table"
					and type(latest_data.MetaData) == "table"
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					if update_settings.ExistingProfileHandle ~= nil then
						update_settings.ExistingProfileHandle(latest_data)
					end
					-- Case #2: Profile was not loaded but GlobalUpdate data exists
				elseif latest_data.Data == nil
					and latest_data.MetaData == nil
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates or global_updates_data
					missing_profile = true
				else
					missing_profile = true
					data_corrupted = true
				end
			end

			-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates_data,
				}
				if update_settings.MissingProfileHandle ~= nil then
					update_settings.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if update_settings.EditProfile ~= nil then
				update_settings.EditProfile(latest_data)
			end

			-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
			if data_corrupted == true then
				latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end
		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
			loaded_data, key_info = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		elseif UseMockDataStore == true then -- Used when API access is disabled
			loaded_data, key_info = MockUpdateAsync(MockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		else
			loaded_data, key_info = CustomWriteQueueAsync(
				function() -- Callback
					if is_get_call == true then
						local get_data, get_key_info
						if version ~= nil then
							local success, error_message = pcall(function()
								get_data, get_key_info = profile_store._global_data_store:GetVersionAsync(profile_key, version)
							end)
							if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
								warn("[ProfileService]: Passed version argument is not valid; Traceback:\n" .. debug.traceback())
							end
						else
							get_data, get_key_info = profile_store._global_data_store:GetAsync(profile_key)
						end
						get_data = transform_function(get_data)
						return get_data, get_key_info
					else
						return profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
					end
				end,
				profile_store._profile_store_lookup, -- Store
				profile_key -- Key
			)
		end
	end)
	if success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true and is_get_call ~= true then
			RegisterCorruption(
				profile_store._profile_store_name,
				profile_store._profile_store_scope,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		RegisterIssue(
			(error_message ~= nil) and error_message or "Undefined error",
			profile_store._profile_store_name,
			profile_store._profile_store_scope,
			profile_key
		)
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index = table.find(AutoSaveList, profile)
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
	loaded_profiles[profile._profile_key] = nil
	if next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	local place_id
	local game_job_id
	local active_session = profile.MetaData.ActiveSession
	if active_session ~= nil then
		place_id = active_session[1]
		game_job_id = active_session[2]
	end
	profile._release_listeners:Fire(place_id, game_job_id)
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					global_updates_object._new_active_update_listeners:Fire(new_global_update[1], new_global_update[4])
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:

					global_updates_object._new_locked_update_listeners:FireUntil(
						function()
							-- Check if listener marked the update to be cleared:
							-- Normally there should be only one listener per profile for new locked global updates, but
							-- in case several listeners are connected we will not trigger more listeners after one listener
							-- marks the locked global update to be cleared.
							return table.find(pending_update_clear, new_global_update[1]) == nil
						end,
						new_global_update[1], new_global_update[4]
					)

				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session, is_overwriting)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(
			profile._profile_store._profile_store_name,
			profile._profile_store._profile_store_scope,
			profile._profile_key
		)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! Profile: " .. profile:Identify())
	end
	if release_from_session == true and is_overwriting ~= true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local last_session_load_count = profile.MetaData.SessionLoadCount
	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again
	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	while repeat_save_flag == true do
		if release_from_session ~= true then
			repeat_save_flag = false
		end
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			profile._profile_store,
			profile._profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local session_owns_profile = false
					local force_load_pending = false

					if is_overwriting ~= true then
						-- 1) Check if this session still owns the profile: --
						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
						end
						if type(force_load_session) == "table" then
							force_load_pending = not IsThisSession(force_load_session)
						end
					else
						session_owns_profile = true
					end

					if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile

						if is_overwriting ~= true then
							-- 2) Manage global updates: --
							local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							local latest_global_updates_list = latest_global_updates_data[2]

							local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
							local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
							local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
							-- Active update locking:
							for i = 1, #latest_global_updates_list do
								for _, lock_id in ipairs(pending_update_lock) do
									if latest_global_updates_list[i][1] == lock_id then
										latest_global_updates_list[i][3] = true
										break
									end
								end
							end
							-- Locked update clearing:
							for _, clear_id in ipairs(pending_update_clear) do
								for i = 1, #latest_global_updates_list do
									if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then
										table.remove(latest_global_updates_list, i)
										break
									end
								end
							end
						end

						-- 3) Save profile data: --
						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then
							latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
							latest_data.MetaData.LastUpdate = os.time()
							if release_from_session == true or force_load_pending == true then
								latest_data.MetaData.ActiveSession = nil
							end
						else
							latest_data.MetaData = profile.MetaData
							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil
							latest_data.GlobalUpdates = profile.GlobalUpdates._updates_latest
						end

					end
				end,
			},
			profile._is_user_mock
		)
		if loaded_data ~= nil and key_info ~= nil then
			if is_overwriting == true then
				break
			end
			repeat_save_flag = false
			-- 4) Set latest data in profile: --
			-- Updating DataStoreKeyInfo:
			profile.KeyInfo = key_info
			-- Setting global updates:
			local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
			local old_global_updates_data = global_updates_object._updates_latest
			local new_global_updates_data = loaded_data.GlobalUpdates
			global_updates_object._updates_latest = new_global_updates_data
			-- Setting MetaData:
			local session_meta_data = profile.MetaData
			local latest_meta_data = loaded_data.MetaData
			for key in pairs(SETTINGS.MetaTagsUpdatedValues) do
				session_meta_data[key] = latest_meta_data[key]
			end
			session_meta_data.MetaTagsLatest = latest_meta_data.MetaTags
			-- 5) Check if session still owns the profile: --
			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false
			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
			end
			local is_active = profile:IsActive()
			if session_owns_profile == true then
				-- 6) Check for new global updates: --
				if is_active == true then -- Profile could've been released before the saving thread finished
					CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
				end
			else
				-- Session no longer owns the profile:
				-- 7) Release profile if it hasn't been released yet: --
				if is_active == true then
					ReleaseProfileInternally(profile)
				end
				-- Cleanup reference in custom write queue:
				CustomWriteQueueMarkForCleanup(profile._profile_store._profile_store_lookup, profile._profile_key)
				-- Hop ready listeners:
				if profile._hop_ready == false then
					profile._hop_ready = true
					profile._hop_ready_listeners:Fire()
				end
			end
			-- Signaling MetaTagsUpdated listeners after a possible external profile release was handled:
			profile.MetaTagsUpdated:Fire(profile.MetaData.MetaTagsLatest)
			-- Signaling KeyInfoUpdated listeners:
			profile.KeyInfoUpdated:Fire(key_info)
		elseif repeat_save_flag == true then
			task.wait() -- Prevent infinite loop in case DataStore API does not yield
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
		
		_new_active_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		_new_locked_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		
		_profile = Profile / nil, -- [Profile / nil]
		
		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_active_update_listeners:Connect(listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_locked_update_listeners:Connect(listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]
		
		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]
		
		_release_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready = false,
		
		_view_mode = true / nil, -- [bool] or nil
		
		_load_timestamp = os.clock(),
		
		_is_user_mock = false, -- ProfileStore.Mock
		_mock_key_info = {},
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	local loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles
	return loaded_profiles[self._profile_key] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self._profile_store._profile_template)
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self:IsActive() == false then
		-- Call release listener immediately if profile is expired
		local place_id
		local game_job_id
		local active_session = self.MetaData.ActiveSession
		if active_session ~= nil then
			place_id = active_session[1]
			game_job_id = active_session[2]
		end
		listener(place_id, game_job_id)
		return {Disconnect = function() end}
	else
		return self._release_listeners:Connect(listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode - Should you be calling :OverwriteAsync() instead?")
	end
	if self:IsActive() == false then
		warn("[ProfileService]: Attempted saving an inactive profile "
			.. self:Identify() .. "; Traceback:\n" .. debug.traceback())
		return
	end
	-- Reject save request if a save is already pending in the queue - this will prevent the user from
	--	unecessary API request spam which we could not meaningfully execute anyways!
	if IsCustomWriteQueueEmptyFor(self._profile_store._profile_store_lookup, self._profile_key) == true then
		-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
		RemoveProfileFromAutoSave(self)
		AddProfileToAutoSave(self)
		-- Call save function in a new thread:
		task.spawn(SaveProfileAsync, self)
	end
end

function Profile:Release()
	if self._view_mode == true then
		return
	end
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true) -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:ListenToHopReady(listener) --> [ScriptConnection] ()
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToHopReady()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self._hop_ready == true then
		task.spawn(listener)
		return {Disconnect = function() end}
	else
		return self._hop_ready_listeners:Connect(listener)
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :AddUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end

	if user_id < 0 and self._is_user_mock ~= true and UseMockDataStore ~= true then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end
	
end

function Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :RemoveUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end
	
	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:Identify() --> [string]
	return IdentifyProfile(
		self._profile_store._profile_store_name,
		self._profile_store._profile_store_scope,
		self._profile_key
	)
end

function Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

	if self._view_mode ~= true then
		error("[ProfileService]: :ClearGlobalUpdates() can only be used in view mode")
	end

	local global_updates_object = {
		_updates_latest = {0, {}},
		_profile = self,
	}
	setmetatable(global_updates_object, GlobalUpdates)

	self.GlobalUpdates = global_updates_object

end

function Profile:OverwriteAsync() -- Saves the profile to the DataStore and removes the session lock

	if self._view_mode ~= true then
		error("[ProfileService]: :OverwriteAsync() can only be used in view mode")
	end

	SaveProfileAsync(self, nil, true)

end

-- ProfileVersionQuery object:

local ProfileVersionQuery = {
	--[[
		_profile_store = profile_store,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = pages, -- [DataStoreVersionPages]
		_query_index = index, -- [number]
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	--]]
}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery:_MoveQueue()
	while #self._query_queue > 0 do
		local queue_entry = table.remove(self._query_queue, 1)
		task.spawn(queue_entry)
		if self._is_query_yielded == true then
			break
		end
	end
end

function ProfileVersionQuery:NextAsync(_is_stacking) --> [Profile] or nil

	if self._profile_store == nil then
		return nil
	end

	local profile
	local is_finished = false

	local function query_job()

		if self._query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self._query_pages == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)
			
			local list_success, error_message = pcall(function()
				self._query_pages = self._profile_store._global_data_store:ListVersionsAsync(
					self._profile_key,
					self._sort_direction,
					self._min_date,
					self._max_date
				)
				self._query_index = 0
			end)

			if list_success == false or self._query_pages == nil then
				warn("[ProfileService]: Version query fail - " .. tostring(error_message))
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		local current_page = self._query_pages:GetCurrentPage()
		local next_item = current_page[self._query_index + 1]

		-- No more entries:
		
		if self._query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)

			local success = pcall(function()
				self._query_pages:AdvanceToNextPageAsync()
				self._query_index = 0
			end)

			if success == false or #self._query_pages:GetCurrentPage() == 0 then
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		-- Next page item:

		self._query_index += 1
		profile = self._profile_store:ViewProfileAsync(self._profile_key, next_item.Version)
		is_finished = true

	end

	if self._is_query_yielded == false then
		query_job()
	else
		if _is_stacking == true then
			table.insert(self._query_queue, 1, query_job)
		else
			table.insert(self._query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

-- ProfileStore object:

local ProfileStore = {
	--[[
		Mock = {},
	
		_profile_store_name = "", -- [string] -- DataStore name
		_profile_store_scope = nil, -- [string] or [nil] -- DataStore scope
		_profile_store_lookup = "", -- [string] -- _profile_store_name .. "\0" .. (_profile_store_scope or "")
		
		_profile_template = {}, -- [table]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
		
		_loaded_profiles = {[profile_key] = Profile, ...},
		_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
		
		_mock_loaded_profiles = {[profile_key] = Profile, ...},
		_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)

	not_released_handler = not_released_handler or "ForceLoad"

	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" and not_released_handler ~= "Steal" then
		error("[ProfileService]: Invalid not_released_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	local is_user_mock = _use_mock == UseMockTag

	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_lookup == self._profile_store_lookup then
			local loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
			if loaded_profiles[profile_key] ~= nil then
				error("[ProfileService]: Profile " .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) .. " is already loaded in this session")
				-- Are you using Profile:Release() properly?
			end
		end
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = not_released_handler == "ForceLoad"
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	local aggressive_steal = not_released_handler == "Steal" -- Developer invoked steal
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs
		local loaded_data, key_info
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = table.pack(StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									local last_update = latest_data.MetaData.LastUpdate
									if last_update ~= nil then
										if os.time() - last_update > SETTINGS.AssumeDeadSessionLock then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
											return
										end
									end
									if steal_session == true or aggressive_steal == true then
										local force_load_uninterrupted = false
										if force_load_session ~= nil then
											force_load_uninterrupted = IsThisSession(force_load_session)
										end
										if force_load_uninterrupted == true or aggressive_steal == true then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
										end
									elseif request_force_load == true then
										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
						}
					end,
					EditProfile = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							if active_session ~= nil and IsThisSession(active_session) == true then
								latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
								latest_data.MetaData.LastUpdate = os.time()
							end
						end
					end,
				},
				is_user_mock
			))
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},

						_new_active_update_listeners = Madwork.NewScriptSignal(),
						_new_locked_update_listeners = Madwork.NewScriptSignal(),

						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						MetaTagsUpdated = Madwork.NewScriptSignal(),

						RobloxMetaData = loaded_data.RobloxMetaData or {},
						UserIds = loaded_data.UserIds or {},
						KeyInfo = key_info,
						KeyInfoUpdated = Madwork.NewScriptSignal(),

						GlobalUpdates = global_updates_object,

						_profile_store = self,
						_profile_key = profile_key,

						_release_listeners = Madwork.NewScriptSignal(),
						_hop_ready_listeners = Madwork.NewScriptSignal(),
						_hop_ready = false,

						_load_timestamp = os.clock(),

						_is_user_mock = is_user_mock,
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					if is_user_mock == true then
						self._mock_loaded_profiles[profile_key] = profile
					else
						self._loaded_profiles[profile_key] = profile
					end
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if ProfileService.ServiceLocked == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							task.wait() -- Overload prevention
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					elseif aggressive_steal == true then
						task.wait() -- Overload prevention
					else
						local handler_result = not_released_handler(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							task.wait() -- Overload prevention
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							task.wait() -- Overload prevention
						elseif handler_result == "Steal" then
							aggressive_steal = true
							task.wait() -- Overload prevention
						else
							error(
								"[ProfileService]: Invalid return from not_released_handler (\"" .. tostring(handler_result) .. "\")(" .. type(handler_result) .. ");" ..
									"\n" .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) ..
									" Traceback:\n" .. debug.traceback()
							)
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely the ProfileService.ServiceLocked flag was raised
			end
		else
			task.wait() -- Overload prevention
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			},
			_use_mock == UseMockTag
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end

function ProfileStore:ViewProfileAsync(profile_key, version, _use_mock) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	if version ~= nil and (_use_mock == UseMockTag or UseMockDataStore == true) then
		return nil -- No version support in mock mode
	end

	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)
					latest_data.Data = DeepCopyTable(self._profile_template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {},
					}
				end,
				EditProfile = nil,
			},
			_use_mock == UseMockTag,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handle load_data:
		if loaded_data ~= nil then
			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates, -- {0, {}}
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				MetaTagsUpdated = Madwork.NewScriptSignal(),

				RobloxMetaData = loaded_data.RobloxMetaData or {},
				UserIds = loaded_data.UserIds or {},
				KeyInfo = key_info,
				KeyInfoUpdated = Madwork.NewScriptSignal(),

				GlobalUpdates = global_updates_object,

				_profile_store = self,
				_profile_key = profile_key,

				_view_mode = true,

				_load_timestamp = os.clock(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- If loop breaks return nothing
end

function ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date, _use_mock) --> [ProfileVersionQuery]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return setmetatable({}, ProfileVersionQuery) -- Silently fail :Next() requests
	end

	WaitForPendingProfileStore(self)

	if _use_mock == UseMockTag or UseMockDataStore == true then
		error("[ProfileService]: :ProfileVersionQuery() is not supported in mock mode")
	end

	-- Type check:
	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error("[ProfileService]: Invalid sort_direction (" .. tostring(sort_direction) .. ")")
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error("[ProfileService]: Invalid min_date (" .. tostring(min_date) .. ")")
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error("[ProfileService]: Invalid max_date (" .. tostring(max_date) .. ")")
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	local profile_version_query = {
		_profile_store = self,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = nil,
		_query_index = 0,
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	}
	setmetatable(profile_version_query, ProfileVersionQuery)

	return profile_version_query

end

function ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return false
	end

	WaitForPendingProfileStore(self)

	local wipe_status = false

	if _use_mock == UseMockTag then -- Used when the profile is accessed through ProfileStore.Mock
		local mock_data_store = UserMockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	elseif UseMockDataStore == true then -- Used when API access is disabled
		local mock_data_store = MockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	else
		wipe_status = pcall(function()
			self._global_data_store:RemoveAsync(profile_key)
		end)
	end

	CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)

	return wipe_status
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]

	local profile_store_name
	local profile_store_scope = nil

	-- Parsing profile_store_index:
	if type(profile_store_index) == "string" then
		-- profile_store_index as string:
		profile_store_name = profile_store_index
	elseif type(profile_store_index) == "table" then
		-- profile_store_index as table:
		profile_store_name = profile_store_index.Name
		profile_store_scope = profile_store_index.Scope
	else
		error("[ProfileService]: Invalid or missing profile_store_index")
	end

	-- Type checking:
	if profile_store_name == nil or type(profile_store_name) ~= "string" then
		error("[ProfileService]: Missing or invalid \"Name\" parameter")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: ProfileStore name cannot be an empty string")
	end

	if profile_store_scope ~= nil and (type(profile_store_scope) ~= "string" or string.len(profile_store_scope) == 0) then
		error("[ProfileService]: Invalid \"Scope\" parameter")
	end

	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end

	local profile_store
	profile_store = {
		Mock = {
			LoadProfileAsync = function(_, profile_key, not_released_handler)
				return profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)
			end,
			GlobalUpdateProfileAsync = function(_, profile_key, update_handler)
				return profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)
			end,
			ViewProfileAsync = function(_, profile_key, version)
				return profile_store:ViewProfileAsync(profile_key, version, UseMockTag)
			end,
			FindProfileVersionAsync = function(_, profile_key, sort_direction, min_date, max_date)
				return profile_store:FindProfileVersionAsync(profile_key, sort_direction, min_date, max_date, UseMockTag)
			end,
			WipeProfileAsync = function(_, profile_key)
				return profile_store:WipeProfileAsync(profile_key, UseMockTag)
			end
		},

		_profile_store_name = profile_store_name,
		_profile_store_scope = profile_store_scope,
		_profile_store_lookup = profile_store_name .. "\0" .. (profile_store_scope or ""),

		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
		_mock_loaded_profiles = {},
		_mock_profile_load_jobs = {},
		_is_pending = false,
	}
	setmetatable(profile_store, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if IsLiveCheckActive == true then
		profile_store._is_pending = true
		task.spawn(function()
			WaitForLiveAccessCheck()
			if UseMockDataStore == false then
				profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
			end
			profile_store._is_pending = false
		end)
	else
		if UseMockDataStore == false then
			profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
		end
	end

	return profile_store
end

function ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)

	WaitForLiveAccessCheck()

	return UseMockDataStore == false

end

----- Initialize -----

if IsStudio == true then
	IsLiveCheckActive = true
	task.spawn(function()
		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)
		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil
		if no_internet_access == true then
			warn("[ProfileService]: No internet access - check your network connection")
		end
		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			UseMockDataStore = true
			ProfileService._use_mock_data_store = true
			print("[ProfileService]: Roblox API services unavailable - data will not be saved")
		else
			print("[ProfileService]: Roblox API services available - data will be saved")
		end
		IsLiveCheckActive = false
	end)
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile._load_timestamp < SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = os.clock()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
task.spawn(function()
	WaitForLiveAccessCheck()
	Madwork.ConnectToOnClose(
		function()
			ProfileService.ServiceLocked = true
			-- 1) Release all active profiles: --
			-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
			local on_close_save_job_count = 0
			local active_profiles = {}
			for index, profile in ipairs(AutoSaveList) do
				active_profiles[index] = profile
			end
			-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
			for _, profile in ipairs(active_profiles) do
				if profile:IsActive() == true then
					on_close_save_job_count = on_close_save_job_count + 1
					task.spawn(function() -- Save profile on new thread
						SaveProfileAsync(profile, true)
						on_close_save_job_count = on_close_save_job_count - 1
					end)
				end
			end
			-- 2) Yield until all active profile jobs are finished: --
			while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
				task.wait()
			end
			return -- We're done!
		end,
		UseMockDataStore == false -- Always run this OnClose task if using Roblox API services
	)
end)

return ProfileService
--// END OF SCRIPT: game.ServerScriptService.Overseer.Modules.ProfileService

--------------------------------------------------------------------
--// [Script] Path: game.ServerScriptService.Overseer.Systems.LeanReplicator | Enabled: true
--------------------------------------------------------------------
--- @ Core System
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage.Peak.Remotes
local ReplicateLean = Remotes.ReplicateLean

--- @ Core System > Logic
ReplicateLean.OnServerEvent:Connect(function(player, bp, br, hp, hr)
	ReplicateLean:FireAllClients(player, bp, br, hp, hr)
end)
--// END OF SCRIPT: game.ServerScriptService.Overseer.Systems.LeanReplicator

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ServerScriptService.Stories.exampleStory.story | Enabled: N/A
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Types = require(ReplicatedStorage.Iris.PubTypes)

return function(parent: GuiObject)
    local Iris: Types.Iris = require(ReplicatedStorage.Iris)
    local Input = require(script.Parent.UserInputService)

    Input.SinkFrame.Parent = parent

    Iris.Internal._utility.UserInputService = Input
    Iris.UpdateGlobalConfig({
        UseScreenGUIs = false,
    })
    Iris.Internal._utility.GuiOffset = Input.SinkFrame.AbsolutePosition
    Iris.Internal._utility.MouseOffset = Input.SinkFrame.AbsolutePosition
    Input.SinkFrame:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
        Iris.Internal._utility.GuiOffset = Input.SinkFrame.AbsolutePosition
        Iris.Internal._utility.MouseOffset = Input.SinkFrame.AbsolutePosition
    end)

    Iris.Init(parent)

    -- Actual Iris code here:
    Iris:Connect(Iris.ShowDemoWindow)

    return function()
        Iris.Shutdown()

        for _, connection in Input._connections do
            connection:Disconnect()
        end

        Input.SinkFrame:Destroy()
    end
end

--// END OF SCRIPT: game.ServerScriptService.Stories.exampleStory.story

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ServerScriptService.Stories.UserInputService | Enabled: N/A
--------------------------------------------------------------------
local Signal = require(script.Signal)

local UserInputService: UserInputService = game:GetService("UserInputService")

local Input = {}

Input.X = 0
Input.Y = 0
Input.KeyDown = {}
Input._connections = {}

-- This frame will act as our UserInputService detector. Most events should go through it.
-- it's not perfect, but there's not a better alternative (I think)
local SinkFrame: Frame = Instance.new("Frame")
SinkFrame.Name = "SinkFrame"
SinkFrame.AnchorPoint = Vector2.new(0.5, 0.5)
SinkFrame.Position = UDim2.fromScale(0.5, 0.5)
SinkFrame.Size = UDim2.fromScale(1, 1)
SinkFrame.BackgroundTransparency = 1
SinkFrame.ZIndex = 1024 ^ 2

Input.SinkFrame = SinkFrame

-- Methods and events

Input.InputBegan = Signal.new()
Input.InputChanged = Signal.new()
Input.InputEnded = Signal.new()
Input.MouseMoved = Signal.new()
Input.TouchTapInWorld = Signal.new()

function Input:GetMouseLocation()
    return Vector2.new(Input.X, Input.Y)
end

function Input:IsKeyDown(keyCode: Enum.KeyCode)
    if Input.KeyDown[keyCode] == true then
        return true
    end
    return false
end

-- UserInputService hooks

function inputBegan(input: InputObject)
    Input.KeyDown[input.KeyCode] = true
    Input.InputBegan:Fire(input, true)
end

function inputChanged(input: InputObject)
    Input.InputChanged:Fire(input, true)
end

function inputEnded(input: InputObject)
    Input.KeyDown[input.KeyCode] = nil
    Input.InputEnded:Fire(input, true)
end

function mouseMoved(x: number, y: number)
    Input.X = x
    Input.Y = y
end

SinkFrame.InputBegan:Connect(inputBegan)
SinkFrame.InputChanged:Connect(inputChanged)
SinkFrame.InputEnded:Connect(inputEnded)
SinkFrame.MouseMoved:Connect(mouseMoved)

table.insert(Input._connections, UserInputService.InputBegan:Connect(inputBegan))
table.insert(Input._connections, UserInputService.InputChanged:Connect(inputChanged))
table.insert(Input._connections, UserInputService.InputEnded:Connect(inputEnded))

return Input

--// END OF SCRIPT: game.ServerScriptService.Stories.UserInputService

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ServerScriptService.Stories.UserInputService.Signal | Enabled: N/A
--------------------------------------------------------------------
--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
    local acquiredRunnerThread = freeRunnerThread
    freeRunnerThread = nil
    fn(...)
    -- The handler finished running, this runner thread is free again.
    freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
    -- Note: We cannot use the initial set of arguments passed to
    -- runEventHandlerInFreeThread for a call to the handler, because those
    -- arguments would stay on the stack for the duration of the thread's
    -- existence, temporarily leaking references. Without access to raw bytecode
    -- there's no way for us to clear the "..." references from the stack.
    while true do
        acquireRunnerThreadAndCallEventHandler(coroutine.yield())
    end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
    return setmetatable({
        _connected = true,
        _signal = signal,
        _fn = fn,
        _next = false,
    }, Connection)
end

function Connection:Disconnect()
    self._connected = false

    -- Unhook the node, but DON'T clear it. That way any fire calls that are
    -- currently sitting on this node will be able to iterate forwards off of
    -- it, but any subsequent fire calls will not hit it, and it will be GCed
    -- when no more fire calls are sitting on it.
    if self._signal._handlerListHead == self then
        self._signal._handlerListHead = self._next
    else
        local prev = self._signal._handlerListHead
        while prev and prev._next ~= self do
            prev = prev._next
        end
        if prev then
            prev._next = self._next
        end
    end
end

-- Make Connection strict
setmetatable(Connection, {
    __index = function(_, key)
        error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
    end,
    __newindex = function(_, key, _)
        error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
    end,
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
    return setmetatable({
        _handlerListHead = false,
    }, Signal)
end

function Signal:Connect(fn)
    local connection = Connection.new(self, fn)
    if self._handlerListHead then
        connection._next = self._handlerListHead
        self._handlerListHead = connection
    else
        self._handlerListHead = connection
    end
    return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
    self._handlerListHead = false
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
    local item = self._handlerListHead
    while item do
        if item._connected then
            if not freeRunnerThread then
                freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
                -- Get the freeRunnerThread to the first yield
                coroutine.resume(freeRunnerThread)
            end
            task.spawn(freeRunnerThread, item._fn, ...)
        end
        item = item._next
    end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
    local waitingCoroutine = coroutine.running()
    local cn
    cn = self:Connect(function(...)
        cn:Disconnect()
        task.spawn(waitingCoroutine, ...)
    end)
    return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
    local cn
    cn = self:Connect(function(...)
        if cn._connected then
            cn:Disconnect()
        end
        fn(...)
    end)
    return cn
end

-- Make signal strict
setmetatable(Signal, {
    __index = function(_, key)
        error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
    end,
    __newindex = function(_, key, _)
        error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
    end,
})

return Signal

--// END OF SCRIPT: game.ServerScriptService.Stories.UserInputService.Signal

--------------------------------------------------------------------
--// [ModuleScript] Path: game.ServerScriptService.Modules.SoundSystemModule | Enabled: N/A
--------------------------------------------------------------------
local SoundSystemModule = {}
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

-- CONFIGURATION
local MAX_HEAR_DISTANCE = 60 -- studs
local MIN_WAIT_TIME = 8
local MAX_WAIT_TIME = 20
local FADE_TIME = 2

-- Attachment names to check
local VALID_ATTACHMENT_NAMES = {
	["var_AmbientCreak"] = true,
	["var_AmbientCreakWood"] = true,
	["var_AmbientCreakMetal"] = true,
	
	["var_AmbientWolf"] = true,
	["var_AmbientCoyote"] = true,
	["var_AmbientBird"] = true,

	
	
	["var_AmbientScream"] = true,
	
	["var_AmbientWinterTree"] = true,
	["var_AmbientSummerTree"] = true,
	["var_AmbientTree"] = true,
}

-- Fade helper
local function fadeSound(sound: Sound, targetVolume: number, duration: number)
	local tween = TweenService:Create(sound, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { Volume = targetVolume })
	tween:Play()
	tween.Completed:Wait()
end

-- Check if any player is near the sound position
local function isPlayerNearby(position: Vector3)
	for _, player in ipairs(Players:GetPlayers()) do
		local char = player.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		if hrp and (hrp.Position - position).Magnitude <= MAX_HEAR_DISTANCE then
			return true
		end
	end
	return false
end

function SoundSystemModule.StartAmbientCreakSystem(searchScope: Instance)
	local attachments = {}

	for _, obj in ipairs(searchScope:GetDescendants()) do
		if obj:IsA("Attachment") and VALID_ATTACHMENT_NAMES[obj.Name] then
			table.insert(attachments, obj)
		end
	end

	print("[SoundSystemModule] Found", #attachments, "ambient creak attachments")

	for _, attachment in ipairs(attachments) do
		task.spawn(function()
			while attachment.Parent do
				task.wait(math.random(MIN_WAIT_TIME, MAX_WAIT_TIME))

				-- Skip if no players are near
				if not isPlayerNearby(attachment.WorldPosition) then
					continue
				end

				-- Gather sounds inside this attachment
				local availableSounds = {}
				for _, child in ipairs(attachment:GetChildren()) do
					if child:IsA("Sound") then
						table.insert(availableSounds, child)
					end
				end

				if #availableSounds == 0 then
					continue
				end

				-- Pick and play one random sound
				local randomSound = availableSounds[math.random(1, #availableSounds)]
				if not randomSound.IsPlaying then
					local targetVolume = randomSound:GetAttribute("TargetVolume") or 0.6
					randomSound.Volume = 0
					randomSound:Play()
					fadeSound(randomSound, targetVolume, FADE_TIME)

					-- Wait until sound finishes
					randomSound.Ended:Wait()

					-- Fade out smoothly
					fadeSound(randomSound, 0, FADE_TIME)
					randomSound:Stop()
				end
			end
		end)
	end
end

return SoundSystemModule

--// END OF SCRIPT: game.ServerScriptService.Modules.SoundSystemModule

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script | Enabled: true
--------------------------------------------------------------------
local part = script.Parent

part.Material = Enum.Material.ForceField
part.Transparency = -math.huge

script:Destroy()
--// END OF SCRIPT: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script | Enabled: true
--------------------------------------------------------------------
local part = script.Parent

part.Material = Enum.Material.ForceField
part.Transparency = -math.huge

script:Destroy()
--// END OF SCRIPT: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script | Enabled: true
--------------------------------------------------------------------
local part = script.Parent

part.Material = Enum.Material.ForceField
part.Transparency = -math.huge

script:Destroy()
--// END OF SCRIPT: game.ServerStorage.Maps.Bookstore.Invi [trimmed]  -  Edit
  14:15:02.418  --------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script | Enabled: true
--------------------------------------------------------------------
local part = script.Parent

part.Material = Enum.Material.ForceField
part.Transparency = -math.huge

script:Destroy()
--// END OF SCRIPT: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script | Enabled: true
--------------------------------------------------------------------
local part = script.Parent

part.Material = Enum.Material.ForceField
part.Transparency = -math.huge

script:Destroy()
--// END OF SCRIPT: game.ServerStorage.Maps.Bookstore.Invisible Shadows / Contour Shadows.Invisible Shadow.Script

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerStorage.Test Area.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.ServerStorage.Test Area.Rig.Animate

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerStorage.Test Area.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.ServerStorage.Test Area.Rig.Animate

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerStorage.Test Area.IMPORTED ASSETS FROM REARMED.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.ServerStorage.Test Area.IMPORTED ASSETS FROM REARMED.Rig.Animate

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerStorage.Test Area.Folder.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.ServerStorage.Test Area.Folder.Rig.Animate

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerStorage.Test Area.Folder.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.ServerStorage.Test Area.Folder.Rig.Animate

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerStorage.Test Area.Folder.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



--// END OF SCRIPT: game.ServerStorage.Test Area.Folder.Rig.Animate

--------------------------------------------------------------------
--// [LocalScript] Path: game.ServerStorage.Test Area.Folder.Rig.Animate | Enabled: true
--------------------------------------------------------------------
-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh =  [trimmed]  -  Edit
  14:15:02.875  --------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Target.Respawn | Enabled: true
--------------------------------------------------------------------
name="Humanoid"
robo=script.Parent:clone()
while true do
	wait(4)
	if script.Parent.Humanoid.Health<1 then
		robot=robo:clone()
		robot.Parent=script.Parent.Parent
		robot:makeJoints()
		script.Parent:remove()
	end
end

		






--// END OF SCRIPT: game.ServerStorage.Test Area.Target.Respawn

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Target.Robot | Enabled: true
--------------------------------------------------------------------
model = script.Parent
backup = model:Clone()
regentime = 1 --5 minutes

------------------
--SPAWNING--
------------------

miked=script.Parent

itlh=miked.Torso:findFirstChild("Left Hip")
itlh.Part0=miked.Torso
itlh.Part1=miked:findFirstChild("Left Leg")
itlh.C0=CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)

itrh=miked.Torso:findFirstChild("Right Hip")
itrh.Part0=miked.Torso
itrh.Part1=miked:findFirstChild("Right Leg")
itrh.C0=CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)

itls=miked.Torso:findFirstChild("Left Shoulder")
itls.Part1=miked.Torso
itls.C0=CFrame.new(2, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
itls.Part0=miked:findFirstChild("Left Arm")

itrs=miked.Torso:findFirstChild("Right Shoulder")
itrs.Part1=miked.Torso
itrs.C0=CFrame.new(-2, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
itrs.Part0=miked:findFirstChild("Right Arm")

miked.Head:makeJoints()
------------------
------------------


function waitForChild(parent, childName)
	while true do
		local child = parent:findFirstChild(childName)
		if child then
			return child
		end
		parent.ChildAdded:wait()
	end
end

local Figure = script.Parent
local Torso = waitForChild(Figure, "Torso")
local RightShoulder = waitForChild(Torso, "Right Shoulder")
local LeftShoulder = waitForChild(Torso, "Left Shoulder")
local RightHip = waitForChild(Torso, "Right Hip")
local LeftHip = waitForChild(Torso, "Left Hip")
local Neck = waitForChild(Torso, "Neck")
local Humanoid = waitForChild(Figure, "Zombie")
local pose = "Standing"

local toolAnim = "None"
local toolAnimTime = 0

local isSeated = false


function onRunning(speed)
	if isSeated then return end

	if speed>0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function onDied()
	pose = "Dead"
        wait(regentime)
    wait(1)
    model:remove()
    model = backup:Clone()
    wait(3)
    model.Parent = game.Workspace
    model:MakeJoints()
end

function onJumping()
	isSeated = false
	pose = "Jumping"
end

function onClimbing()
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	pose = "FreeFall"
end

function onDancing()
	pose = "Dancing"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	isSeated = true
	pose = "Seated"
end



function moveJump()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -3.14
	LeftShoulder.DesiredAngle = -3.14
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function moveFreeFall()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1
	LeftShoulder.DesiredAngle = -1
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function moveFloat()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1.57
	LeftShoulder.DesiredAngle = 1.57
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = -1.57
end

function moveBoogy()
while pose=="Boogy" do
	wait(.5)
	RightShoulder.MaxVelocity = 1
	LeftShoulder.MaxVelocity = 1
	RightShoulder.DesiredAngle = -3.14
	LeftShoulder.DesiredAngle = 0
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = 0
	wait(.5)
	RightShoulder.MaxVelocity = 1
	LeftShoulder.MaxVelocity = 1
	RightShoulder.DesiredAngle = 0
	LeftShoulder.DesiredAngle = -3.14
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 1.57
end
end

function moveZombie()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1.57
	LeftShoulder.DesiredAngle = 1.57
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function movePunch()
	script.Parent.Torso.Anchored=true
	RightShoulder.MaxVelocity = 60
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1.57
	LeftShoulder.DesiredAngle = 0
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
wait(1)
script.Parent.Torso.Anchored=false
pose="Standing"

end

function moveKick()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 0
	LeftShoulder.DesiredAngle = 0
	RightHip.MaxVelocity = 40
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = 0
wait(1)
pose="Standing"

end

function moveFly()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 0
	LeftShoulder.DesiredAngle = 0
	RightHip.MaxVelocity = 40
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = 0
wait(1)
pose="Standing"

end


function moveClimb()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -3.14
	LeftShoulder.DesiredAngle = 3.14
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder.DesiredAngle = -3.14 /2
	LeftShoulder.DesiredAngle = -3.14 /2
	RightHip.DesiredAngle = 3.14 /2
	LeftHip.DesiredAngle = -3.14 /2
end

function getTool()
	
	kidTable = Figure:children()
	if (kidTable ~= nil) then
		numKids = #kidTable
		for i=1,numKids do
			if (kidTable[i].className == "Tool") then return kidTable[i] end
		end
	end
	
	return nil
end

function getToolAnim(tool)

	c = tool:children()
	for i=1,#c do
		if (c[i].Name == "toolanim" and c[i].className == "StringValue") then
			return c[i]
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		RightShoulder.DesiredAngle = -1.57
		return
	end

	if (toolAnim == "Slash") then
		RightShoulder.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = 0
		return
	end

	if (toolAnim == "Lunge") then
		RightShoulder.MaxVelocity = 0.5
		LeftShoulder.MaxVelocity = 0.5
		RightHip.MaxVelocity = 0.5
		LeftHip.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = -1.57
		LeftShoulder.DesiredAngle = 1.0
		RightHip.DesiredAngle = 1.57
		LeftHip.DesiredAngle = 1.0
		return
	end
end

function move(time)
	local amplitude
	local frequency

	if (pose == "Jumping") then
		moveJump()
		return
	end

	if (pose == "Zombie") then
		moveZombie()
		return
	end

	if (pose == "Boogy") then
		moveBoogy()
		return
	end

	if (pose == "Float") then
		moveFloat()
		return
	end

	if (pose == "Punch") then
		movePunch()
		return
	end

	if (pose == "Kick") then
		moveKick()
		return
	end

	if (pose == "Fly") then
		moveFly()
		return
	end

	if (pose == "FreeFall") then
		moveFreeFall()
		return
	end

	if (pose == "Climbing") then
		moveClimb()
		return
	end

	if (pose == "Seated") then
		moveSit()
		return
	end

		amplitude = 0.1
		frequency = 1

	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	if (pose == "Running") then
		amplitude = 1
		frequency = 9
	elseif (pose == "Dancing") then
		amplitude = 2
		frequency = 16
	end


	desiredAngle = amplitude * math.sin(time*frequency)
	if pose~="Dancing" then
		RightShoulder.DesiredAngle = -desiredAngle
		LeftShoulder.DesiredAngle = desiredAngle
		RightHip.DesiredAngle = -desiredAngle
		LeftHip.DesiredAngle = -desiredAngle
	else
		RightShoulder.DesiredAngle = desiredAngle
		LeftShoulder.DesiredAngle = desiredAngle
		RightHip.DesiredAngle = -desiredAngle
		LeftHip.DesiredAngle = -desiredAngle
	end
		


	local tool = getTool()

	if tool ~= nil then
	
		animStringValueObject = getToolAnim(tool)

		if animStringValueObject ~= nil then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()

		
	else
		toolAnim = "None"
		toolAnimTime = 0
	end
end


-- connect events
-----------------------------------------------------------------------------------------------------------------------

function unequip()
	local items=script.Parent:children()
	for i=1, #items do
		if items[i].className=="Tool" then items[i]:remove() end
	end
end

function onChatted(msg, recipient) 
	msg = string.lower(msg)

	if string.match(msg, string.lower(script.Parent.Name))~=nil or string.match(msg, "everyone") then
		if string.match(msg, "equip") then 
			if game.Workspace:findFirstChild("Hub") then
				if string.match(msg, "rocket") then unequip()
					game.Workspace.Hub.Rocket:clone().Parent=script.Parent
				elseif string.match(msg, "slingshot") then unequip()
					game.Workspace.Hub.Slingshot:clone().Parent=script.Parent
				elseif string.match(msg, "sword") then unequip()
					game.Workspace.Hub.Sword:clone().Parent=script.Parent
				elseif string.match(msg, "pbg") then unequip()
					game.Workspace.Hub.PBG:clone().Parent=script.Parent
				elseif string.match(msg, "superball") then unequip()
					game.Workspace.Hub.Superball:clone().Parent=script.Parent
				elseif string.match(msg, "trowel") then unequip()
					game.Workspace.Hub.Trowel:clone().Parent=script.Parent
				elseif string.match(msg, "bomb") then unequip()
					game.Workspace.Hub.Bomb:clone().Parent=script.Parent
				end
			end
		end
		if string.match(msg, "unequip") then unequip() end
		if string.match(msg, "run") then onRunning(1) end
		if string.match(msg, "climb") then onClimbing() end
		if string.match(msg, "jump") then onJumping() end
		if string.match(msg, "zombie") then pose="Zombie" end
		if string.match(msg, "disco") then pose="Boogy" end
		if string.match(msg, "float") then pose="Float" end
		if string.match(msg, "punch") then pose="Punch" end
		if string.match(msg, "kick") then pose="Kick" end
		if string.match(msg, "fly") then pose="Fly" end
		if string.match(msg, "heal") then script.Parent.Humanoid.Health=script.Parent.Humanoid.MaxHealth end
		if string.match(msg, "defend") then defence() end
		if string.match(msg, "stop") then pose="Standing"; proxkill=false; following=false; stopmoving() end
		if string.match(msg, "go home") then following=false; gohome() end
		if string.match(msg, "follow") then
			if string.match(msg, "all") then
				followany()
			else
				local egg=game.Players:children()
				for i=1, #egg do
					if string.match(msg, string.lower(egg[i].Name)) then
						follow(egg[i].Name)
						return
					end
				end
			end
		end
		if string.match(msg, "kill") then
			if string.match(msg, "all") then
				attackany()
			else
				local egg=game.Players:children()
				for i=1, #egg do
					if string.match(msg, string.lower(egg[i].Name)) then
						attack(egg[i].Name)
						return
					end
				end
			end
		end

	end
end

if game.Players.NumPlayers>1 then
	x=game.Players:children()
	
	for i=1, #x do
		if script.Parent:findFirstChild("Commander")~=nil then
			if script.Parent.Commander:children()~=nil or script.Parent.Commander:children()>0 then
				local ch=script.Parent.Commander:children()
				for i=1, #ch do
					if string.lower(ch[i].Name)==string.lower(x[i].Name) then
						x[i].Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
					end
				end
			elseif string.lower(script.Parent.Commander.Value)==string.lower(x[i].Name) then
				x[i].Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
			end
		else
			x[i].Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end)
		end
	end
end


function onPlayerEntered(Player) 
	while Player.Name==nil do
		wait(2)
	end
	if script.Parent:findFirstChild("Commander")~=nil then
		if script.Parent.Commander:children()~=nil or script.Parent.Commander:children()>0 then
			local ch=script.Parent.Commander:children()
			for i=1, #ch do
				if string.lower(ch[i].Name)==string.lower(Player.Name) then
					Player.Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
				end
			end
		elseif string.lower(script.Parent.Commander.Value)==string.lower(Player.Name) then
			Player.Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
		end
	else
		Player.Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end)
	end
end

game.Players.ChildAdded:connect(onPlayerEntered) 



-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
dist=20

function followany()
following=true
	while following==true do

		local ch=game.Players:children()
		for i=1, #ch do
			local l=game.Workspace:findFirstChild(ch[i].Name)
			if l~=nil then
				local s=l.Torso
				local p=l.Torso.Position
				local q=script.Parent.Torso.Position
				local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
				if smallest==nil then
					smallest=d
					target=s
				elseif d<smallest then
					smallest=d
					target=s
				end
			end
		end

		if smallest==nil then stopmoving() return end
		
		if smallest>6*dist then return end
		
		script.Parent.Humanoid:MoveTo(target.Position, target)

		wait(0.5)
		for i=1, 6 do
			if target.Parent.Humanoid.Health<1 then stopmoving() else	wait(0.5) end
		end
	end
end



function gohome()
	script.Parent.Humanoid:MoveTo(Vector3.new(0,0,0), game.Workspace.Bases.Base)
end
function stopmoving()
	script.Parent.Humanoid:MoveTo(script.Parent.Torso.Position, script.Parent.Torso)
end

function follow(name)
	following=true

	local p=game.Workspace:findFirstChild(name)
	if p==nil then return end
	while following==true do	
		script.Parent.Humanoid:MoveTo(p.Torso.Position, p.Torso)
		wait(0.5)
		for i=1, 3 do
			if p.Humanoid.Health<1 then following=false; stopmoving() return end
			wait(0.5)
		end
	end
end

function attack(name)
	if script.Parent:findFirstChild("Sword")~=nil then	
		following=true
		local p=game.Workspace:findFirstChild(name)
		if p==nil then return end
		while following==true do
			script.Parent.Humanoid:MoveTo(p.Torso.Position, p.Torso)
			wait(0.5)
			for i=1, 3 do
				if p.Humanoid.Health<1 then following=false; stopmoving() return end
				local l=p.Torso.Position
				local q=script.Parent.Torso.Position
				local d=math.sqrt( ((l.x-q.x)^2)+((l.y-q.y)^2)+((l.z-q.z)^2) )
				if d<10 then
					script.Parent.Humanoid:MoveTo(p.Torso.Position, p.Torso); slash()
					if (q.y-l.y)>3 and (q.y-l.y)<7 then
						script.Parent.Humanoid:MoveTo(p.Torso.Position+Vector3.new(math.random(-4,4),0,math.random(-4,4)), p.Torso);
					end
				end
				wait(1)
			end
		end
	end
end

function attackany()
if script.Parent:findFirstChild("Sword")~=nil then	

	following=true
		while following==true do

			local ch=game.Players:children()
			for i=1, #ch do
				local l=game.Workspace:findFirstChild(ch[i].Name)
				if l~=nil then
					local s=l.Torso
					local p=l.Torso.Position
					local q=script.Parent.Torso.Position
					local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
					if smallest==nil then
						smallest=d
						target=s
					elseif d<smallest then
						smallest=d
						target=s
					end
				end
			end

			if smallest==nil then stopmoving() return end
			
			if smallest>6*dist then return end
			
			script.Parent.Humanoid:MoveTo(target.Position, target)

			if smallest<10 then
				slash()
			end
			if target.Parent==nil then stopmoving() return end
			wait(0.5)
			for i=1, 3 do
				if target.Parent.Humanoid.Health<1 then 
					stopmoving() 
				else
					local p=target.Position
					local q=script.Parent.Torso.Position
					local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
					if d<10 then
						script.Parent.Humanoid:MoveTo(target.Position, target); slash()
						if (q.y-p.y)>3 and (q.y-p.y)<7 then
							script.Parent.Humanoid:MoveTo(p.Torso.Position+Vector3.new(math.random(-4,4),0,math.random(-4,4)), p.Torso);
						end
					end
					wait(1)
				end
			end
		end
	end
end


function patrol()
	if points==nil then
		points=0
		if game.Workspace:findFirstChild("pp1")~=nil then
		pp1=game.Workspace:findFirstChild("pp1")
		local points=points+1
			if game.Workspace:findFirstChild("pp2")~=nil then
			pp2=game.Workspace:findFirstChild("pp2")
		local points=points+1
				if game.Workspace:findFirstChild("pp3")~=nil then
				pp3=game.Workspace:findFirstChild("pp3")
		local points=points+1
					if game.Workspace:findFirstChild("pp4")~=nil then
					pp4=game.Workspace:findFirstChild("pp4")
		local points=points+1
						if game.Workspace:findFirstChild("pp5")~=nil then
						pp5=game.Workspace:findFirstChild("pp5")
		local points=points+1
							if game.Workspace:findFirstChild("pp6")~=nil then
							pp6=game.Workspace:findFirstChild("pp6")
		local points=points+1
								if game.Workspace:findFirstChild("pp7")~=nil then
								pp7=game.Workspace:findFirstChild("pp7")
		local points=points+1
									if game.Workspace:findFirstChild("pp8")~=nil then
									pp8=game.Workspace:findFirstChild("pp8")
		local points=points+1
										if game.Workspace:findFirstChild("pp9")~=nil then
										pp9=game.Workspace:findFirstChild("pp9")
		local points=points+1
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end

	if points<1 then return end
	patrolling=true
	local time=2
	if points==1 then return end
	if points>1 then
		while patrolling==true do
			script.Parent.Humanoid:MoveTo(pp1.Position, pp1)
			wait(time)
			script.Parent.Humanoid:MoveTo(pp2.Position, pp2)
			wait(time)
			if points>2 then
				script.Parent.Humanoid:MoveTo(pp3.Position, pp3)
				wait(time)
				if points>3 then
					script.Parent.Humanoid:MoveTo(pp4.Position, pp4)
					wait(time)
					if points>4 then
						script.Parent.Humanoid:MoveTo(pp5.Position, pp5)
						wait(time)
						if points>5 then
							script.Parent.Humanoid:MoveTo(pp6.Position, pp6)
							wait(time)
							if points>6 then
								script.Parent.Humanoid:MoveTo(pp7.Position, pp7)
								wait(time)
								if points>7 then
									script.Parent.Humanoid:MoveTo(pp8.Position, pp8)
									wait(time)
									if points>8 then
										script.Parent.Humanoid:MoveTo(pp9.Position, pp9)
										wait(time)
									end
								end
							end
						end
					end
				end
			end
		end
	end
end


function goto(pos,part)
while true do
end
end


function slash()
	for i=1, 3 do
		wait(.3)
		RightShoulder.MaxVelocity = 2
		LeftShoulder.MaxVelocity = 1
		RightShoulder.DesiredAngle = -2.14
		LeftShoulder.DesiredAngle = 0
		RightHip.DesiredAngle = 0
		LeftHip.DesiredAngle = 0
		wait(.2)
		RightShoulder.MaxVelocity = 2
		LeftShoulder.MaxVelocity = 1
		RightShoulder.DesiredAngle = 0
		LeftShoulder.DesiredAngle = 0
		RightHip.DesiredAngle = 0
		LeftHip.DesiredAngle = 0
	end
end

function defence()
	proxkill=true
	while proxkill==true do
		local ch=game.Players:children()
		for i=1, #ch do
			local p=game.Workspace:findFirstChild(ch[i].Name)
			if p~=nil then
				local p=p.Torso.Position
				local q=script.Parent.Torso.Position
				local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
				if d<dist and d>8 then
					local ex=Instance.new("Explosion")
					ex.Position=p
					ex.Parent=game.Workspace
				end
			end		
		end
		wait(1)
	end
end




-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------


Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)


--[[

function newSound(id)
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.Parent = script.Parent.Head
	return sound
end


local sDied = newSound("rbxasset://sounds/uuhhh.wav")
local sFallingDown = newSound("rbxasset://sounds/splat.wav")
local sFreeFalling = newSound("rbxasset://sounds/swoosh.wav")
local sGettingUp = newSound("rbxasset://sounds/hit.wav")
local sJumping = newSound("rbxasset://sounds/button.wav")
local sRunning = newSound("rbxasset://sounds/bfsl-minifigfoots1.mp3")
sRunning.Looped = true

local Figure = script.Parent
local Head = waitForChild(Figure, "Head")
local Humanoid = waitForChild(Figure, "Humanoid")


function onDied()
	sDied:play()
end

function onState(state, sound)
	if state then
		sound:play()
	else
		sound:pause()
	end
end

function onRunning(speed)
	if speed>0 then
		sRunning:play()
	else
		sRunning:pause()
	end
end


Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(function(state) onState(state, sJumping) end)
Humanoid.GettingUp:connect(function(state) onState(state, sGettingUp) end)
Humanoid.FreeFalling:connect(function(state) onState(state, sFreeFalling) end)
Humanoid.FallingDown:connect(function(state) onState(state, sFallingDown) end)
--]]

local nextTime = 0
local runService = game:service("RunService");

while Figure.Parent~=nil do
	time = runService.Stepped:wait()
	if time > nextTime then
		move(time)
		nextTime = time + 0.1
	end
end

--// END OF SCRIPT: game.ServerStorage.Test Area.Target.Robot

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Target.Weld Script | Enabled: true
--------------------------------------------------------------------
local p=script.Parent:GetChildren()
for i=1,#p do 
if p[i].className=="Part" then 

	local weld = Instance.new("Weld") 
        weld.Name="Hold"
	weld.Part0 = p[i]
	weld.Part1 = script.Parent.Parent.Torso

	local HitPos = p[i].Position + (p[i].CFrame.lookVector * .5) 

	local CJ = CFrame.new(HitPos) 
	local C0 = p[i].CFrame:inverse() *CJ 
	local C1 = script.Parent.Parent.Torso.CFrame:inverse() * CJ 

	weld.C0 = C0 
	weld.C1 = C1 

	weld.Parent = p[i]
end
end 
--// END OF SCRIPT: game.ServerStorage.Test Area.Target.Weld Script

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Target.Respawn | Enabled: true
--------------------------------------------------------------------
name="Humanoid"
robo=script.Parent:clone()
while true do
	wait(4)
	if script.Parent.Humanoid.Health<1 then
		robot=robo:clone()
		robot.Parent=script.Parent.Parent
		robot:makeJoints()
		script.Parent:remove()
	end
end

		






--// END OF SCRIPT: game.ServerStorage.Test Area.Target.Respawn

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Target.Robot | Enabled: true
--------------------------------------------------------------------
model = script.Parent
backup = model:Clone()
regentime = 1 --5 minutes

------------------
--SPAWNING--
------------------

miked=script.Parent

itlh=miked.Torso:findFirstChild("Left Hip")
itlh.Part0=miked.Torso
itlh.Part1=miked:findFirstChild("Left Leg")
itlh.C0=CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)

itrh=miked.Torso:findFirstChild("Right Hip")
itrh.Part0=miked.Torso
itrh.Part1=miked:findFirstChild("Right Leg")
itrh.C0=CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)

itls=miked.Torso:findFirstChild("Left Shoulder")
itls.Part1=miked.Torso
itls.C0=CFrame.new(2, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
itls.Part0=miked:findFirstChild("Left Arm")

itrs=miked.Torso:findFirstChild("Right Shoulder")
itrs.Part1=miked.Torso
itrs.C0=CFrame.new(-2, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
itrs.Part0=miked:findFirstChild("Right Arm")

miked.Head:makeJoints()
------------------
------------------


function waitForChild(parent, childName)
	while true do
		local child = parent:findFirstChild(childName)
		if child then
			return child
		end
		parent.ChildAdded:wait()
	end
end

local Figure = script.Parent
local Torso = waitForChild(Figure, "Torso")
local RightShoulder = waitForChild(Torso, "Right Shoulder")
local LeftShoulder = waitForChild(Torso, "Left Shoulder")
local RightHip = waitForChild(Torso, "Right Hip")
local LeftHip = waitForChild(Torso, "Left Hip")
local Neck = waitForChild(Torso, "Neck")
local Humanoid = waitForChild(Figure, "Zombie")
local pose = "Standing"

local toolAnim = "None"
local toolAnimTime = 0

local isSeated = false


function onRunning(speed)
	if isSeated then return end

	if speed>0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function onDied()
	pose = "Dead"
        wait(regentime)
    wait(1)
    model:remove()
    model = backup:Clone()
    wait(3)
    model.Parent = game.Workspace
    model:MakeJoints()
end

function onJumping()
	isSeated = false
	pose = "Jumping"
end

function onClimbing()
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	pose = "FreeFall"
end

function onDancing()
	pose = "Dancing"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	isSeated = true
	pose = "Seated"
end



function moveJump()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -3.14
	LeftShoulder.DesiredAngle = -3.14
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function moveFreeFall()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1
	LeftShoulder.DesiredAngle = -1
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function moveFloat()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1.57
	LeftShoulder.DesiredAngle = 1.57
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = -1.57
end

function moveBoogy()
while pose=="Boogy" do
	wait(.5)
	RightShoulder.MaxVelocity = 1
	LeftShoulder.MaxVelocity = 1
	RightShoulder.DesiredAngle = -3.14
	LeftShoulder.DesiredAngle = 0
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = 0
	wait(.5)
	RightShoulder.MaxVelocity = 1
	LeftShoulder.MaxVelocity = 1
	RightShoulder.DesiredAngle = 0
	LeftShoulder.DesiredAngle = -3.14
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 1.57
end
end

function moveZombie()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1.57
	LeftShoulder.DesiredAngle = 1.57
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function movePunch()
	script.Parent.Torso.Anchored=true
	RightShoulder.MaxVelocity = 60
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -1.57
	LeftShoulder.DesiredAngle = 0
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
wait(1)
script.Parent.Torso.Anchored=false
pose="Standing"

end

function moveKick()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 0
	LeftShoulder.DesiredAngle = 0
	RightHip.MaxVelocity = 40
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = 0
wait(1)
pose="Standing"

end

function moveFly()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 0
	LeftShoulder.DesiredAngle = 0
	RightHip.MaxVelocity = 40
	RightHip.DesiredAngle = 1.57
	LeftHip.DesiredAngle = 0
wait(1)
pose="Standing"

end


function moveClimb()
	RightShoulder.MaxVelocity = 0.5
	LeftShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = -3.14
	LeftShoulder.DesiredAngle = 3.14
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder.DesiredAngle = -3.14 /2
	LeftShoulder.DesiredAngle = -3.14 /2
	RightHip.DesiredAngle = 3.14 /2
	LeftHip.DesiredAngle = -3.14 /2
end

function getTool()
	
	kidTable = Figure:children()
	if (kidTable ~= nil) then
		numKids = #kidTable
		for i=1,numKids do
			if (kidTable[i].className == "Tool") then return kidTable[i] end
		end
	end
	
	return nil
end

function getToolAnim(tool)

	c = tool:children()
	for i=1,#c do
		if (c[i].Name == "toolanim" and c[i].className == "StringValue") then
			return c[i]
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		RightShoulder.DesiredAngle = -1.57
		return
	end

	if (toolAnim == "Slash") then
		RightShoulder.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = 0
		return
	end

	if (toolAnim == "Lunge") then
		RightShoulder.MaxVelocity = 0.5
		LeftShoulder.MaxVelocity = 0.5
		RightHip.MaxVelocity = 0.5
		LeftHip.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = -1.57
		LeftShoulder.DesiredAngle = 1.0
		RightHip.DesiredAngle = 1.57
		LeftHip.DesiredAngle = 1.0
		return
	end
end

function move(time)
	local amplitude
	local frequency

	if (pose == "Jumping") then
		moveJump()
		return
	end

	if (pose == "Zombie") then
		moveZombie()
		return
	end

	if (pose == "Boogy") then
		moveBoogy()
		return
	end

	if (pose == "Float") then
		moveFloat()
		return
	end

	if (pose == "Punch") then
		movePunch()
		return
	end

	if (pose == "Kick") then
		moveKick()
		return
	end

	if (pose == "Fly") then
		moveFly()
		return
	end

	if (pose == "FreeFall") then
		moveFreeFall()
		return
	end

	if (pose == "Climbing") then
		moveClimb()
		return
	end

	if (pose == "Seated") then
		moveSit()
		return
	end

		amplitude = 0.1
		frequency = 1

	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	if (pose == "Running") then
		amplitude = 1
		frequency = 9
	elseif (pose == "Dancing") then
		amplitude = 2
		frequency = 16
	end


	desiredAngle = amplitude * math.sin(time*frequency)
	if pose~="Dancing" then
		RightShoulder.DesiredAngle = -desiredAngle
		LeftShoulder.DesiredAngle = desiredAngle
		RightHip.DesiredAngle = -desiredAngle
		LeftHip.DesiredAngle = -desiredAngle
	else
		RightShoulder.DesiredAngle = desiredAngle
		LeftShoulder.DesiredAngle = desiredAngle
		RightHip.DesiredAngle = -desiredAngle
		LeftHip.DesiredAngle = -desiredAngle
	end
		


	local tool = getTool()

	if tool ~= nil then
	
		animStringValueObject = getToolAnim(tool)

		if animStringValueObject ~= nil then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()

		
	else
		toolAnim = "None"
		toolAnimTime = 0
	end
end


-- connect events
-----------------------------------------------------------------------------------------------------------------------

function unequip()
	local items=script.Parent:children()
	for i=1, #items do
		if items[i].className=="Tool" then items[i]:remove() end
	end
end

function onChatted(msg, recipient) 
	msg = string.lower(msg)

	if string.match(msg, string.lower(script.Parent.Name))~=nil or string.match(msg, "everyone") then
		if string.match(msg, "equip") then 
			if game.Workspace:findFirstChild("Hub") then
				if string.match(msg, "rocket") then unequip()
					game.Workspace.Hub.Rocket:clone().Parent=script.Parent
				elseif string.match(msg, "slingshot") then unequip()
					game.Workspace.Hub.Slingshot:clone().Parent=script.Parent
				elseif string.match(msg, "sword") then unequip()
					game.Workspace.Hub.Sword:clone().Parent=script.Parent
				elseif string.match(msg, "pbg") then unequip()
					game.Workspace.Hub.PBG:clone().Parent=script.Parent
				elseif string.match(msg, "superball") then unequip()
					game.Workspace.Hub.Superball:clone().Parent=script.Parent
				elseif string.match(msg, "trowel") then unequip()
					game.Workspace.Hub.Trowel:clone().Parent=script.Parent
				elseif string.match(msg, "bomb") then unequip()
					game.Workspace.Hub.Bomb:clone().Parent=script.Parent
				end
			end
		end
		if string.match(msg, "unequip") then unequip() end
		if string.match(msg, "run") then onRunning(1) end
		if string.match(msg, "climb") then onClimbing() end
		if string.match(msg, "jump") then onJumping() end
		if string.match(msg, "zombie") then pose="Zombie" end
		if string.match(msg, "disco") then pose="Boogy" end
		if string.match(msg, "float") then pose="Float" end
		if string.match(msg, "punch") then pose="Punch" end
		if string.match(msg, "kick") then pose="Kick" end
		if string.match(msg, "fly") then pose="Fly" end
		if string.match(msg, "heal") then script.Parent.Humanoid.Health=script.Parent.Humanoid.MaxHealth end
		if string.match(msg, "defend") then defence() end
		if string.match(msg, "stop") then pose="Standing"; proxkill=false; following=false; stopmoving() end
		if string.match(msg, "go home") then following=false; gohome() end
		if string.match(msg, "follow") then
			if string.match(msg, "all") then
				followany()
			else
				local egg=game.Players:children()
				for i=1, #egg do
					if string.match(msg, string.lower(egg[i].Name)) then
						follow(egg[i].Name)
						return
					end
				end
			end
		end
		if string.match(msg, "kill") then
			if string.match(msg, "all") then
				attackany()
			else
				local egg=game.Players:children()
				for i=1, #egg do
					if string.match(msg, string.lower(egg[i].Name)) then
						attack(egg[i].Name)
						return
					end
				end
			end
		end

	end
end

if game.Players.NumPlayers>1 then
	x=game.Players:children()
	
	for i=1, #x do
		if script.Parent:findFirstChild("Commander")~=nil then
			if script.Parent.Commander:children()~=nil or script.Parent.Commander:children()>0 then
				local ch=script.Parent.Commander:children()
				for i=1, #ch do
					if string.lower(ch[i].Name)==string.lower(x[i].Name) then
						x[i].Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
					end
				end
			elseif string.lower(script.Parent.Commander.Value)==string.lower(x[i].Name) then
				x[i].Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
			end
		else
			x[i].Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end)
		end
	end
end


function onPlayerEntered(Player) 
	while Player.Name==nil do
		wait(2)
	end
	if script.Parent:findFirstChild("Commander")~=nil then
		if script.Parent.Commander:children()~=nil or script.Parent.Commander:children()>0 then
			local ch=script.Parent.Commander:children()
			for i=1, #ch do
				if string.lower(ch[i].Name)==string.lower(Player.Name) then
					Player.Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
				end
			end
		elseif string.lower(script.Parent.Commander.Value)==string.lower(Player.Name) then
			Player.Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end) 
		end
	else
		Player.Chatted:connect(function(msg, recipient) onChatted(msg, recipient) end)
	end
end

game.Players.ChildAdded:connect(onPlayerEntered) 



-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
dist=20

function followany()
following=true
	while following==true do

		local ch=game.Players:children()
		for i=1, #ch do
			local l=game.Workspace:findFirstChild(ch[i].Name)
			if l~=nil then
				local s=l.Torso
				local p=l.Torso.Position
				local q=script.Parent.Torso.Position
				local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
				if smallest==nil then
					smallest=d
					target=s
				elseif d<smallest then
					smallest=d
					target=s
				end
			end
		end

		if smallest==nil then stopmoving() return end
		
		if smallest>6*dist then return end
		
		script.Parent.Humanoid:MoveTo(target.Position, target)

		wait(0.5)
		for i=1, 6 do
			if target.Parent.Humanoid.Health<1 then stopmoving() else	wait(0.5) end
		end
	end
end



function gohome()
	script.Parent.Humanoid:MoveTo(Vector3.new(0,0,0), game.Workspace.Bases.Base)
end
function stopmoving()
	script.Parent.Humanoid:MoveTo(script.Parent.Torso.Position, script.Parent.Torso)
end

function follow(name)
	following=true

	local p=game.Workspace:findFirstChild(name)
	if p==nil then return end
	while following==true do	
		script.Parent.Humanoid:MoveTo(p.Torso.Position, p.Torso)
		wait(0.5)
		for i=1, 3 do
			if p.Humanoid.Health<1 then following=false; stopmoving() return end
			wait(0.5)
		end
	end
end

function attack(name)
	if script.Parent:findFirstChild("Sword")~=nil then	
		following=true
		local p=game.Workspace:findFirstChild(name)
		if p==nil then return end
		while following==true do
			script.Parent.Humanoid:MoveTo(p.Torso.Position, p.Torso)
			wait(0.5)
			for i=1, 3 do
				if p.Humanoid.Health<1 then following=false; stopmoving() return end
				local l=p.Torso.Position
				local q=script.Parent.Torso.Position
				local d=math.sqrt( ((l.x-q.x)^2)+((l.y-q.y)^2)+((l.z-q.z)^2) )
				if d<10 then
					script.Parent.Humanoid:MoveTo(p.Torso.Position, p.Torso); slash()
					if (q.y-l.y)>3 and (q.y-l.y)<7 then
						script.Parent.Humanoid:MoveTo(p.Torso.Position+Vector3.new(math.random(-4,4),0,math.random(-4,4)), p.Torso);
					end
				end
				wait(1)
			end
		end
	end
end

function attackany()
if script.Parent:findFirstChild("Sword")~=nil then	

	following=true
		while following==true do

			local ch=game.Players:children()
			for i=1, #ch do
				local l=game.Workspace:findFirstChild(ch[i].Name)
				if l~=nil then
					local s=l.Torso
					local p=l.Torso.Position
					local q=script.Parent.Torso.Position
					local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
					if smallest==nil then
						smallest=d
						target=s
					elseif d<smallest then
						smallest=d
						target=s
					end
				end
			end

			if smallest==nil then stopmoving() return end
			
			if smallest>6*dist then return end
			
			script.Parent.Humanoid:MoveTo(target.Position, target)

			if smallest<10 then
				slash()
			end
			if target.Parent==nil then stopmoving() return end
			wait(0.5)
			for i=1, 3 do
				if target.Parent.Humanoid.Health<1 then 
					stopmoving() 
				else
					local p=target.Position
					local q=script.Parent.Torso.Position
					local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
					if d<10 then
						script.Parent.Humanoid:MoveTo(target.Position, target); slash()
						if (q.y-p.y)>3 and (q.y-p.y)<7 then
							script.Parent.Humanoid:MoveTo(p.Torso.Position+Vector3.new(math.random(-4,4),0,math.random(-4,4)), p.Torso);
						end
					end
					wait(1)
				end
			end
		end
	end
end


function patrol()
	if points==nil then
		points=0
		if game.Workspace:findFirstChild("pp1")~=nil then
		pp1=game.Workspace:findFirstChild("pp1")
		local points=points+1
			if game.Workspace:findFirstChild("pp2")~=nil then
			pp2=game.Workspace:findFirstChild("pp2")
		local points=points+1
				if game.Workspace:findFirstChild("pp3")~=nil then
				pp3=game.Workspace:findFirstChild("pp3")
		local points=points+1
					if game.Workspace:findFirstChild("pp4")~=nil then
					pp4=game.Workspace:findFirstChild("pp4")
		local points=points+1
						if game.Workspace:findFirstChild("pp5")~=nil then
						pp5=game.Workspace:findFirstChild("pp5")
		local points=points+1
							if game.Workspace:findFirstChild("pp6")~=nil then
							pp6=game.Workspace:findFirstChild("pp6")
		local points=points+1
								if game.Workspace:findFirstChild("pp7")~=nil then
								pp7=game.Workspace:findFirstChild("pp7")
		local points=points+1
									if game.Workspace:findFirstChild("pp8")~=nil then
									pp8=game.Workspace:findFirstChild("pp8")
		local points=points+1
										if game.Workspace:findFirstChild("pp9")~=nil then
										pp9=game.Workspace:findFirstChild("pp9")
		local points=points+1
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end

	if points<1 then return end
	patrolling=true
	local time=2
	if points==1 then return end
	if points>1 then
		while patrolling==true do
			script.Parent.Humanoid:MoveTo(pp1.Position, pp1)
			wait(time)
			script.Parent.Humanoid:MoveTo(pp2.Position, pp2)
			wait(time)
			if points>2 then
				script.Parent.Humanoid:MoveTo(pp3.Position, pp3)
				wait(time)
				if points>3 then
					script.Parent.Humanoid:MoveTo(pp4.Position, pp4)
					wait(time)
					if points>4 then
						script.Parent.Humanoid:MoveTo(pp5.Position, pp5)
						wait(time)
						if points>5 then
							script.Parent.Humanoid:MoveTo(pp6.Position, pp6)
							wait(time)
							if points>6 then
								script.Parent.Humanoid:MoveTo(pp7.Position, pp7)
								wait(time)
								if points>7 then
									script.Parent.Humanoid:MoveTo(pp8.Position, pp8)
									wait(time)
									if points>8 then
										script.Parent.Humanoid:MoveTo(pp9.Position, pp9)
										wait(time)
									end
								end
							end
						end
					end
				end
			end
		end
	end
end


function goto(pos,part)
while true do
end
end


function slash()
	for i=1, 3 do
		wait(.3)
		RightShoulder.MaxVelocity = 2
		LeftShoulder.MaxVelocity = 1
		RightShoulder.DesiredAngle = -2.14
		LeftShoulder.DesiredAngle = 0
		RightHip.DesiredAngle = 0
		LeftHip.DesiredAngle = 0
		wait(.2)
		RightShoulder.MaxVelocity = 2
		LeftShoulder.MaxVelocity = 1
		RightShoulder.DesiredAngle = 0
		LeftShoulder.DesiredAngle = 0
		RightHip.DesiredAngle = 0
		LeftHip.DesiredAngle = 0
	end
end

function defence()
	proxkill=true
	while proxkill==true do
		local ch=game.Players:children()
		for i=1, #ch do
			local p=game.Workspace:findFirstChild(ch[i].Name)
			if p~=nil then
				local p=p.Torso.Position
				local q=script.Parent.Torso.Position
				local d=math.sqrt( ((p.x-q.x)^2)+((p.y-q.y)^2)+((p.z-q.z)^2) )
				if d<dist and d>8 then
					local ex=Instance.new("Explosion")
					ex.Position=p
					ex.Parent=game.Workspace
				end
			end		
		end
		wait(1)
	end
end




-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------


Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)


--[[

function newSound(id)
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.Parent = script.Parent.Head
	return sound
end


local sDied = newSound("rbxasset://sounds/uuhhh.wav")
local sFallingDown = newSound("rbxasset://sounds/splat.wav")
local sFreeFalling = newSound("rbxasset://sounds/swoosh.wav")
local sGettingUp = newSound("rbxasset://sounds/hit.wav")
local sJumping = newSound("rbxasset://sounds/button.wav")
local sRunning = newSound("rbxasset://sounds/bfsl-minifigfoots1.mp3")
sRunning.Looped = true

local Figure = script.Parent
local Head = waitForChild(Figure, "Head")
local Humanoid = waitForChild(Figure, "Humanoid")


function onDied()
	sDied:play()
end

function onState(state, sound)
	if state then
		sound:play()
	else
		sound:pause()
	end
end

function onRunning(speed)
	if speed>0 then
		sRunning:play()
	else
		sRunning:pause()
	end
end


Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(function(state) onState(state, sJumping) end)
Humanoid.GettingUp:connect(function(state) onState(state, sGettingUp) end)
Humanoid.FreeFalling:connect(function(state) onState(state, sFreeFalling) end)
Humanoid.FallingDown:connect(function(state) onState(state, sFallingDown) end)
--]]

local nextTime = 0
local runService = game:service("RunService");

while Figure.Parent~=nil do
	time = runService.Stepped:wait()
	if time > nextTime then
		move(time)
		nextTime = time + 0.1
	end
end

--// END OF SCRIPT: game.ServerStorage.Test Area.Target.Robot

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Target.Weld Script | Enabled: true
--------------------------------------------------------------------
local p=script.Parent:GetChildren()
for i=1,#p do 
if p[i].className=="Part" then 

	local weld = Instance.new("Weld") 
        weld.Name="Hold"
	weld.Part0 = p[i]
	weld.Part1 = script.Parent.Parent.Torso

	local HitPos = p[i].Position + (p[i].CFrame.lookVector * .5) 

	local CJ = CFrame.new(HitPos) 
	local C0 = p[i].CFrame:inverse() *CJ 
	local C1 = script.Parent.Parent.Torso.CFrame:inverse() * CJ 

	weld.C0 = C0 
	weld.C1 = C1 

	weld.Parent = p[i]
end
end 
--// END OF SCRIPT: game.ServerStorage.Test Area.Target.Weld Script

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Target.Respawn | Enabled: true
--------------------------------------------------------------------
name="Humanoid"
robo=script.Parent:clone()
while true do
	wait(4)
	if script.Parent.Humanoid.Health<1 then
		robot=robo:clone()
		robot.Parent=script.Parent.Parent
		robot:makeJoints()
		script.Parent:remove()
	end
end

		






--// END OF SCRIPT: game.ServerStorage.Test Area.Target.Respawn

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Invisible Shadow.Script | Enabled: true
--------------------------------------------------------------------
local part = script.Parent

part.Material = Enum.Material.ForceField
part.Transparency = -math.huge

script:Destroy()
--// END OF SCRIPT: game.ServerStorage.Test Area.Invisible Shadow.Script

--------------------------------------------------------------------
--// [Script] Path: game.ServerStorage.Test Area.Shootable door test.Test | Enabled: true
--------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Peak = ReplicatedStorage:WaitForChild("Peak")
local Remotes = Peak:WaitForChild("Remotes")
local WeaponRemotes = Remotes:WaitForChild("WeaponSys")
local ObjectHitEvent = WeaponRemotes:WaitForChild("ObjectHit")

local model = script.Parent
local button = model:WaitForChild("Button")
local door = model:WaitForChild("Door")

local isBusy = false
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local originalBtnColor = button.Color
local originalDoorCFrame = door.CFrame
local openCFrame = originalDoorCFrame * CFrame.new(-15, 0, 0)

local function Activate()
	if isBusy then return end
	isBusy = true

	button.Color = Color3.fromRGB(255, 0, 0)
	button.Material = Enum.Material.Neon

	local openTween = TweenService:Create(door, tweenInfo, {CFrame = openCFrame})
	openTween:Play()

	task.wait(3)

	local closeTween = TweenService:Create(door, tweenInfo, {CFrame = originalDoorCFrame})
	closeTween:Play()
	closeTween.Completed:Wait()

	button.Color = originalBtnColor
	isBusy = false
end

local connection = ObjectHitEvent.Event:Connect(function(player, hitPart, hitPosition, weaponData, shotDirection)
	if hitPart == button then
		Activate()
	end
end)

model.Destroying:Connect(function()
	if connection then connection:Disconnect() end
end)
--// END OF SCRIPT: game.ServerStorage.Test Area.Shootable door test.Test
  -  Edit
  14:15:03.341  

====================================================================  -  Edit
  14:15:03.341  ====================================================================  -  Edit
  14:15:03.341  ==                                                                ==  -  Edit
  14:15:03.341  ==                  END OF SCRIPT EXPORT PROCESS                  ==  -  Edit
  14:15:03.341  ==            (Exported a total of 209 scripts)             ==  -  Edit
  14:15:03.341  ==                                                                ==  -  Edit
  14:15:03.341  ====================================================================  -  Edit
  14:15:03.341  ====================================================================
  -  Edit